from __future__ import annotations

from collections.abc import Iterable
from typing import Any

IndexType = Iterable[tuple[int, dict[str, Any]]]


class Index(list):
    def __init__(self, index: IndexType):
        super().__init__(index)
        self.__ids = [row[0] for row in self]

    @property
    def ids(self) -> list[int]:
        return self.__ids

    def select(self, where=None, start=None, stop=None, columns=None, **kwargs) -> Index:
        """
        Retrieve (partial) data of an index, optionally based on where criteria

        :param where: Expression (operating condition keys, metadata keys or result names are valid identifiers) to
                      specify which rows to return, optional. If None, no expression-based filtering is done.
                      Example: "Vin => 10 and Chipname in ['A', 'B']"
        :param start: integer (defaults to None), row number to start selection.
                      Must be >= 0 and smaller then the index length
        :param stop: integer (defaults to None), row number to stop selection. Must be > 0 and at most the index length.
        :param columns: An iterable of column names that if not None, will limit the return columns
        :param kwargs:
        """
        if len(self) == 0:
            return self

        if columns is not None and not isinstance(columns, (list, tuple)):
            msg = "Argument 'columns' must be None or an iterable of strings!"
            raise TypeError(msg)
        if isinstance(columns, (list, tuple)):
            # Make sure columns is an iterable of strings
            columns = list(map(str, columns))

        def select_cols(dikt: dict) -> dict:
            if columns is None:
                return dikt
            return {k: v for k, v in dikt.items() if k in columns}

        start_ = start or self[0][0]
        stop_ = stop or self[-1][0]
        if where is None:

            def select_func(row):
                return start_ <= row[0] <= stop_

        elif isinstance(where, str):

            def select_func(row):
                return eval(where, None, row[1]) and start_ <= row[0] <= stop_

        elif isinstance(where, (tuple, list)):
            where = list(map(int, where))  # This must not fail, otherwise data type is wrong

            def select_func(row):
                return row[0] in where and start_ <= row[0] <= stop_

        else:
            msg = "Argument 'where' must be None or a string!"
            raise TypeError(msg)

        idx = Index([(row[0], select_cols(row[1])) for row in self if select_func(row)])
        if isinstance(where, (tuple, list)) and set(where) != set(idx.get_group_ids()):
            msg = f"No all requested rows {where[0]}...{where[-1]} are existing in resulting Index instance!"
            raise IndexError(msg)
        return idx

    def as_dataframe(self):
        """
        Returns the index as dataframe if possible
        """
        try:
            import pandas as pd
        except ImportError:  # pragma: no cover
            msg = "Cannot return selection as pandas Dataframe because the pandas package is not installed!"
            raise ImportError(msg) from None
        else:
            return pd.DataFrame.from_records(data=(row[1] for row in self), index=[row[0] for row in self])

    def get_group_ids(self) -> list[int]:
        """
        Returns a list of group ids that can be used to further filter array/waveform-types channels
        """
        return [row[0] for row in self]

    def intersect(self, other: Index, on_merge_conflict="use_left", **kwargs) -> Index:
        """
        Intersect with another index. The resulting index will only contains rows with same group id in both indexes.
        Also the data of both indexes will be merged.
        If there are columns with equal names in both indexes only one of them is kept
        (dep. on argument on_merge_conflict)

        :param other: The other index to intersect
        :param on_merge_conflict: "use_left" to prefer columns of origin index, "use_right" otherwise.
                                  "rename" will prefix/suffix intersecting column names automatically based on the
                                  keyword arguments prefix_left, prefix_right, suffix_left (default: _left),
                                  suffix_right (default: _right).
        """
        intersect_gids = list(set(self.get_group_ids()).intersection(set(other.get_group_ids())))
        sel_self = self.select(where=intersect_gids)
        sel_other = other.select(where=intersect_gids)

        if on_merge_conflict == "use_right":
            return Index(
                [(left_row[0], {**left_row[1], **right_row[1]}) for left_row, right_row in zip(sel_self, sel_other)]
            )
        if on_merge_conflict == "use_left":
            return Index(
                [(left_row[0], {**right_row[1], **left_row[1]}) for left_row, right_row in zip(sel_self, sel_other)]
            )
        if on_merge_conflict == "rename":

            def rename_dict_key(dikt, old_key, new_key):
                return {new_key if k == old_key else k: v for k, v in dikt.items()}

            prefix_left = kwargs.get("prefix_left", "")
            prefix_right = kwargs.get("prefix_right", "")
            suffix_left = kwargs.get("suffix_left", "_left")
            suffix_right = kwargs.get("suffix_right", "_right")

            new_ind = []
            for left_row, right_row in zip(sel_self, sel_other):
                intersect_keys = set(left_row[1]).intersection(set(right_row[1]))
                if len(intersect_keys):
                    for ik in intersect_keys:
                        left_row_dict = rename_dict_key(left_row[1], ik, f"{prefix_left}{ik}{suffix_left}")
                        right_row_dict = rename_dict_key(right_row[1], ik, f"{prefix_right}{ik}{suffix_right}")
                        new_ind.append((left_row[0], {**right_row_dict, **left_row_dict}))
                else:
                    new_ind.append((left_row[0], {**right_row[1], **left_row[1]}))
            return Index(new_ind)
        return None
