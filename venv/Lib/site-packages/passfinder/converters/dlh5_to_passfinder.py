from __future__ import annotations

import json
import numbers
from pathlib import Path

from dlh5 import DLH5
from dlh5.errors import DatasetExistsError

from passfinder.bounds import ExpBound, NumericBound, PWLBound
from passfinder.report import create_report
from passfinder.spec import Specification


def dlh5_to_passfinder(
    filepath_in: Path | str,
    filepath_out: Path | str,
    filter_sort_kwargs: dict | None = None,
    n_bins: int = 1000,
    max_plots: int = 0,
    min_span: float = 1.5,
    specifications: list[Specification] | None = None,
    version: str = "v1",
) -> tuple[Path, dict]:
    """
    Creates a PassFinder report file and optional plots from DLH5.

    :param filepath_in: The file path to the result data to be converted
    :param filepath_out: The output directory for the PassFinder report. It will be generated if it does not exist.
    :param filter_sort_kwargs: Dict of keyword args for :func:`passfinder.bounds.filter_sort_error_segments`
    :param n_bins: The approximate number of samples the signals shall be down-sampled to before plotting.
                   The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                   an integer multiple of `n_bins`.
    :param max_plots: The maximum amount of additional error segments plots to generate per signal.
    :param min_span: The minimum time span the error segment plot shall display compared to the duration of the
                     error segment.
                     Minimum is 1.01, which means if the error segment has a duration of 1s, 1.01s will be displayed
                     by the plot (error segment is centered, so 0.005s added left and right).
                     This is generally useful to see the surroundings of the signal shortly before and after the error
                     segment.
    :param specifications: A list of ``passfinder.spec.Specification`` objects.
                           If not given, this method tries to read them from the DLH5
                           file (only supported for DLH5 files produced by a PyVerify test).
    :param version: The report version, "v1" or "v2"
    :returns: A tuple of a path (to the json report file) and dictionary (content of the file).
    """
    specifications = specifications or []
    filepath_in = Path(filepath_in)
    filepath_out = Path(filepath_out)
    filepath_out.parent.mkdir(parents=True, exist_ok=True)

    with DLH5(filepath_in, "r") as d:
        if not specifications:
            try:
                test_interface_json_encoded, _ = d.static_get_text_data("test_interface_definition")
            except DatasetExistsError:
                msg = (
                    "The input DLH5 file seems to not contain the PyVerify test interface definition!\n"
                    "Please provide the specifications manually via the 'specifications' argument!"
                )
                raise Exception(msg)
            test_interface = json.loads(test_interface_json_encoded)
            specifications = [limit2spec(limit) for limit in test_interface["limits"]]

        parameters_gen = (item[1] for item in d.get_index_operating_conditions())

        def result_gen():
            for gid in d.file_list_groups():
                grp = d.file_get_group(gid)
                results = {}
                for ch in d.list_numeric_channels(grp):
                    data, _ = d.group_get_channel(grp, ch)
                    results[ch] = data
                for ch in d.list_waveform_channels(grp):
                    data, _ = d.group_get_channel(grp, ch)
                    results[ch] = data
                yield results

        filter_sort_kwargs = filter_sort_kwargs or {"sort_by": "length"}
        reportfile, report = create_report(
            specifications,
            parameters_gen,
            result_gen(),
            filepath_out,
            filter_sort_kwargs=filter_sort_kwargs,
            n_bins=n_bins,
            max_plots=max_plots,
            min_span=min_span,
            version=version,
        )

    return reportfile, report


def limit2spec(limit: dict) -> Specification:
    x_range = limit["x_range"] or (None, None)
    x_range = tuple(x_range)
    x_ref = limit["reference"] or ""

    bounds = []
    for bound_type, definition in (("ubound", limit["upper_thres"]), ("lbound", limit["lower_thres"])):
        if definition is None:
            continue
        kwargs = {"bound_type": bound_type, "x_ref": x_ref, "x_range": x_range}
        if isinstance(definition, numbers.Number):
            bounds.append(NumericBound(value=definition, **kwargs))
        elif isinstance(definition, list):
            bounds.append(PWLBound(value=definition, **kwargs))
        elif isinstance(definition, str):
            bounds.append(ExpBound(value=definition.replace("$x", "x"), **kwargs))

    return Specification(
        name=limit["alias"],
        ref=limit["reference_output"],
        conditions=limit["conditions"] or "",
        bounds=bounds,
        source="PyVerify",
    )
