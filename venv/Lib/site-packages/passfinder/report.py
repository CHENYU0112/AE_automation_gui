from __future__ import annotations

import copy
import json
import os
from pathlib import Path
from typing import TYPE_CHECKING, Union

import wavewatson

from passfinder.bounds import filter_sort_error_segments
from passfinder.plotting import generate_bound_violation_overview_plot, generate_bound_violation_plots

if TYPE_CHECKING:
    from collections.abc import Iterator

    from passfinder.spec import Specification

Pathlike = Union[str, Path]


def create_report(
    specs: list[Specification],
    parameters: Iterator[dict],
    results: Iterator[dict],
    report_dst: Pathlike,
    *,
    filter_sort_kwargs: dict | None = None,
    n_bins: int = 1000,
    max_plots: int = 0,
    min_span: float = 1.5,
    version: str = "v1",
) -> tuple[Path, dict]:
    """
    Creates a PassFinder report file and maybe plots.

    :param specs: A list of :class:`passfinder.spec.Specification` instances
    :param parameters: An iterator that yields dicts of parameter name-value pairs for each test iteration.
                       Using iterators allow loading data on-demand and keep memory consumption low.
    :param results: An iterator that yields dicts of result name-value pairs for each test iteration.
                    Using iterators allow loading data on-demand and keep memory consumption low.
    :param report_dst: The target directory where the report shall be generated.
    :param filter_sort_kwargs: Dict of keyword args for :func:`passfinder.bounds.filter_sort_error_segments`
    :param n_bins: The approximate number of samples the signals shall be down-sampled to before plotting.
                   The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                   an integer multiple of `n_bins`.
    :param max_plots: The maximum amount of error segments plots to generate.
    :param min_span: The minimum time span the error segment plot shall display compared to the duration of the
                     error segment.
                     Minimum is 1.01, which means if the error segment has a duration of 1s, 1.01s will be displayed
                     by the plot (error segment is centered, so 0.005s added left and right).
                     This is generally useful to see the surroundings of the signal shortly before and after the error
                     segment.
    :param version: The report version to build. v1, v2, ...
    """
    version = version.lower()
    kwargs = {
        "specs": specs,
        "parameters": parameters,
        "results": results,
        "report_dst": report_dst,
        "filter_sort_kwargs": filter_sort_kwargs,
        "n_bins": n_bins,
        "max_plots": max_plots,
        "min_span": min_span,
    }
    if version == "v1":
        return v1(**kwargs)
    if version == "v2":
        return v2(**kwargs)
    return None


def v1(
    specs: list[Specification],
    parameters: Iterator[dict],
    results: Iterator[dict],
    report_dst: Pathlike,
    *,
    filter_sort_kwargs: dict | None = None,
    n_bins: int = 1000,
    max_plots: int = 0,
    min_span: float = 1.5,
) -> tuple[Path, dict]:
    report_dst = Path(report_dst)
    report = {"parameters": {}, "specs": {}}

    for iteration, (params, res) in enumerate(zip(parameters, results)):
        report["parameters"][iteration] = copy.deepcopy(params)
        for spec in specs:
            if spec.name not in report["specs"]:
                report["specs"][spec.name] = []
            plots = []
            sresult = spec.analyse(params, res)
            err_segments = [err_seg for boundres in sresult.bound_results for err_seg in boundres.error_segments]
            err_segments = filter_sort_error_segments(err_segments, **(filter_sort_kwargs or {"sort_by": "length"}))

            if len(err_segments) and isinstance(res[spec.ref], wavewatson.Waveform):
                fig = generate_bound_violation_overview_plot(
                    signal=res[spec.ref],
                    bounds=spec.bounds,
                    error_segments=err_segments,
                    n_bins=n_bins,
                )
                plotdir = report_dst / "plots"
                plotdir.mkdir(parents=True, exist_ok=True)
                plotname = plotdir / f"{spec.name}_{iteration:>06}_overview.html"
                plots.append(str(plotname.relative_to(report_dst)))
                fig.write_html(plotname, include_plotlyjs=os.environ.get("PASSFINDER_PLOTLYJS", "cdn"))

                for i, fig in enumerate(
                    generate_bound_violation_plots(
                        signal=res[spec.ref],
                        error_segments=err_segments,
                        n_bins=n_bins,
                        max_plots=max_plots,
                        min_span=min_span,
                        show_markers=False,
                    )
                ):
                    plotname = plotdir / f"{spec.name}_{iteration:>06}_segment{i:>03}.html"
                    plots.append(str(plotname.relative_to(report_dst)))
                    fig.write_html(plotname, include_plotlyjs=os.environ.get("PASSFINDER_PLOTLYJS", "cdn"))

            report["specs"][spec.name].append(
                {"iteration": iteration, "result": sresult.model_dump(mode="json"), "plots": plots}
            )

    report_dst.mkdir(parents=True, exist_ok=True)
    report_file = report_dst / "passfinder_report.json"
    with open(report_file, "w") as f:
        json.dump(report, f, indent=2)
    return report_file, report


def v2(
    specs: list[Specification],
    parameters: Iterator[dict],
    results: Iterator[dict],
    report_dst: Pathlike,
    *,
    filter_sort_kwargs: dict | None = None,
    n_bins: int = 1000,
    max_plots: int = 0,
    min_span: float = 1.5,
) -> tuple[Path, dict]:
    report_dst = Path(report_dst)
    report = {"specs": {}, "results": []}

    for spec in specs:
        spec_as_dict = spec.model_dump()
        bounds = {bound["uuid"]: bound for bound in spec_as_dict["bounds"]}
        for bound in bounds.values():
            del bound["uuid"]
        spec_as_dict["bounds"] = bounds
        report["specs"][spec.name] = spec_as_dict

    for iteration, (params, res) in enumerate(zip(parameters, results)):
        iteration_results = {"parameters": copy.copy(params), "spec_results": {}}
        specs_results = iteration_results["spec_results"]
        for spec in specs:
            plots = []
            sresult = spec.analyse(params, res)
            err_segments = [err_seg for boundres in sresult.bound_results for err_seg in boundres.error_segments]
            err_segments = filter_sort_error_segments(err_segments, **(filter_sort_kwargs or {"sort_by": "length"}))

            if len(err_segments) and isinstance(res[spec.ref], wavewatson.Waveform):
                fig = generate_bound_violation_overview_plot(
                    signal=res[spec.ref],
                    bounds=spec.bounds,
                    error_segments=err_segments,
                    n_bins=n_bins,
                )
                plotdir = report_dst / "plots"
                plotdir.mkdir(parents=True, exist_ok=True)
                plotname = plotdir / f"{spec.name}_{iteration:>06}_overview.html"
                plots.append(str(plotname.relative_to(report_dst)))
                fig.write_html(plotname, include_plotlyjs=os.environ.get("PASSFINDER_PLOTLYJS", "cdn"))

                for i, fig in enumerate(
                    generate_bound_violation_plots(
                        signal=res[spec.ref],
                        error_segments=err_segments,
                        n_bins=n_bins,
                        max_plots=max_plots,
                        min_span=min_span,
                        show_markers=False,
                    )
                ):
                    plotname = plotdir / f"{spec.name}_{iteration:>06}_segment{i:>03}.html"
                    plots.append(str(plotname.relative_to(report_dst)))
                    fig.write_html(plotname, include_plotlyjs=os.environ.get("PASSFINDER_PLOTLYJS", "cdn"))

            sresult_as_dict = sresult.model_dump(mode="json")
            del sresult_as_dict["spec"]
            for bound_result in sresult_as_dict["bound_results"]:
                bound_result["bound"] = bound_result["bound"]["uuid"]
            sresult.spec = None
            specs_results[spec.name] = {"result": sresult_as_dict, "plots": plots}

        report["results"].append(iteration_results)

    report_dst.mkdir(parents=True, exist_ok=True)
    report_file = report_dst / "passfinder_report.json"
    with open(report_file, "w") as f:
        json.dump(report, f, indent=2)
    return report_file, report
