from __future__ import annotations

import typing as tp

import numpy as np
import plotly.graph_objs as go
from wavewatson import Waveform

from passfinder.bounds import (
    Bound,
    BoundErrorSegments,
    DiscreteValuedBound,
    extract_features_and_compress,
    filter_sort_error_segments,
    generate_error_segment_detail_view,
)
from passfinder.util.checks import BoundType


def _create_scatter_for_error_segments(error_segments: BoundErrorSegments, signal_min, signal_max):
    for _j, sr in enumerate(error_segments or []):
        linewidth = 1 if sr.t2 is None else 0
        t2 = sr.t2 if sr.t2 is not None else sr.t1
        yield go.Scatter(
            x=[sr.t1, t2, t2, sr.t1],
            y=[signal_min, signal_min, signal_max, signal_max],
            fill="toself",
            fillcolor="rgba(255, 0, 0, 0.1)",
            mode="lines",
            line={"width": linewidth, "color": "rgba(255, 0, 0, 0.5)"},
            showlegend=False,
            hoverinfo="skip",
        )


def _create_scatter_for_mean_min_max(x: np.ndarray, mean: np.ndarray, min: np.ndarray, max: np.ndarray, line_mode: str):
    return [
        go.Scatter(
            name="Signal Mean",
            x=x,
            y=mean,
            mode=line_mode,
            line={"color": "rgb(0, 255, 0)"},
            marker={"color": "rgb(0, 255, 0)"},
        ),
        go.Scatter(
            name="Signal Max",
            x=x,
            y=max,
            mode="lines",
            marker={"color": "#444"},
            line={"width": 0},
            showlegend=False,
        ),
        go.Scatter(
            name="Signal Min",
            x=x,
            y=min,
            marker={"color": "#444"},
            line={"width": 0},
            mode="lines",
            fillcolor="rgba(68, 68, 68, 0.3)",
            fill="tonexty",
            showlegend=False,
        ),
    ]


def generate_bound_violation_plots(
    signal: Waveform,
    error_segments: BoundErrorSegments,
    max_plots: int = 10,
    filter_sort_kwargs: dict | None = None,
    n_bins: int = 1000,
    min_span: float = 1.5,
    show_markers: bool = False,
) -> tp.Iterable[go.Figure]:
    """
    Iterates over passed segment results and generates fail plots for each segment.
    The fail plots contain the downsampled signal (as min,max,mean), the downsampled bound as well as red
    semitransparent rectangular shapes that visualize the areas where the signal violates the bound.

    Since a high amount of error segments would lead to the same amount of plots, the plot generation
    should always be limited by limiting the maximum amount of generated plots (`max_plots` argument),
    as well as to filter and sort the error segments using the `filter_sort_kwargs` argument.

    :param signal: The signal to overlay the error segments
    :param error_segments: A list of BoundErrorSegment instances returned by :func:`passfinder.bounds.compare_bound`
    :param max_plots: The maximum amount of plots to generate.
    :param filter_sort_kwargs: Dict of keyword args for :func:`passfinder.bounds.filter_sort_error_segments`
    :param n_bins:  The approximate number of samples the signals shall be downsampled to before plotting.
                    The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                    an integer multiple of `n_bins`.
    :param min_span: The minimum time span the plot shall display compared to the duration of the error segment.
                     Minimum is 1.01, which means if the error segment has a duration of 1s, 1.01s will be displayed
                     by the plot (error segment is centered, so 0.005s added left and right).
                     This is generally useful to see the surroundings of the signal shortly before and after the error
                     segment.
    :param show_markers: If True, the bound and mean signal in the plot will have markers. Enabling this may affect
                         display performance and is usually not needed since the plot provides hover info on all traces.
    :return: Returns a generator that yields plotly Figure instances that may be saved or shown by the caller.
    """
    if len(signal) == 1:
        msg = "Cannot generate bound violation plot for signal of length 1!"
        raise ValueError(msg)

    results = (
        filter_sort_error_segments(error_segments, **filter_sort_kwargs)
        if isinstance(filter_sort_kwargs, dict)
        else error_segments
    )
    for i, error_segment in enumerate(results):
        if i == max_plots:
            break
        bound = error_segment.bound
        if n_bins > signal.length:
            continue

        line_mode = "lines+markers" if show_markers or error_segment.length < 100 else "lines"

        zoom_data = generate_error_segment_detail_view(signal, error_segment, int(n_bins), min_span)
        signal_min = np.min(zoom_data["min"])
        signal_max = np.max(zoom_data["max"])
        error_segments_to_plot = filter_sort_error_segments(
            error_segments,
            expression=f"t1 >= {zoom_data['x'][0]} and t2 <= {zoom_data['x'][-1]} or index == {error_segment.index}",
        )

        figure_data = list(_create_scatter_for_error_segments(error_segments_to_plot, signal_min, signal_max))
        figure_data.extend(
            _create_scatter_for_mean_min_max(
                zoom_data["x"], zoom_data["mean"], zoom_data["min"], zoom_data["max"], line_mode
            )
        )

        if "bound" in zoom_data:
            assert isinstance(bound, DiscreteValuedBound)
            dash = None if bound.bound_included else "dot"
            marginal_suffix = ",marginal" if bound.marginal else ""
            legend = "Upper Bound" if bound.bound_type == "ubound" else "Lower Bound"
            legend += f" (incl.{marginal_suffix})" if bound.bound_included else f" (excl.{marginal_suffix})"
            color = "rgb(250, 170, 0)" if bound.marginal else "rgb(255, 0, 0)"

            figure_data.append(
                go.Scatter(
                    name=legend,
                    x=zoom_data["bound_x"],
                    y=zoom_data["bound"],
                    mode=line_mode,
                    line={"color": color, "dash": dash},
                    marker={"color": color},
                )
            )

        title = f"Bound violation segment plot #{i}"
        fig = go.Figure(figure_data, layout={"hovermode": "x", "title": title, "margin": {"b": 100}})
        fig.add_annotation(
            {
                "font": {"color": "black", "size": 12},
                "x": 0,
                "y": 0,
                "showarrow": False,
                "text": f"Bound: {bound!r}<br>Signal: {signal}<br>Error Segment Info: {error_segment!r}",
                "textangle": 0,
                "align": "left",
                "xanchor": "left",
                "xref": "paper",
                "yref": "paper",
                "yshift": -70,
            }
        )
        yield fig


def generate_bound_violation_overview_plot(
    signal: Waveform,
    bounds: list[Bound] | None = None,
    error_segments: BoundErrorSegments = None,
    n_bins: int = 1000,
    title: str = "Bound violation overview plot",
) -> go.Figure:
    """
    Plots the signal together with its defined upper- and lower bounds.
    Potential bound violations are also plotted.

    :param signal: The signal to overlay the error segments
    :param bounds: A list of Bounds
    :param error_segments: A list of BoundErrorSegment instances returned by :func:`passfinder.bounds.compare_bound`
    :param n_bins:  The approximate number of samples the signals shall be downsampled to before plotting.
                    The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                    an integer multiple of `n_bins`.
    :param title: The plot title
    :return: Returns a plotly Figure that may be saved or shown by the caller.
    """
    if len(signal) == 1:
        msg = "Cannot generate bound violation plot for signal of length 1!"
        raise ValueError(msg)

    compressed_signal = extract_features_and_compress(signal, n_bins=n_bins)

    plotdata: dict = compressed_signal
    plotdata["ubounds"] = []
    plotdata["lbounds"] = []

    for bound in bounds or []:
        if isinstance(bound, DiscreteValuedBound):
            time = bound.adjust(signal).time
            if bound.bound_type == BoundType.ubound:
                compressed = extract_features_and_compress(
                    Waveform(bound.get_discrete_bound(), time), n_bins=n_bins, features=("min",)
                )
                plotdata["ubounds"].append(
                    (
                        compressed["min"],
                        compressed["x"],
                        bound,
                    )
                )
            elif bound.bound_type == BoundType.lbound:
                compressed = extract_features_and_compress(
                    Waveform(bound.get_discrete_bound(), time), n_bins=n_bins, features=("max",)
                )
                plotdata["lbounds"].append(
                    (
                        compressed["max"],
                        compressed["x"],
                        bound,
                    )
                )
            else:
                raise AssertionError

    signal_min = np.min(plotdata["min"])
    signal_max = np.max(plotdata["max"])

    figure_data = list(_create_scatter_for_error_segments(error_segments, signal_min, signal_max))
    figure_data.extend(
        _create_scatter_for_mean_min_max(plotdata["x"], plotdata["mean"], plotdata["min"], plotdata["max"], "lines")
    )

    if "ubounds" in plotdata:
        bound: DiscreteValuedBound
        for i, (data, time, bound) in enumerate(plotdata["ubounds"]):
            dash = None if bound.bound_included else "dot"
            marginal_suffix = ",marginal" if bound.marginal else ""
            legend_suffix = f" (incl.{marginal_suffix})" if bound.bound_included else f" (excl.{marginal_suffix})"
            color = "rgb(250, 170, 0)" if bound.marginal else "rgb(255, 0, 0)"
            figure_data.append(
                go.Scatter(
                    name=f"Upper Bound {i + 1}" + legend_suffix,
                    x=time,
                    y=data,
                    mode="lines",
                    line={"color": color, "dash": dash},
                    marker={"color": color},
                )
            )

    if "lbounds" in plotdata:
        bound: DiscreteValuedBound
        for i, (data, time, bound) in enumerate(plotdata["lbounds"]):
            dash = None if bound.bound_included else "dot"
            marginal_suffix = ",marginal" if bound.marginal else ""
            legend_suffix = f" (incl.{marginal_suffix})" if bound.bound_included else f" (excl.{marginal_suffix})"
            color = "rgb(250, 170, 0)" if bound.marginal else "rgb(255, 0, 0)"
            figure_data.append(
                go.Scatter(
                    name=f"Lower Bound {i + 1}" + legend_suffix,
                    x=time,
                    y=data,
                    mode="lines",
                    line={"color": color, "dash": dash},
                    marker={"color": color},
                )
            )

    fig = go.Figure(figure_data, layout={"hovermode": "x", "title": title, "margin": {"b": 150}})
    fig.add_annotation(
        {
            "font": {"color": "black", "size": 12},
            "x": 0,
            "y": 0,
            "showarrow": False,
            "text": "Bounds:<br>" + "".join([f"- {bound!r}<br>" for bound in (bounds or [])]) + f"Signal: {signal}<br>"
            f"# of error segment in plot: {len(error_segments or [])}",
            "textangle": 0,
            "align": "left",
            "xanchor": "left",
            "xref": "paper",
            "yref": "paper",
            "yshift": -120,
        }
    )
    return fig
