from __future__ import annotations

import enum
import operator
from numbers import Number
from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from wavewatson import Waveform


class BoundType(str, enum.Enum):
    undefined = "undefined"
    ubound = "ubound"
    lbound = "lbound"


boundtype_operator_map = {
    # (bound, bound_included) -> operator (data, bound)
    (BoundType.ubound, True): operator.gt,
    (BoundType.ubound, False): operator.ge,
    (BoundType.lbound, True): operator.lt,
    (BoundType.lbound, False): operator.le,
}
operator_boundtype_map = {v: k for k, v in boundtype_operator_map.items()}


def is_number(value):
    return isinstance(value, Number)


def is_number_iterable(value):
    if isinstance(value, (list, tuple)):
        return all(map(is_number, value))
    return False


def is_condition_fulfilled(parameters: dict, conditions: str) -> bool:
    """
    Evaluates a Python expression with parameters/operating conditions.

    Example::

        A == 1 and B > 2

    :param parameters: A dict of parameter names and values available for evaluation
    :param conditions: The expression to evaluate. Variables in parameters argument are in the namespace.
    :return:
    """
    if conditions in (None, ""):
        return True
    result = eval(conditions, {}, parameters or {})
    if not isinstance(result, bool):
        msg = f"Conditions {conditions} evaluated to {result!r} (type {type(result)}), but a boolean was expected!"
        raise ValueError(msg)
    return result


def extract_features_and_compress(
    signal: Waveform, n_bins: int = 1000, features=("min", "max", "mean")
) -> dict[str, np.ndarray]:
    """
    Down samples a signal by extracting features, like mean/min/max, that represent areas of the original data.

    :param signal: The signal to extract features from
    :param n_bins:  The approximate number of samples the signals shall be down sampled to before plotting.
                    The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                    an integer multiple of `n_bins`.
    :param features: A tuple of features that are names of functions in the numpy modules.
    :return: A dictionary with numpy arrays `x` (the time vector) and the selected features.
    """
    if n_bins <= 0:
        msg = "n_points cannot be negative"
        raise ValueError(msg)
    pts_per_bin = signal.length // n_bins
    if pts_per_bin >= 2:
        num_bins = signal.length // pts_per_bin
        x_out = signal.time[: num_bins * pts_per_bin : pts_per_bin]
        y_temp: np.ndarray = signal.data[: num_bins * pts_per_bin].reshape((num_bins, pts_per_bin))
    else:
        x_out = signal.time[:]
        y_temp = signal.data[:, np.newaxis]

    result = {}
    for feature in features:
        result[feature] = getattr(np, feature)(y_temp, axis=1)
    result["x"] = x_out
    return result
