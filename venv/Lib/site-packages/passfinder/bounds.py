from __future__ import annotations

import ast
import builtins
import enum
import typing as t
import uuid
from numbers import Number

import numpy as np
from pydantic import BaseModel, ConfigDict, Field, field_serializer, field_validator, model_validator
from wavewatson import Waveform

from passfinder.util.checks import BoundType, boundtype_operator_map, extract_features_and_compress, is_number_iterable

_BUILTINS = dir(builtins)


def _format_value(value):
    if isinstance(value, float):
        return f"{value:.3f}"
    return f"{value!r}"


class Bound(BaseModel):
    bound_class: str = Field("", repr=False)
    uuid: str = Field(default_factory=lambda: uuid.uuid4().hex, repr=False)
    x_range: tuple[float | None, float | None] = (None, None)
    marginal: bool = False
    source: str = ""  # The source of the bound

    @model_validator(mode="after")
    def update_class_name(self):
        self.bound_class = self.__class__.__name__
        return self

    def __hash__(self):
        return id(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(xrange={self.x_range!r}, marginal={self.marginal}, source={self.source!r})"

    @staticmethod
    def from_dict(obj: dict) -> Bound:
        return globals()[obj.pop("bound_class")](**obj)

    def adjust(self, value) -> Waveform:
        """
        Converts a scalar value to a Waveform and slice according to bounds x-range attribute.
        """
        if isinstance(value, Waveform):
            try:
                if self.x_range == (None, None) or len(value) == 1:
                    return value
                return value.slice_by_time(*self.x_range, endpoint=False)
            except Exception:
                msg = f"Failed to slice {value} in x-range {self.x_range}"
                raise Exception(msg)
        elif isinstance(value, Number):
            # Treat scalar values as single-point waveforms. This makes it easier for comparing/resampling later on.
            return Waveform([value], [0])
        else:
            raise TypeError

    def compare(self, value: Number | Waveform, **kwargs) -> BoundErrorSegments:
        raise NotImplementedError


class CustomBound(Bound):
    analyzer: t.Callable[[CustomBound, Waveform], BoundErrorSegments] = Field(
        default_factory=lambda bound, waveform: ..., repr=False
    )

    def compare(self, value: Number | Waveform, **kwargs) -> BoundErrorSegments:
        signal = self.adjust(value)

        result = self.analyzer(self, signal, **kwargs)
        if not isinstance(result, (list, tuple)):
            msg = f"Function {self.analyzer} did not return an iterable (list,tuple)!"
            raise ValueError(msg)
        if len(result) and not all(isinstance(item, BoundErrorSegment) for item in result):
            msg = f"Function {self.analyzer} did not return a list of BoundErrorSegment instances!"
            raise ValueError(msg)
        return result


class DiscreteValuedBound(Bound):
    discrete_bound: np.ndarray | None = Field(None, exclude=True, repr=False)
    bound_type: BoundType = BoundType.undefined
    bound_included: bool = True
    x_ref: str = ""
    value: t.Any

    model_config = ConfigDict(arbitrary_types_allowed=True)

    def __repr__(self):
        return (
            f"{self.__class__.__name__}(value={self.value!r}, x_ref={self.x_ref!r}, xrange={self.x_range!r}, "
            f"marginal={self.marginal}, source={self.source!r})"
        )

    @field_serializer("discrete_bound")
    def _serialize_discrete_bound(self, discrete_bound: np.ndarray, _info):
        return discrete_bound.tolist()

    def init_bound(self, value: Number | Waveform, parameters: dict | None = None) -> np.ndarray:
        raise NotImplementedError

    def get_discrete_bound(self) -> np.ndarray:
        if self.discrete_bound is None or not len(self.discrete_bound):
            msg = "Bound not discretized yet."
            raise Exception(msg)
        return self.discrete_bound

    def compare(self, value: Number | Waveform, **kwargs) -> BoundErrorSegments:
        if self.bound_type == "undefined":
            msg = (
                "The bound_type traits has to be set to 'ubound' or 'lbound' in order "
                "to compare the bound to a signal"
            )
            raise ValueError(msg)

        discrete_bound, signal = self.init_bound(value, kwargs.get("parameters", {}))

        op = boundtype_operator_map[(self.bound_type, self.bound_included)]
        fail_mask = op(signal.data, self.discrete_bound)
        if len(fail_mask) == 1:
            if fail_mask.item() is True:
                error = abs(signal.data - self.discrete_bound).item()
                return [
                    BoundErrorSegment(
                        bound=self,
                        index=0,
                        x1=0,
                        x2=None,
                        length=1,
                        t1=0.0,
                        t2=None,
                        error_max=error,
                        error_mean=error,
                    )
                ]
            return []

        violation_areas = list(zip(*_apply_condition(fail_mask)))
        sub = signal.data - self.discrete_bound

        result = []

        signal_len = len(signal)
        index = 0
        for x1, x2 in violation_areas:
            subarea = abs(sub[x1:x2])
            len_area = len(subarea)
            result.append(
                BoundErrorSegment(
                    bound=self,
                    index=index,
                    x1=x1,
                    x2=x2,
                    length=len_area,
                    t1=signal.time[x1],
                    t2=signal.time[x2] if x2 < signal_len else signal.time[-1],
                    error_max=subarea.max(),
                    error_mean=subarea.mean(),
                )
            )
            index += 1
        return result


class NumericBound(DiscreteValuedBound):
    value: float | int

    def init_bound(self, value: Number | Waveform, parameters: dict | None = None) -> tuple[np.ndarray, Waveform]:
        signal = self.adjust(value)
        self.discrete_bound = np.full(len(signal), fill_value=self.value)
        return self.discrete_bound, signal


class PWLBound(DiscreteValuedBound):
    value: list[float | int]

    @field_validator("value")
    @classmethod
    def _validate_value(cls, value):
        if is_number_iterable(value):
            if len(value) % 2 != 0:  # Check if len is a multiple of 2
                msg = "Length of PWL must be a multiple of 2!"
                raise ValueError(msg)
            if not np.all(np.diff(value[::2], 1) > 0):  # Check for monotonous rising
                msg = "PWL must monotonously rise!"
                raise ValueError(msg)
            return value
        msg = "Not an iterable of numbers!"
        raise ValueError(msg)

    def init_bound(self, value: Number | Waveform, parameters: dict | None = None) -> tuple[np.ndarray, Waveform]:
        parameters = parameters or {}
        signal = self.adjust(value)
        lim_x = self.value[::2]
        lim_y = self.value[1::2]
        if self.x_ref or len(signal) == 1:  # Reduces to static bound
            if not self.x_ref:
                msg = "For scalar results the bound's x_ref parameter has to be supplied!"
                raise Exception(msg)

            parameter_ref_x_value = parameters[self.x_ref]

            if lim_x[0] > parameter_ref_x_value:
                # If bound start is greater than the reference value, use the bound start as fill value
                fill_value = lim_y[0]
            elif lim_x[-1] < parameter_ref_x_value:
                # If bound start is less than the reference value, use the bound start as fill value
                fill_value = lim_y[-1]
            else:
                fill_value = Waveform(lim_y, lim_x).interpolate(parameter_ref_x_value)
            self.discrete_bound = np.full(len(signal), fill_value=fill_value)
        else:
            if lim_x[0] > signal.time[0]:
                # If bound start begins after signal start, extend bound to the left with first bound value
                lim_x.insert(0, signal.time[0])
                lim_y.insert(0, lim_y[0])
            if lim_x[-1] < signal.time[-1]:
                # If bound end begins before signal end, extend bound to the right with last bound value
                lim_x.append(signal.time[-1])
                lim_y.append(lim_y[-1])
            self.discrete_bound = Waveform(lim_y, lim_x).interpolate(signal.time).data
        assert len(self.discrete_bound) == len(signal)
        return self.discrete_bound, signal


class ExpBound(DiscreteValuedBound):
    value: str

    @field_validator("value")
    @classmethod
    def _validate_value(cls, value):
        if not isinstance(value, str) or value == "":
            msg = "Must be a non-empty string!"
            raise ValueError(msg)
        vars = set()
        for node in ast.walk(ast.parse(value)):
            if isinstance(node, ast.Name):
                if isinstance(node.ctx, ast.Load):
                    if node.id not in _BUILTINS:
                        vars.add(node.id)
                else:
                    # Don't allow expressions where variables are not read
                    msg = "Expression may only read-access variables!"
                    raise ValueError(msg)
        # Try eval with all variables other than x set to 1 and x set to an array.
        # An array or numeric values must return
        if "x" in vars:
            # x is used in expression, so we expect the returned value to be of array type
            result = eval(value, None, {**{k: 1 for k in vars if k != "x"}, "x": 1.0})
            if not isinstance(result, Number):
                msg = "Expression returned a type other than a number!"
                raise ValueError(msg)
        else:
            # If no x is used in expression, a numeric values shall be returned
            result = eval(value, None, {k: 1 for k in vars})
            if isinstance(result, bool) or not isinstance(result, (float, int)):
                msg = "If 'x' is not used inside the expression, a scalar numeric value must be returned!"
                raise ValueError(msg)
        return value

    def init_bound(self, value: Number | Waveform, parameters: dict | None = None) -> tuple[np.ndarray, Waveform]:
        parameters = parameters or {}
        signal = self.adjust(value)
        if self.x_ref or len(signal) == 1:  # Reduces to static bound
            if not self.x_ref:
                msg = "For scalar results the bound's x_ref parameter has to be supplied!"
                raise Exception(msg)
            fill_value = float(eval(self.value, {}, {**parameters, "x": parameters[self.x_ref]}))
            self.discrete_bound = np.full(len(signal), fill_value=fill_value)
        else:
            bound_val = np.fromiter(
                (eval(self.value, {}, {**parameters, "x": x}) for x in signal.time), dtype=np.float64
            )
            self.discrete_bound = bound_val
        assert len(self.discrete_bound) == len(signal)
        return self.discrete_bound, signal


class ResultEnum(enum.Enum):
    notset = "notset"
    unknown = "unknown"
    error = "error"
    passed = "pass"
    fail = "fail"
    skipped = "skipped"


class BoundResult(BaseModel):
    bound: Bound
    result_string: ResultEnum = ResultEnum.notset
    error_segments: BoundErrorSegments = Field(default_factory=list)
    error_message: str = ""

    @staticmethod
    def from_dict(spec, obj: dict) -> BoundResult:
        """

        :type spec: passfinder.spec.Specification
        """
        bound_id = obj.pop("bound")
        bound = None
        for bound in spec.bounds:
            if bound.uuid == bound_id:
                break

        assert bound is not None

        esegments = [BoundErrorSegment(**{"bound": bound, **eseg}) for eseg in obj.pop("error_segments")]

        return BoundResult(
            bound=bound,
            error_segments=esegments,
            **obj,
        )

    def set_error_message(self, error_message):
        self.error_message = error_message
        self.result_string = ResultEnum.fail

    def set_error_segments(self, error_segments: BoundErrorSegments):
        self.error_segments = error_segments
        if len(self.error_segments):
            self.result_string = ResultEnum.fail
        else:
            self.result_string = ResultEnum.passed


class BoundErrorSegment(BaseModel):
    uuid: str = Field(default_factory=lambda: uuid.uuid4().hex, repr=False)
    bound: Bound = Field(exclude=True, repr=False)
    index: int
    x1: int
    x2: int | None
    t1: float | int
    t2: float | int | None
    duration: float = 0
    length: int | None
    error_max: float = -1
    error_mean: float = -1

    @model_validator(mode="before")
    @classmethod
    def _validate(cls, values):
        t1 = values.get("t1")
        t2 = values.get("t2", None)
        x1 = values.get("x1")
        x2 = values.get("x2", None)
        values["duration"] = 0 if t2 is None else t2 - t1
        values["length"] = 1 if x2 in (None, 0) else x2 - x1

        return values

    @field_validator("length")
    @classmethod
    def length_validator(cls, v):
        assert v >= 1, "must be greater or equal to 1"
        return int(v)


BoundErrorSegments = list[BoundErrorSegment]

BoundResult.model_rebuild()


# https://github.com/rwhitt2049/trouve/blob/master/trouve/find_events.py
def _apply_condition(condition):
    """Distill an array of bool into start and stop indexes
    Convert a conditional array of bools into two numpy.ndarrays of
    integers where starts are the indexes where condition goes from
    False to True. Stops are the indexes where condition goes from
    True to False.
    Args:
        condition (numpy.array of bool):
    Returns:
        tuple(numpy.ndarray, numpy.ndarray):
    """
    mask = (condition > 0).view("i1")
    slice_index = np.arange(mask.size + 1, dtype=np.int32)

    # Determine if condition is active at array start, set to_begin accordingly
    to_begin = np.array([0], dtype="i1") if mask[0] == 0 else np.array([1], dtype="i1")

    # Determine if condition is active at array end, set to_end accordingly
    to_end = np.array([0], dtype="i1") if mask[-1] == 0 else np.array([-1], dtype="i1")

    deltas = np.ediff1d(mask, to_begin=to_begin, to_end=to_end)

    starts = np.ma.masked_where(deltas < 1, slice_index).compressed()
    stops = np.ma.masked_where(deltas > -1, slice_index).compressed()

    return starts, stops


def filter_sort_error_segments(
    error_segments: list[BoundErrorSegment], expression="", sort_by="", reverse=True
) -> BoundErrorSegments:
    """
    Filters and sorts a list of segment results.

    :param error_segments: The list of BoundErrorSegment instances to filter and sort
    :param expression:  A Python expression that is evaluated with the BoundErrorSegment's instance
                        variables as context. If the expressions yields a value that evaluates to True,
                        the item will be kept.
    :param sort_by: The name of the attribute of the BoundErrorSegment instances which shall be used as a sort key.
                    An empty string will skip sorting.
    :param reverse: If True, return the result in reversed order
    """
    if expression:
        expr = compile(expression, "<string>", mode="eval")

        def myfilter(error_segment: BoundErrorSegment):
            return bool(eval(expr, {}, error_segment.model_dump()))

        error_segments = filter(myfilter, error_segments)

    if sort_by:
        error_segments = sorted(error_segments, key=lambda x: getattr(x, sort_by))

    error_segments = list(error_segments)

    if reverse:
        error_segments = error_segments[::-1]

    return error_segments


def generate_error_segment_detail_view(
    signal: Waveform,
    error_segment: BoundErrorSegment,
    n_bins: int = 1000,
    min_span: float | int = 1.05,
) -> dict[str, np.ndarray]:
    """
    Plots the signal together with a single bound violation.

    :param signal: The signal to overlay the error segments
    :param error_segment: A BoundErrorSegment instance returned by :func:`passfinder.bounds.compare_bound`
    :param n_bins:  The approximate number of samples the signals shall be downsampled to before plotting.
                    The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                    an integer multiple of `n_bins`.
    :param min_span: The minimum time span the plot shall display compared to the duration of the error segment.
                     Minimum is 1.01, which means if the error segment has a duration of 1s, 1.01s will be displayed
                     by the plot (error segment is centered, so 0.005s added left and right).
                     This is generally useful to see the surroundings of the signal shortly before and after the error
                     segment.
    :return: A dictionary with following numpy arrays:`x` - The time vector,`min`,`max` and `mean` of the signal
             and `bound` - the bound
    """
    if len(signal) == 1:
        msg = "Cannot generate error segment detail view for signal of length 1!"
        raise ValueError(msg)
    bound = error_segment.bound

    min_samples = int(max(1.01, min_span) * error_segment.length)
    min_samples_margin = max(10, int((min_samples - error_segment.length) / 2))
    xt1 = signal.time_to_index(error_segment.t1)
    xt2 = signal.time_to_index(error_segment.t2)
    x1 = int(max(xt1 - min_samples_margin, 0))
    x2 = int(min(xt2 + min_samples_margin, len(signal) - 1))
    # Slice signals to segment start/stop +- margin, to see a bit more than only the segment error
    signal_span = signal[x1:x2]

    compressed_signal = extract_features_and_compress(signal_span, n_bins=n_bins)
    view = dict(
        **compressed_signal,
    )

    if isinstance(bound, DiscreteValuedBound):
        min_samples = int(max(1.01, min_span) * error_segment.length)
        min_samples_margin = max(10, int((min_samples - error_segment.length) / 2))  # min. 10 samples extra each side
        x1 = int(max(error_segment.x1 - min_samples_margin, 0))
        x2 = int(error_segment.x2 + min_samples_margin)
        adj_signal = bound.adjust(signal)

        feature = ["min", "max"][[BoundType.ubound, BoundType.lbound].index(bound.bound_type)]
        bound = Waveform(bound.get_discrete_bound()[x1:x2], adj_signal[x1:x2].time)
        compressed_bound = extract_features_and_compress(
            bound, n_bins=int(n_bins * len(bound) / len(signal_span)), features=(feature,)
        )
        view["bound"] = compressed_bound[feature]
        view["bound_x"] = compressed_bound["x"]
    return view


# if __name__ == '__main__':
#     BoundErrorSegment(
#         bound=
#         index=
#         x1=
#         x2=
#         t1=
#         t2=
#         duration=
#         length=
#         error_max=
#         error_mean=
#     )
