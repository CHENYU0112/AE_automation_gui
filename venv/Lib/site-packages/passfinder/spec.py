from __future__ import annotations

import ast
import copy
import numbers
import typing as t

from pydantic import BaseModel, Field, field_validator
from wavewatson import Waveform

from passfinder.bounds import (
    Bound,
    BoundResult,
    CustomBound,
    DiscreteValuedBound,
    ExpBound,
    NumericBound,
    PWLBound,
    ResultEnum,
)
from passfinder.plotting import (
    filter_sort_error_segments,
    generate_bound_violation_overview_plot,
    generate_bound_violation_plots,
)
from passfinder.util.checks import is_condition_fulfilled

if t.TYPE_CHECKING:
    import plotly.graph_objs as go


class Specification(BaseModel):
    name: str  # An alias for the spec
    ref: str  # The name of the result the spec references
    bounds: list[Bound | DiscreteValuedBound | ExpBound | PWLBound | NumericBound | CustomBound] = Field(
        default_factory=list
    )
    conditions: str | None = None
    source: str = ""  # The source for this specification, e.g. manual, JAMA, Vesper. Set by the generating tool.

    @field_validator("name")
    @classmethod
    def _validate_name(cls, v):
        if len(v) < 1:
            msg = "name must be a string with at least one character!"
            raise ValueError(msg)
        return v

    @field_validator("ref")
    @classmethod
    def _validate_ref(cls, v):
        if len(v) < 1:
            msg = "ref must be a string with at least one character!"
            raise ValueError(msg)
        return v

    @field_validator("conditions")
    @classmethod
    def _validate_conditions(cls, v):
        if v is None:
            return ""
        if not isinstance(v, str):
            msg = "Must provide a string!"
            raise ValueError(msg)
        vars = []
        for node in ast.walk(ast.parse(v)):
            if isinstance(node, ast.Name):
                if isinstance(node.ctx, ast.Load):
                    vars.append(node.id)
                else:
                    msg = "Expression may only read-access variables!"
                    raise ValueError(msg)
        # Try eval with all variables other than x set to 1.
        # A boolean or integer value must be returned
        if len(vars):
            try:
                result = eval(v, None, {k: 1 for k in vars})
            except Exception:
                result = eval(v, None, {k: "1" for k in vars})
            if not isinstance(result, (bool, int)):
                msg = "Expression must return a bool or int!"
                raise ValueError(msg)
        return v

    @staticmethod
    def from_dict(obj: dict) -> Specification:
        obj = copy.deepcopy(obj)
        bounds = [Bound.from_dict(bound_obj) for bound_obj in obj.pop("bounds").values()]
        return Specification(**{**obj, "bounds": bounds})

    def analyse(self, parameters: dict, results: dict) -> SpecificationResult:
        """
        Analyze the specification against one of the results (dep. on the ref parameter)

        :param parameters: A dict of operating conditions/parameters.
                           It is needed since some bounds might refer to them.
        :param results: A dict of result name to result value. The values may be any type, but only Waveform-typed
                        results are plotted by this function.
        :return:
        """
        specres = SpecificationResult(spec=self)

        result = results.get(self.ref)
        if isinstance(result, (int, float)):
            specres.raw_result = result

        try:
            if not is_condition_fulfilled(parameters, self.conditions):
                specres.set_all_skipped()
                return specres
        except Exception as e:
            specres.set_error_message(
                f"Evaluating condition {self.conditions} with parameters {parameters} failed: {e}"
            )
            return specres

        # Check bounds
        for bound in self.bounds:
            if not isinstance(result, (numbers.Number, Waveform)):
                specres.add_bound_result(BoundResult(bound=bound, result_string=ResultEnum.unknown))
                continue

            bound_res = BoundResult(bound=bound)
            try:
                error_segments = bound.compare(result, parameters=parameters)
                bound_res.set_error_segments(error_segments)
            except Exception as e:
                bound_res.set_error_message(str(e))
            specres.add_bound_result(bound_res)

        return specres

    def create_plots(
        self, results: dict, spec_result: SpecificationResult, n_bins: int = 1000, **kwargs
    ) -> t.Iterator[go.Figure]:
        """
        Generates a collection of plots that visualize the bound violations.
        If the specification has at least one bound violation, the returned iterator yields at least 2 plots.
        The first plot is always a bound violation overview plot created via
        :func:`passfinder.plotting.generate_bound_violation_overview_plot`.

        The next plots are "zoomed-in" plots for each bound violation segment of each bound, created via
        :func:`passfinder.plotting.generate_bound_violation_plots`.

        :param results: A dict of result name to result value. The values may be any type, but only Waveform-typed
                        results are plotted by this function.
        :param spec_result: A :class:`SpecificationResult` instance as
                            returned by :func:`passfinder.spec.Specification.analyse`
        :param n_bins: The approximate number of samples the signals shall be downsampled to before plotting.
                The actual number of samples may be up to 49% higher than `n_bins`, if the signal length is not
                an integer multiple of `n_bins`.
        :keyword max_plots: See docs of :func:`passfinder.plotting.generate_bound_violation_plots`:
        :keyword filter_sort_kwargs: See docs of :func:`passfinder.plotting.generate_bound_violation_plots`:
        :keyword min_span: See docs of :func:`passfinder.plotting.generate_bound_violation_plots`:
        :keyword show_markers: See docs of :func:`passfinder.plotting.generate_bound_violation_plots`:

        :return: An iterator of Plotly Figure instances
        """
        if spec_result.spec.ref not in results:
            msg = f"No result called {spec_result.spec.ref}!"
            raise LookupError(msg)
        signal: Waveform = results[spec_result.spec.ref]
        if not isinstance(signal, Waveform):
            msg = "Can only create plots for results of type wavewatson.Waveform!"
            raise TypeError(msg)

        bounds = list({br.bound for br in spec_result.bound_results})
        error_segments = [es for br in spec_result.bound_results for es in br.error_segments]
        error_segments = filter_sort_error_segments(error_segments, sort_by="length", reverse=True)

        yield generate_bound_violation_overview_plot(
            signal=signal,
            bounds=bounds,
            error_segments=error_segments,
            n_bins=n_bins,
            title=f"Bound violation overview for "
            f"specification {spec_result.spec.name!r} on result {spec_result.spec.ref!r}",
        )

        kwargs.pop("n_bins", None)
        for bound in bounds:
            es_for_current_bound = [es for es in error_segments if es.bound == bound]
            for _i, fig in enumerate(
                generate_bound_violation_plots(
                    signal=signal, error_segments=es_for_current_bound, n_bins=n_bins, **kwargs
                )
            ):
                yield fig


class SpecificationResult(BaseModel):
    spec: Specification
    error_message: str = ""

    raw_result: float | int | None = None
    result_string: ResultEnum = ResultEnum.notset
    bound_results: list[BoundResult] = Field(default_factory=list)

    @staticmethod
    def from_dict(spec: Specification, obj: dict) -> SpecificationResult:
        return SpecificationResult(
            **{
                "spec": spec,
                "bound_results": [BoundResult.from_dict(spec, bound_res) for bound_res in obj.pop("bound_results")],
                **obj,
            }
        )

    @property
    def is_pass(self):
        return self.result_string == ResultEnum.passed

    @property
    def is_fail(self):
        return self.result_string == ResultEnum.fail

    def set_error_message(self, error_message):
        self.result_string = ResultEnum.error
        self.error_message = error_message
        for br in self.bound_results:
            br.set_error_message(error_message)

    def set_all_skipped(self):
        self.result_string = ResultEnum.skipped
        for br in self.bound_results:
            br.result_string = self.result_string

    def add_bound_result(self, bound_results: BoundResult):
        self.bound_results.append(bound_results)
        self.update_result()

    def update_result(self):
        if any(rs.result_string in (ResultEnum.fail,) for rs in self.bound_results):
            self.result_string = ResultEnum.fail
        elif any(rs.result_string in (ResultEnum.error,) for rs in self.bound_results):
            self.result_string = ResultEnum.error
        elif any(rs.result_string in (ResultEnum.unknown,) for rs in self.bound_results):
            self.result_string = ResultEnum.unknown
        elif all(rs.result_string == ResultEnum.skipped for rs in self.bound_results):
            self.result_string = ResultEnum.skipped
        elif all(rs.result_string in (ResultEnum.passed, ResultEnum.skipped) for rs in self.bound_results):
            self.result_string = ResultEnum.passed
