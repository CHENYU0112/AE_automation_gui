from __future__ import annotations

import gc
import hashlib
import itertools
import math
import os
import warnings
from math import gcd

import numpy as np
import scipy.linalg as LA
import scipy.optimize
import scipy.signal as sps
from scipy.integrate import cumtrapz, simps, trapz
from scipy.interpolate import interp1d
from scipy.ndimage import uniform_filter1d

from wavewatson.compat import compat_inplace
from wavewatson.util.array_checks import (
    array_eq,
    array_ge,
    array_gt,
    array_le,
    array_lt,
    is_numeric,
    is_numeric_iterable,
)

eps = np.finfo(float).eps

__all__ = ["Waveform"]


def is_float(a):
    return isinstance(a, (float, np.floating))


def is_int(a):
    return isinstance(a, (int, np.integer))


class Filter:
    """
    This class is the filter subclass class for the Waveform class.
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    @compat_inplace
    def MovingAverage(self, window_length: int, mode: str = "reflect") -> Waveform:
        """
        Applies a moving average filter on the waveform.

        Inspired by https://stackoverflow.com/a/43200476

        :param window_length: The length of the filter window.
        :param mode: {reflect, nearest, mirror, wrap}, optional
        :return: The filtered waveform.

        .. note::

            Details on the ``mode`` options:

                The mode parameter determines how the input array is extended beyond its boundaries.
                Default is ``reflect``.
                Behavior for each valid value is as follows:

                ``reflect`` (d c b a | a b c d | d c b a)
                    The input is extended by reflecting about the edge of the last pixel. This mode is also sometimes
                    referred to as half-sample symmetric.

                ``nearest`` (a a a a | a b c d | d d d d)
                    The input is extended by replicating the last pixel.

                ``mirror`` (d c b | a b c d | c b a)
                    The input is extended by reflecting about the center of the last pixel. This mode is also sometimes
                    referred to as whole-sample symmetric.

                ``wrap`` (a b c d | a b c d | a b c d)
                    The input is extended by wrapping around to the opposite edge.
        """
        wf = self._w.copy()
        wf.data = uniform_filter1d(wf.data, size=window_length, mode=mode)
        return wf

    def SavitzkyGolay(self, window_length, polyorder, mode="interp", cval=0.0) -> Waveform:
        """
        Apply a Savitzky-Golay filter to an array.
        This is a 1-d filter.  If `x`  has dimension greater than 1, `axis`
        determines the axis along which the filter is applied.+

        :param window_length: The length of the filter window (i.e. the number of coefficients).
                              `window_length` must be a positive odd integer.
        :type window_length:  int
        :param polyorder: The order of the polynomial used to fit the samples.
                          `polyorder` must be less than `window_length`.
        :type polyorder: int
        :param mode:    Must be 'mirror', 'constant', 'nearest', 'wrap' or 'interp'.  This
                        determines the type of extension to use for the padded signal to
                        which the filter is applied.  When `mode` is 'constant', the padding
                        value is given by `cval`.  See the Notes for more details on 'mirror',
                        'constant', 'wrap', and 'nearest'.
                        When the 'interp' mode is selected (the default), no extension
                        is used.  Instead, a degree `polyorder` polynomial is fit to the
                        last `window_length` values of the edges, and this polynomial is
                        used to evaluate the last `window_length // 2` output values.
        :type mode: choice(mirror,constant,nearest,wrap,interp)
        :param cval: Value to fill past the edges of the input if `mode` is 'constant'.
                     Default is 0.0.
        :type cval: float
        :return: The filtered waveform.

        .. note::

            Details on the `mode` options:

            'mirror':
            Repeats the values at the edges in reverse order.  The value
            closest to the edge is not included.
            'nearest':
            The extension contains the nearest input value.
            'constant':
            The extension contains the value given by the `cval` argument.
            'wrap':
            The extension contains the values from the other end of the array.

        For example, if the input is [1, 2, 3, 4, 5, 6, 7, 8], and
        `window_length` is 7, the following shows the extended data for
        the various `mode` options (assuming `cval` is 0):

        +-----------+---------+------------------------+---------+
        |mode       |   Ext   |         Input          |   Ext   |
        +===========+=========+========================+=========+
        |'mirror'   | 4  3  2 | 1  2  3  4  5  6  7  8 | 7  6  5 |
        +-----------+---------+------------------------+---------+
        |'nearest'  | 1  1  1 | 1  2  3  4  5  6  7  8 | 8  8  8 |
        +-----------+---------+------------------------+---------+
        |'constant' | 0  0  0 | 1  2  3  4  5  6  7  8 | 0  0  0 |
        +-----------+---------+------------------------+---------+
        |'wrap'     | 6  7  8 | 1  2  3  4  5  6  7  8 | 1  2  3 |
        +-----------+---------+------------------------+---------+

        """
        wf = self._w.copy()
        wf.data = sps.savgol_filter(
            x=wf.data,
            window_length=window_length,
            polyorder=polyorder,
            mode=mode,
            cval=cval,
        )
        gc.collect()
        return wf

    @compat_inplace
    def MedianFilter(self, window_length) -> Waveform:
        """
        Perform a median filter on an N-dimensional array.
        Apply a median filter to the input array using a local window-size
        given by `kernel_size`.

        :param window_length: array_like, optional
                              A scalar or an N-length list giving the size of the median filter
                              window in each dimension.  Elements of `kernel_size` should be odd.
                              If `kernel_size` is a scalar, then this scalar is used as the size in
                              each dimension. Default size is 3 for each dimension.
        :type window_length: int
        :return: The filtered waveform.
        """
        wf = self._w.copy()
        wf.data = sps.medfilt(volume=wf.data, kernel_size=window_length)
        gc.collect()
        return wf

    @compat_inplace
    def WienerFilter(self, noise_power=None) -> Waveform:
        """
        Wiener filter is a filter used to produce an estimate of a desired or target random process by linear
        time-invariant filtering of an observed noisy process, assuming known stationary signal and noise spectra,
        and additive noise. The Wiener filter minimizes the mean square error between the estimated random process
        and the desired process. http://en.wikipedia.org/wiki/Wiener_filter

        :param noise_power: The noise-power to use. If None, then noise is estimated as the average
                            of the local variance of the input.
        :type noise_power: float
        :return: The filtered waveform.
        """
        wf = self._w.copy()
        wf.data = sps.wiener(im=wf.data, noise=noise_power)
        gc.collect()
        return wf

    @compat_inplace
    def FIR_LowPass_Hamming(self, bandwidth, window_length=64) -> Waveform:
        """
        Applies a fir low pass filter of the given bandwidth.

        :param bandwidth: Cutoff frequency of the filter (-3dB)
        :type bandwidth: float
        :param window_length: Length of the digital filter
        :type window_length: int
        :return: The filtered waveform.
        """
        if int(window_length) != float(window_length) or (int(window_length) % 2):
            msg = "Argument window length must be an even integer!"
            raise ValueError(msg)
        window_length = int(window_length)

        cutoff = float(bandwidth) / float(self._w.samplerate) / 2.0
        data = np.pad(
            self._w.data,
            (window_length, window_length),
            "constant",
            constant_values=(self._w.data[0], self._w.data[-1]),
        )
        filt = sps.firwin(numtaps=window_length, cutoff=cutoff, window="hamming")
        data = sps.lfilter(b=filt, a=1.0, x=data)
        data = data[int(window_length * 1.5) : int(-window_length * 0.5)]  # remove the filter settling time
        wf = self._w.copy()
        wf.data = data
        gc.collect()
        return wf

    @compat_inplace
    def IIR_LowPass(self, f_pass, f_stop, attn_pass=3, attn_stop=40, ftype="butter", mode="fb") -> Waveform:
        """
        Applies an IIR lowpass filter on the signal.

        :param f_pass: Passband edge frequency
        :type f_pass: float
        :param f_stop: Stopband edge frequency
        :type f_stop: float
        :param attn_pass: The maximum loss in the passband (dB).
        :type attn_pass: float
        :param attn_stop: The minimum attenuation in the stopband (dB).
        :type attn_stop: float
        :param ftype: The type of IIR filter to design:

            - Butterworth : "butter"
            - Chebyshev I : "cheby1"
            - Chebyshev II : "cheby2"
            - Cauer/elliptic: "ellip"
            - Bessel/Thomson: "bessel"

        :type ftype: choice(butter,cheby1,cheby2,ellip,bessel)

        :param mode: The filtering mode:

            - "normal": Filter data normally along one-dimension.
            - "fb": Apply the linear filter twice, once forward and once backwards.
                    The combined filter has linear phase.

        :type mode: choice(normal,fb)
        :return: The filtered waveform.
        """
        if f_pass > f_stop:
            msg = "Frequency of passband must be lower than frequency of stopband."
            raise ValueError(msg)
        nyq = self._w.samplerate / 2.0
        b, a = sps.iirdesign(
            wp=f_pass / nyq,
            ws=f_stop / nyq,
            gpass=attn_pass,
            gstop=attn_stop,
            ftype=ftype,
        )
        wf = self._w.copy()
        if mode == "normal":
            wf.data = sps.lfilter(b=b, a=a, x=wf.data)
        elif mode == "fb":
            wf.data = sps.filtfilt(b=b, a=a, x=wf.data)
        else:
            msg = f"Unknown mode '{mode}'."
            raise ValueError(msg)
        return wf

    @compat_inplace
    def IIR_HighPass(self, f_pass, f_stop, attn_pass=3, attn_stop=40, ftype="butter", mode="fb") -> Waveform:
        """
        Applies an IIR highpass filter on the signal.

        :param f_pass: Passband edge frequency
        :type f_pass: float
        :param f_stop: Stopband edge frequency
        :type f_stop: float
        :param attn_pass: The maximum loss in the passband (dB).
        :type attn_pass: float
        :param attn_stop: The minimum attenuation in the stopband (dB).
        :type attn_stop: float
        :param ftype: The type of IIR filter to design:

            - Butterworth : "butter"
            - Chebyshev I : "cheby1"
            - Chebyshev II : "cheby2"
            - Cauer/elliptic: "ellip"
            - Bessel/Thomson: "bessel"

        :type ftype: choice(butter,cheby1,cheby2,ellip,bessel)
        :param mode: The filtering mode:

            - "normal": Filter data normally along one-dimension.
            - "fb": Apply the linear filter twice, once forward and once backwards.
                    The combined filter has linear phase.

        :type mode: choice(normal,fb)
        :return: The filtered waveform.
        """
        if f_pass < f_stop:
            msg = "Frequency of passband must be higher than frequency of stopband."
            raise ValueError(msg)
        nyq = self._w.samplerate / 2.0
        b, a = sps.iirdesign(
            wp=f_pass / nyq,
            ws=f_stop / nyq,
            gpass=attn_pass,
            gstop=attn_stop,
            ftype=ftype,
        )
        wf = self._w.copy()
        if mode == "normal":
            wf.data = sps.lfilter(b=b, a=a, x=wf.data)
        elif mode == "fb":
            wf.data = sps.filtfilt(b=b, a=a, x=wf.data)
        else:
            msg = f"Unknown mode '{mode}'."
            raise ValueError(msg)
        return wf

    @compat_inplace
    def IIR_BandPass(self, f_pass, f_stop, attn_pass=3, attn_stop=40, ftype="butter", mode="fb") -> Waveform:
        """
        Applies an IIR bandpass filter on the signal.

        :param f_pass: Passband edge frequencies
        :type f_pass: list[float]
        :param f_stop: Stopband edge frequencies
        :type f_stop: list[float]
        :param attn_pass: The maximum loss in the passband (dB).
        :type attn_pass: float
        :param attn_stop: The minimum attenuation in the stopband (dB).
        :type attn_stop: float
        :param ftype: The type of IIR filter to design:

            - Butterworth : "butter"
            - Chebyshev I : "cheby1"
            - Chebyshev II : "cheby2"
            - Cauer/elliptic: "ellip"
            - Bessel/Thomson: "bessel"

        :type ftype: choice(butter,cheby1,cheby2,ellip,bessel)
        :param mode: The filtering mode:

            - "normal": Filter data normally along one-dimension.
            - "fb": Apply the linear filter twice, once forward and once backwards.
                    The combined filter has linear phase.

        :type mode: choice(normal,fb)
        :return: The filtered waveform.
        """
        if type(f_pass) in [list, np.ndarray] and len(f_pass) == 2:
            fp = np.array(f_pass)
        else:
            msg = "Parameter f_pass is not a list/array with length 2."
            raise ValueError(msg)
        if type(f_stop) in [list, np.ndarray] and len(f_stop) == 2:
            fs = np.array(f_stop)
        else:
            msg = "Parameter f_stop is not a list/array with length 2."
            raise ValueError(msg)

        if not (np.all(fs[0] < fp) and np.all(fs[1] > fp)):
            msg = "Frequencies of passband must be between stopband frequencies."
            raise ValueError(msg)
        nyq = self._w.samplerate / 2.0
        b, a = sps.iirdesign(wp=fp / nyq, ws=fs / nyq, gpass=attn_pass, gstop=attn_stop, ftype=ftype)
        wf = self._w.copy()
        if mode == "normal":
            wf.data = sps.lfilter(b=b, a=a, x=wf.data)
        elif mode == "fb":
            wf.data = sps.filtfilt(b=b, a=a, x=wf.data)
        else:
            msg = f"Unknown mode '{mode}'."
            raise ValueError(msg)
        return wf

    @compat_inplace
    def IIR_BandStop(self, f_pass, f_stop, attn_pass=3, attn_stop=40, ftype="butter", mode="fb") -> Waveform:
        """
        Applies an IIR bandstop filter on the signal.

        :param f_pass: Passband edge frequencies
        :type f_pass: list[float]
        :param f_stop: Stopband edge frequencies
        :type f_stop: list[float]
        :param attn_pass: The maximum loss in the passband (dB).
        :type attn_pass: float
        :param attn_stop: The minimum attenuation in the stopband (dB).
        :type attn_stop: float
        :param ftype: The type of IIR filter to design:

            - Butterworth : "butter"
            - Chebyshev I : "cheby1"
            - Chebyshev II : "cheby2"
            - Cauer/elliptic: "ellip"
            - Bessel/Thomson: "bessel"

        :type ftype: choice(butter,cheby1,cheby2,ellip,bessel)
        :param mode: The filtering mode:

            - "normal": Filter data normally along one-dimension.
            - "fb": Apply the linear filter twice, once forward and once backwards.
                    The combined filter has linear phase.

        :type mode: choice(normal,fb)
        :return: The filtered waveform.
        """
        if type(f_pass) in [list, np.ndarray] and len(f_pass) == 2:
            fp = np.array(f_pass)
        else:
            msg = "Parameter f_pass is not a list/array with length 2."
            raise ValueError(msg)
        if type(f_stop) in [list, np.ndarray] and len(f_stop) == 2:
            fs = np.array(f_stop)
        else:
            msg = "Parameter f_stop is not a list/array with length 2."
            raise ValueError(msg)

        if not (np.all(fp[0] < fs) and np.all(fp[1] > fs)):
            msg = "Frequencies of passband must be between stopband frequencies."
            raise ValueError(msg)
        nyq = self._w.samplerate / 2.0
        b, a = sps.iirdesign(wp=fp / nyq, ws=fs / nyq, gpass=attn_pass, gstop=attn_stop, ftype=ftype)
        wf = self._w.copy()
        if mode == "normal":
            wf.data = sps.lfilter(b=b, a=a, x=wf.data)
        elif mode == "fb":
            wf.data = sps.filtfilt(b=b, a=a, x=wf.data)
        else:
            msg = f"Unknown mode '{mode}'."
            raise ValueError(msg)
        return wf

    def rate_limit(self, rate: float) -> Waveform:
        """
        Apply a rate limit to the waveform.

        Example::

            w = Waveform(data=np.array([1, 4, 5, 0, 3]), time=[0.0, 1.0]).repeat_samples(1000)
            w100 = w.Filter.RateLimit(100)

        :param rate: The rate limit in units/s.
        """
        w = self._w
        x = w.data
        t = w.time

        def gen():
            y = x[0]
            tprev = t[0]
            for xi, ti in zip(x, t):
                dy = xi - y
                dt = ti - tprev
                y += np.clip(dy, -rate * dt, rate * dt)
                tprev = ti
                yield y

        data = np.fromiter(gen(), float, count=len(w))
        return Waveform(time=w.time[:], data=data)


# https://github.com/NickFoubert/simple-segment
class Fitting:
    """
    This class is the fitting subclass class for the Waveform class.
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    def segmented_linear_best_fit(self, max_err, min_segment_len=1000, window_reduce_factor=0.5):
        """
        Separates a waveform into several lines of best fit. The shape of the parts is defined by the fitting function.
        The algorithm always tries to first fit to the whole remaining window (waveform length).
        The error exceeds max_err the window is reduced by window_length * window_reduce_factor. This is done as
        long
        as the error drops below max_err or the min_segment_len is reached.

        :param max_err: The maximum tolerated error for 'error' = np.sum((fit_curve - ydata[Tstart:Tstop])**2).
                        If 'error' is bigger than 'max_err' the fitting window is reduced by window_length *
                        window_reduce_factor.
        :type max_err: float
        :param min_segment_len: The minimal window length the algorithm uses for a line of best fit.
        :type min_segment_len: int
        :param window_reduce_factor: The factor of window reduction in case the error is greater than max_err.
        :type window_reduce_factor: float
        :return: wf_fit. Assembled fitting curve as waveform object
                  wf_fit_gr. Curve of first derivative of the fit curve(without discontinuities) as waveform
        :rtype: list[Waveform]
        """

        def fitting_func(x, m, t):
            return m * x + t

        if window_reduce_factor >= 1:
            msg = "window_reduce_factor has to be smaller than 1."
            raise ValueError(msg)

        fitting_curves = []

        Tstart = 0
        length = len(self._w.time)
        Tstop = length
        while True:
            fit_coef, fit_pcov = scipy.optimize.curve_fit(
                fitting_func,
                self._w.time[Tstart:Tstop],
                self._w.data[Tstart:Tstop],
            )
            fit_curve = fitting_func(self._w.time[Tstart:Tstop], *fit_coef)
            # error = np.sum((fit_curve - ydata[Tstart:Tstop])**2)
            error = np.sqrt(np.sum(np.abs(fit_curve - self._w.data[Tstart:Tstop]) ** 2))
            result = {
                "data": fit_curve,
                "time": self._w.time[Tstart:Tstop],
                "gradient": np.polyder(fit_coef),
                "coef": fit_coef,
            }
            if error <= max_err or (Tstop - Tstart) * window_reduce_factor < min_segment_len:
                fitting_curves.append(result)
                Tstart = Tstop
                Tstop = length
            elif (Tstop - Tstart) * window_reduce_factor >= min_segment_len:
                # TODO: BUG: Tstop can become a float by this calculation and will cause a TypeError when trying to
                #  do integer slicing in the next loop iteration `self._w.time[Tstart:Tstop]`
                Tstop = Tstart + (Tstop - Tstart) * window_reduce_factor

            if Tstart == Tstop:
                break

        fit_curve = np.array([])
        gradient_curve = np.array([])
        for curve in fitting_curves:
            fit_curve = np.append(fit_curve, curve["data"])
            gradient_curve = np.append(gradient_curve, (list(curve["gradient"]) * len(curve["time"])))

        wf_fit = Waveform(time=self._w.time, data=fit_curve)
        wf_fit_gr = Waveform(time=self._w.time, data=gradient_curve)
        gc.collect()
        return wf_fit, wf_fit_gr

    def detrend(self, breakpoints=None) -> Waveform:
        """
        Remove linear trend along axis from waveform.

        :param breakpoints: A sequence of break points. If given, an individual linear fit is performed for each part
                            of data between two break points.\n
                            Use integers to define the indices where the breakpoint is set.\n
                            To define breakpoints at specifiec times use the waveform member function 'time_to_index'
                            with a list of floats as argument.
        :type breakpoints: list[int]
        :return: The waveform with the linear trend removed.
        """
        if breakpoints is None:
            bp = 0
        elif isinstance(breakpoints, list):
            bp = np.array(breakpoints, dtype=np.int64)
        else:
            msg = "Argument breakpoints has to be None or a list of integers"
            raise TypeError(msg)

        wf = self._w.copy()
        wf.data = sps.detrend(wf.data, type="linear", bp=bp)
        return wf

    def remove_baseline(self, deg=None, max_it=None, tol=None) -> Waveform:
        """
        Computes and removes the baseline from the signal

        Iteratively performs a polynomial fitting in the data to detect its
        baseline. At every iteration, the fitting weights on the regions with
        peaks are reduced to identify the baseline only.

        :param deg: Default: 3.
                    Degree of the polynomial that will estimate the data baseline. A low
                    degree may fail to detect all the baseline present, while a high
                    degree may make the data too oscillatory, especially at the edges.
        :type deg: ndarray
        :param max_it: Default: 100. Maximum number of iterations to perform.
        :type max_it: int
        :param tol: Default: 1e-3.
                    Tolerance to use when comparing the difference between the current
                    fit coefficients and the ones from the last iteration. The iteration
                    procedure will stop when the difference between them is lower than
                    *tol*.
        :type tol: float
        :returns: The fitted waveform.
        """
        # for not repeating ourselves in `envelope`
        if deg is None:
            deg = 3
        if max_it is None:
            max_it = 100
        if tol is None:
            tol = 1e-3
        y = self._w.data

        order = deg + 1
        coeffs = np.ones(order)

        # try to avoid numerical issues
        cond = math.pow(y.max(), 1.0 / order)
        x = np.linspace(0.0, cond, y.size)
        base = y.copy()

        vander = np.vander(x, order)
        vander_pinv = LA.pinv2(vander)

        for _ in range(max_it):
            coeffs_new = np.dot(vander_pinv, y)

            if LA.norm(coeffs_new - coeffs) / LA.norm(coeffs) < tol:
                break

            coeffs = coeffs_new
            base = np.dot(vander, coeffs)
            y = np.minimum(y, base)

        wf = self._w.copy()
        wf.data -= y
        return wf

    def curve_fit(
        self,
        function,
        p0=None,
        sigma=None,
        absolute_sigma=False,
        check_finite=True,
        bounds=(-np.inf, np.inf),
        method=None,
        jac=None,
        **kwargs,
    ) -> tuple[Waveform, np.ndarray, np.ndarray]:
        """
        Use non-linear least squares to fit a function, f, to data.

        Assumes ``ydata = f(xdata, *params) + eps``


        :param function:    callable.
                            The model function, f(x, ...).  It must take the independent
                            variable as the first argument and the parameters to fit as
                            separate remaining arguments.
        :param p0:  None, scalar, or N-length sequence, optional.
                    Initial guess for the parameters.  If None, then the initial
                    values will all be 1 (if the number of parameters for the function
                    can be determined using introspection, otherwise a ValueError
                    is raised).
        :param sigma:   None or M-length sequence or MxM array, optional.
                        Determines the uncertainty in `ydata`. If we define residuals as
                        ``r = ydata - f(xdata, *popt)``, then the interpretation of `sigma`
                        depends on its number of dimensions:

                            - A 1-d `sigma` should contain values of standard deviations of
                              errors in `ydata`. In this case, the optimized function is
                              ``chisq = sum((r / sigma) ** 2)``.

                            - A 2-d `sigma` should contain the covariance matrix of
                              errors in `ydata`. In this case, the optimized function is
                              ``chisq = r.T @ inv(sigma) @ r``.

                        None (default) is equivalent of 1-d `sigma` filled with ones.
        :param absolute_sigma:  bool, optional.
                                If True, `sigma` is used in an absolute sense and the estimated parameter
                                covariance `pcov` reflects these absolute values.

                                If False, only the relative magnitudes of the `sigma` values matter.
                                The returned parameter covariance matrix `pcov` is based on scaling
                                `sigma` by a constant factor. This constant is set by demanding that the
                                reduced `chisq` for the optimal parameters `popt` when using the
                                *scaled* `sigma` equals unity. In other words, `sigma` is scaled to
                                match the sample variance of the residuals after the fit.
                                Mathematically,
                                ``pcov(absolute_sigma=False) = pcov(absolute_sigma=True) * chisq(popt)/(M-N)``
        :param check_finite:    bool, optional.
                                If True, check that the input arrays do not contain nans of infs,
                                and raise a ValueError if they do. Setting this parameter to
                                False may silently produce nonsensical results if the input arrays
                                do contain nans. Default is True.
        :param bounds:  2-tuple of array_like, optional.
                        Lower and upper bounds on parameters. Defaults to no bounds.
                        Each element of the tuple must be either an array with the length equal
                        to the number of parameters, or a scalar (in which case the bound is
                        taken to be the same for all parameters.) Use ``np.inf`` with an
                        appropriate sign to disable bounds on all or some parameters.

        :param method:  {'lm', 'trf', 'dogbox'}, optional.
                        Method to use for optimization.  See `least_squares` for more details.
                        Default is 'lm' for unconstrained problems and 'trf' if `bounds` are
                        provided. The method 'lm' won't work when the number of observations
                        is less than the number of variables, use 'trf' or 'dogbox' in this
                        case.

        :param jac:     callable, string or None, optional.
                        Function with signature ``jac(x, ...)`` which computes the Jacobian
                        matrix of the model function with respect to parameters as a dense
                        array_like structure. It will be scaled according to provided `sigma`.
                        If None (default), the Jacobian will be estimated numerically.
                        String keywords for 'trf' and 'dogbox' methods can be used to select
                        a finite difference scheme, see `least_squares`.

        :param kwargs: Keyword arguments passed to `leastsq` for ``method='lm'`` or `least_squares` otherwise.
        """
        popt, pcov = scipy.optimize.curve_fit(
            function,
            self._w.time,
            self._w.data,
            p0,
            sigma,
            absolute_sigma,
            check_finite,
            bounds,
            method,
            jac,
            **kwargs,
        )

        fit = Waveform(function(self._w.time, *popt), self._w.time)
        return fit, popt, pcov


class Generator:
    @staticmethod
    def Sine(Length, Amplitude, Frequency, Offset, StartPhase):
        """
        Returns a sine waveform.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param Amplitude: The waveforms amplitude
        :type Amplitude: float
        :param Frequency: The frequency of the waveform
        :type Frequency: float
        :param Offset: The DC offset of the waveform
        :type Offset: float
        :param StartPhase: The start phase of the waveform. Valid value: 0.0 - 360.0
        :type StartPhase: float
        :rtype: Waveform
        """

        if StartPhase < 0 or StartPhase > 360:
            msg = "Valid range for StartPhase is 0 to 360"
            raise ValueError(msg)
        timevec = np.linspace(0, 1.0 / Frequency, Length, endpoint=False)
        datavec = Amplitude * np.sin(2 * np.pi * Frequency * timevec + (StartPhase / 180.0) * np.pi) + Offset
        return Waveform(time=timevec, data=datavec)

    @staticmethod
    def Square(Length, Amplitude, Frequency, Offset, DutyCycleHigh):
        """
        Returns a square waveform.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param Amplitude: The waveforms amplitude
        :type Amplitude: float
        :param Frequency: The frequency of the waveform
        :type Frequency: float
        :param Offset: The DC offset of the waveform
        :type Offset: float
        :param DutyCycleHigh: The dutycycle high in percent.
        :type DutyCycleHigh: float
        :rtype: Waveform
        """
        timevec = np.linspace(0, 1.0 / Frequency, Length, endpoint=False)
        if DutyCycleHigh < 0 or DutyCycleHigh > 100:
            msg = "Valid range for DutyCycleHigh is 0.0 to 100.0"
            raise ValueError(msg)
        return (
            Waveform(
                time=timevec,
                data=sps.square(2 * np.pi * Frequency * timevec, DutyCycleHigh / 100.0),
            )
            * Amplitude
            + Offset
        )

    @staticmethod
    def Triangle(Length, Amplitude, Frequency, Offset, StartPhase):
        """
        Returns a triangular waveform.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param Amplitude: The waveforms amplitude
        :type Amplitude: float
        :param Frequency: The frequency of the waveform
        :type Frequency: float
        :param Offset: The DC offset of the waveform
        :type Offset: float
        :param StartPhase: The start phase of the waveform. Valid value: 0.0 - 360.0
        :type StartPhase: float
        :rtype: Waveform
        """
        if Frequency <= 0 or Length <= 0:
            msg = "frequency and Length shall have a positive value"
            raise ValueError(msg)
        timevec = np.linspace(0, 1.0 / Frequency, Length, endpoint=False)
        phase = ((180.0 + StartPhase) / 180.0) * np.pi + 1.5 * np.pi
        phase %= 2 * np.pi
        datavec = Amplitude * sps.sawtooth(2 * np.pi * Frequency * timevec + phase, 0.5) + Offset
        return Waveform(time=timevec, data=datavec)

    @staticmethod
    def Sawtooth(Length, Width, Amplitude, Frequency, Offset, StartPhase):
        """
        Returns a sawtooth waveform.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param Width: Width of the rising ramp as a proportion of the total cycle.
                      Default is 1, producing a rising ramp, while 0 produces a falling ramp.
                      0.5 produces a triangle wave.
        :type Width: float
        :param Amplitude: The waveforms amplitude
        :type Amplitude: float
        :param Frequency: The frequency of the waveform
        :type Frequency: float
        :param Offset: The DC offset of the waveform
        :type Offset: float
        :param StartPhase: The start phase of the waveform. Valid value: 0.0 - 360.0
        :type StartPhase: float
        :rtype: Waveform
        """
        if Frequency <= 0 or Length <= 0:
            msg = "frequency and Length shall have a positive value"
            raise ValueError(msg)
        timevec = np.linspace(0, 1.0 / Frequency, Length, endpoint=False)
        phase = (StartPhase / 180.0) * np.pi
        phase %= 2 * np.pi
        datavec = Amplitude * sps.sawtooth(2 * np.pi * Frequency * timevec + phase, Width) + Offset
        return Waveform(time=timevec, data=datavec)

    @staticmethod
    def Ramp(Length, From, To, Frequency):
        """
        Returns a ramp waveform.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param From: The start value of the ramp
        :type From: float
        :param To: The stop value of the ramp
        :type To: float
        :param Frequency: The frequency of the waveform
        :type Frequency: float
        :rtype: Waveform
        """
        if Frequency <= 0 or Length <= 0:
            msg = "Frequency and length shall have a positive value"
            raise ValueError(msg)
        timevec = np.linspace(0, 1.0 / Frequency, Length, endpoint=False)
        return Waveform(time=timevec, data=np.linspace(From, To, len(timevec)))

    @staticmethod
    def DC(Length, SampleRate, DCOffset):
        """
        Returns a constant waveform.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param SampleRate: The desired samplerate
        :type SampleRate: float
        :param DCOffset: The constant DC value to set
        :type DCOffset: float
        :rtype: Waveform
        """
        if SampleRate <= 0 or Length <= 0:
            msg = "samplerate or length shall have a positive value"
            raise ValueError(msg)
        time = Length / float(SampleRate)
        timevec = np.linspace(0, time, Length, endpoint=False)
        return Waveform(time=timevec, data=np.ones(Length) * DCOffset)

    @staticmethod
    def PWM(Length, Amplitude, Frequency, Offset, ModulationSignal):
        """
        Returns a PWM waveform that has the length as specified and the time base (start + end)
        from the modulation signal.

        :param Length: The number of points the waveform shall have.
        :type Length: int
        :param Amplitude: The waveforms amplitude
        :type Amplitude: float
        :param Frequency: The frequency of the square waveform
        :type Frequency: float
        :param Offset: The DC offset of the waveform
        :type Offset: float
        :param ModulationSignal: The waveform that modulates the duty cycle of the square wave
        :type ModulationSignal: Waveform
        :rtype: Waveform
        """
        if Frequency <= 0 or Length <= 0:
            msg = "samplerate or length shall have a positive value"
            raise ValueError(msg)
        if not isinstance(ModulationSignal, Waveform):
            msg = "Argument 'ModulationSignal' must be of type Waveform"
            raise TypeError(msg)
        if len(ModulationSignal) < Length:
            ModulationSignal = ModulationSignal.up_sample_interp(nr_points=Length)
        elif len(ModulationSignal) > Length:
            ModulationSignal = ModulationSignal.down_sample(nr_points=Length)
        if ModulationSignal.Measurements_Base.max() > 1 or ModulationSignal.Measurements_Base.min() < 0:
            ModulationSignal = ModulationSignal.scale_to_minmax(0, 1)

        timevec = np.linspace(0, ModulationSignal.time[-1], Length, endpoint=False)

        return (
            Waveform(time=timevec, data=sps.square(2 * np.pi * Frequency * timevec, ModulationSignal.data)) * Amplitude
            + Offset
        )


class Measurements_Base:
    """
    This class is the basic measurement class used in the basic Waveform class.
    Waveform classes which inherit from the Waveform base class and need extended functionality for measurements use
    this class to define a waveform specific measurements class inheriting from this one.
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    def max(self):
        """
        Returns the maximum of the signal.

        :rtype: float
        """

        return np.max(self._w.data)

    def min(self):
        """
        Returns the minimum of the signal.

        :rtype: float
        """

        return np.min(self._w.data)

    def mean(self):
        """
        Returns the mean of the signal.

        :rtype: float
        """

        if self._w.samplerate == 0:
            return trapz(self._w.data, self._w.time) / self._w.duration

        return np.mean(self._w.data)

    def peak_to_peak(self):
        """
        Returns the peak to peak value of the signal. Uses min and max function to determine result.

        :rtype: float
        """

        return np.ptp(self._w.data)

    def standard_deviation(self):
        """
        Returns the maximum of the signal.

        :rtype: float
        """

        return np.std(self._w.data)

    def rms(self):
        """
        Returns the RMS value of the signal.

        :rtype: float
        """

        return np.sqrt(np.sum(self._w.data**2) / float(self._w.length))

    def level_percent(self, level):
        """
        Converts a level in percent to a real data value.
        Returns value by using following function:

        value = min(wave) + peak_to_peak(wave) * level

        :param level: The level of the signal in percent.
        :type level: float
        """
        if not (0 <= level <= 100):
            msg = "level shall have a value between 0 and 100"
            raise ValueError(msg)

        return self.min() + self.peak_to_peak() * float(level) / 100.0


class Measurements_Utils:
    def __init__(self, wf):
        self._w: Waveform = wf

    def argmax(self, return_index=False):
        """
        Returns the time when the first maximum of the signal occurs.

        :param return_index: If True an index is returned instead of a time value.
        :type return_index: bool
        """
        idx = np.argmax(self._w.data)
        if return_index:
            return idx

        return self._w.time[idx]

    def argmin(self, return_index=False):
        """
        Returns the time when the first minimum of the signal occurs.

        :param return_index: If True an index is returned instead of a time value.
        :type return_index: bool
        """
        idx = np.argmin(self._w.data)
        if return_index:
            return idx

        return self._w.time[idx]

    def find_intersections(
        self, other, timebase="both", interpolate_result=True, return_indices=False, skip_check=False
    ):
        """
        Returns all times when the signal crosses the other signal. It is assumed that both signals are functions
        (i.e. x-values strictly increasing).

        :param other: The waveform to find intersections to.
        :type other: Waveform
        :param timebase:

            - 'self': use the time array of the own waveform and interpolate the other onto it. (cheapest)
            - 'both': calculate a time array using both waveforms and interpolate both onto it. (most expensive)
            - 'finer': use the time array of the waveform with the finer resolution.
                      (Might give worse results than 'self', if used with unevenly spaced time arrays.)
        :type timebase: choice(self,both,finer)
        :param interpolate_result: If True, a linear interpolation will be executed to find the exact crossing,
                                   otherwise the timestamps will be rounded down to the closest sample.
                                   Will be ignored, if return_indices is True.
        :type interpolate_result: bool
        :param return_indices: If True indices are returned instead of time steps.
        :type return_indices: bool
        :param skip_check: Whether to skip the safety check, which ensures that both waveforms have strictly increasing
                           time-values (results might be meaningless without this check)
        :type skip_check: bool
        :return: Timestamps of the crossings
        :rtype: np.ndarray
        """

        if not skip_check:
            # Check, that both waveforms have strictly increasing time-values.
            # Otherwise the results might be meaningless
            assert np.all(np.diff(self._w.time) > 0)
            assert np.all(np.diff(other.time) > 0)
        # The algorithm only works, if both waveforms share the same timebase,
        # so equalize the timebase according to the parameter
        if timebase == "self":
            # take the timebase of your own waveform
            time = self._w.time
            self_data = self._w.data
            other_data = other.interpolate(time).data
        elif timebase == "both":
            # combine both timebases
            time = np.unique(np.concatenate((self._w.time, other.time)))
            time.sort()
            self_data = self._w.interpolate(time).data
            other_data = other.interpolate(time).data
        elif timebase == "finer":
            # take the timebase with the higher resolution
            self_res = len(self._w.time) / (self._w.time[-1] - self._w.time[0])
            other_res = len(other.time) / (other.time[-1] - other.time[0])
            if self_res > other_res:
                time = self._w.time
                self_data = self._w.data
                other_data = other.interpolate(time).data
            else:
                time = other.time
                self_data = self._w.interpolate(time).data
                other_data = other.data
        else:
            raise Exception("invalid argument for parameter timebase: " + timebase)

        # prevent extrapolation -> only look for intersections in the time-region
        # covered by both of the original waveforms
        min_t = max(self._w.time[0], other.time[0])
        max_t = min(self._w.time[-1], other.time[-1])
        min_idx = np.where(time >= min_t)[0][0]
        max_idx = np.where(time <= max_t)[0][-1]
        time = time[min_idx:max_idx]
        self_data = self_data[min_idx:max_idx]
        other_data = other_data[min_idx:max_idx]

        # find crossings
        idxs = np.where(np.diff(self_data > other_data) & np.diff(self_data < other_data))[0]
        if return_indices:
            return idxs
        ts = time[idxs]
        if not interpolate_result:
            return ts

        # linearly interpolate between the points in idxs and the next ones to reach a more precise result
        idxs2 = idxs + 1
        ts2 = time[idxs2]
        s1 = self_data[idxs]
        s2 = self_data[idxs2]
        o1 = other_data[idxs]
        o2 = other_data[idxs2]
        m = ((s1 - s2) - (o1 - o2)) / (ts - ts2)
        return -(-m * ts + s1 - o1) / m

    def find_all_crossings(self, level, hysteresis=0, htype="abs", return_indices=False, return_point="mid"):
        """
        Returns all times and slopes where the signal crosses a specific level with hysteresis.
        If hysteresis is used, the argument 'return_point' will determine which point of the hysteresis area is
        returned as the crossing.

        :param level: The crossing level to look for.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param htype: Type of the hysteresis parameter "rel" -> hysteresis is relative to the crossing level
                      "abs"  -> hysteresis is an absolute value
        :type htype: choice(abs,rel)
        :param return_indices: If True indices are returned instead of time steps.
        :type return_indices: bool
        :param return_point: Specifies which point of the hysteresis area of the found crossing to return.
                             "start" returns the point where the signal enters the hysteresis area, "mid" the median
                             and "end" the point where the signal leaves the hysteresis area.
        :type return_point: str
        :return: Returns a numpy array with {"index": <index>, "slope": "rise"} or {"index": <index>, "slope": "fall"}
                 entries
        :rtype: list[dict[str, str|int|float]]
        """

        data = abs(self._w.data) if self._w.type == Waveform.TYPES.FFT else self._w.data
        eps = np.finfo(np.float64).eps
        if htype == "rel":
            ptop = self._w.Measurements_Base.peak_to_peak()
            hyst_high = level + abs(hysteresis * ptop)
            hyst_low = level - abs(hysteresis * ptop)
        else:
            hyst_high = level + abs(hysteresis) / 2.0 + eps * (max(abs(level), 1))
            hyst_low = level - abs(hysteresis) / 2.0 - eps * (max(abs(level), 1))

        # http://stackoverflow.com/questions/23289976/how-to-find-zero-crossings-with-hysteresis
        initial = False
        hi = data >= hyst_high
        lo_or_hi = (data <= hyst_low) | hi

        ind = np.nonzero(lo_or_hi)[0]
        if not ind.size:  # prevent index error if ind is empty
            return []
        cnt = np.cumsum(lo_or_hi)  # from 0 to len(x)
        h = np.where(cnt, hi[ind[cnt - 1]], initial).astype(
            np.int64
        )  # No idea how this works, got it from the internet :)
        d = h[1:] - h[:-1]  # Transition indices of h
        r = np.where(d == 1)[0]  # Rising transition indices
        f = np.where(d == -1)[0]  # Falling transition indices
        if r.__len__() > 0 or f.__len__() > 0:
            first_cr = int(
                min(np.append(r, f))
            )  # Remove first crossing if the signal starts within the hysteresis area
            if (
                len(data[: first_cr + 1]) > 0
                and np.all(hyst_low <= data[: first_cr + 1])
                and np.all(data[: first_cr + 1] <= hyst_high)
            ):
                if first_cr in r:
                    r = r[1:]
                if first_cr in f:
                    f = f[1:]
            if len(np.append(r, f)) > 0:  # Otherwise we have an error max empty argument.
                last_cr = int(max(np.append(r, f)))  # Remove last crossing if the signal end within the hysteresis area
                if len(data[last_cr:]) > 0 and np.all((hyst_low <= data[last_cr:]) & (data[last_cr:] <= hyst_high)):
                    if last_cr in r:
                        r = r[:-1]
                    if last_cr in f:
                        f = f[:-1]

            if str(return_point).lower() in ["start", "middle"] or "mid" in str(return_point).lower():
                ind2 = np.nonzero(~lo_or_hi)[0]
                areas = np.split(
                    ind2, np.where(np.diff(ind2) > 1)[0] + 1
                )  # Areas where the signal is within the hyst area
                if areas[0].__len__() > 0:
                    if areas[0][0] == 0:
                        areas = areas[1:]  # If first area starts at 0 remove area
                    if len(areas) > 0 and areas[-1][-1] == len(self._w) - 1:
                        areas = areas[:-1]  # If last area ends with len(self.wf) - 1 remove area

                    retpoints = {}
                    if (
                        "mid" in str(return_point).lower()
                    ):  # Find the area medians and assign them to the indices where the signal leaves the hyst area
                        retpoints.update({area[-1]: int(area[int(len(area) / 2)]) for area in areas})
                    elif (
                        "sta" in str(return_point).lower()
                    ):  # Find the area start points and assign them to the indices where the
                        # signal leaves the hyst area
                        retpoints.update({area[-1]: int(area[0]) for area in areas})

                    r_new, f_new = [], []
                    # If the indices where the signal leaves the hyst area can be found inside the repoints dict,
                    # assign their values. It might be that the index cannot be found in retpoints because the
                    # signal has too low resolution and there are no points that are inside the hyst area.
                    for _r in r:
                        r_new.append(retpoints.get(_r, _r))
                    for _f in f:
                        f_new.append(retpoints.get(_f, _f))

                    r, f = r_new, f_new

                if abs(len(r) - len(f)) > 1:
                    msg = (
                        "Found wrong number of rising/falling crossings. The number of rising and falling"
                        "crossings must not be differ more than 1."
                    )
                    raise Exception(msg)

        if len(f) == len(r) == 0:
            return []

        rf = [-1] * (len(r) + len(f))
        # Interleave rising/falling crossing indices

        if len(f) > 0 and len(r) > 0 and f[0] < r[0]:
            start_slope = "fall"
            rf[::2] = f
            rf[1::2] = r
        elif len(f) > 0 and len(r) > 0 and r[0] < f[0]:
            start_slope = "rise"
            rf[::2] = r
            rf[1::2] = f
        elif len(r) == 0 and len(f) == 1:
            if self._w.time is not None and not return_indices:
                return [{"index": self._w.time[f[0]], "slope": "fall"}]

            return [{"index": f[0], "slope": "fall"}]
        elif len(f) == 0 and len(r) == 1:
            if self._w.time is not None and not return_indices:
                return [{"index": self._w.time[r[0]], "slope": "rise"}]

            return [{"index": r[0], "slope": "rise"}]
        else:
            msg = "Unknown error."
            raise Exception(msg)

        cr = [0] * len(rf)
        mod = 0 if start_slope == "rise" else 1
        for i, val in enumerate(rf):
            if self._w.time is not None and not return_indices:
                cr[i] = {
                    "index": self._w.time[val],
                    "slope": "rise" if i % 2 == mod else "fall",
                }
            else:
                cr[i] = {
                    "index": int(val),
                    "slope": "rise" if i % 2 == mod else "fall",
                }
        return cr

    def find_specific_crossings(
        self,
        level,
        slope,
        hysteresis=0,
        htype="abs",
        return_indices=False,
        return_point="mid",
    ):
        """
        Returns all indices/times where the signal crosses a specific level with hysteresis with a specific slope.

        :param level: The crossing level to look for.
        :type level: float
        :param slope: The type of crossings to find. "rise" or "fall"
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param htype: Type of the hysteresis parameter "rel" -> hysteresis is relative to the crossing level
                      "abs"  -> hysteresis is an absolute value
        :type htype: choice(abs,rel)
        :param return_indices: If True indices are returned instead of time steps.
        :type return_indices: bool
        :param return_point: Specifies which point of the hysteresis area of the found crossing to return.
                             "start" returns the point where the signal enters the hysteresis area, "mid" the median
                             and "end" the point where the signal leaves the hysteresis area.
        :type return_point: str
        :return: List with indices/times of the crossings
        :rtype: list[float]
        """
        crossings = self.find_all_crossings(level, hysteresis, htype, return_indices, return_point)
        if slope.lower() not in ["rise", "fall"]:
            msg = f"Unknown edge '{slope}'."
            raise Exception(msg)
        slope = slope.lower()
        edges = []
        for cr in crossings:
            if cr["slope"] == slope:
                edges.append(cr["index"])
        return edges

    def find_nth_crossing(
        self,
        level,
        slope,
        index,
        hysteresis=0,
        htype="abs",
        return_indices=False,
        return_point="mid",
    ):
        """
        Returns the first time where 'data' crosses a certain value (with hysteresis).

        :param level: The crossing level to look for.
        :type level: float
        :param slope: The type of crossings to find. "rise" or "fall"
        :type slope: choice(rise,fall)
        :param index: The number of the crossing which shall be returned.
                      0 for the first crossing, -1 for the last one.
        :type index: int
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param htype: Type of the hysteresis parameter "rel" -> hysteresis is relative to the crossing level
                      "abs"  -> hysteresis is an absolute value
        :type htype: choice(abs,rel)
        :param return_indices: If True indices are returned instead of time steps.
        :type return_indices: bool
        :param return_point: Specifies which point of the hysteresis area of the found crossing to return.
                             "start" returns the point where the signal enters the hysteresis area, "mid" the median
                             and "end" the point where the signal leaves the hysteresis area.
        :type return_point: str
        :return: Returns the time of the crossing. If no crossing is found the function returns None
        :rtype: float|NoneType
        """

        crossings = self.find_specific_crossings(level, slope, hysteresis, htype, return_indices, return_point)
        if crossings:
            try:
                return crossings[index]
            except IndexError:
                msg = "No crossing could be found with the specified index"
                raise IndexError(msg) from None
        else:
            return None

    def find_n_maxima(
        self, min_find_count, hysteresis=0, min_level=None, stepsize=5, return_point="start", return_indices=False
    ):
        """
        Searches at least "min_find_count" maxima.
        The signal is split into several parts with the splitting points determined by intersecting the signal with a
        horizontal line. Each pair of positiv and negative crossings defines an area where the signal must have a
        maximum.
        Also, a single falling edge in the beginning as well as a rising edge in the end defines such an area.
        Afterwards the index of the maximum is searched in all areas.
        If the resulting number of maxima is less than the specified one the line offset is reduced by 5% of
        signal range (starting at 100%). This procedure is repeated until the specified number of maxima is found or
        the line offset drops below 'min_level' (in this case an exception is raised).

        :param min_find_count: The number of maxima the algorithm has to find
        :type min_find_count: int
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param min_level: The minimum offset of the horizontal intersection line before an error is raised.
                          The offset is reduced as 5% by signal range until the specified number of crossings is found.
        :type min_level: float
        :param stepsize: The reduction of the horizontal crossing line in % of the signal range if not enought maxima
               were found.
        :type stepsize: float
        :param return_point: In case the maximum of a found area consists of multiple points with equal level,
                             this argument specifies which point to return. "start" returns the first point where
                             the maximum is found, "mid" the median one and "end" the last point
        :type return_point: str
        :param return_indices: If True indices are returned instead of time steps.
        :return: list of times of the maxima.
        :rtype: list[float]
        :raises ValueError: if min_find_count < 1.
        :raises LookupError: if specified number of minima could not be found
        :raises Exception: if there are unfitting pairs of crossings (fall/fall, fall/rise, rise/rise)
        """

        if min_find_count < 1:
            msg = "Parameter count has to be greater or equal to 1."
            raise Exception(msg)
        data = abs(self._w.data) if self._w.type == Waveform.TYPES.FFT else self._w.data
        if stepsize <= 0:
            msg = "stepsize parameter should be greater than 0."
            raise ValueError(msg)
        found_maxima = 0
        signal_max = np.max(data)
        signal_min = min_level if min_level is not None else np.min(data)
        signal_range = signal_max - signal_min
        stepsize = (stepsize / 100.0) * signal_range
        cnt = 1  # Iteration counter

        while found_maxima < min_find_count:
            found_maxima = 0
            level = signal_max - cnt * stepsize
            if level <= signal_min:
                break
            crossings = self.find_all_crossings(level=level, hysteresis=hysteresis, return_indices=True)

            maxima = []
            ranges_start = None
            ranges_stop = None
            if len(crossings) == 0:
                cnt += 1  # If no crossing found with this level increase counter (decrease level)
            else:
                try:
                    # If first crossing is falling insert a rising crossing at index 0
                    if crossings[0]["slope"] == "fall":
                        ranges_start = [{"slope": "rise", "index": 0}, crossings[0]]
                        crossings = crossings[1:]  # Remove the false first crossing
                        found_maxima += 1
                except IndexError:
                    pass

                try:
                    # If last crossing is rising insert a falling crossing at index -1
                    if crossings[-1]["slope"] == "rise":
                        ranges_stop = [
                            crossings[-1],
                            {"slope": "fall", "index": len(self._w.time) - 1},
                        ]
                        crossings = crossings[:-1]  # Remove the false last crossing
                        found_maxima += 1
                except IndexError:
                    pass

                if len(crossings) % 2 == 0:  # Check if there are the same number of rising and falling crossings
                    found_maxima += len(crossings) / 2
                cnt += 1

                if level <= signal_min and found_maxima < min_find_count:
                    raise Exception(
                        "Could not find %d maxima in signal range %.2f to %.2f."
                        % (min_find_count, signal_min, signal_max)
                    )

                if found_maxima >= min_find_count:
                    ranges = crossings[:]
                    if ranges_start is not None:
                        ranges_start.extend(ranges)
                        ranges = ranges_start
                    if ranges_stop is not None:
                        ranges.extend(ranges_stop)

                    for r in np.array_split(ranges, len(ranges) / 2):
                        if not (r[0]["slope"] == "rise" and r[1]["slope"] == "fall"):
                            # Check if ranges always consist of a riseing and falling crossing
                            msg = f"Unfittings pair of crossings. (Ranges: {ranges})"
                            raise Exception(msg)

                        slice_ = slice(int(r[0]["index"]), int(r[1]["index"]) + 1)
                        t = int(self._w[slice_].Measurements_Utils.argmax(return_index=True) + int(r[0]["index"]))
                        if return_point == "start":
                            max_point = t
                        else:
                            max_point_t = self._w[t]
                            maxima_points = (np.where(self._w.data[slice_] == max_point_t))[0] + int(
                                r[0]["index"]
                            )  # index of maxima points

                            if return_point == "end":
                                max_point = maxima_points[len(maxima_points) - 1]
                            else:
                                max_point = maxima_points[int(len(maxima_points) / 2)]
                        maxima.append(max_point)
                    if return_indices:
                        return maxima

                    return list(self._w.time[maxima])

        msg = "Unknown error occurred. No maxima found."
        raise Exception(msg)

    def find_n_minima(
        self, min_find_count, hysteresis=0, max_level=None, stepsize=5, return_point="start", return_indices=False
    ):
        """
        Searches at least "min_find_count" minima.
        The signal is split into several parts with the splitting points found by intersecting the signal with a
        horizontal line. Each pair of negative and positiv crossings defines an area where the signal must have a
        maximum.
        Also, a single rising edge in the beginning as well as a falling edge in the end defines such an area.
        Afterwards the index of the minimum is searched in all areas.
        If the resulting number of minima is less than the specified one the line offset is increased by 5% of
        signal range (starting at 0%). This procedure is repeated until the specified number of minima is found or
        the line offset rises above 'max_level' (in this case an exception is raised).

        :param min_find_count: The number of minima the algorithm has to find
        :type min_find_count: int
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param max_level: The maximum offset of the horizontal intersection line before an error is raised.
                          The offset is increased by 5% of signal range until the specified number of crossings is
                          found.
        :type max_level: float
        :param stepsize: The increment of the horizontal crossing line in % of the signal range if not enought minima
                         were found.
        :type stepsize: float
        :param return_point: In case the maximum of a found area consists of multiple points with equal level,
                             this argument specifies which point to return. "start" returns the first point where the
                             maximum is found, "mid" the median one and "end" the last point
        :type return_point: str
        :param return_indices: If True indices are returned instead of time steps.
        :return: list of times of the minima.
        :rtype: list[float]
        :raises ValueError: if min_find_count < 1.
        :raises LookupError: if specified number of maxima could not be found
        :raises Exception: if there are unfitting pairs of crossings (fall/fall, rise/fall, rise/rise)"""

        if min_find_count < 1:
            msg = "Parameter cound has to be greater or equal to 1."
            raise ValueError(msg)
        if stepsize <= 0:
            msg = "stepsize parameter should be greater than 0."
            raise ValueError(msg)
        data = abs(self._w.data) if self._w.type == Waveform.TYPES.FFT else self._w.data
        found_minima = 0
        signal_max = np.max(data)
        signal_min = max_level if max_level is not None else np.min(data)
        signal_range = signal_max - signal_min
        stepsize = (stepsize / 100.0) * signal_range
        cnt = 1

        while found_minima < min_find_count:
            found_minima = 0
            level = signal_min + cnt * stepsize
            if (max_level is not None and level >= max_level) or (max_level is None and level > np.max(data)):
                raise LookupError(
                    "Could not find %d minima in signal range %.2f to %.2f." % (min_find_count, signal_min, signal_max)
                )
            crossings = self.find_all_crossings(level=level, hysteresis=hysteresis, return_indices=True)

            minima = []
            ranges_start = None
            ranges_stop = None
            if len(crossings) == 0:
                cnt += 1
            else:
                try:
                    # If first crossing is rising insert a falling crossing at index 0
                    if crossings[0]["slope"] == "rise":
                        ranges_start = [{"slope": "fall", "index": 0}, crossings[0]]
                        crossings = crossings[1:]  # Remove the false first crossing
                        found_minima += 1
                except IndexError:
                    pass

                try:
                    # If last crossing is falling insert a rising crossing at index -1
                    if crossings[-1]["slope"] == "fall":
                        ranges_stop = [
                            crossings[-1],
                            {"slope": "rise", "index": len(self._w.time) - 1},
                        ]
                        crossings = crossings[:-1]  # Remove the false last crossing
                        found_minima += 1
                except IndexError:
                    pass

                if len(crossings) % 2 == 0:  # Check if there are the same number of rising and falling crossings
                    found_minima += len(crossings) / 2
                cnt += 1
                if level >= signal_max and found_minima < min_find_count:
                    raise LookupError(
                        "Could not find %d minima in signal range %.2f to %.2f."
                        % (min_find_count, signal_min, signal_max)
                    )

                if found_minima >= min_find_count:
                    ranges = crossings[:]
                    if ranges_start is not None:
                        ranges_start.extend(ranges)
                        ranges = ranges_start
                    if ranges_stop is not None:
                        ranges.extend(ranges_stop)

                    for r in np.array_split(ranges, len(ranges) / 2):
                        if not (r[0]["slope"] == "fall" and r[1]["slope"] == "rise"):
                            # Check if ranges always consist of a falling and rising crossing
                            msg = f"Unfittings pair of crossings. (Ranges: {ranges})"
                            raise Exception(msg)

                        slice_ = slice(int(r[0]["index"]), int(r[1]["index"]) + 1)
                        t = int(self._w[slice_].Measurements_Utils.argmin(return_index=True) + int(r[0]["index"]))
                        if return_point == "start":
                            min_point = t
                        else:
                            min_point_t = self._w[t]
                            minima_points = (np.where(self._w.data[slice_] == min_point_t))[0] + int(
                                r[0]["index"]
                            )  # index of minima points

                            if return_point == "end":
                                min_point = minima_points[len(minima_points) - 1]
                            else:
                                min_point = minima_points[int(len(minima_points) / 2)]

                        minima.append(min_point)
                    if return_indices:
                        return minima

                    return list(self._w.time[minima])
        return None

    def find_maxima_at_level(self, level, hysteresis=0, return_point="start", return_indices=False):
        """
        Searches all maxima in the areas where the signal is greater than the specified level.
        The signal is split into several parts with the splitting points found by intersecting the signal with a
        horizontal line. Each pair of positiv and negative crossings defines an area where the signal must have a
        maximum.
        Also, a single falling edge in the beginning as well as a rising edge in the end defines such an area.
        Afterwards the index of the maximum is searched in all areas.

        :param level: The offset of the horizontal intersection line.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param return_point: In case the maximum of a found area consists of multiple points with equal level,
                             this argument specifies which point to return. "start" returns the first point where
                             the maximum is found, "mid" the median one and "end" the last point
        :type return_point: str
        :param return_indices: If True indices are returned instead of time steps.
        :return:  None if no crossing found or list of times of the maxima.
        :rtype: list[float]
        :raises Exception: if there are unfitting pairs of crossings (fall/fall, fall/rise, rise/rise)
        """

        found_maxima = 0

        crossings = self.find_all_crossings(level=level, hysteresis=hysteresis, return_indices=True)

        maxima = []
        ranges_start = None
        ranges_stop = None
        if len(crossings) == 0:
            return None

        try:
            # If first crossing is falling insert a rising crossing at index 0
            if crossings[0]["slope"] == "fall":
                ranges_start = [{"slope": "rise", "index": 0}, crossings[0]]
                crossings = crossings[1:]  # Remove the false first crossing
                found_maxima += 1
        except IndexError:
            pass

        try:
            # If last crossing is rising insert a falling crossing at index -1
            if crossings[-1]["slope"] == "rise":
                ranges_stop = [
                    crossings[-1],
                    {"slope": "fall", "index": len(self._w.time) - 1},
                ]
                crossings = crossings[:-1]  # Remove the false last crossing
                found_maxima += 1
        except IndexError:
            pass

        if len(crossings) % 2 == 0:  # Check if there are the same number of rising and falling crossings
            found_maxima += len(crossings) / 2

        if found_maxima >= 1:
            ranges = crossings[:]
            if ranges_start is not None:
                ranges_start.extend(ranges)
                ranges = ranges_start
            if ranges_stop is not None:
                ranges.extend(ranges_stop)
            for r in np.array_split(ranges, len(ranges) / 2):
                if not (r[0]["slope"] == "rise" and r[1]["slope"] == "fall"):
                    # Check if ranges always consist of a riseing and falling crossing
                    msg = f"Unfittings pair of crossings. (Ranges: {ranges})"
                    raise Exception(msg)

                slice_ = slice(int(r[0]["index"]), int(r[1]["index"]) + 1)
                t = int(self._w[slice_].Measurements_Utils.argmax(return_index=True) + int(r[0]["index"]))
                if return_point == "start":
                    max_point = t
                else:
                    max_point_t = self._w[t]
                    maxima_points = (np.where(self._w.data[slice_] == max_point_t))[0] + int(
                        r[0]["index"]
                    )  # index of maxima points

                    if return_point == "end":
                        max_point = maxima_points[len(maxima_points) - 1]
                    else:
                        max_point = maxima_points[int(len(maxima_points) / 2)]
                maxima.append(max_point)

            if return_indices:
                return maxima

            return list(self._w.time[maxima])
        return None

    def find_minima_at_level(self, level, hysteresis=0, return_point="start", return_indices=False):
        """
        Searches all minima in the areas where the signal is less than the specified level.
        The signal is split into several parts with the splitting points found by intersecting the signal with a
        horizontal line. Each pair of negative and positiv crossings defines an area where the signal must have a
        minimum.
        Also, a single rising edge in the beginning as well as a falling edge in the end defines such an area.
        Afterwards the index of the minimum is searched in all areas.

        :param level: The offset of the horizontal intersection line.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param return_point: In case the maximum of a found area consists of multiple points with equal level,
                             this argument specifies which point to return. "start" returns the first point where the
                             maximum is found, "mid" the median one and "end" the last point
        :type return_point: str
        :param return_indices: If True indices are returned instead of time steps.
        :return:  None if no crossing found or list of times of the minima.
        :rtype: list[float]
        :raises Exception: if there are unfitting pairs of crossings (fall/fall, rise/fall, rise/rise)
        """

        found_minima = 0

        crossings = self.find_all_crossings(level=level, hysteresis=hysteresis, return_indices=True)

        minima = []
        ranges_start = None
        ranges_stop = None
        if len(crossings) == 0:
            return None

        try:
            if crossings[0]["slope"] == "rise":  # If first crossing is rising insert a falling crossing at index 0
                ranges_start = [{"slope": "fall", "index": 0}, crossings[0]]
                crossings = crossings[1:]  # Remove the false first crossing
                found_minima += 1
        except IndexError:
            pass

        try:
            if crossings[-1]["slope"] == "fall":  # If last crossing is falling insert a rising crossing at index -1
                ranges_stop = np.array(
                    [
                        crossings[-1],
                        {"slope": "rise", "index": len(self._w.time) - 1},
                    ]
                )
                crossings = crossings[:-1]  # Remove the false last crossing
                found_minima += 1
        except IndexError:
            pass

        if len(crossings) % 2 == 0:  # Check if there are the same number of rising and falling crossings
            found_minima += len(crossings) / 2

        if found_minima >= 1:
            ranges = crossings[:]
            if ranges_start is not None:
                ranges_start.extend(ranges)
                ranges = ranges_start
            if ranges_stop is not None:
                ranges.extend(ranges_stop)

            for r in np.array_split(ranges, len(ranges) / 2):
                if not (r[0]["slope"] == "fall" and r[1]["slope"] == "rise"):
                    # Check if ranges always consist of a falling and rising crossing
                    msg = f"Unfittings pair of crossings. (Ranges: {ranges})"
                    raise Exception(msg)

                slice_ = slice(int(r[0]["index"]), int(r[1]["index"]) + 1)
                t = int(self._w[slice_].Measurements_Utils.argmin(return_index=True) + int(r[0]["index"]))
                if return_point == "start":
                    min_point = t
                else:
                    min_point_t = self._w[t]
                    minima_points = (np.where(self._w.data[slice_] == min_point_t))[0] + int(
                        r[0]["index"]
                    )  # index of minima points

                    if return_point == "end":
                        min_point = minima_points[len(minima_points) - 1]
                    else:
                        min_point = minima_points[int(len(minima_points) / 2)]

                minima.append(min_point)
            if return_indices:
                return minima

            return list(self._w.time[minima])
        return None

    def find_periods(
        self,
        start_slope,
        level,
        hysteresis=0,
        htype="abs",
        return_indices=False,
        hyst_point="start",
    ):
        """
        Returns all found periods (rising/falling/rising or falling/rising/falling) and return a list of lists of
        the crossing times. Returns None in case no periods are found in the signal

        :param start_slope: "rise" or "fall".
                            Defines how periods are found (rising/falling/rising or falling/rising/falling).
        :type start_slope: choice(rise,fall)
        :param level: The crossing level to look for.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param htype: Type of the hysteresis parameter "rel" -> hysteresis is relative to the crossing level
                      "abs"  -> hysteresis is an absolute value
        :type htype: choice(abs,rel)
        :param return_indices: If True indices are returned instead of time steps.
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Returns a list with indices/times of periods {rising, falling, rising] oder [falling, rising, falling]
        :rtype: list[list[float]]

        .. code-block:: python

          >> gd[0:4.4e-5].Measurements_Utils.find_periods("rise", 6, 2)
          [[1.16368e-05, 1.24416e-05, 2.4352e-05],
          [2.4352e-05, 2.51424e-05, 3.69392e-05]]
        """
        period_collection = []
        area = 0

        cr = self._w.Measurements_Utils.find_all_crossings(
            level,
            hysteresis,
            htype=htype,
            return_indices=return_indices,
            return_point=hyst_point,
        )
        if cr.__len__() > 2:
            if cr[0]["slope"] != start_slope:
                cr = cr[1:]

            if cr[len(cr) - 1]["slope"] != start_slope:
                cr = cr[: (len(cr) - 1)]

            while area < len(cr) - 2:
                areas = []
                areas.append(cr[area]["index"])
                areas.append(cr[area + 1]["index"])
                areas.append(cr[area + 2]["index"])
                period_collection.append(areas)
                area += 2

            return list(period_collection)
        return None

    def within_limit(self, thres_min, thres_max):
        """
        Returns if the signal has data values lower than, or greater than the thresholds.

        :param thres_min: The lower limit, the signal should not exceed.
        :type thres_min: float
        :param thres_max: The upper limit, the signal should not exceed.
        :type thres_max: float
        :return: True / False.
        :rtype: bool
        """

        data = abs(self._w.data) if self._w.type == Waveform.TYPES.FFT else self._w.data
        return not (min(data) < thres_min or max(data) > thres_max)

    def find_n_highest_values(self, find_count, return_indices=False):
        """
        Returns a list with the times/indices of the highest n values in the signal.

        :param find_count: The number of values that should be found.
        :type find_count: int
        :param return_indices: If True indices are returned instead of time steps.
        :type return_indices: bool
        :rtype: list[float]
        """

        data = abs(self._w.data) if self._w.type == Waveform.TYPES.FFT else self._w.data
        sort = np.argsort(data)[::-1]
        highest_n = sort[: int(abs(find_count))]
        if return_indices:
            return highest_n

        return self._w.index_to_time(highest_n)

    def find_n_lowest_values(self, find_count, return_indices=False):
        """
        Returns a list with the times/indices of the lowest n values in the signal.

        :param find_count: The number of values that should be found.
        :type find_count: int
        :param return_indices: If True indices are returned instead of time steps.
        :type return_indices: bool
        :rtype: list[float]
        """

        data = abs(self._w.data) if self._w.type == Waveform.TYPES.FFT else self._w.data
        sort = np.argsort(data)
        lowest_n = sort[: int(abs(find_count))]
        if return_indices:
            return lowest_n

        return self._w.index_to_time(lowest_n)

    def detect_peaks(
        self,
        mph=None,
        mpd=1,
        threshold=0,
        edge="rising",
        kpsh=False,
        valley=False,
        return_indices=False,
    ):
        """
        Detect peaks in data based on their amplitude and other features.

        :param mph: detect peaks that are greater than minimum peak height.
        :type mph: int|float|NoneType
        :param mpd: detect peaks that are at least separated by minimum peak distance (in number of data).
        :type mpd: int|float
        :param threshold: detect peaks (valleys) that are greater (smaller) than 'threshold' in relation to their
                          immediate neighbors.
        :type threshold: int|float
        :param edge: for a flat peak, keep only the rising edge ('rising'), only the
                     falling edge ('falling'), both edges ('both'), or don't detect a
                     flat peak (None).
        :type edge: str
        :param kpsh: keep peaks with same height even if they are closer than "mpd".
        :type kpsh: bool
        :param valley: if True, detect valleys (local minima) instead of peaks.
        :type valley: bool
        :param return_indices: If True, return indexes of the peaks, else time values
        :type return_indices: bool
        :returns: Times/Indices of the peaks
        :rtype: np.ndarray

        Notes
        -----

        The detection of valleys instead of peaks is performed internally by simply
        negating the data: "ind_valleys = detect_peaks(-x)"

        The function can handle NaN's

        See this
        `IPython Notebook <https://nbviewer.jupyter.org/github/demotu/BMC/blob/master/notebooks/DetectPeaks.ipynb>`_

        """

        x = self._w.data

        x = np.atleast_1d(x).astype("float64")
        if x.size < 3:
            return np.array([], dtype=int)
        if valley:
            x = -x
            if mph is not None:
                mph = -mph
        # find indices of all peaks
        dx = x[1:] - x[:-1]
        # handle NaN's
        indnan = np.where(np.isnan(x))[0]
        if indnan.size:
            x[indnan] = np.inf
            dx[np.where(np.isnan(dx))[0]] = np.inf
        ine, ire, ife = np.array([[], [], []], dtype=int)
        if not edge:
            ine = np.where((np.hstack((dx, 0)) < 0) & (np.hstack((0, dx)) > 0))[0]
        else:
            if edge.lower() in ["rising", "both"]:
                ire = np.where((np.hstack((dx, 0)) <= 0) & (np.hstack((0, dx)) > 0))[0]
            if edge.lower() in ["falling", "both"]:
                ife = np.where((np.hstack((dx, 0)) < 0) & (np.hstack((0, dx)) >= 0))[0]
        ind = np.unique(np.hstack((ine, ire, ife)))  #
        # handle NaN's
        if ind.size and indnan.size:
            # NaN's and values close to NaN's cannot be peaks
            ind = ind[
                np.in1d(
                    ind,
                    np.unique(np.hstack((indnan, indnan - 1, indnan + 1))),
                    invert=True,
                )
            ]
        # first and last values of x cannot be peaks
        if ind.size and ind[0] == 0:
            ind = ind[1:]
        if ind.size and ind[-1] == x.size - 1:
            ind = ind[:-1]
        # remove peaks < minimum peak height
        if ind.size and mph is not None:
            ind = ind[x[ind] >= mph]
        # remove peaks - neighbors < threshold
        if ind.size and threshold > 0:
            dx = np.min(np.vstack([x[ind] - x[ind - 1], x[ind] - x[ind + 1]]), axis=0)
            ind = np.delete(ind, np.where(dx < threshold)[0])
        # detect small peaks closer than minimum peak distance
        if ind.size and mpd > 1:
            ind = ind[np.argsort(x[ind])][::-1]
            idel = np.zeros(ind.size, dtype=bool)
            for i in range(ind.size):
                if not idel[i]:
                    # keep peaks with the same height if kpsh is True
                    idel = idel | (ind >= ind[i] - mpd) & (ind <= ind[i] + mpd) & (x[ind[i]] > x[ind] if kpsh else True)
                    idel[i] = 0  # Keep current peak
            # remove the small peaks and sort back the indices by their occurrence
            ind = np.sort(ind[~idel])

        if return_indices:
            return ind

        return self._w.time[ind]

    def find_transitions(
        self, from_lvl: int, to_lvl: int, index: int | None = None, return_indices: bool = False
    ) -> np.ndarray | int:
        """
        Finds immediate transitions from one level to another (e.g. 3 to 5 as step).
        This only properly works on discrete signals since the function is working with exact numbers.

        :param from_lvl: The start level
        :param to_lvl: The end level
        :param index: None to return all transitions, an index of the found transition if there were multiple
                      (0 for first, -1 for last)
        :param return_indices: If True, indices are returned instead of time stamps
        """
        arr = self._w.data
        diff = to_lvl - from_lvl
        w_diff = np.where(np.diff(arr) == diff)[0]
        w_at_from = np.where(arr == from_lvl)
        transistions = np.intersect1d(w_diff, w_at_from) + 1
        if not len(transistions):
            msg = f"Cannot find transition from {from_lvl} to {to_lvl}"
            raise LookupError(msg)
        if not return_indices:
            transistions = self._w.time[transistions]
        if index is None:
            return transistions

        return transistions[index]


class Measurements_NonPeriodic:
    """
    This Class implements various functions which extract parameters applicable to non-periodic signals,
    e.g. overshoot, undershoot, risetime, falltime
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    def high(self):
        """
        Uses histogram mode to determine the high level of the waveform. Therefore, this calculation ignores overshoots.

        The algorithm (using a histogram) only returns stable results if the data points of the analyzed waveform
        are mainly located at
        only 2 different levels while the mean value of the waveform is located between those 2 levels.

        :rtype: float
        """
        w = self._w.copy()
        histogram = w.histogram()
        histpart = histogram[float(w.Measurements_Base.mean()) :]
        del histogram, w
        gc.collect()
        return histpart.time[np.argmax(histpart.data)]  # returned 6, but should 6,7

    def low(self):
        """
        Uses histogram mode to determine the low level of the waveform. Therefore, this calculation ignores undershoots.

        The algorithm (using a histogram) only returns stable results if the data points of the analyzed waveform
        are mainly located at only 2 different levels while the mean value of the waveform is located between
        those 2 levels.

        :rtype: float
        """

        w = self._w.copy()
        histogram = w.histogram()
        histpart = histogram[: float(w.Measurements_Base.mean())]
        del histogram, w
        gc.collect()
        return histpart.time[np.argmax(histpart.data)]

    def overshoot(self, relative=False):
        """
        Returns the overshoot of the waveform.
        Overshoot is when the signals max is greater than signals high, then the difference is returned. Else 0 is
        returned.

        The algorithm (using a histogram) only returns stable results if the data points of the analyzed waveform are
        mainly located at
        only 2 different levels while the mean value of the waveform is located between those 2 levels.

        :param relative: If True, the function will return the overshoot in percent of the settle value.
        :type relative: bool
        :rtype: float
        """

        _max = self._w.Measurements_Base.max()
        _high = self._w.Measurements_NonPeriodic.high()
        if _max > _high:
            if relative:
                return (_max - _high) / float(_high) * 100.0

            return _max - _high

        return 0

    def undershoot(self, relative=False):
        """
        Returns the undershoot of the waveform.
        Undershoot is when the signals min is lower than signals low, then the difference is returned. Else 0 is
        returned.

        The algorithm (using a histogram) only returns stable results if the data points of the analyzed waveform are
        mainly located at
        only 2 different levels while the mean value of the waveform is located between those 2 levels.

        :param relative: If True, the function will return the undershoot in percent of the settle value.
        :type relative: bool
        :rtype: float
        """

        _min = self._w.Measurements_Base.min()
        _low = self._w.Measurements_NonPeriodic.low()
        if _min < _low:
            if relative:
                return abs(_min - _low) / float(abs(_low)) * 100.0

            return abs(_min - _low)

        return 0

    def amplitude(self):
        """
        Returns the amplitude of the signal by calculating the difference of low() and high().

        The algorithm (using a histogram) only returns stable results if the data points of the analyzed waveform are
        mainly located at
        only 2 different levels while the mean value of the waveform is located between those 2 levels.

        :rtype: float
        """

        return abs(self._w.Measurements_NonPeriodic.high() - self._w.Measurements_NonPeriodic.low())

    def find_levels(self, mode="histogram", minlevel=None, maxlevel=None, **kwargs):
        """
        Calculates the low and high level of the current waveform and optionally applies a filter, if requested.

        :param mode: "histogram", "minmax" or "custom"

                     Histogram:
                        Signal min and max value is calculated by taking the two highest peaks in the histogram.

                        The algorithm (using a histogram) only returns stable results if the data points of the
                        analyzed waveform are mainly located at only 2 different levels while the mean value of
                        the waveform is located between those 2 levels.

                     Minmax:
                        Signal min and max values is calculated by simply calling min/max function on the array.
                        If your signal has an overshoot a wrong risetime will be calculated.

                     Custom:
                        Signal min and max values are specified as parameters minlevel and maxlevel
                        Use this mode if your signal has overshoots and more than 2 areas where the
                        signal gradient is around 0.
        :type mode: choice(histogram,minmax,custom)
        :param minlevel: Required if mode is 'custom'. Signal minimum.
        :type minlevel: float
        :param maxlevel: Required if mode is 'custom'. Signal maximum.
        :type maxlevel: float
        :keyword sgol_len: Window-length of SavitzkyGolay filter
        :return: Copy of the current waveform, which is optionally filtered; LowLevel; Highlevel
        :rtype: (Waveform, float, float)
        """

        w = self._w.copy()
        sgol_len = kwargs.get("sgol_len", 0)
        if sgol_len > 1:
            if sgol_len % 2 == 0:
                sgol_len += 1
            w.Filter.SavitzkyGolay(window_length=sgol_len, polyorder=1, mode="mirror")

        if mode.lower() == "histogram":
            histogram = w.histogram()
            mean = w.Measurements_Base.mean()
            hist1 = histogram[: float(mean)]
            hist2 = histogram[float(mean) :]

            lowlevel = histogram.time[np.argmax(hist1.data)]
            highlevel = histogram.time[np.argmax(hist2.data) + len(hist1)]
        elif mode.lower() == "minmax":
            lowlevel = w.Measurements_Base.min()
            highlevel = w.Measurements_Base.max()
        elif mode.lower() == "custom":
            lowlevel = minlevel
            highlevel = maxlevel
        else:
            msg = f"Unknown mode '{mode}'"
            raise ValueError(msg)

        return w, lowlevel, highlevel

    def risetime(
        self,
        low_threshold=10,
        high_threshold=90,
        mode="histogram",
        minlevel=None,
        maxlevel=None,
        hysteresis=0,
        hyst_point="mid",
        **kwargs,
    ):
        """
        Calculates the risetime of the current waveform.

        :param low_threshold: The lower threshold in % for the start level of the risetime calcuation.
        :type low_threshold: float
        :param high_threshold: The higher threshold in % for the end of the risetime calcuation
        :type high_threshold: float
        :param mode: "histogram", "minmax" or "custom"

                     Histogram:
                        Signal min and max value is calculated by taking the two highest peaks in the histogram.

                        The algorithm (using a histogram) only returns stable results if the data points of the
                        analyzed waveform are mainly located at only 2 different levels while the mean value of the
                        waveform is located between those 2 levels.

                     Minmax:
                        Signal min and max values is calculated by simply calling min/max function on the array.
                        If your signal has an overshoot a wrong risetime will be calculated.

                     Custom:
                        Signal min and max values are specified as parameters minlevel and maxlevel
                        Use this mode if your signal has overshoots and more than 2 areas where the
                        signal gradient is around 0.
        :type mode: choice(histogram,minmax,custom)
        :param minlevel: Required if mode is 'custom'. Signal minimum.
        :type minlevel: float
        :param maxlevel: Required if mode is 'custom'. Signal maximum.
        :type maxlevel: float
        :param hysteresis: The absolute size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Risetime in s
        :rtype: float
        """

        w, lowlevel, highlevel = self.find_levels(mode=mode, minlevel=minlevel, maxlevel=maxlevel, **kwargs)

        first_crossing = w.Measurements_Utils.find_nth_crossing(
            level=lowlevel + ((highlevel - lowlevel) * low_threshold / 100.0),
            slope="rise",
            index=0,
            hysteresis=hysteresis,
            return_point=hyst_point,
        )
        second_crossing = w.Measurements_Utils.find_nth_crossing(
            level=lowlevel + ((highlevel - lowlevel) * high_threshold / 100.0),
            slope="rise",
            index=0,
            hysteresis=hysteresis,
            return_point=hyst_point,
        )
        dT = second_crossing - first_crossing
        if dT < 0:
            msg = f"Cannot calculate risetime because signal has a falling edge. (Falltime: {dT:.4f})"
            raise Exception(msg)
        return dT

    def falltime(
        self,
        low_threshold=10,
        high_threshold=90,
        mode="histogram",
        minlevel=None,
        maxlevel=None,
        hysteresis=0,
        hyst_point="mid",
        **kwargs,
    ):
        """
        Calculates the falltime of the current waveform.

        :param low_threshold: The lower threshold in % for the end of the falltime calcuation
        :type low_threshold: float
        :param high_threshold: The higher threshold in % for the start level of the falltime calcuation
        :type high_threshold: float
        :param mode: "histogram", "minmax" or "custom"

                     Histogram:
                        Signal min and max value is calculated by taking the two highest peaks in the histogram.

                        The algorithm (using a histogram) only returns stable results if the data points of the
                        analyzed waveform are mainly located at only 2 different levels while the mean value of the
                        waveform is located between those 2 levels.

                     Minmax:
                        Signal min and max values is calculated by simply calling min/max function on the array.
                        If your signal has an overshoot a wrong falltime will be calculated.

                     Custom:
                        Signal min and max values are specified as parameters minlevel and maxlevel
                        Use this mode if your signal has overshoots and more than 2 areas where the
                        signal gradient is around 0.
        :type mode: choice(histogram,minmax,custom)
        :param minlevel: Required if mode is 'custom'. Signal minimum.
        :type minlevel: float
        :param maxlevel: Required if mode is 'custom'. Signal maximum.
        :type maxlevel: float
        :param hysteresis: The absolute size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Falltime in s
        :rtype: float
        """

        w, lowlevel, highlevel = self.find_levels(mode=mode, minlevel=minlevel, maxlevel=maxlevel, **kwargs)

        first_crossing = w.Measurements_Utils.find_nth_crossing(
            level=lowlevel + ((highlevel - lowlevel) * high_threshold / 100.0),
            slope="fall",
            index=0,
            hysteresis=hysteresis,
            return_point=hyst_point,
        )
        second_crossing = w.Measurements_Utils.find_nth_crossing(
            level=lowlevel + ((highlevel - lowlevel) * low_threshold / 100.0),
            slope="fall",
            index=0,
            hysteresis=hysteresis,
            return_point=hyst_point,
        )
        dT = second_crossing - first_crossing
        if dT < 0:
            msg = f"Cannot calculate falltime because signal has a rising edge. (Risetime: {dT:.4f})"
            raise Exception(msg)
        return dT

    def slewrate(
        self,
        low_threshold=10,
        high_threshold=90,
        mode="histogram",
        minlevel=None,
        maxlevel=None,
        hysteresis=0,
        hyst_point="mid",
        slope="",
        **kwargs,
    ):
        """
        Calculates the slewrate of the current waveform.

        :param low_threshold: The lower threshold in % for the end of the slewrate calcuation
        :type low_threshold: float
        :param high_threshold: The higher threshold in % for the start level of the slewrate calcuation
        :type high_threshold: float
        :param mode: "histogram", "minmax" or "custom"

                     Histogram:
                        Signal min and max value is calculated by taking the two highest peaks in the histogram.

                        The algorithm (using a histogram) only returns stable results if the data points of the
                        analyzed waveform are mainly located at only 2 different levels while the mean value of the
                        waveform is located between those 2 levels.

                     Minmax:
                        Signal min and max values is calculated by simply calling min/max function on the array.
                        If your signal has an overshoot a wrong slewrate may be calculated.

                     Custom:
                        Signal min and max values are specified as parameters minlevel and maxlevel
                        Use this mode if your signal has overshoots and more than 2 areas where the
                        signal gradient is around 0.
        :type mode: choice(histogram,minmax,custom)
        :param minlevel: Required if mode is 'custom'. Signal minimum.
        :type minlevel: float
        :param maxlevel: Required if mode is 'custom'. Signal maximum.
        :type maxlevel: float
        :param hysteresis: The absolute size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param slope: Defines which slope to use for slew rate calculation
        :type slope: choice(rise, fall, )
        :return: Slewrate in <unit>/second
        :rtype: float
        """
        lowlevel, highlevel, low_crossing, high_crossing = self.find_critical_crossings(
            low_threshold=low_threshold,
            high_threshold=high_threshold,
            hysteresis=hysteresis,
            hyst_point=hyst_point,
            slope=slope,
            mode=mode,
            minlevel=minlevel,
            maxlevel=maxlevel,
            **kwargs,
        )
        diff = highlevel - lowlevel
        return ((diff * high_threshold / 100.0) - (diff * low_threshold / 100.0)) / (high_crossing - low_crossing)

    def find_critical_crossings(
        self,
        low_threshold=10,
        high_threshold=90,
        mode="histogram",
        minlevel=None,
        maxlevel=None,
        hysteresis=0,
        hyst_point="mid",
        slope="",
        **kwargs,
    ):
        """
        Calculates the critical crossings of the current waveform.
        For a given slope, this ensures that there are no crossings of the given thresholds between the two
        extracted crossings.

        :param low_threshold: The lower threshold in %
        :type low_threshold: float
        :param high_threshold: The higher threshold in %
        :type high_threshold: float
        :param mode: "histogram", "minmax" or "custom"

                     Histogram:
                        Signal min and max value is calculated by taking the two highest peaks in the histogram.

                        The algorithm (using a histogram) only returns stable results if the data points of the
                        analyzed waveform are mainly located at only 2 different levels while the mean value of the
                        waveform is located between those 2 levels.

                     Minmax:
                        Signal min and max values is calculated by simply calling min/max function on the array.
                        If your signal has an overshoot a wrong slewrate may be calculated.

                     Custom:
                        Signal min and max values are specified as parameters minlevel and maxlevel
                        Use this mode if your signal has overshoots and more than 2 areas where the
                        signal gradient is around 0.
        :type mode: choice(histogram,minmax,custom)
        :param minlevel: Required if mode is 'custom'. Signal minimum.
        :type minlevel: float
        :param maxlevel: Required if mode is 'custom'. Signal maximum.
        :type maxlevel: float
        :param hysteresis: The absolute size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param slope: Defines which slope to use for slew rate calculation
        :type slope: choice("rise", "fall", "")
        :return: lowlevel, highlevel, index of crossing for lowlevel, index of crossing for highlevel
        :rtype: float, float, float, float
        """

        w, lowlevel, highlevel = self.find_levels(mode=mode, minlevel=minlevel, maxlevel=maxlevel, **kwargs)

        diff = highlevel - lowlevel
        high_crossings = w.Measurements_Utils.find_all_crossings(
            level=lowlevel + (diff * high_threshold / 100.0),
            hysteresis=hysteresis,
            return_point=hyst_point,
        )
        low_crossings = w.Measurements_Utils.find_all_crossings(
            level=lowlevel + (diff * low_threshold / 100.0),
            hysteresis=hysteresis,
            return_point=hyst_point,
        )
        if slope == "":
            high_crossing = high_crossings[0]
            low_crossing = low_crossings[0]
            if low_crossing["slope"] != high_crossing["slope"]:
                msg = "High and low crossing have different slopes."
                raise ValueError(msg)
        else:
            high_crossings = filter(lambda crossing: crossing["slope"] == slope, high_crossings)
            low_crossings = filter(lambda crossing: crossing["slope"] == slope, low_crossings)
            if slope == "fall":
                # find last high-crossing before first low-crossing
                low_crossing = next(low_crossings)
                idx = low_crossing["index"]
                *_, high_crossing = itertools.takewhile(lambda t: t["index"] < idx, high_crossings)
            elif slope == "rise":
                # find last low-crossing before first high-crossing
                high_crossing = next(high_crossings)
                idx = high_crossing["index"]
                *_, low_crossing = itertools.takewhile(lambda t: t["index"] < idx, low_crossings)
            else:
                msg = f"Unknown slope '{slope}'."
                raise ValueError(msg)

        return lowlevel, highlevel, low_crossing["index"], high_crossing["index"]

    def find_threshold_crossing(
        self, threshold=50, mode="histogram", minlevel=None, maxlevel=None, hysteresis=0, hyst_point="mid", **kwargs
    ):
        """
        Finds the first crossing of the given threshold of the current waveform.

        :param threshold: The threshold in %
        :type threshold: float
        :param mode: "histogram", "minmax" or "custom"

                     Histogram:
                        Signal min and max value is calculated by taking the two highest peaks in the histogram.

                        The algorithm (using a histogram) only returns stable results if the data points of the
                        analyzed waveform are mainly located at only 2 different levels while the mean value of the
                        waveform is located between those 2 levels.

                     Minmax:
                        Signal min and max values is calculated by simply calling min/max function on the array.
                        If your signal has an overshoot a wrong slewrate may be calculated.

                     Custom:
                        Signal min and max values are specified as parameters minlevel and maxlevel
                        Use this mode if your signal has overshoots and more than 2 areas where the
                        signal gradient is around 0.
        :type mode: choice(histogram,minmax,custom)
        :param minlevel: Required if mode is 'custom'. Signal minimum.
        :type minlevel: float
        :param maxlevel: Required if mode is 'custom'. Signal maximum.
        :type maxlevel: float
        :param hysteresis: The absolute size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param slope: Defines which slope to use for slew rate calculation
        :type slope: choice("rise", "fall", "")
        :return: lowlevel, highlevel, index of crossing for lowlevel, index of crossing for highlevel
        :rtype: float, float, float, float
        """

        w, lowlevel, highlevel = self.find_levels(mode=mode, minlevel=minlevel, maxlevel=maxlevel, **kwargs)
        crossing = w.Measurements_Utils.find_all_crossings(
            level=lowlevel + ((highlevel - lowlevel) * threshold / 100.0),
            hysteresis=hysteresis,
            return_point=hyst_point,
        )[0]

        return crossing["index"]

    def find_settled(self, thres_min, thres_max, return_index=False):
        """
        Finds the time/index when the signal enters an area defined by thres_min and thres_max and stays in this area.

        :param thres_min: The lower limit of the area
        :type thres_min: float
        :param thres_max: The upper limit of the area
        :type thres_max: float
        :param return_index: If True an index is returned instead of a time value.
        :type return_index: bool
        :return: A time or index value where the signal settles
        :rtype: float
        """

        within = np.where(np.logical_and(self._w.data >= thres_min, self._w.data <= thres_max))[0]
        diff = np.diff(within, 1)[::-1]  # Check if there are several areas where data is between thresholds
        if max(diff) == 1:
            if return_index:
                return within[0]

            return self._w.time[within[0]]

        # Multiple areas
        # Find index of last settled area
        idx = len(self._w.time) - (np.where(diff > 1)[0][0] + 1)
        if return_index:
            return idx

        return self._w.time[idx]


class Measurements_Periodic:
    """
    This Class implements various function which extract parameters applicable for periodic signals, e.g. period,
    frequency, burst width or pulse count
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    def period(
        self, level, slope, hysteresis=0, hyst_point="start"
    ):  # I have added the default value zero tio hysteresis parameter
        """
        Searches all rising to rising resp. falling to falling edges and calculates their period.
        Returns the last period found. Return None in case now periods are found

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param slope: Defines which slope to use for calculating the period.
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Last found period.
        :rtype: float
        """

        periods = self._w.Measurements_Utils.find_periods(
            start_slope=slope,
            level=level,
            hysteresis=hysteresis,
            return_indices=False,
            hyst_point=hyst_point,
        )
        if periods:
            return periods[-1][2] - periods[-1][0]
        return None

    def period_average(self, level, slope, hysteresis, hyst_point="start"):
        """
        Searches all rising to rising resp. falling to falling edges and calculates the average period of them.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param slope: Defines which slope to use for calculating the period.
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Average period.
        :rtype: float
        """

        periods = self._w.Measurements_Utils.find_periods(
            start_slope=slope,
            level=level,
            hysteresis=hysteresis,
            return_indices=False,
            hyst_point=hyst_point,
        )
        p = []
        if periods is None:
            return 0  # return 0 because rtype is float

        for per in periods:  #
            p.append(per[2] - per[0])
        return np.mean(p)

    def period_curve(
        self,
        level,
        slope,
        hysteresis,
        keep_length=True,
        hyst_point="start",
        strip_incomplete_periods=False,
    ):
        """
        Searches all rising to rising resp. falling to falling edges and calculates the period curve of them.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param slope: Defines which slope to use for calculating the period.
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points within a period to the same value.\n
                            If False, the function only returns a waveform with the period start edges as time and
                            periods as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param strip_incomplete_periods: If true the function will return just all points within the period
        :type strip_incomplete_periods: bool
        :return: Waveform that represents the period of the self.
        :rtype: Waveform
        """

        indices_split = [0]
        period_only_data = []
        indices_to_remove = []
        if keep_length:
            edges = self._w.Measurements_Utils.find_specific_crossings(
                level,
                slope,
                hysteresis,
                return_indices=True,
                return_point=hyst_point,
            )
            periods = np.diff(edges, 1) / self._w.samplerate
            pwave = self._w.copy()
            new_pwave_data = np.zeros(self._w.length, dtype=np.float64)
            for i, p in enumerate(periods):
                new_pwave_data[edges[i] : edges[i + 1]] = p
                indices_split.append(edges[i])
                indices_split.append(edges[i + 1])
            if strip_incomplete_periods:
                period_segments = np.split(new_pwave_data, indices_split)

                for idx, segment in enumerate(period_segments):
                    if not (all(elem == 0 for elem in segment)):
                        period_only_data.extend(segment)
                    else:  # time vector update
                        if idx > 0:
                            remove_indice = idx - 1 if idx < len(indices_split) else len(indices_split) - 1
                            indices_to_remove.extend(
                                list(
                                    range(
                                        indices_split[remove_indice],
                                        indices_split[remove_indice] + len(segment),
                                    )
                                )
                            )

                pwave.time = np.delete(pwave.time, indices_to_remove)
                new_pwave_data = period_only_data

            pwave.data = np.array(new_pwave_data)
        else:
            edges = self._w.Measurements_Utils.find_specific_crossings(
                level,
                slope,
                hysteresis,
                return_indices=False,
                return_point=hyst_point,
            )
            periods = np.diff(edges, 1)
            pwave = Waveform(data=periods, time=edges[:-1])
        return pwave

    def frequency(self, level, slope, hysteresis, hyst_point="start"):
        """
        Searches all rising to rising resp. falling to falling edges and calculates the frequency of them.
        Returns the last frequency found. Returns 0 in case no frequency could be determined

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param slope: Defines which slope to use for calculating the frequency.
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Last found frequency.
        :rtype: float
        """

        period = self._w.Measurements_Periodic.period(level, slope, hysteresis, hyst_point=hyst_point)
        if period:
            return 1.0 / period

        return 0

    def frequency_average(self, level, slope, hysteresis, hyst_point="start"):
        """
        Searches all rising to rising resp. falling to falling edges and calculates the average frequency of them.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param slope: Defines which slope to use for calculating the frequency.
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Average frequency.
        :rtype: float
        """

        return 1.0 / self._w.Measurements_Periodic.period_average(level, slope, hysteresis, hyst_point=hyst_point)

    def frequency_curve(
        self,
        level,
        slope,
        hysteresis,
        keep_length=True,
        hyst_point="start",
        strip_incomplete_frequencies=False,
    ):
        """
        Searches all rising to rising resp. falling to falling edges and calculates the frequency curve of them.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param slope: Defines which slope to use for calculating the frequency.
        :type slope: choice(rise,fall)
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points within a period to the same value.\n
                            If False, the function only returns a waveform with the period start edges as time and
                            frequencies as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param strip_incomplete_frequencies: If true the function will return just all points within the period
        :type strip_incomplete_frequencies: bool
        :return: Waveform that represents the frequency of the self.
        :rtype: Waveform
        """

        indices_split = [0]
        frequency_only_wave = []
        indices_to_remove = []
        if keep_length:
            edges = self._w.Measurements_Utils.find_specific_crossings(
                level,
                slope,
                hysteresis,
                return_indices=True,
                return_point=hyst_point,
            )
            frequencies = self._w.samplerate / np.diff(edges, 1)
            fwave = self._w.copy()
            new_fwave_data = np.zeros(fwave.length, dtype=np.float64)
            for i, f in enumerate(frequencies):
                new_fwave_data[edges[i] : edges[i + 1]] = f
                indices_split.append(edges[i])
                indices_split.append(edges[i + 1])

            if strip_incomplete_frequencies:
                frequency_segments = np.split(new_fwave_data, indices_split)
                for idx, segment in enumerate(frequency_segments):
                    if not (all(elem == 0 for elem in segment)):
                        frequency_only_wave.extend(segment)
                    else:  # time vector update
                        if idx > 0:
                            remove_indice = idx - 1 if idx < len(indices_split) else len(indices_split) - 1
                            indices_to_remove.extend(
                                list(
                                    range(
                                        indices_split[remove_indice],
                                        indices_split[remove_indice] + len(segment),
                                    )
                                )
                            )

                fwave.time = np.delete(fwave.time, indices_to_remove)
                new_fwave_data = frequency_only_wave

            fwave.data = np.array(new_fwave_data)
        else:
            edges = self._w.Measurements_Utils.find_specific_crossings(
                level,
                slope,
                hysteresis,
                return_indices=False,
                return_point=hyst_point,
            )
            frequencies = 1.0 / np.diff(edges, 1)
            fwave = Waveform(data=frequencies, time=edges[:-1])
        return fwave

    def find_all_bursts(self, level, min_burst_distance, hysteresis=0, hyst_point="start"):
        """
        Finds all bursts (sequence of pulses surrounded with low time longer than 2 times minimum pulse distance)
        and returns a list of dictionaries containing the keys: "start", "stop", "duration" and "pulse_cnt".

        :param level: The level the pulses have to cross to be recognized as pulse. Usually 10% of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param min_burst_distance: The minimum time between pulses to recognize a burst
        :type min_burst_distance: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: list[dict[str,float]]
        """
        w = self._w.copy()
        burst_start_times = []
        crossings = w.Measurements_Utils.find_all_crossings(level, hysteresis, return_point=hyst_point)
        for i, cr in enumerate(crossings):
            if cr["slope"] == "rise":
                # Find the last rising edge before the current one. If there is none, it is assumed it happened at
                # signal start -> if first edge occurs 'min_burst_distance' seconds after signal start, it is
                # considered a valid burst start
                last = w.time[0] if i == 0 else crossings[i - 1]["index"]
                if cr["index"] - last >= min_burst_distance:
                    burst_start_times.append(cr["index"])
            else:
                pass

        w_parts = w.split_by_times(burst_start_times)[1:]  # Split waveform at burst start times, discard first
        if len(w_parts):
            bursts = []
            for w_part in w_parts:
                try:
                    timeout = w_part.Measurements_Periodic.find_nth_timeout(
                        0, min_burst_distance, level, hysteresis, polarity="neg"
                    )
                except Exception:
                    continue
                burst_dur = timeout - w_part.time[0]
                burst_pulse_cnt = len(
                    list(
                        filter(
                            lambda c: w_part.time[0] <= c["index"] <= timeout and c["slope"] == "rise",
                            crossings,
                        )
                    )
                )
                bursts.append(
                    {
                        "start": w_part.time[0],
                        "stop": timeout,
                        "duration": burst_dur,
                        "pulse_cnt": burst_pulse_cnt,
                    }
                )
            return bursts
        return None

    def get_burst_frequencies(self, level, min_burst_distance, hysteresis=0, hyst_point="start"):
        """
        Finds all bursts (sequence of pulses surrounded with low time longer than 2 times minimum pulse distance)
        and returns a list of dictionaries containing the keys: "start", "stop", "duration" and "pulse_cnt".

        :param level: The level the pulses have to cross to be recognized as pulse. Usually 10% of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param min_burst_distance: The minimum time between pulses to recognize a burst
        :type min_burst_distance: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: np.multiarray.ndarray
        """
        bursts = self.find_all_bursts(level, min_burst_distance, hysteresis, hyst_point)
        if bursts is not None and len(bursts) >= 2:
            freqs = []
            for i in range(1, len(bursts)):
                freqs.append(1.0 / (bursts[i]["start"] - bursts[i - 1]["start"]))
            return np.array(freqs)
        return np.array([])

    def get_burst_frequencies2(self, burst_list):
        """
        Finds all bursts (sequence of pulses surrounded with low time longer than 2 times minimum pulse distance)
        and returns a list of dictionaries containing the keys: "start", "stop", "duration" and "pulse_cnt".

        :param burst_list: A list of burst dicts previously acquired with function "find_all_bursts"
        :type burst_list: list[dict[str,float]]
        """
        if len(burst_list) >= 2:
            freqs = []
            for i in range(1, len(burst_list)):
                freqs.append(1.0 / (burst_list[i]["start"] - burst_list[i - 1]["start"]))
            return np.array(freqs)

        return np.array([])

    def find_nth_burst(self, index, level, min_burst_distance, hysteresis=0, hyst_point="start"):
        """
        Finds the nth burst (sequence of pulses surrounded with low time longer than 2 times minimum pulse distance)
        and returns a dictionary containing the keys: "start", "stop", "duration" and "pulse_cnt".

        :param index: Index of the burst to return
        :type index: int
        :param level: The level the pulses have to cross to be recognized as pulse. Usually 10% of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param min_burst_distance: The minimum time between pulses to recognize a burst
        :type min_burst_distance: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: dict[str,float]
        """
        # TODO ask if we should return None or something else
        bursts_found_array = self.find_all_bursts(level, min_burst_distance, hysteresis, hyst_point)
        if bursts_found_array is not None:
            try:
                return self.find_all_bursts(level, min_burst_distance, hysteresis, hyst_point)[index]
            except IndexError:
                return None
        else:
            return None

    def find_all_timeouts(
        self,
        timeout,
        level,
        hysteresis,
        hyst_point="start",
        htype="abs",
        polarity="neg",
    ):
        """
        Returns a all times where the signal drops and stays below a certain "level" for at least
        "timeout" seconds.

        :param timeout: The min. time the level has to stay below "level" to be recognized as timeout.
        :type timeout: float
        :param level: The level threshold the signal has to drop below.
        :type level: float
        :param hysteresis: The total hysteresis around 'level' as absolut value.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param polarity: The polarity of the pulse that triggers the timeout.
                         Either "POSITIVE", or "NEGATIVE", or short "POS", "NEG"
        :type polarity: str
        :rtype: list[float]
        """

        w = self._w.copy()
        cr = w.Measurements_Utils.find_all_crossings(level, hysteresis, htype, return_point=hyst_point)
        timeouts = []
        if not len(cr):
            return timeouts

        polarity = str(polarity).lower()
        if "pos" in polarity:
            if cr[0]["slope"] == "fall":
                cr = cr[1:]
        elif "neg" in polarity and cr[0]["slope"] == "rise":
            cr = cr[1:]

        c = 0
        while True:
            try:
                t1 = cr[c]["index"]
            except IndexError:
                break  # Break because no crossings left
            try:
                t2 = cr[c + 1]["index"]
            except IndexError:
                # Last falling crossing not available but return timeout if time from last rising crossing
                # to end of waveform is > timeout
                if w.time[-1] - t1 > timeout:
                    timeouts.append(t1)
                break
            time = t2 - t1
            if time > timeout:
                timeouts.append(t1)
            c += 2

        return np.array(timeouts)

    def find_nth_timeout(
        self,
        index,
        timeout,
        level,
        hysteresis,
        hyst_point="start",
        htype="abs",
        polarity="neg",
    ):
        """
        Returns a the nth time where the signal drops and stays below a certain "level" for at least
        "timeout" seconds.

        :param index: The number of the timeout to return
        :type index: int
        :param timeout: The min. time the level has to stay below "level" to be recognized as timeout.
        :type timeout: float
        :param level: The level threshold the signal has to drop below.
        :type level: float
        :param hysteresis: The total hysteresis around 'level' as absolut value.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param polarity: The polarity of the pulse that triggers the timeout.
                         Either "POSITIVE", or "NEGATIVE", or short "POS", "NEG"
        :type polarity: str
        :rtype: float
        """

        try:
            return self._w.Measurements_Periodic.find_all_timeouts(
                timeout, level, hysteresis, hyst_point, htype, polarity
            )[index]
        except IndexError:
            return None

    def find_all_pulses(
        self,
        duration: float,
        level: float,
        hysteresis: float,
        hyst_point: str | None = "start",
        duration_max: float | None = None,
        htype: str | None = "abs",
    ) -> np.ndarray | None:
        """
        Returns the times where pulses start which have a positive width longer than duration seconds.

        :param duration: The duration the signal has to be above level (+hysteresis) to be recognized as pulse.
        :param level: The level where the pulse width is calculated. Usually half of signal range.
        :param hysteresis: The total hysteresis around 'level' as absolut value.
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :param duration_max: The maximum duration of the pulse. Optional
        :param htype: Type of the hysteresis parameter "rel" -> hysteresis is relative to the crossing level
                      "abs"  -> hysteresis is an absolute value
        """

        w = self._w.copy()
        cr = w.Measurements_Utils.find_all_crossings(level, hysteresis, htype, return_point=hyst_point)
        c = 0
        pulses: list[float] = []
        try:
            if cr[0]["slope"] == "fall":
                cr = cr[1:]
            if cr[-1]["slope"] == "rise":
                cr = cr[:-1]
        except IndexError:
            return np.array(pulses)

        while c < len(cr) - 1:
            time = cr[c + 1]["index"] - cr[c]["index"]
            if (time >= duration) and (duration_max is None or (duration_max is not None and duration <= duration_max)):
                pulses.append(cr[c]["index"])
            c += 2

        return np.array(pulses)

    def find_nth_pulse(self, index, duration, level, hysteresis, hyst_point="start", htype="abs"):
        """
        Returns the nth pulse with a width longer than duration.

        :param index: The nth pulse start count with 0.
        :type index: int
        :param duration: The duration the signal has to be above level (+hysteresis) to be recognized as pulse.
        :type duration: float
        :param level: The level where the pulse width is calculated. Usually half of signal range.
        :type level: float
        :param hysteresis: The total hysteresis around 'level' as absolut value.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: float
        """
        # TODO: add unit test

        try:
            return self._w.Measurements_Periodic.find_all_pulses(duration, level, hysteresis, hyst_point, None, htype)[
                index
            ]
        except IndexError:
            return None

    def pulse_count(self, level, hysteresis, hyst_point="start"):
        """
        Returns the number of pulses found. Always returns the smaller number of found rising edges and falling edges.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: int
        """

        crossings = self._w.Measurements_Utils.find_all_crossings(
            level=level, hysteresis=hysteresis, return_point=hyst_point
        )
        rise, fall = 0, 0
        for cr in crossings:
            if cr["slope"] == "rise":
                rise += 1
            elif cr["slope"] == "fall":
                fall += 1
        return min(rise, fall)

    def width_pos(self, level, hysteresis, hyst_point="start"):
        """
        Returns the width of the last found positive pulse. A positive pulse is only recognized if there is a rising
        & falling edge at the end (trailing rising edge is ignored)

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: float
        """
        # TODO ask johannes: should we raise an error or return 0

        crossings = self._w.Measurements_Utils.find_all_crossings(
            level=level, hysteresis=hysteresis, return_point=hyst_point
        )
        if len(crossings) > 0:
            if crossings[-1]["slope"] == "rise":
                if crossings[-3]["slope"] == "rise" and crossings[-2]["slope"] == "fall":
                    t_rise, t_fall = crossings[-3]["index"], crossings[-2]["index"]
                else:
                    msg = "Expected a rising and falling edge at the end, but found '{}' and '{}'.".format(
                        crossings[-3]["slope"], crossings[-2]["slope"]
                    )
                    raise Exception(msg)
            else:
                if crossings[-2]["slope"] == "rise" and crossings[-1]["slope"] == "fall":
                    t_rise, t_fall = crossings[-2]["index"], crossings[-1]["index"]
                else:
                    msg = "Expected a rising and falling edge at the end, but found '{}' and '{}'.".format(
                        crossings[-2]["slope"], crossings[-1]["slope"]
                    )
                    raise Exception(msg)
            return t_fall - t_rise

        msg = "No crossing can be found with the specified level"
        raise ValueError(msg)

    def width_neg(self, level, hysteresis, hyst_point="start"):
        """
        Returns the width of the last found negative pulse. A positive pulse is only recognized if there is a falling
        & rising edge at the end (trailing falling edge is ignored)

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :rtype: float
        """

        crossings = self._w.Measurements_Utils.find_all_crossings(
            level=level, hysteresis=hysteresis, return_point=hyst_point
        )
        if len(crossings) > 0:
            if crossings[-1]["slope"] == "fall":
                if crossings[-3]["slope"] == "fall" and crossings[-2]["slope"] == "rise":
                    t_fall, t_rise = crossings[-3]["index"], crossings[-2]["index"]
                else:
                    msg = "Expected a falling and rising edge at the end, but found '{}' and '{}'.".format(
                        crossings[-3]["slope"], crossings[-2]["slope"]
                    )
                    raise Exception(msg)
            else:
                if crossings[-2]["slope"] == "fall" and crossings[-1]["slope"] == "rise":
                    t_fall, t_rise = crossings[-2]["index"], crossings[-1]["index"]
                else:
                    msg = "Expected a falling and rising edge at the end, but found '{}' and '{}'.".format(
                        crossings[-2]["slope"], crossings[-1]["slope"]
                    )
                    raise Exception(msg)
            return t_rise - t_fall

        msg = "No pulse can be found with the specified level"
        raise IndexError(msg)

    def duty_cycle_pos(self, level, hysteresis, hyst_point="start"):
        """
        Returns the high to low duty cycle of the last found period.

        :param level: The crossing level to look for.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Returns the ratio from the last period between high and low
        :rtype: float
        """

        lp = self._w.Measurements_Utils.find_periods("rise", level, hysteresis, hyst_point=hyst_point)
        if lp is None:
            return 0
        if len(lp) > 0:
            lp = lp[-1]
            return (lp[1] - lp[0]) / (lp[2] - lp[0])

        return 0

    def duty_cycle_neg(self, level, hysteresis, hyst_point="start"):
        """
        Returns the low to high duty cycle of the last found period.

        :param level: The crossing level to look for.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :return: Returns the ratio from the last period between low and high
        :rtype: float
        """

        lp = self._w.Measurements_Utils.find_periods("fall", level, hysteresis, hyst_point=hyst_point)
        if lp is None:
            return 0
        if len(lp) > 0:
            lp = lp[-1]
            return (lp[1] - lp[0]) / (lp[2] - lp[0])

        return 0

    def pulse_pos_width_curve(
        self,
        level,
        hysteresis=0,
        keep_length=True,
        hyst_point="start",
        htype="abs",
        hold_value=True,
    ):
        """
        Finds the positive pulse width of all pulses of a signal and returns the information as waveform.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points during the pulse to the same pulse duration value.\n
                            If False, the function only returns a waveform with the pulse start edges as time and pulse
                            durations as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param hold_value: Only effective if keep_length is True. Holds the pulse duration until the next pulse,
                           otherwise the waveform is set to 0 value while there is no pulse.
        """
        cr = self._w.Measurements_Utils.find_all_crossings(
            level, hysteresis, htype, return_indices=True, return_point=hyst_point
        )
        if not len(cr):
            return None

        if cr[0]["slope"] == "fall":
            cr = cr[1:]  # Only start with positive crossings

        if not len(cr):
            return None

        if len(cr) % 2:
            cr = cr[:-1]  # Strip incomplete pulses

        found_pulses = list(zip(cr[::2], cr[1::2]))
        pulses = []
        for p_start, p_end in found_pulses:
            start = p_start["index"]
            end = p_end["index"]
            duration = float(self._w.time[end] - self._w.time[start])
            pulses.append((start, end, duration))

        if keep_length:
            new_w = self._w.copy().cast_float()
            new_w[:] = 0
            for p_start, p_end, p_duration in pulses:
                if hold_value:
                    new_w.data[p_start:] = p_duration
                else:
                    new_w.data[p_start:p_end] = p_duration
        else:
            time = []
            data = []
            for p_start, _p_end, p_duration in pulses:
                time.append(self._w.time[p_start])
                data.append(p_duration)
            new_w = Waveform(data, time)

        return new_w

    def pulse_neg_width_curve(
        self,
        level,
        hysteresis=0,
        keep_length=True,
        hyst_point="start",
        htype="abs",
        hold_value=True,
    ):
        """
        Finds the negative pulse width of all pulses of a signal and returns the information as waveform.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points during the pulse to the same pulse duration value.\n
                            If False, the function only returns a waveform with the pulse start edges as time and pulse
                            durations as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param hold_value: Only effective if keep_length is True. Holds the pulse duration until the next pulse,
                           otherwise the waveform is set to 0 value while there is no pulse.
        """
        cr = self._w.Measurements_Utils.find_all_crossings(
            level, hysteresis, htype, return_indices=True, return_point=hyst_point
        )
        if not len(cr):
            return None

        if cr[0]["slope"] == "rise":
            cr = cr[1:]  # Only start with negative crossings

        if not len(cr):
            return None

        if len(cr) % 2:
            cr = cr[:-1]  # Strip incomplete pulses

        found_pulses = list(zip(cr[::2], cr[1::2]))
        pulses = []
        for p_start, p_end in found_pulses:
            start = p_start["index"]
            end = p_end["index"]
            duration = float(self._w.time[end] - self._w.time[start])
            pulses.append((start, end, duration))

        if keep_length:
            new_w = self._w.copy().cast_float()
            new_w[:] = 0
            for p_start, p_end, p_duration in pulses:
                if hold_value:
                    new_w.data[p_start:] = p_duration
                else:
                    new_w.data[p_start:p_end] = p_duration
        else:
            time = []
            data = []
            for p_start, _p_end, p_duration in pulses:
                time.append(self._w.time[p_start])
                data.append(p_duration)
            new_w = Waveform(data, time)

        return new_w

    def on_time_curve(
        self,
        level,
        hysteresis=0,
        keep_length=True,
        hyst_point="start",
        strip_incomplete_periods=False,
    ):
        """
        Expect a periodic signal and searches all rising to falling edges to calculate the frequency curve of them.
        Returns a waveform that represents the length from the on times from the signal.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points within a period to the same value.\n
                            If False, the function only returns a waveform with the period start edges as time and
                            periods as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param strip_incomplete_periods: If true the function will return just all points within the period
        :type strip_incomplete_periods: bool
        :return: Waveform that represents the frequency of the self.
        :rtype: Waveform
        """

        indices_split = [0]
        period_only_data = []
        indices_to_remove = []
        _sr = float(self._w.samplerate)
        if keep_length:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=True,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            wave = self._w.copy()
            new_wave_data = np.zeros(wave.length, dtype=np.float64)
            for _i, p in enumerate(periods):
                new_wave_data[p[0] : p[2]] = (p[1] - p[0]) / _sr
                indices_split.append(p[0])
                indices_split.append(p[2])
            if strip_incomplete_periods:
                period_segments = np.split(new_wave_data, indices_split)

                for idx, segment in enumerate(period_segments):
                    if not (all(elem == 0 for elem in segment)):
                        period_only_data.extend(segment)
                    else:  # time vector update
                        if idx > 0:
                            remove_indice = idx - 1 if idx < len(indices_split) else len(indices_split) - 1
                            indices_to_remove.extend(
                                list(
                                    range(
                                        indices_split[remove_indice],
                                        indices_split[remove_indice] + len(segment),
                                    )
                                )
                            )
                wave.time = np.delete(wave.time, indices_to_remove)
                new_wave_data = period_only_data

            wave.data = np.array(new_wave_data)
        else:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=False,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            edges = [p[0] for p in periods]
            per = [p[1] - p[0] for p in periods]
            wave = Waveform(data=per, time=edges)
        return wave

    def off_time_curve(
        self,
        level,
        hysteresis=0,
        keep_length=True,
        hyst_point="start",
        strip_incomplete_periods=False,
    ):
        """
        Expect an periodic signal and searches all falling to rising edges to calculate the frequency curve of them.
        Returns a waveform that represents the length from the off times from the signal.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points within a period to the same value.\n
                            If False, the function only returns a waveform with the period start edges as time and
                            periods as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param strip_incomplete_periods: If true the function will return just all points within the period
        :type strip_incomplete_periods: bool
        :return: Waveform that represents the frequency of the self.
        :rtype: Waveform
        """

        indices_split = [0]
        period_only_data = []
        indices_to_remove = []
        _sr = float(self._w.samplerate)
        if keep_length:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=True,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            wave = self._w.copy()
            new_wave_data = np.zeros(wave.length, dtype=np.float64)
            for _i, p in enumerate(periods):
                new_wave_data[p[0] : p[2]] = (p[2] - p[1]) / _sr
                indices_split.append(p[0])
                indices_split.append(p[2])
            if strip_incomplete_periods:
                period_segments = np.split(new_wave_data, indices_split)

                for idx, segment in enumerate(period_segments):
                    if not (all(elem == 0 for elem in segment)):
                        period_only_data.extend(segment)
                    else:  # time vector update
                        if idx > 0:
                            remove_indice = idx - 1 if idx < len(indices_split) else len(indices_split) - 1
                            indices_to_remove.extend(
                                list(
                                    range(
                                        indices_split[remove_indice],
                                        indices_split[remove_indice] + len(segment),
                                    )
                                )
                            )
                wave.time = np.delete(wave.time, indices_to_remove)
                new_wave_data = period_only_data

            wave.data = np.array(new_wave_data)
        else:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=False,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            edges = [p[0] for p in periods]
            per = [p[2] - p[1] for p in periods]
            wave = Waveform(data=per, time=edges)
        return wave

    def dutycycle_pos_curve(
        self,
        level,
        hysteresis=0,
        keep_length=True,
        hyst_point="start",
        strip_incomplete_periods=False,
    ):
        """
        Expect an periodic signal and searches all falling to rising edges to calculates the frequency curve of them.
        Returns a waveform that represents the length from positive duty cycles.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points within a period to the same value.\n
                            If False, the function only returns a waveform with the period start edges as time and
                            periods as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param strip_incomplete_periods: If true the function will return just all points within the period
        :type strip_incomplete_periods: bool
        :return: Waveform that represents the frequency of the self.
        :rtype: Waveform
        """

        indices_split = [0]
        period_only_data = []
        indices_to_remove = []
        if keep_length:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=True,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            wave = self._w.copy()
            new_wave_data = np.zeros(wave.length, dtype=np.float64)
            for _i, p in enumerate(periods):
                new_wave_data[p[0] : p[2]] = (p[1] - p[0]) / float(p[2] - p[0])
                indices_split.append(p[0])
                indices_split.append(p[2])
            if strip_incomplete_periods:
                period_segments = np.split(new_wave_data, indices_split)

                for idx, segment in enumerate(period_segments):
                    if not (all(elem == 0 for elem in segment)):
                        period_only_data.extend(segment)
                    else:  # time vector update
                        if idx > 0:
                            remove_indice = idx - 1 if idx < len(indices_split) else len(indices_split) - 1
                            indices_to_remove.extend(
                                list(
                                    range(
                                        indices_split[remove_indice],
                                        indices_split[remove_indice] + len(segment),
                                    )
                                )
                            )
                wave.time = np.delete(wave.time, indices_to_remove)
                new_wave_data = period_only_data

            wave.data = np.array(new_wave_data)
        else:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=False,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            edges = [p[0] for p in periods]
            per = [(p[1] - p[0]) / float(p[2] - p[0]) for p in periods]
            wave = Waveform(data=per, time=edges)
        return wave

    def dutycycle_neg_curve(
        self,
        level,
        hysteresis=0,
        keep_length=True,
        hyst_point="start",
        strip_incomplete_periods=False,
    ):
        """
        Expect an periodic signal and searches all falling to rising edges to calculates the frequency curve of them.
        Returns a waveform that represents the length from negative duty cycles.

        :param level: The level where the edges can be found. Usually half of signal range.
        :type level: float
        :param hysteresis: The size of the hysteresis area around the crossing level to supress noise.
        :type hysteresis: float
        :param keep_length: If True, the function returns a waveform with the same length as the original one and sets
                            all points within a period to the same value.\n
                            If False, the function only returns a waveform with the period start edges as time and
                            periods as data vector.
        :type keep_length: bool
        :param hyst_point: Specifies which point of the hysteresis area of the found crossing to use.
                           "start" uses the point where the signal enters the hysteresis area, "mid" the median
                           and "end" the point where the signal leaves the hysteresis area.
        :type hyst_point: str
        :param strip_incomplete_periods: If true the function will return just all points within the period
        :type strip_incomplete_periods: bool
        :return: Waveform that represents the frequency of the self.
        :rtype: Waveform
        """

        indices_split = [0]
        period_only_data = []
        indices_to_remove = []
        if keep_length:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=True,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            wave = self._w.copy()
            new_wave_data = np.zeros(wave.length, dtype=np.float64)
            for _i, p in enumerate(periods):
                new_wave_data[p[0] : p[2]] = (p[2] - p[1]) / float(p[2] - p[0])
                indices_split.append(p[0])
                indices_split.append(p[2])
            if strip_incomplete_periods:
                period_segments = np.split(new_wave_data, indices_split)

                for idx, segment in enumerate(period_segments):
                    if not (all(elem == 0 for elem in segment)):
                        period_only_data.extend(segment)
                    else:  # time vector update
                        if idx > 0:
                            remove_indice = idx - 1 if idx < len(indices_split) else len(indices_split) - 1
                            indices_to_remove.extend(
                                list(
                                    range(
                                        indices_split[remove_indice],
                                        indices_split[remove_indice] + len(segment),
                                    )
                                )
                            )
                wave.time = np.delete(wave.time, indices_to_remove)
                new_wave_data = period_only_data

            wave.data = np.array(new_wave_data)
        else:
            periods = self._w.Measurements_Utils.find_periods(
                "rise",
                level,
                hysteresis,
                return_indices=False,
                hyst_point=hyst_point,
            )
            if periods is None:
                return None
            edges = [p[0] for p in periods]
            per = [(p[2] - p[1]) / float(p[2] - p[0]) for p in periods]
            wave = Waveform(data=per, time=edges)
        return wave


class Math:
    """
    This class is the math class used in the basic Waveform class.
    Waveform classes which inherit from the Waveform base class and need extended functionality for math use
    this class to define a waveform specific fitting class inheriting from this one.
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    def round(self, n=0) -> Waveform:
        """
        Evenly round the current waveform data to the given number of decimals.

        :param n: Number of decimal places to round to (default: 0).
                  If decimals is negative, it specifies the number of positions to the left of the decimal point.
        :type n: int
        """
        wf = self._w.copy()
        wf.data = np.round(wf.data, decimals=n)
        return wf

    def round_towards_zero(self) -> Waveform:
        """Returns the current waveform with the data rounded to nearest integer towards zero"""
        wf = self._w.copy()
        wf.data = np.fix(wf.data)
        return wf

    def floor(self) -> Waveform:
        """Floors the current waveform down to the nearest integer."""
        wf = self._w.copy()
        wf.data = np.floor(wf.data)
        return wf

    def ceil(self) -> Waveform:
        """Ceils the current waveform up to the nearest integer."""
        wf = self._w.copy()
        wf.data = np.ceil(wf.data)
        return wf

    def truncate(self) -> Waveform:
        """Returns the current waveform with the fractional part of the data vector is discarded."""
        wf = self._w.copy()
        wf.data = np.trunc(wf.data)
        return wf

    def derivate(self, n) -> Waveform:
        """
        Deprecated and only for backward compatibility! Alias for :func:`diff`.

        :param n: The number passed to numpy.diff (n-th)
        :type n: int

        .. deprecated:: 1.4.0
           Please use either the function :func:`derive` for a numerical derivative or :func:`diff` to retain the
           original behaviour of this function and remove this warning!
        """
        warnings.warn(
            "Warning: Use of obsolete function Waveform.Math.derivate! "
            "Consider replacing this call with either Waveform.Math.derive or Waveform.Math.diff (see documentation)",
            DeprecationWarning,
            stacklevel=2,
        )
        return self.diff(n)

    def diff(self, n) -> Waveform:
        """
        Returns the n-th finite difference of the waveform.

        :param n: The number passed to numpy.diff (n-th)
        :type n: int
        """
        if n < 1:
            msg = "Cannot calculate a difference smaller than 1."
            raise ValueError(msg)
        return Waveform(time=self._w.time[: -int(n)], data=np.diff(self._w.data, int(n)))

    def derive(self, n=1, keep_time=False) -> Waveform:
        """
        Returns the n-th derivative of the waveform.

        :param n: The number of the derivative (n-th)
        :type n: int
        :param keep_time: Keep the original timebase instead of interpolating, which is often easier to handle but
                          mathematically not entirely correct
        :type keep_time: bool
        """
        if n < 1:
            msg = "Cannot calculate a derivative smaller than 1."
            raise ValueError(msg)

        wf = self._w.copy()

        for _ in range(n):
            wf.data = np.diff(wf.data) / np.diff(wf.time)
            if keep_time:
                wf.time = wf.time[:-1]
            else:
                wf.time = (wf.time[1:] + wf.time[:-1]) / 2
        return wf

    def integrate(self, order=1, initial=0.0):
        """
        Returns the integral of the waveform and adds an initial value.

        In case of arbitrary spaced samples, the two functions trapz and simps are available.
        They are using Newton-Coates formulas of order 1 and 2 respectively to perform integration.
        The trapezoidal rule approximates the function as a straight line between adjacent points,
        while Simpsons rule approximates the function between three adjacent points as a parabola.

        :param order: 1 for trapezoidal rule, 2 for Simpsons rule
        :type order: int
        :param initial: The initial value to add.
        :type initial: float
        :rtype: float
        """
        if order == 1:
            return trapz(self._w.data, self._w.time) + initial
        if order == 2:
            return simps(self._w.data, self._w.time) + initial

        msg = "Parameter 'order' out of range [1,2]"
        raise ValueError(msg)

    def sum(self):
        """Returns the sum of the signals data vector"""
        return np.sum(self._w.data)

    def cumsum(self) -> Waveform:
        """Returns a waveform with a cumulative sum of the elements of the signals data vector."""
        wf = self._w.copy()
        wf.data = np.cumsum(wf.data)
        return wf

    def integral_wf(self) -> Waveform:
        """Return the integral function of the waveform, using the trapz method."""
        wf = self._w.copy()
        wf.data = np.concatenate((np.array([0]), cumtrapz(wf.data, wf.time)))
        return wf

    def extrapolate(self, minval=None, maxval=None) -> Waveform:
        """
        Returns a new waveform, which is linearly extrapolated from the first two points to minval and from the last
        two points to maxval

        :param minval: If smaller than the first time-value, the first two points will be extrapolated until this
                       time-value
        :type minval: float
        :param maxval: If bigger than the last time-value, the last two points will be extrapolated until this
                       time-value
        :type maxval: float
        """
        d = self._w.data
        t = self._w.time
        data = d
        time = t
        if minval is not None and minval < t[0]:
            fac = (t[0] - minval) / (t[1] - t[0])
            time = np.append([minval], time)
            data = np.append([d[0] - (d[1] - d[0]) * fac], data)
        if maxval is not None and maxval > t[-1]:
            fac = (maxval - t[-1]) / (t[-2] - t[-1])
            time = np.append(time, [maxval])
            data = np.append(data, [d[-1] + (d[-2] - d[-1]) * fac])
        return Waveform(data=data, time=time, metaData=self._w.getMeta())


class Export:
    """
    This class is the math class used in the basic Waveform class.
    Waveform classes which inherit from the Waveform base class and need extended functionality for math use
    this class to define a waveform specific fitting class inheriting from this one.
    """

    def __init__(self, wf):
        self._w: Waveform = wf

    def excel(self, filename, tabname=None, metadata=None, plot=False):
        """
        Exports the waveform to an Excel workbook.

        :param filename: The filename where to save the workbook.

                         Note: If the file already exists it will be loaded and a new tab generated.
                         Existing plots cannot be imported and will not be included when exporting again!
        :param tabname: The name of the tab. If None, the tab will be named as the waveform. See Waveform.setMeta()
        :param metadata: A dictionary of metadata to include (like parameters, settings...)
        :param plot: If True a simple scatter plot is generated
        """
        try:
            from openpyxl import Workbook, load_workbook
            from openpyxl.chart import Reference, ScatterChart
            from openpyxl.chart.series_factory import SeriesFactory
        except ModuleNotFoundError:
            msg = "openpyxl needs to be installed (pip install openpyxl) for this feature to work!"
            raise ModuleNotFoundError(msg) from None

        if not os.path.exists(filename):
            wb = Workbook()
            for ws in wb.worksheets:
                wb.remove_sheet(ws)
        else:
            wb = load_workbook(filename)

        xlabel = self._w.getMeta("xtitle", "time")
        if self._w.getMeta("xunit", "") != "":
            xlabel += " ({})".format(self._w.getMeta("xunit", ""))

        ylabel = self._w.getMeta("ytitle", "data")
        if self._w.getMeta("yunit", "") != "":
            ylabel += " ({})".format(self._w.getMeta("yunit", ""))

        ws = wb.create_sheet(title=str(tabname) if tabname is not None else self._w.getMeta("name", "noname"))

        if isinstance(metadata, dict):
            ws.cell(row=1, column=4, value="Metadata")
            for i, item in enumerate(metadata.items()):
                ws.cell(row=i + 2, column=4, value=item[0])
                ws.cell(row=i + 2, column=5, value=item[1])

        ws.cell(row=1, column=1, value=xlabel)
        ws.cell(row=1, column=2, value=ylabel)

        time = self._w.time
        data = self._w.data
        for i in range(len(self._w)):
            ws.cell(row=i + 2, column=1, value=time[i])
            ws.cell(row=i + 2, column=2, value=data[i])

        if plot:
            xaxis = Reference(ws, min_col=1, min_row=2, max_row=len(time) + 1)
            yaxis = Reference(ws, min_col=2, min_row=2, max_row=len(data) + 1)
            s = SeriesFactory(yaxis, xvalues=xaxis)

            ch = ScatterChart()
            ch.title = self._w.getMeta("title", ylabel)
            ch.y_axis.title = ylabel
            ch.x_axis.title = xlabel
            ch.legend = None
            ch.append(s)
            ws.add_chart(ch, "G2")

        wb.save(filename)


class Waveform:
    """
    This class acts as a representation of a waveform which has an equidistant-sampled time vector and a data vector.
    The class provides many possibilities of processing a waveform like:

    - Arithmetical operations (add, sub, mul, div, mod, abs, inv, pow, ...)
    - Mathematical operations (round, round->0, floor, ceil, truncate, derivate, integrate, derivate, ...)
    - Comparing waveforms (<, <=, >, >=, ==, !=)
    - Construction methods (extend, insert, repeat, mirror, ...)
    - Editting/slicing methods (slice, interpolate, split, time shift, ...)
    - File caching (save, load)
    - Resampling method (upsample, downsample(with AAF), down_sample(no AAF)
    - Filtering (lowpass, median, savitzky-golay)
    - Fitting (segmented_best_fit, polynomial)
    - Finding crossings
    - Finding extrema
    - Basic Measurements (max, min, RMS, peak to peak, mean, ...)
    - Periodic Measurements (period, avg_period, frequency, avg_frequency, dutycycle, burst_width,
      pulse_count, on/off-time, period/frequency/ontime/offtime/pos_duty/neg_duty curve, ...)
    - Non-Periodic Measurements (high, low, overshoot, undershoot, risetime, falltime, amplitude, ...)

    To create a waveform object follow this example:

    .. code-block:: python

        from pverify.postproc.waveform import Waveform
        # or
        from pverify import Waveform

        wave1 = Waveform(data=[0,1,2,3,4])                       # data vector only, time is [0 .. len(data)-1]
        wave2 = Waveform(data=[0,1,2,3,4], time=[0, 2, 4, 6, 8]) # data & time vector
        wave3 = Waveform(data=[0,1,2,3,4], time=[0, 10])         # data vector only, only start & stop time given,
                                                                 # time vector will be built up internally
        wave4 = Waveform.Generation.Sine(100, 10, 50, 0, 0)      # Use static signal generator functions
        wave5 = Waveform.load_from_file(filepath=r"C:/temp/...") # Use static method to create waveform from data files

    """

    Generation = Generator
    __instance = 0
    legacy_inplace_behavior = True  # todo: change to False in wavewatson>=2.0.0

    def __init__(self, data, time=None, metaData=None, nan_to_num=True):
        """
        Creates a waveform object with a time and data vector.

        :param data: The data vector of the waveform
        :param time: The time vector of the waveform
        :param metaData: A dictionary of metadata for this waveform instance
        :param nan_to_num: If True (default) any NaN or Inf values in the data array will be replaced.
                           NaN is replaced by zero, and infinity and -infinity replaced by the respectively largest
                           and most negative finite floating point values representable.

        .. note::
            If time only contains 2 values these will be treated as start and
            stop time and the waveforms time vector will be created as linear range from start to stop
            with the same amount of points as data.

        """

        if type(data) not in (list, np.ndarray):
            msg = "The data vector has to be either a list or numpy array."
            raise ValueError(msg)
        if nan_to_num:
            self.data: np.ndarray = np.nan_to_num(np.array(data))
        else:
            self.data: np.ndarray = np.array(data)
        if np.issubdtype(self.data.dtype, np.complex_):
            msg = "Waveform cannot be instantiated with a complex data vector!"
            raise TypeError(msg)
        self.__slicemode = None
        if time is not None:
            if type(time) not in (list, np.ndarray):
                msg = "The time vector has to be either a list or numpy array."
                raise ValueError(msg)
            if len(time) == 2 and len(self.data) > 2:  # Time is compressed data --> decompress
                self.time: np.ndarray = np.linspace(time[0], time[1], len(self.data))
            else:
                self.time: np.ndarray = np.array(time)
        else:
            self.time: np.ndarray = np.linspace(0, len(self.data), len(self.data), endpoint=False)

        len_time = len(self.time)
        len_data = len(self.data)
        if len_time != len_data:
            msg = f"time (len: {len_time}) and data (len: {len_data}) vector must have the same length!"
            raise ValueError(msg)

        self.type = self.TYPES.WAVEFORM
        self._length = 0
        self._samplerate = 0
        self.__meta = {
            "name": "wave_%03d" % Waveform.__instance,
            "xtitle": "",
            "xunit": "",
            "ytitle": "",
            "yunit": "",
            "title": "",
        }

        self._recalc_attributes()  # here we are calculating some attributes like samplerate

        self.Export = Export(self)
        self.Math = Math(self)
        self.Filter = Filter(self)
        self.Fitting = Fitting(self)
        self.Measurements_Base = Measurements_Base(self)
        self.Measurements_Utils = Measurements_Utils(self)
        self.Measurements_Periodic = Measurements_Periodic(self)
        self.Measurements_NonPeriodic = Measurements_NonPeriodic(self)

        if isinstance(metaData, dict):
            [metaData.update({k: v}) for k, v in self.__meta.items() if k not in metaData]
            Waveform.__instance += 1
            self.__meta.update(**metaData)

    @property
    def _name(self):
        return self.getMeta("name")

    @_name.setter
    def _name(self, value):
        self.setMeta(name=value)

    @property
    def length(self):
        return len(self)

    @property
    def samplerate(self):
        return self._samplerate

    @property
    def is_empty(self):
        return self.length == 0

    def __sizeof__(self):
        return self.data.nbytes + self.time.nbytes

    def __repr__(self):
        """
        Returns a string representation of the waveform with the format:\n
        "Waveform instance --> Name:%s, Type:%s, Length:%d, SampleRate:%.3f, Tstart: %.3f, Tstop:%.3f"
        """
        try:
            if self.type == self.TYPES.FFT:
                info = "Waveform --> Name:%s, Type:%s, Length:%d, SampleRate:%.3e, Tstart: %.3e, Tstop:%.3e" % (
                    self.getMeta("name"),
                    self.type,
                    self.length,
                    self.samplerate,
                    self.time[0],
                    self.time[-1],
                )
            else:
                if self.length >= 2:
                    info = "Waveform --> Name:%s, Length:%d, SampleRate:%.3e, Tstart: %.3e, Tstop:%.3e" % (
                        self.getMeta("name"),
                        self.length,
                        self.samplerate,
                        self.time[0],
                        self.time[-1],
                    )
                elif self.length == 1:
                    info = "Waveform --> Name:{} (single-valued), x={:.3e}, y={:.3e}".format(
                        self.getMeta("name"),
                        self.time[0],
                        self.data[0],
                    )
                else:
                    info = "Waveform --> Name:{} (empty)".format(self.getMeta("name"))
            return info
        except Exception:
            return "Failed creating waveform representation string"

    def __len__(self):
        """
        Returns the length (number of data points) of the waveform.

        :rtype: int
        """
        return len(self.time)

    def __add__(self, other):
        """
        Returns a new waveform object which is the sum of the current waveform and another waveform or numeric value.
        The time vector is not effected.

        :param other: The waveform/numeric to add.
        :type other: Waveform|int|float
        :rtype: Waveform
        """
        if isinstance(other, Waveform):
            if not array_eq(self.time, other.time):
                msg = "The signals to add must have the same time"
                raise ValueError(msg)
            return Waveform(time=self.time, data=self.data + other.data, metaData=self.getMeta())

        try:
            other = float(other)
            return Waveform(time=self.time, data=self.data + other, metaData=self.getMeta())
        except Exception:
            msg = "The add operator can only handle the sum of Waveform instances or scalars."
            raise ValueError(msg) from None

    def __sub__(self, other):
        """
        Returns a new waveform object which is the difference of the current waveform and another waveform or numeric
        value.
        The time vector is not effected.

        :param other: The waveform/numeric to subtract.
        :type other: Waveform|int|float
        :rtype: Waveform
        """
        if isinstance(other, Waveform):
            if not array_eq(self.time, other.time):
                msg = "The signals to subtract must have the same time"
                raise ValueError(msg)
            return Waveform(time=self.time, data=self.data - other.data, metaData=self.getMeta())

        try:
            other = float(other)
            return Waveform(time=self.time, data=self.data - other, metaData=self.getMeta())
        except Exception:
            msg = "The subtraction operator can only handle the sub of Waveform instances or scalars."
            raise ValueError(msg) from None

    def __mul__(self, other):
        """
        Returns a new waveform object which is the product of the current waveform and another waveform or numeric
        value.
        The time vector is not effected.

        :param other: The waveform/numeric to multiply with.
        :type other: Waveform|int|float
        :rtype: Waveform
        """
        if isinstance(other, Waveform):
            if not array_eq(self.time, other.time):
                msg = "The signals to multiply must have the same time"
                raise ValueError(msg)
            return Waveform(time=self.time, data=self.data * other.data, metaData=self.getMeta())

        try:
            other = float(other)
            return Waveform(time=self.time, data=self.data * other, metaData=self.getMeta())
        except Exception:
            msg = "The multiply operator can only handle the sub of Waveform instances or scalars."
            raise ValueError(msg) from None

    def __truediv__(self, other):
        """
        Returns a new waveform object which is the true division of the current waveform and another waveform or numeric
        value.
        The time vector is not effected.

        :param other: The waveform/numeric to divide.
        :type other: Waveform|int|float
        :rtype: Waveform
        """
        if isinstance(other, Waveform):
            if not array_eq(self.time, other.time):
                msg = "The signals to divide must have the same time"
                raise ValueError(msg)
            return Waveform(
                time=self.time,
                data=np.where(
                    other.data == 0, self.data, self.data / other.data
                ),  # FIXED, TODO ask if it should be zero or self.data
                metaData=self.getMeta(),
            )

        try:
            other = float(other)
            return Waveform(
                time=self.time,
                data=np.where(other == 0, self.data, self.data / other),
                metaData=self.getMeta(),
            )
        except Exception:
            msg = "The division operator can only handle the sub of Waveform instances or scalars."
            raise ValueError(msg) from None

    def __floordiv__(self, other):
        """
        Returns a new waveform object which is the floor division
        of the current waveform and another waveform or numeric value.
        The time vector is not effected.

        :param other: The waveform/numeric to divide.
        :type other: Waveform|int|float
        :rtype: Waveform
        """
        if isinstance(other, Waveform):
            if not array_eq(self.time, other.time):
                msg = "The signals to divide must have the same time"
                raise ValueError(msg)
            return Waveform(
                time=self.time,
                data=np.where(other.data == 0, self.data, self.data // other.data),  # FIXED
                metaData=self.getMeta(),
            )

        try:
            other = float(other)
            return Waveform(
                time=self.time,
                data=np.where(other == 0, self.data, self.data // other),
                metaData=self.getMeta(),
            )
        except Exception:
            msg = "The division operator can only handle the sub of Waveform instances or scalars."
            raise ValueError(msg) from None

    def __mod__(self, other):
        """
        Returns a new waveform object which is the remainder of the current waveform and another waveform or numeric
        value.
        The time vector is not effected.

        :param other: The waveform/numeric to divide.
        :type other: Waveform|int|float
        :rtype: Waveform
        """
        try:
            other = int(other)
            return Waveform(
                time=self.time,
                data=np.where(other == 0, self.data, np.remainder(self.data, other)),
                metaData=self.getMeta(),
            )
        except Exception:
            msg = "The modulo operator can only handle integers."
            raise ValueError(msg) from None

    def __abs__(self):
        """
        Returns a new waveform with the data vector converted to absolute values.
        The time vector is not effected.

        :rtype: Waveform
        """
        return Waveform(time=self.time, data=np.abs(self.data), metaData=self.getMeta())

    def __neg__(self):
        """
        Returns a waveform multiplied by -1.

        :return:
        :rtype: Waveform
        """
        return Waveform(time=self.time, data=-self.data, metaData=self.getMeta())

    def __invert__(self):
        """
        Returns a waveform with inverted data points. (Power to -1)
        :return:A new Waveform
        :rtype: Waveform

        """
        with warnings.catch_warnings():
            warnings.simplefilter(action="ignore", category=RuntimeWarning)
            return Waveform(
                time=self.time,
                data=np.where(self.data == 0, 0, 1.0 / self.data),
                metaData=self.getMeta(),
            )

    def __pow__(self, power):
        """
        Returns a waveform with data vector to the power of parameter 'power'.

        :param power: The power to calculate.
        :type power: float
        :return: Returns a new Waveform
        :rtype: Waveform

        """
        return Waveform(time=self.time, data=self.data**power, metaData=self.getMeta())

    def __eq__(self, other):
        """
        Compares two waveforms if they have the same time and data vectors.

        :param other: The waveform to compare.
        :type other: Waveform
        :return: Indication
        :rtype: bool

        """
        if isinstance(other, Waveform):
            if len(self) != len(other):
                return False
            # If other is a waveform, compare time and data array
            return array_eq(self.time, other.time) and array_eq(self.data, other.data)
        if other is None:
            return False
        if is_numeric(other):
            # If other is a scalar value (int, float), compare the data array to the scalar value
            return array_eq(self.data, other)
        if is_numeric_iterable(other) and len(other) == 1:
            # If other is a list/array of numeric values with length 1, compare the data array to the scalar value
            return array_eq(self.data, other)
        return False

    def __ne__(self, other):
        """
        Compares two waveforms if they have the same time and data vectors and returns True is they are not equal.

        :param other: The waveform to compare.
        :type other: Waveform
        :return: Indication
        :rtype: bool

        """
        return not (self == other)

    def __gt__(self, other):
        """
        Compares if a waveform is greater than another waveform or numeric value.

        :param other: The waveform to compare.
        :type other: Waveform|int|float|list[float]|list[int]
        :rtype: bool

        """
        if isinstance(other, Waveform):
            t_start = max([other.time[0], self.time[0]])
            t_stop = min([other.time[-1], self.time[-1]])
            tmpother = other.copy()
            tmpself = self.copy()

            if t_start > t_stop:
                msg = "The waveforms to compare are not overlapping!"
                raise Exception(msg)
            merged_time = np.concatenate((tmpself[t_start:t_stop].time, tmpother[t_start:t_stop].time))
            merged_time.sort(kind="mergesort")

            tmpself = tmpself.interpolate(merged_time)
            tmpother = tmpother.interpolate(merged_time)

            result = array_gt(tmpself.data, tmpother.data)
            del tmpother, tmpself
            gc.collect()
            return result

        if is_numeric(other):
            # If other is a scalar value (int, float), compare the data array to the scalar value
            return array_gt(self.data, other)
        if is_numeric_iterable(other):
            if len(other) == 1:
                # If other is a list/array of numeric values with length 1, compare the data array to the scalar value
                return array_gt(self.data, other)
            other_wf = Waveform(other, [self.time[0], self.time[-1]])
            return self > other_wf
        msg = f"Can only compare with type 'Waveform', not with type '{other.__class__.__name__}'."
        raise TypeError(msg)

    def __ge__(self, other):
        """
        Compares if a waveform is greater or equal than another waveform or numeric value.

        :param other: The waveform to compare.
        :type other: Waveform|int|float|list[float]|list[int]
        :rtype: bool

        """
        if isinstance(other, Waveform):
            t_start = max([other.time[0], self.time[0]])
            t_stop = min([other.time[-1], self.time[-1]])
            tmpother = other.copy()
            tmpself = self.copy()

            if t_start > t_stop:
                msg = "The waveforms to compare are not overlapping!"
                raise Exception(msg)
            merged_time = np.concatenate((tmpself[t_start:t_stop].time, tmpother[t_start:t_stop].time))
            merged_time.sort(kind="mergesort")
            tmpself = tmpself.interpolate(merged_time)
            tmpother = tmpother.interpolate(merged_time)

            result = array_ge(tmpself.data, tmpother.data)
            del tmpother, tmpself
            gc.collect()
            return result
        if is_numeric(other):
            # If other is a scalar value (int, float), compare the data array to the scalar value
            return array_ge(self.data, other)
        if is_numeric_iterable(other):
            if len(other) == 1:
                # If other is a list/array of numeric values with length 1, compare the data array to the scalar value
                return array_ge(self.data, other)
            other_wf = Waveform(other, [self.time[0], self.time[-1]])
            return self >= other_wf
        msg = f"Can only compare with type 'Waveform', not with type '{other.__class__.__name__}'."
        raise TypeError(msg)

    def __lt__(self, other):
        """
        Compares if a waveform is lower than another waveform or numeric value.

        :rtype: bool
        """
        if isinstance(other, Waveform):
            t_start = max([other.time[0], self.time[0]])
            t_stop = min([other.time[-1], self.time[-1]])
            tmpother = other.copy()
            tmpself = self.copy()

            if t_start > t_stop:
                msg = "The waveforms to compare are not overlapping!"
                raise Exception(msg)
            merged_time = np.concatenate((tmpself[t_start:t_stop].time, tmpother[t_start:t_stop].time))
            merged_time.sort(kind="mergesort")
            tmpself = tmpself.interpolate(merged_time)
            tmpother = tmpother.interpolate(merged_time)

            result = array_lt(tmpself.data, tmpother.data)
            del tmpother, tmpself
            gc.collect()
            return result
        if is_numeric(other):
            # If other is a scalar value (int, float), compare the data array to the scalar value
            return array_lt(self.data, other)
        if is_numeric_iterable(other):
            if len(other) == 1:
                # If other is a list/array of numeric values with length 1, compare the data array to the scalar value
                return array_lt(self.data, other)
            other_wf = Waveform(other, [self.time[0], self.time[-1]])
            return self < other_wf
        msg = f"Can only compare with type 'Waveform', not with type '{other.__class__.__name__}'."
        raise TypeError(msg)

    def __le__(self, other):
        """
        Compares if a waveform is lower or equal than another waveform or numeric value.

        :param other: The waveform to compare.
        :type other: Waveform|int|float|list[float]|list[int]
        :return: Indication
        :rtype: bool

        """
        if isinstance(other, Waveform):
            t_start = max([other.time[0], self.time[0]])
            t_stop = min([other.time[-1], self.time[-1]])
            tmpother = other.copy()
            tmpself = self.copy()

            if t_start > t_stop:
                msg = "The waveforms to compare are not overlapping!"
                raise Exception(msg)
            merged_time = np.concatenate((tmpself[t_start:t_stop].time, tmpother[t_start:t_stop].time))
            merged_time.sort(kind="mergesort")
            tmpself = tmpself.interpolate(merged_time)
            tmpother = tmpother.interpolate(merged_time)

            result = array_le(tmpself.data, tmpother.data)
            del tmpother, tmpself
            gc.collect()
            return result
        if is_numeric(other):
            # If other is a scalar value (int, float), compare the data array to the scalar value
            return array_le(self.data, other)
        if is_numeric_iterable(other):
            if len(other) == 1:
                # If other is a list/array of numeric values with length 1, compare the data array to the scalar value
                return array_le(self.data, other)
            other_wf = Waveform(other, [self.time[0], self.time[-1]])
            return self <= other_wf
        msg = f"Can only compare with type 'Waveform', not with type '{other.__class__.__name__}'."
        raise TypeError(msg)

    @property
    def duration(self):
        return float(self.time[-1] - self.time[0])

    def enforce_slice_mode(self, mode=None):
        """
        Enforces waveform slicing with a specific mode independent of the datatypes (int, float) used for slicing.

        :param mode: Either "time", "index" or None to turn off
        """
        if mode is not None:
            mode = str(mode).lower()
            if mode == "time":
                self.__slicemode = "time"
            elif mode == "index":
                self.__slicemode = "index"
            else:
                self.__slicemode = None
        else:
            self.__slicemode = None

    def __check_slice(self, Slice, endpoint=False):
        if Slice.start is not None:
            if self.__slicemode == "time":
                Slice.start = float(Slice.start)
            elif self.__slicemode == "index":
                Slice.start = int(Slice.start)

            if is_float(Slice.start):
                start = np.where(self.time >= Slice.start)[0][0]
            elif is_int(Slice.start):
                start = Slice.start
            else:
                start = 0
        else:
            start = 0

        if start > (len(self.time) - 1):
            msg = f"Slice start index ({start:d}) out of range [0:{len(self) - 1:d}]!"
            raise IndexError(msg)

        if Slice.stop is not None:
            if self.__slicemode == "time":
                Slice.stop = float(Slice.stop)
            elif self.__slicemode == "index":
                Slice.stop = int(Slice.stop)

            if is_float(Slice.stop) and Slice.stop <= self.time[-1]:
                stop = (
                    np.where(self.time <= Slice.stop)[0][-1] + 1
                )  # TODO askkk: As I removed it, it causes Problems by other tests
                if endpoint:
                    stop += 1
            elif is_int(Slice.stop) and Slice.stop <= len(self.time):
                stop = Slice.stop
                if endpoint:
                    stop += 1
            else:
                stop = len(self.time)

            if stop > len(self.time):
                stop = len(self.time)
        else:
            stop = len(self.time)

        if is_float(Slice.step):
            Slice.step = int(Slice.step)

        return slice(int(start), int(stop), Slice.step)

    def __setitem__(self, Slice, values):
        """
        Overwrites a time slice of the wave by either a numeric or a vector.

        Case 'numeric': The data vector for the time slice is set to a constant value
        Case 'vector': The data vector for the time slice is set to a vector. If the vector does not have the same
        length as the time slice it will be interpolated.

        If Start and Stop of the slice are floats the waveform is sliced by time, otherwise if start or stop is integer
        the waveform is sliced by indices.

        """
        if isinstance(Slice, slice):
            # Search indices for time slice values
            new_slice = self.__check_slice(Slice)

            y = self.data[:]
            ts = self.time[new_slice]
            if is_numeric(values):
                y[new_slice] = float(values)
            elif type(values) in [list, np.ndarray]:
                y[new_slice] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values)), values)
            elif isinstance(values, Waveform):
                y[new_slice] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values.data)), values.data)

            self.data = y[:]
            del y, ts, new_slice
            gc.collect()

        elif type(Slice) is tuple:
            indices = np.array(Slice)
            if np.issubdtype(indices.dtype, np.int):
                if is_numeric(values):
                    self.data[indices] = values
                elif type(values) in [list, np.ndarray]:
                    ts = self.time[indices]
                    self.data[indices] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values)), values)
                elif isinstance(values, Waveform):
                    ts = self.time[indices]
                    self.data[indices] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values.data)), values.data)
                else:
                    msg = (
                        "When assigning a value/values to a slice of the "
                        "waveform only numeric scalars or vector are allowed"
                    )
                    raise Exception(msg)
            elif np.issubdtype(indices.dtype, np.float):
                if is_numeric(values):
                    self.data[self.time_to_index(indices)] = values
                elif type(values) in [list, np.ndarray]:
                    ts = self.time[self.time_to_index(indices)]
                    self.data[self.time_to_index(indices)] = np.interp(
                        ts, np.linspace(ts[0], ts[-1], len(values)), values
                    )
                elif isinstance(values, Waveform):
                    ts = self.time[self.time_to_index(indices)]
                    self.data[self.time_to_index(indices)] = np.interp(
                        ts, np.linspace(ts[0], ts[-1], len(values.data)), values.data
                    )
                else:
                    msg = (
                        "When assigning a value/values to a slice of the "
                        "waveform only numeric scalars or vector are allowed"
                    )
                    raise Exception(msg)

        elif is_int(Slice) and isinstance(values, (int, float, complex)):
            self.data[Slice] = values

        elif is_float(Slice) and isinstance(values, (int, float, complex)):
            index = np.where(self.time >= Slice)[0][0]
            self.data[index] = values

        elif type(Slice) in [list, np.ndarray] and np.issubdtype(np.array(Slice).dtype, np.int):
            if is_numeric(values):
                self.data[Slice] = values
            elif type(values) in [list, np.ndarray]:
                ts = self.time[Slice]
                self.data[Slice] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values)), values)
            elif isinstance(values, Waveform):
                ts = self.time[Slice]
                self.data[Slice] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values.data)), values.data)
            else:
                msg = (
                    "When assigning a value/values to a slice of the "
                    "waveform only numeric scalars or vector are allowed"
                )
                raise Exception(msg)

        elif type(Slice) in [list, np.ndarray] and np.issubdtype(np.array(Slice).dtype, np.float):
            if is_numeric(values):
                self.data[self.time_to_index(Slice)] = values
            elif type(values) in [list, np.ndarray]:
                ts = self.time[self.time_to_index(Slice)]
                self.data[self.time_to_index(Slice)] = np.interp(ts, np.linspace(ts[0], ts[-1], len(values)), values)
            elif isinstance(values, Waveform):
                ts = self.time[self.time_to_index(Slice)]
                self.data[self.time_to_index(Slice)] = np.interp(
                    ts, np.linspace(ts[0], ts[-1], len(values.data)), values.data
                )
            else:
                msg = (
                    "When assigning a value/values to a slice of the "
                    "waveform only numeric scalars or vector are allowed"
                )
                raise Exception(msg)

    def __getitem__(self, Slice, endpoint=False):
        """
        If Slice is a numeric the function interpolates the data vector at this time and returns the value.\n
        If Slice if of type slice the function slices the waveform accordingly and returns the slice as waveform.\n
        If Start and Stop of the slice are floats the waveform is sliced by time, otherwise if start OR stop is integer
        the waveform is sliced by indices.

        :return: A slice of the current waveform
        :rtype: Waveform

        Example:

        .. code-block:: python

            w = Waveform(time=[0.0,0.5,1.0,1.5,2.0,2.5,3.0], data=[3,4,5,6,7,8,9])
            w2 = w[0:2]       # Slice by indices from 0 to 1.0 seconds
            w2 = w[0.0:1.0]   # Slice by time from 0 to 1.0 seconds
            w2 = w[0.0:2.0:2] # Slice from 0 to 2 seconds taking every second index (0.0,1.0,2.0)
            w[3]              # Return data at time 1.5s
            w[1.5]            # Return data at time 1.5s

        """
        if isinstance(Slice, slice):
            new_slice = self.__check_slice(Slice, endpoint)
            w = Waveform(
                time=self.time[new_slice],
                data=self.data[new_slice],
                metaData=self.getMeta(),
            )
            w.type = self.type
            w._recalc_attributes()
            return w

        if type(Slice) is tuple:
            indices = np.array(Slice)
            if np.issubdtype(indices.dtype, np.int):
                return self.data[indices]
            if np.issubdtype(indices.dtype, np.float):
                return [self.at_time(t) for t in list(indices)]
            return None

        if is_float(Slice):  # Return data at specific time
            return self.interpolate(Slice)

        if (
            is_int(Slice) or type(Slice) in [list, np.ndarray] and np.issubdtype(np.array(Slice).dtype, np.int_)
        ):  # Return data at specific time
            return self.data[Slice]
        if type(Slice) in [list, np.ndarray] and np.issubdtype(np.array(Slice).dtype, np.float_):
            return [self.at_time(t) for t in list(Slice)]
        msg = f"Unknown slice type '{Slice}'"
        raise Exception(msg)

    def getMeta(self, key: str | None = None, default=None) -> dict | str:
        """Returns the meta information of the waveform."""
        if key is None:
            return self.__meta
        if isinstance(key, str):
            return self.__meta.get(key, default)
        msg = "Invalid datatype for argument 'key'. Allowed: None, StringType"
        raise TypeError(msg)

    def setMeta(self, **kwargs):
        """
        Sets meta information of the waveform.

        :key name: The name of the waveform.
        :key xtitle: The name of the x/time vector.
        :key xunit: The unit of the x/time vector.
        :key ytitle: The name of the y/data vector.
        :key yunit: The unit of the y/data vector.
        :key title: The title of the waveform (can be shown as plot title)
        :key resolution_bits: The number of bits of the scope resolution (used for optimizing histograms)
        """
        self.__meta.update(kwargs)

    @property
    def resolution_bits(self):
        """
        The number of bits of the scope resolution (used for optimizing histograms)
        """
        return self.getMeta("resolution_bits", 13)

    @resolution_bits.setter
    def resolution_bits(self, val):
        """
        The number of bits of the scope resolution (used for optimizing histograms)
        """
        self.setMeta(resolution_bits=val)

    def is_data_close(self, other: Waveform, rel_tol: float, abs_tol: float) -> bool:
        """
        Determine whether two waveform data arrays are close in value.

        rel_tol: maximum difference for being considered "close", relative to the magnitude of the input values

        abs_tol: maximum difference for being considered "close", regardless of the magnitude of the input values

        Return True if a is close in value to b, and False otherwise.

        For the values to be considered close, the difference between them
        must be smaller than at least one of the tolerances.
        """
        return math.isclose(self.data, other.data, rel_tol=rel_tol, abs_tol=abs_tol)

    def is_time_close(self, other: Waveform, rel_tol: float, abs_tol: float) -> bool:
        """
        Determine whether two waveform time arrays are close in value.

        rel_tol: maximum difference for being considered "close", relative to the magnitude of the input values

        abs_tol: maximum difference for being considered "close", regardless of the magnitude of the input values

        Return True if a is close in value to b, and False otherwise.

        For the values to be considered close, the difference between them
        must be smaller than at least one of the tolerances.
        """
        return math.isclose(self.time, other.time, rel_tol=rel_tol, abs_tol=abs_tol)

    @compat_inplace
    def apply_window(self, window, div_by_win_mean=True) -> Waveform:
        """
        Applies a window on the current waveform.

        :param window: The type of window to create a periodic signal.
        :type window: string
        :param div_by_win_mean: If True, the signal is divided by window mean value to not distort the fft spectrum.
        :type div_by_win_mean: bool
        :return: The current waveform

        .. note::
            Window types:\n
            boxcar, triang, blackman, hamming, hann, bartlett, flattop, parzen, bohman, blackmanharris,
            nuttall, barthann, kaiser (needs beta), gaussian (needs std), general_gaussian (needs power, width),
            slepian (needs width), chebwin (needs attenuation)\n
            If the window requires no parameters, then window can be a string.\n
            If the window requires parameters, then window must be a tuple with
            the first argument the string name of the window, and the next arguments the needed parameters.

        """
        wf = self.copy()

        win = sps.get_window(window, wf.length)
        wf.data *= win
        if div_by_win_mean:
            wf.data /= np.mean(win)
        return wf

    def apply_inverse_window(self, window, mult_by_win_mean=True) -> Waveform:
        """
        Applies an inverse window on the current waveform.

        :param window: The type of window to create a periodic signal.
        :type window: string
        :param mult_by_win_mean: If True, the signal is multiplied by window
                                 mean value to not distort the original waveform.
        :type mult_by_win_mean: bool

        .. note::
            Window types:\n
            boxcar, triang, blackman, hamming, hann, bartlett, flattop, parzen, bohman, blackmanharris,
            nuttall, barthann, kaiser (needs beta), gaussian (needs std), general_gaussian (needs power, width),
            slepian (needs width), chebwin (needs attenuation)\n
            If the window requires no parameters, then window can be a string.\n
            If the window requires parameters, then window must be a tuple with
            the first argument the string name of the window, and the next arguments the needed parameters.

        """
        wf = self.copy()

        win = sps.get_window(window, wf.length)
        if 0 in win:
            msg = "Cannot apply window which contains zeros."
            raise Exception(msg)
        wf.data /= win
        if mult_by_win_mean:
            wf.data *= np.mean(win)
        return wf

    def hash_t(self):
        return hashlib.sha256(self.time.data).hexdigest()

    def hash_d(self):
        return hashlib.sha256(self.data.data).hexdigest()

    def hash(self):
        return self.hash_t() + self.hash_d()

    def at_time(self, time):
        """
        Returns a single point at a given time value. If no sample for time exists it will be interpolated.
        Same as calling as slice: w[time]

        :param time: A time value of which to return the data point.
        :type time: float
        :return: The (interpolated) data at time
        :rtype: float

        """
        if not is_numeric(time):
            msg = f"Given parameter time (type: {type(time)}) must be of type int or float."
            raise TypeError(msg)
        return self.interpolate(time)

    @compat_inplace
    def cast_float(self) -> Waveform:
        """Casts the waveforms data vector to np.float64"""
        wf = self.copy()
        wf.data = wf.data.astype(np.float64, copy=True)
        return wf

    @compat_inplace
    def cast_int32(self) -> Waveform:
        """Casts the waveforms data vector to np.int32"""
        wf = self.copy()
        wf.data = wf.data.astype(np.int32, copy=True)
        return wf

    @compat_inplace
    def cast_int64(self) -> Waveform:
        """Casts the waveforms data vector to np.int64"""
        wf = self.copy()
        wf.data = wf.data.astype(np.int64, copy=True)
        return wf

    @compat_inplace
    def change_samplerate(self, samplerate) -> Waveform:
        """
        Up- or downsamples the waveform to reach a specific sample rate.
        Up- and downsampling is done with interpolation.

        :param samplerate: The new samplerate of the waveform
        :type samplerate: float
        :return: A waveform Object with the new sample rate
        """
        samples = int(samplerate * np.ptp(self.time)) + 1
        if samples <= 0:
            msg = "Give appropriate Sample Rate"
            raise ValueError(msg)
        if samples < self.length:
            wf = self.down_sample(nr_points=samples)
        elif samples > self.length:
            wf = self.up_sample_interp(nr_points=samples)
        else:
            wf = self.copy()
        return wf

    def contains_nan(self):
        """
        Returns True if the signals data vector contains a NAN value.
        To convert all NAN values to 0 use method convert_nan.

        :return: Indication whether NAN is in Waveform data
        :rtype: bool
        """
        return np.any(np.isnan(self.data))

    @compat_inplace
    def convert_nan(self) -> Waveform:
        """Converts all NAN values of the signals data vector to 0."""
        wf = self.copy()
        wf.data = np.nan_to_num(wf.data)
        return wf

    def convert_to_logical_levels(self, Vcc, Vih, Vil, Gnd=0):
        """
        Sets the waveform y-data values either to 1 if between Vcc and Vih or to 0 if between Vil and Gnd.
        The areas between Vih and Vil will be used as hysteresis.

        :param Vcc: The bus supply voltage. Usually 5.0V or 3.3V
        :param Vih: Defines the minimum voltage level that will be interpreted as a '1' by a digital input.
        :param Vil: Defines the maximum voltage level that will be interpreted as a '0' by a digital input.
        :param Gnd: The ground level. Usually 0 (default).
        :returns: Copy of the waveform converted to a logical signal
        :rtype: Waveform
        """
        if not Vcc > Vih > Vil > Gnd:
            msg = "Following equation is not fulfilled: Vcc > Vih > Vil > Gnd"
            raise ValueError(msg)
        edges = self.Measurements_Utils.find_all_crossings(
            level=(Vih + Vil) / 2,
            hysteresis=Vih - Vil,
            return_indices=True,
            return_point="start",
        )
        if len(edges) > 0:
            bit = 0 if edges[0]["slope"] == "rise" else 1
            wf = self.copy()
            wf[:] = bit

            startframe = 0
            endframe = 0

            for edge in edges:
                endframe = edge["index"]
                wf.data[startframe + 1 : endframe] = int(edge["slope"] == "fall")
                startframe = endframe
            # wf.data[startframe:] = 1 if edges[-1]["slope"] == "rise" else wf.data[startframe+1:]= 0
            # endframe is within the hysteresis area which means that it is already above Vil.
            # So if the slope is rise, from this endframe on, we
            # set data to 1. Otherwise from the next data point on, we set data to zero : wf.data[startframe+1:] = 0
            if edges[-1]["slope"] == "rise":  # FIXED
                wf.data[startframe:] = 1
            else:
                wf.data[startframe + 1 :] = 0

            wf.type = self.TYPES.LOGIC
        else:
            wf = self.copy()
            if max(self.data) < (
                (Vih + Vil) / 2
            ):  # max(data)<level, that means that Vih> max(self.data) => set all data to zero
                wf[:] = 0
            else:
                wf[:] = np.where(wf.data[:] < Vih, 0, 1)
        return wf

    def copy(self):
        """
        Returns a copy (NOT A REFERENCE) from the waveform.

        :return: a copy of the current Waveform Object
        :rtype: Waveform

        """
        w = Waveform(time=self.time[:], data=self.data[:], metaData=self.getMeta())
        w.type = self.type
        return w

    @compat_inplace
    def downsample_mean(self, nr_points: int | None = None, factor: int | None = None) -> Waveform:
        """
        Downsamples the waveform in-place by mean-sampling to the given integer factor.
        If nr_points is given, the factor will be calculated by using an integer division waveform length / nr_points.

        E.g. if the factor is 10, all n...n+10 points will be reduced to their mean value.
        Be aware that this type of downsampling may remove outliers and noise from the signal.
        """

        if nr_points is not None:
            if nr_points > self.length:
                raise ValueError("Cannot down-sample a signal with %d points to %d." % (self.length, nr_points))
            if nr_points <= 0:
                msg = "nr_points cannot be negative"
                raise ValueError(msg)
            factor = self.length // nr_points
        elif nr_points is None and factor is not None and factor < 2:
            msg = "factor cannot be less then 2!"
            raise ValueError(msg)
        elif nr_points is None and factor is None:
            return self
        else:
            factor = int(factor)

        nr_points: int = self.length // factor
        if not nr_points:
            return self

        wf = self.copy()
        wf.time = wf.time[: nr_points * factor : factor]  # type: ignore[operator]
        wf.data = wf.data[: nr_points * factor].reshape(nr_points, factor).mean(axis=1)  # type: ignore[operator,arg-type]
        wf._recalc_attributes()
        return wf

    @compat_inplace
    def downsample_peak(self, nr_points: int | None = None, factor: int | None = None) -> Waveform:
        """
        Downsamples the waveform in-place by peak-sub-sampling to the given integer factor.
        If nr_points is given, the factor will be calculated by using an integer division waveform length / nr_points.

        E.g. if the factor is 10, all n...n+10 points will be reduced to 2 points, their min and max value.
        This type of downsampling is peak-preserving but will change the basic signal shape to a sawtooth
        (min/max values alternating).
        """
        if not self.samplerate:
            return self

        if nr_points is not None:
            if nr_points > self.length:
                raise ValueError("Cannot down-sample a signal with %d points to %d." % (self.length, nr_points))
            if nr_points <= 0:
                msg = "nr_points cannot be negative"
                raise ValueError(msg)
            factor = self.length // nr_points
        elif nr_points is None and factor is not None and factor < 2:
            msg = "factor cannot be less then 2!"
            raise ValueError(msg)
        elif nr_points is None and factor is None:
            return self
        else:
            factor = int(factor)

        factor *= 2  # type: ignore[operator]

        num_bins = self.length // factor
        pts_per_bin = factor
        if not pts_per_bin or not num_bins:
            return self

        # Create temp to hold the reshaped & slightly cropped y
        y_temp = self.data[: num_bins * pts_per_bin].reshape((num_bins, pts_per_bin))
        y_out = np.empty((num_bins, 2))
        # Take the min/max by rows.
        y_out[:, 0] = y_temp.max(axis=1)
        y_out[:, 1] = y_temp.min(axis=1)
        y_out = y_out.ravel()

        # This duplicates the x-value for each min/max y-pair
        x_out = np.empty((num_bins, 2))
        x_out[:] = self.time[: num_bins * pts_per_bin : pts_per_bin, np.newaxis]
        x_out = x_out.ravel()

        return Waveform(y_out, x_out)

    def downsample_ybins(self, bins: int = 200) -> Waveform:
        """
        Takes a waveform object and drops all value changes below a certain threshold,
        similar to a variable bitrate audio codec.

        The goal is to optimize waveforms for plotting given a certain vertical resolution/number of bins.

        The vertical resolution/number of bins and the waveforms peak to peak amplitude is used to calculate the
        value change threshold used to compress the signal.

        The result is a timeseries with non-equidistant spacing of datapoints.

        :param bins: The target vertical plotting resolution as number of bins.
                     E.g. 200 means a resolution of 0.5% of the signal range.
        :return: The downsampled Waveform
        """
        threshold = self.Measurements_Base.peak_to_peak() / bins
        abs_slope = abs(np.diff(self.data, n=1))

        # create a mask for the data points we want to keep
        mask_keep = []
        plotted_last = self.data[0]
        len_data = len(self.data)
        condition2_mask = threshold < abs_slope
        # todo: this code might be accelerated using some JIT compilation
        for idx, amplitude in enumerate(self.data[:-1]):
            condition1 = threshold < abs(amplitude - plotted_last)
            if condition1 or (idx < len_data and condition2_mask[idx]):
                mask_keep.append(True)
                plotted_last = amplitude
            else:
                mask_keep.append(False)

        # need to tighten the deletion mask on the transitions to keep the datapoints just before/after the transition.
        # this is accomplished by widening the keep-mask transitions by one in each direction and inverting the result
        tightened_deletion_mask = np.invert(
            np.append(mask_keep[1:], mask_keep[-1]) | np.insert(mask_keep[:-1], 0, mask_keep[0])
        )
        # always keep the first and last sample of a signal
        tightened_deletion_mask[0] = False
        tightened_deletion_mask[-1] = False
        # drop the obsolete data points using the computed mask
        compressed_data = np.delete(self.data[1:], tightened_deletion_mask)
        compressed_time = np.delete(self.time[1:], tightened_deletion_mask)

        return Waveform(compressed_data, compressed_time)

    @compat_inplace
    def down_sample(self, nr_points=None, factor=None) -> Waveform:
        """
        Downsamples the waveform in-place by sub-sampling with the given integer factor.
        If nr_points is given, the factor will be calculated by using an integer division waveform length / nr_points.

        Be aware that this type of downsampling may remove outliers from the signal and may introduce aliasing.
        """
        if nr_points is not None:
            if nr_points > self.length:
                raise ValueError("Cannot down-sample a signal with %d points to %d." % (self.length, nr_points))
            if nr_points <= 0:
                msg = "nr_points cannot be negative"
                raise ValueError(msg)
            factor = self.length // nr_points
        elif nr_points is None and factor is not None and factor < 2:
            msg = "factor cannot be less then 2!"
            raise ValueError(msg)
        elif nr_points is None and factor is None:
            return self
        else:
            factor = int(factor)

        wf = self.copy()
        wf.data = wf.data[::factor]
        wf.time = wf.time[::factor]

        wf._recalc_attributes()
        return wf

    downsample = down_sample

    @compat_inplace
    def decimate(self, nr_points=None, factor=None, filter_ord=30, filter_type="fir") -> Waveform:
        """
        Decimates the current signal and uses an AA-filter to avoid aliasing.
        By default a 30 point FIR filter with hamming window is used if FilterType is fir.
        An order 8 Chebyshev type I filter is used, if FilterType is iir.

        :param nr_points: The number of points to sample. Has to be lower than the current waveform length.
        :type nr_points: int
        :param factor: The decimation factor. Must be a positive integer.
        :type factor: int
        :param filter_ord: The order of the AAF filter
        :type filter_ord: int
        :param filter_type: The type of the AAF filter. fir or iir
        :type filter_type: choice
        :return: The decimated Waveform
        :raises ValueError: if nr_points is greater than waveform length.

        .. Note::
           If the original waveform length divided by nr_points is an integer the algorithm will
           only AAF and down_sample the waveform by this factor.\n
        """
        if nr_points is not None:
            if nr_points > self.length:
                raise ValueError("Cannot down-sample a signal with %d points to %d." % (self.length, nr_points))
            if nr_points <= 0:
                msg = "nr_points cannot be negative"
                raise ValueError(msg)
            factor = self.length // nr_points
        elif nr_points is None and factor is not None and factor < 2:
            msg = "factor cannot be less then 2!"
            raise ValueError(msg)
        elif nr_points is None and factor is None:
            return self
        else:
            factor = int(factor)
        nr_points = self.length // factor

        def lcm(x, y):
            return int(x * y / gcd(x, y))

        _lcm = int(lcm(int(factor), filter_ord))
        wf = self.copy()
        wf.data = np.pad(wf.data, (_lcm, 0), "mean")
        wf.data = sps.decimate(x=wf.data, q=int(factor), n=filter_ord, ftype=filter_type)[int(_lcm / int(factor)) :]
        wf.time = wf.time[:: wf.length // nr_points]
        wf._recalc_attributes()
        return wf

    @compat_inplace
    def decimate2(
        self,
        nr_points=None,
        factor=None,
        aaf_transition_width=500.0,
        aaf_attpass=0.01,
        aaf_attstop=40,
        aaf_type="butter",
    ) -> Waveform:
        """
        Like decimate but the filter characteristics can be specified.

        :param nr_points: The number of points to sample. Has to be lower than the current waveform length.
                          If the original waveform length divided by nr_points is an integer the algorithm will
                          only AAF and down_sample the waveform by this factor.
        :type nr_points: int
        :param factor: The decimation factor. Must be a positive integer.
        :type factor: float
        :param aaf_transition_width: The transition width of the AAF filter
        :type aaf_transition_width: float
        :param aaf_attpass: The pass-band attenuation of the AAF filter
        :type aaf_attpass: float
        :param aaf_attstop: The stop-band attenuation of the AAF filter
        :type aaf_attstop: float
        :param aaf_type: The filter type of the AAF filter
        :type aaf_type: choice(butter,cheby1,cheby2,ellip,bessel)
        :return: The current Waveform Object
        """
        if nr_points is not None:
            if nr_points > self.length:
                raise ValueError("Cannot down-sample a signal with %d points to %d." % (self.length, nr_points))
            if nr_points <= 0:
                msg = "nr_points cannot be negative"
                raise ValueError(msg)
            factor = self.length // nr_points
        elif nr_points is None and factor is not None and factor < 2:
            msg = "factor cannot be less then 2!"
            raise ValueError(msg)
        elif nr_points is None and factor is None:
            return self
        else:
            factor = int(factor)
        nr_points = self.length // factor

        if self.contains_nan():
            msg = "Signal contains NaN values."
            raise Exception(msg)

        new_sr = self.samplerate / 2.0 / factor

        wf = self.copy()
        for _i in range(10):
            try:
                wf = self.Filter.IIR_LowPass(
                    f_pass=new_sr - (aaf_transition_width / 2.0),
                    f_stop=new_sr + (aaf_transition_width / 2.0),
                    attn_pass=aaf_attpass,
                    attn_stop=aaf_attstop,
                    ftype=aaf_type,
                    mode="normal",
                )
            except ValueError:
                msg = (
                    "Could not apply anti-aliasing filter because the requirements cannot be observed."
                    "Try using a bigger transition with or small bigger maximal pass/stop-band attenuations."
                )
                raise ValueError(msg) from None
            aaf_transition_width *= 1.5
            if not wf.contains_nan():
                break
            print(
                "Waveform.Filter.decimate: Warning. Did not manage to filter with "
                f"transition width of {aaf_transition_width:.2e} Hz with the specified attenuations."
            )

        return wf.down_sample(nr_points, factor)

    @compat_inplace
    def extend(self, waveform) -> Waveform:
        """
        Appends another waveform to the end. The time vector of the appended waveform will be adjusted that it starts
        where the current waveform time ends.

        :param waveform: The waveform instance to append.
        :type waveform: Waveform
        :return: The extended Waveform Object

        Example:

            >>> w = Waveform(time=[1,2,3], data=[5,6,7])
            >>> w2 = Waveform(time=[1,2,3], data=[10,9,8])
            >>> w3 = w.extend(w2)
            >>> w3.time
            array([1, 2, 3, 4, 5, 6])
            >>> w3.data
            array([ 5, 6, 7, 10, 9, 8])

        """
        other = waveform
        if not isinstance(other, Waveform):
            msg = "Can only append a 'Waveform' type!"
            raise TypeError(msg)

        wf = self.copy()
        if other.time[0] == 0:
            wf.time = np.append(wf.time, other.time + wf.time[-1] + 1.0 / other.samplerate)
        else:
            wf.time = np.append(wf.time, other.time + wf.time[-1])

        wf.data = np.append(wf.data, other.data)
        wf._recalc_attributes()
        return wf

    def fft(self, window=None):
        """
        Returns an FFT of the current signal. The fft is shown from frequency 0 to half of samplerate.

        :param window: The type of window to apply before performing fft.
        :type window: choice
        :return: A waveform Object with the fft transform of the current waveform
        :rtype: Waveform

        .. note::
            Window types
            boxcar, triang, blackman, hamming, hann, bartlett, flattop, parzen, bohman, blackmanharris,
            nuttall, barthann, kaiser (needs beta), gaussian (needs std), general_gaussian (needs power, width),
            slepian (needs width), chebwin (needs attenuation)
            If the window requires no parameters, then window can be a string.
            If the window requires parameters, then window must be a tuple with
            the first argument the string name of the window, and the next arguments the needed parameters.

        """

        w = self.copy()  # .up_sample_interp(2**next_multiple_of_2)
        sr = w.samplerate

        if window:
            win = sps.get_window(window, w.length)
            w.data = w.data * win / win.mean()
        amps = np.fft.fft(w.data)[: w.length // 2] * 2.0 / w.length
        amps[0] /= 2.0  # Restore DC amp
        freqs = np.fft.fftfreq(w.length)[: w.length // 2] * sr

        w = Waveform(
            time=freqs,
            data=np.abs(amps),
            metaData={"xtitle": "Frequency", "xunit": "Hz", "ytitle": "Amplitude"},
        )
        w.type = self.TYPES.FFT
        w._samplerate = sr
        return w

    @staticmethod
    def garbage_collect():
        """
        Calls the garbage collector
        """
        for _i in range(5):
            if not gc.collect():
                break

    def histogram(self, bins=None):
        """
        Returns a waveform representing a histogram with 'bins' bins of the current waveform.

        :param bins: Number of containers of the histogram/ granularity. A higher number of bins result in a more
                     precise resolution but the peaks in the histogram will be lower.
                     If the source of the waveform is a scope with a specific ADC resolution, use 2^<number of bits>
                     as bins.
                     If set to None, it will be set to 2^self.resolution_bits
        :type bins: int
        :return: Waveform object representing the data values in "time" and the number of occurences in "data".
        :rtype: Waveform
        """
        if bins is None:
            bins = 2**self.resolution_bits
        hist, edges = np.histogram(self.data, bins)
        w = Waveform(time=edges[:-1], data=hist, metaData={"xtitle": "Bins", "ytitle": "Count"})
        w.type = self.TYPES.HISTOGRAM
        return w

    def ifft(self, window=None):
        """
        Returns the original waveform of an FFT signal.

        :param window: The type of window that was uses to create the fft signal.\n
            Window types:\n
            boxcar, triang, blackman, hamming, hann, bartlett, flattop, parzen, bohman, blackmanharris,
            nuttall, barthann, kaiser (needs beta), gaussian (needs std), general_gaussian (needs power, width),
            slepian (needs width), chebwin (needs attenuation)\n
            If the window requires no parameters, then window can be a string.\n
            If the window requires parameters, then window must be a tuple with
            the first argument the string name of the window, and the next arguments the needed parameters.

        :type window: choice(boxcar,triang,blackman,hamming,hann,
                      bartlett,flattop,parzen,bohman,blackmanharris,nuttall,barthann)
        :return: A new Waveform Object
        :rtype: Waveform

        """
        if self.type != self.TYPES.FFT:
            msg = "Can only perform ifft on an fft signal."
            raise TypeError(msg)
        w = self.copy()

        amps = w.data * w.length * 2  # Denormalize with len(fft) * 2
        inv = np.real(np.fft.ifft(amps, w.length * 2))
        if window:
            win = sps.get_window(window, w.length * 2)
            if 0 in win:
                msg = "Cannot apply window which contains zeros."
                raise Exception(msg)
            inv = inv / win * win.mean()

        w.time = np.linspace(0, (w.length * 2.0) / w.samplerate, len(inv))
        w.data = inv

        w._recalc_attributes()
        w.type = self.TYPES.WAVEFORM
        return w

    def index_to_time(self, index):
        """
        Returns the waveform time to a corresponding index.
        Same as: "Waveform[int(index)]"

        :param index: The index of the timevector to convert to time
        :type index: int|list[int]|(int)|np.ndarray
        """
        if type(index) in [list, np.ndarray, tuple]:
            return (self.time[int(i)] for i in index)
        return self.time[int(index)]

    @compat_inplace
    def insert_start(self, waveform) -> Waveform:
        """
        Inserts another waveform at the beginning of the current waveform.
        The time vector of the appended waveform will be adjusted that it
        starts where the current waveform time ends.

        :param waveform: The waveform instance to append.
        :type waveform: Waveform
        :return: The extended waveform Object

        Example:

            >>> w = Waveform(time=[1,2,3], data=[5,6,7])
            >>> w2 = Waveform(time=[1,2,3], data=[10,9,8])
            >>> w3 = w.insert_start(w2)
            >>> w3.time
            array([1, 2, 3, 4, 5, 6])
            >>> w3.data
            array([10, 9, 8, 5, 6, 7])

        """
        other = waveform
        if not isinstance(other, Waveform):
            msg = "Can only insert a 'Waveform' type!"
            raise TypeError(msg)

        wf = self.copy()
        if wf.time[0] == 0:
            wf.time = np.append(waveform.time, wf.time + waveform.time[-1] + 1 / wf.samplerate)
        else:
            wf.time = np.append(waveform.time, wf.time + waveform.time[-1])
        wf.data = np.append(waveform.data, wf.data)
        wf._recalc_attributes()
        return wf

    def interpolate(self, time):
        """
        Returns a point at a given time value or array. If no samples for t is given they will be interpolated.

        :param time: A scalar or list/array of times where to interpolate y
        :type time: float|list|np.ndarray|Waveform
        :return: A scalar or array of interpolated y
        :rtype: Waveform|float

        """
        if is_numeric(time):
            return np.interp(x=time, xp=self.time, fp=self.data)
        if type(time) in (np.ndarray, list):
            return Waveform(
                time=time,
                data=np.interp(x=time, xp=self.time, fp=self.data),
                metaData=self.getMeta(),
            )
        if isinstance(time, Waveform):
            return Waveform(
                time=time.time,
                data=np.interp(x=time.time, xp=self.time, fp=self.data),
                metaData=self.getMeta(),
            )
        msg = f"Given parameter time (type: {type(time)}) must be of type int, float, list or numpy.ndarray."
        raise TypeError(msg)

    @staticmethod
    def load_from_file(**kwargs):
        r"""
        Reloads a waveform from a file and returns a waveform instance.

        If filepath is a path to an npz file created by Waveform.save_to_file("\*.npz")
        this method will return a single Waveform instance.

        If filepath is a path to an npz file created by a PyVerify test,
        this method will return a list of Waveform instances.

        :keyword filepath: Path to the file to load the waveform
        :rtype: Waveform
        """
        filepath = kwargs["filepath"]
        if os.path.basename(filepath).endswith(".npz"):
            return Waveform.load_from_npz(filepath)
        if os.path.basename(filepath).endswith(".csv"):
            return Waveform.load_from_csv(
                filepath,
                kwargs.get("delimiter", ";"),
                kwargs.get("common_time_col", True),
            )
        msg = "File to reload has to ba a npz or csv"
        raise TypeError(msg)

    @staticmethod
    def load_from_npz(filepath):
        r"""
        If filepath is a path to an npz file created by Waveform.save_to_file("\*.npz")
        this method will return a single Waveform instance.

        If filepath is a path to an npz file created by a PyVerify test,
        this method will return a list of Waveform instances.

        :param filepath: Path to npz file
        :rtype: Waveform|list[Waveform]
        """
        if not os.path.exists(filepath):
            msg = f"npz file '{filepath}' does not exist!"
            raise FileNotFoundError(msg)
        f = np.load(filepath, allow_pickle=True)
        if all(x in f.files for x in ["time", "data"]):
            w = Waveform(time=f["time"], data=f["data"])
            if "metaData" in f:
                meta = f["metaData"]
                if meta.ndim == 0:
                    meta.resize(1)
                w.setMeta(**meta[0])
            return w
        if len(f.files) > 2:
            names = {x.rsplit("_", 1)[0] for x in f.files}
            wf = []
            for name in names:
                w = Waveform(data=f[name + "_data"], time=f[name + "_time"])
                if (name + "metaData") in f:
                    meta = f[name + "metaData"]
                    if meta.ndim == 0:
                        meta.resize(1)
                    w.setMeta(**meta)
                else:
                    w.setMeta(name=name)
                wf.append(w)
            return wf
        return None

    @staticmethod
    def load_from_csv(filepath, delimiter=";", common_time_col=True):
        """
        Loads one or more waveforms froma csv file. THe function expects the waveforms to appear in columns.

        If there is only 1 column it will be used as data vector for a single waveform.

        If there are 2 columns col 1 will be used as time and col 2 as data vector for a single waveform.

        There are 2 formats for the column order:

        - time, data, data, data, ... common_time_col=True
        - time, data, time, data, ... common_time_col=False

        :param filepath: The path of the csv file
        :param delimiter: The column delimiter. Default: ";" for csv files
        :param common_time_col: If true, the first column is used as time vector and the rest as data vectors.
                                If False, time and data columns are alternating.
        :rtype: list[Waveform]
        """
        if not os.path.exists(filepath):
            msg = f"hdf5 file '{filepath}' does not exist!"
            raise FileNotFoundError(msg)

        def slice_nan(array):
            first_nan = np.where(np.isnan(array))[0]
            if len(first_nan):
                first_nan = first_nan[0]
                return array[:first_nan]

            return array

        data = np.genfromtxt(filepath, delimiter=delimiter, unpack=True)
        if len(data) == 1:  # One column -> use as data vector
            return [Waveform(data=slice_nan(data[0]))]
        if len(data) == 2:
            return [Waveform(data=slice_nan(data[1]), time=slice_nan(data[0]))]
        if len(data) > 2:
            if common_time_col:
                t = slice_nan(data[0])
                return [Waveform(slice_nan(data[x]), t) for x in range(1, len(data))]
            return [Waveform(slice_nan(data[x + 1]), slice_nan(data[x])) for x in range(0, len(data), 2)]
        return None

    @compat_inplace
    def mirror(self) -> Waveform:
        """Returns a mirrored waveform."""
        wf = self.copy()
        wf.data = wf.data[::-1]
        return wf

    @compat_inplace
    def modulate(self, ModulationWaveform) -> Waveform:
        """
        Modulates the waveform with the waveform passed as argument. The ModulationWaveform waveform will be scaled to
        the same time as the waveform to modulate and multiplied with it.

        :param ModulationWaveform: The waveform to use as modulating waveform
        :type ModulationWaveform: Waveform
        :return: The modulated Waveform Object
        """
        wf = ModulationWaveform.time_scale(self.time[0], self.time[-1], True)
        if len(wf) < self.length:
            wf = wf.up_sample_interp(nr_points=self.length)
        elif len(wf) > self.length:
            wf = wf.down_sample(nr_points=self.length)
        return wf.data * self.data

    def plot(self, config=None, notime=False, **kwargs):
        """
        Plots the waveform.

        :param config:

            The following format string characters are accepted by argument 'config' to control
            the line style or marker:

            ================    ===============================
            character           description
            ================    ===============================
            ``'-'``             solid line style
            ``'--'``            dashed line style
            ``'-.'``            dash-dot line style
            ``':'``             dotted line style
            ``'.'``             point marker
            ``','``             pixel marker
            ``'o'``             circle marker
            ``'v'``             triangle_down marker
            ``'^'``             triangle_up marker
            ``'<'``             triangle_left marker
            ``'>'``             triangle_right marker
            ``'1'``             tri_down marker
            ``'2'``             tri_up marker
            ``'3'``             tri_left marker
            ``'4'``             tri_right marker
            ``'s'``             square marker
            ``'p'``             pentagon marker
            ``'*'``             star marker
            ``'h'``             hexagon1 marker
            ``'H'``             hexagon2 marker
            ``'+'``             plus marker
            ``'x'``             x marker
            ``'D'``             diamond marker
            ``'d'``             thin_diamond marker
            ``'|'``             vline marker
            ``'_'``             hline marker
            ================    ===============================


            The following color abbreviations are supported:

            ==========  ========
            character   color
            ==========  ========
            'b'         blue
            'g'         green
            'r'         red
            'c'         cyan
            'm'         magenta
            'y'         yellow
            'k'         black
            'w'         white
            ==========  ========

            In addition, you can specify colors in many weird and
            wonderful ways, including full names (``'green'``), hex
            strings (``'#008000'``), RGB or RGBA tuples (``(0,1,0,1)``) or
            grayscale intensities as a string (``'0.8'``).  Of these, the
            string specifications can be used in place of a ``fmt`` group,
            but the tuple forms can be used only as ``kwargs``.

            Line styles and colors are combined in a single format string, as in
            ``'bo'`` for blue circles.

        :type config: str
        :param notime: If true the waveform is plotted over its sample indices, no over its time.
        :type notime: bool|int
        :param kwargs: Keyword arguments for the linestyle of the plot.
                       Refer to http://matplotlib.org/1.4.3/api/lines_api.html
        """
        try:
            from matplotlib.pyplot import grid, plot, show, xlabel, ylabel
        except ModuleNotFoundError:
            msg = "matplotlib needs to be installed (pip install matplotlib) for this feature to work!"
            raise ModuleNotFoundError(msg) from None

        if self.type in [self.TYPES.WAVEFORM, self.TYPES.LOGIC]:
            if not notime:
                plot(self.time, self.data, config if config else "b-", **kwargs)
            else:
                plot(self.data, config if config else "b-", **kwargs)
        elif self.type == self.TYPES.FFT:
            if not notime:
                plot(self.time, abs(self.data), config if config else "ro", **kwargs)
            else:
                plot(abs(self.data), config if config else "ro", **kwargs)
        elif self.type == self.TYPES.HISTOGRAM:
            if not notime:
                plot(self.time, self.data, config if config else "ro", **kwargs)
            else:
                plot(self.data, config if config else "ro", **kwargs)

        xt = self.getMeta("xtitle", "")
        xt = xt if xt != "" else "time"
        xu = self.getMeta("xunit", "")
        xu = xu if xu != "" else "s"
        yt = self.getMeta("ytitle", "")
        yt = yt if yt != "" else "data"
        yu = self.getMeta("yunit", "")
        yu = yu if yu != "" else ""
        xlabel(f"{xt} [{xu}]")
        ylabel(f"{yt} [{yu}]")
        grid(True)
        show()

    def plot_reviz(
        self,
        signal_path: str | None = None,
        plot_name: str | int = 0,
        clear_plot: bool = False,
        autorange: bool = False,
        signal_opt: dict | None = None,
        plot_opt: dict | None = None,
        layout_opt: tuple[int | None, int | None, int | None, int | None, bool | None] | None = None,
        reviz_rpi_port: int | None = None,
        reviz_rpi_client=None,
    ):
        """
        Plots the waveform in ReViz (if installed). If ReViz is not open, it will be started.

        See a rendered version of this docstring here:
        https://goto.infineon.com/wavewatson/reference/wavewatson.html#wavewatson.waveform.Waveform.plot_reviz

        Example::

            wf = Waveform.Generation.Sine(100, 1, 1, 0, 0)
            wf.plot_reviz(
                signal_path="groupA.groupB.mySignal",
                plot_name=0,
                clear_plot=False,
                autorange=True,
                signal_opt=dict(yaxis="Voltage", yaxis_unit="V"),
                plot_opt=dict(title="My Title"),
                layout_opt=(3, 1, 33, 100, True)
            )
            wf.plot_reviz()  # Works also with defaults

        :param signal_path: A dot-seperated name of the signal. E.g. `a.b.c` will create the signal `c` in the group
                            nodes `a.b`. If not given an autogenerated name will be used.
        :param plot_name: Either a string representing the current plot name (e.g. "Plot 0_0"), an integer representing
                          the index of the plot.
                          A negative integer will ...
        :param clear_plot: If True, the selected plot will be cleared before plotting.
        :param autorange: If True, enable autorange for the plot
        :param signal_opt: Signal options.
                           Refer to `reviz.rpi.client.RevizRPIClient.update_signal_params
                           <https://goto.infineon.com/reviz/interfacing.html#reviz.rpi.client.RevizRPIClient.
                           update_signal_params>`_.
        :param plot_opt: Plot options.
                         Refer to `reviz.rpi.client.RevizRPIClient.update_plot
                         <https://goto.infineon.com/reviz/interfacing.html#reviz.rpi.client.RevizRPIClient.
                         update_plot>`_.
        :param layout_opt: Layout options.
                           Refer to `reviz.rpi.client.RevizRPIClient.update_settings
                           <https://goto.infineon.com/reviz/interfacing.html#reviz.rpi.client.RevizRPIClient.
                           update_settings>`_.
        :param reviz_rpi_port: If None, the signal will be plotted in the first found open instance of ReViz.
                               If no ReViz is running, an instance will be started.

                               If given it must be an integer with the port number of a running ReViz instance.
                               The port is displayed in ReViz title, e.g. [RPI 61000].
                               If no ReViz with the specified port number is found, an error is raised.
        :param reviz_rpi_client: If given an already connected instance of RevizRPIClient, the connection is reused
                                 to avoid opening/destroying an RevizRPIClient each time a signal shall be plotted.
        :type reviz_rpi_client: RevizRPIClient
        """
        try:
            from reviz.rpi.client import RevizRPIClient
        except ImportError:
            msg = (
                "ReViz (>1.0.2) is not installed. Please refer the documentation "
                "at http://goto.infineon.com/reviz/installation.html "
                "for information about the installation process."
            )
            raise ImportError(msg) from None
        signal_path = signal_path or self._name
        signal_path = signal_path.split(".")

        if isinstance(reviz_rpi_client, RevizRPIClient):
            c = reviz_rpi_client
        else:
            if not isinstance(reviz_rpi_port, int):
                reviz_rpi_port = RevizRPIClient.start_reviz_if_not_running(30)[0]
            c = RevizRPIClient(port=reviz_rpi_port, receive_timeout=1000)
            c.connect()

        try:
            signal_opt = signal_opt or {}
            signal_opt["signal_path"] = signal_path
            signal_opt["waveform"] = self
            c.update_tree(**signal_opt)

            c.plot_signal(signal_path=signal_path, plot_name=plot_name, clear_plot=clear_plot)

            if isinstance(layout_opt, tuple):
                if len(layout_opt) != 5:
                    msg = "layout_options must be of type Tuple[Opt[int], Opt[int], Opt[int], Opt[int], Opt[bool]]"
                    raise ValueError(msg)
                c.update_settings(*layout_opt)

            plot_opt = plot_opt or {}
            if plot_opt:
                plot_opt["plot_name"] = plot_name
                c.update_plot(**plot_opt)

            if autorange:
                c.autorange()
        finally:
            if not isinstance(reviz_rpi_client, RevizRPIClient):
                c.disconnect()  # Only disconnect is connected in this method

    @compat_inplace
    def remove_time_offset(self) -> Waveform:
        """Shift the time vector so that it starts with 0."""
        wf = self.copy()
        wf.time -= wf.time[0]
        return wf

    @compat_inplace
    def repeat(self, repeats) -> Waveform:
        """
        Appends the waveform to itself (repeats-1)-times.

        :param repeats: Number of repeats.
        :type repeats: int
        :return: The extended Waveform Object

        Example:
            >>> w = Waveform(time=[1,2,3], data=[5,6,7])
            >>> w.data
            array([5, 6, 7])
            >>> w2 = w.repeat(3)
            >>> w2.data
            array([5, 6, 7, 5, 6, 7, 5, 6, 7])

        """
        to_be_repeated = self.copy()
        wf = self.copy()
        for _i in range(repeats - 1):
            wf = wf.extend(to_be_repeated)
        wf._recalc_attributes()
        del to_be_repeated
        gc.collect()
        return wf

    def repeat_samples(self, count: int):
        """
        Repeats each data sample of the waveform count times.

        :param count: Number of times each sample is repeated.
        """
        if count <= 1:
            msg = "count must be greater than 1"
            raise ValueError(msg)
        if self.samplerate == 0:
            msg = "Signal must have a constant sample rate to repeat samples!"
            raise ValueError(msg)
        new_data = np.repeat(self.data, int(count))
        new_time = [self.time[0], self.time[-1]]
        return Waveform(time=new_time, data=new_data)

    def save_to_file(self, filepath, compress=True):
        """
        Save the waveform to a file.

        :param filepath: Path to the file to store the waveform.
        :type filepath: str
        :param compress: If True, the files is compressed.
        :type compress: bool
        """
        filename = filepath
        if not os.path.basename(filepath).endswith(".npz"):
            filename = filepath.rsplit(".")[0] + ".npz"
        if compress:
            if self.samplerate > 0:
                np.savez_compressed(
                    filename,
                    time=np.array([self.time[0], self.time[-1]]),
                    data=self.data,
                    metaData=self.getMeta(),
                )
            else:
                np.savez_compressed(filename, time=self.time, data=self.data, metaData=self.getMeta())
        else:
            np.savez(filename, time=self.time, data=self.data, metaData=self.getMeta())

    @compat_inplace
    def scale_to_amplitude(self, amplitude) -> Waveform:
        """
        Rescales the data vector that the amplitudes is between +- amplitude.

        :param amplitude: The amplitude (+-) of the resulting waveform
        :type amplitude: float
        """
        wf = self.copy()
        wf.scale_to_minmax(-amplitude, +amplitude)
        return wf

    @compat_inplace
    def scale_to_minmax(self, minimum, maximum) -> Waveform:
        """
        Rescales the data vector that the amplitudes is between min and max.

        :param maximum: The maximum of the resulting waveform
        :type maximum: float
        :param minimum: The minimum of the resulting waveform
        :type minimum: float
        """
        if minimum > maximum:
            minimum, maximum = maximum, minimum
        wf = self.copy()
        wf.data -= min(wf.data)
        if max(wf.data):
            wf.data *= abs(maximum - minimum) / max(wf.data)

        wf.data += minimum
        return wf

    @compat_inplace
    def scale_to_absmax(self, maximum) -> Waveform:
        """
        Rescales the data vector to a maximum. Same as scaled = w / abs(max(w))

        :param maximum: The maximum of the resulting waveform
        :type maximum: float
        """
        wf = self.copy()
        try:
            factor = maximum / float(max(abs(self.data)))
            self.data *= factor
        except ZeroDivisionError:
            self.data[:] = maximum
        return wf

    @compat_inplace
    def set_time(self, new_timevector, to_interpolate=False) -> Waveform:
        """
        Applies a new time vector on the waveform.

        :param new_timevector: The new time vector to be applied on the waveform
        :param to_interpolate: When true, an error is raised if time and data don't
                               have the same length, else data will be interpolated
        :type new_timevector: list[float] | np.ndarray
        :type to_interpolate: bool
        """
        wf = self.copy()
        if len(new_timevector) != len(wf.data):
            if to_interpolate:
                wf.data = np.interp(new_timevector, wf.time, wf.data)
            else:
                msg = "time and data must have the same length!"
                raise ValueError(msg)
        wf.time = np.array(new_timevector)
        wf._recalc_attributes()
        return wf

    def slice_by_indices(self, start_index, stop_index, step=None, endpoint=False):
        """
        Returns a slice of the signal starting with start_index and stopping with stop_index.

        :param start_index: Start of the slice.
        :type start_index: int
        :param stop_index: Stop of the slice.
        :type stop_index: int
        :param step: None: Ignored, Int > 1: Take each n-th sample.
        :type step: int|NoneType
        :return: Waveform sliced by indices.
        :rtype: Waveform
        """

        def _int(x):
            return int(x) if x is not None else None

        stop_index = _int(stop_index)
        if stop_index is not None and endpoint:
            stop_index += 1
        return self.__getitem__(slice(_int(start_index), stop_index, _int(step)))

    def slice_by_time(self, start_time, stop_time, step=None, endpoint=False):
        """
        Returns a slice of the signal starting with start_time and stopping with stop_time.

        :param start_time: Start of the slice.
        :type start_time: float
        :param stop_time: Stop of the slice.
        :type stop_time: float
        :param step: None: Ignored, Int > 1: Take each n-th sample.
        :type step: int|NoneType
        :return: Waveform sliced by time.
        :rtype: Waveform
        """

        def _float(x):
            return float(x) if x is not None else None

        def _int(x):
            return int(x) if x is not None else None

        return self.__getitem__(slice(_float(start_time), _float(stop_time), _int(step)), endpoint)

    def split_by_indices(self, indices):
        """
        Splits the waveform at each index in given list of indices and returns a list of new waveform objects.

        :param indices: A list of indices where to split the waveform
        :type indices: list[int]

        Example:
            >>> a = np.array([1,2,3,4,5,6,7,8,9])
            >>> np.split(a, [2,3])
            [array([1, 2]), array([3]), array([4, 5, 6, 7, 8, 9])]
        """
        y_split = np.split(self.data, list(indices))
        x_split = np.split(self.time, list(indices))
        new_waveforms = []
        for i in range(len(x_split)):
            new_waveforms.append(Waveform(time=x_split[i], data=y_split[i], metaData=self.getMeta()))
        del x_split, y_split
        gc.collect()
        return new_waveforms

    def split_by_times(self, times):
        """
        Splits the waveform at each time in given list of times and returns a list of new waveform objects.

        :param times: A list of times where to split the waveform
        :type times: list[float]
        :return: List of split waveform objects
        :rtype: list[Waveform]
        """
        indices = []
        for t in times:
            indices.append(np.where(self.time >= t)[0][0])
        y_split = np.split(self.data, list(indices))
        x_split = np.split(self.time, list(indices))
        new_waveforms = []
        for i in range(len(x_split)):
            new_waveforms.append(Waveform(time=x_split[i], data=y_split[i], metaData=self.getMeta()))
        del x_split, y_split
        gc.collect()
        return new_waveforms

    def shifted(self, timeoffset=0.0, dataoffset=0.0) -> Waveform:
        """
        Shifts the waveform in time and data direction.

        :param timeoffset: The offset to be added to the time vector
        :param dataoffset: The offset to be added to the data vector
        :returns: A shifted copy of the waveform
        """
        wf = self.copy()
        wf.data += dataoffset
        wf.time += timeoffset
        return wf

    def scaled(self, timescale=1.0, datascale=1.0) -> Waveform:
        """
        Scales the waveform in time and data direction.

        :param timescale: The scale to be applied to the time vector
        :param datascale: The scale to be applied to the data vector
        :returns: A scaled copy of the waveform
        """
        wf = self.copy()
        wf.data *= datascale
        wf.time *= timescale
        return wf

    def logX(self) -> Waveform:
        """Returns a copy of the waveform with the time vector formatted with log10"""
        wf = self.copy()
        wf.time = np.log10(wf.time)
        return wf

    def logY(self) -> Waveform:
        """Returns a copy of the waveform with the data vector formatted with log10"""
        wf = self.copy()
        wf.data = np.log10(wf.data)
        return wf

    def expX(self) -> Waveform:
        """Returns a copy of the waveform with the time vector formatted with exp10"""
        wf = self.copy()
        wf.time = 10**wf.time
        return wf

    def expY(self) -> Waveform:
        """Returns a copy of the waveform with the data vector formatted with exp10."""
        wf = self.copy()
        wf.data = 10**wf.data
        return wf

    @compat_inplace
    def skew(self, offset, padding_mode="edge") -> Waveform:
        """
        Skew the waveform to compensate for incorrect deskewing in the scope.
        This leaves the time-base as it is and just moves the data, while padding it according to the given mode.

        :param offset: If offset is negative, the data will be shifted to the left, otherwise to the right.
                       If offset is an int, it will be interpreted as the number of samples to shift.
                       If offset is a float, it will be interpreted as time.
                       This will be quantized so that the timebase does not get modified
        :param padding_mode: See documentation of mode-parameter for numpy.pad
        """
        if is_float(offset):
            offset = int(round(offset / ((self.time[-1] - self.time[0]) / len(self.time))))
        length = len(self.data)
        pad_l = min(length, max(0, offset))
        pad_r = min(length, max(0, -offset))
        wf = self.copy()
        wf.data = np.pad(wf.data, [pad_l, pad_r], mode=padding_mode)[pad_r : -pad_l if pad_l > 0 else None]
        return wf

    def time_shift(self, timeoffset) -> Waveform:
        """
        Shifts the current signal in time.

        :param timeoffset: The time to shift the signal. Either positive or negative
        :type timeoffset: float
        """
        if not is_numeric(timeoffset):
            msg = "Parameter 'timeoffset' has to be numeric (int, float)."
            raise TypeError(msg)
        # if self.time[0] + timeoffset < 0:
        #    raise ValueError("The time shift cannot be performed if resulting starting time (%.3f s) is negative." % (
        #        self.time[0] + timeoffset))
        return self.shifted(timeoffset=timeoffset)

    @compat_inplace
    def time_scale(self, starttime, stoptime, endpoint=False) -> Waveform:
        """
        Rescales the time vector of the waveform to another start and stop value. The waveform length is unchanged.

        :param starttime: The start time of the time-scaled vector
        :type starttime: float
        :param stoptime: The stop time of the time-scaled vector
        :type stoptime: float
        :param endpoint: If True, stop is the last sample. Otherwise, it is not included
        :type endpoint: bool
        """
        wf = self.copy()
        wf.time = np.linspace(start=starttime, stop=stoptime, num=wf.length, endpoint=endpoint)
        return wf

    def time_to_index(self, time):
        """
        Returns the index where the waveform time value is greater or equal to argument "time".

        :param time: The time to convert to an index of the timevector. May be a single float or list of floats
        :type time: float|list[float]|np.ndarray
        """
        if type(time) in [list, np.ndarray]:
            return (np.where(self.time >= float(t))[0][0] for t in list(time))

        return np.where(self.time >= float(time))[0][0]

    @compat_inplace
    def up_sample_interp(self, nr_points=None, factor=None, kind="linear", **kwargs) -> Waveform:
        """
        Upsamples the current signal by interpolating linearly between the points.

        See SciPy documentation for further reference:
        https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html#scipy.interpolate.interp1d

        :param nr_points: The number of points to interpolate. Has to be greater than the current waveform length.
        :type nr_points: int
        :param factor: The upsampling factor. Must be a positive integer.
        :type factor: int
        :param kind: str or int, optional.
                     Specifies the kind of interpolation as a string or as an integer
                     specifying the order of the spline interpolator to use.
                     The string has to be one of 'linear', 'nearest', 'nearest-up', 'zero',
                     'slinear', 'quadratic', 'cubic', 'previous', or 'next'. 'zero',
                     'slinear', 'quadratic' and 'cubic' refer to a spline interpolation of
                     zeroth, first, second or third order; 'previous' and 'next' simply
                     return the previous or next value of the point; 'nearest-up' and
                     'nearest' differ when interpolating half-integers (e.g. 0.5, 1.5)
                     in that 'nearest-up' rounds up and 'nearest' rounds down. Default
                     is 'linear'.
        :param kwargs: Additional keyword arguments passed to scipy.interpolate.iterp1d
        """
        if nr_points is None and factor is not None:
            nr_points = int(self.length * factor)
        elif nr_points is None and factor is None or nr_points == self.length:
            return self

        if nr_points < self.length:
            raise ValueError("Cannot up-sample a signal with %d points to %d." % (self.length, nr_points))

        newtime = np.linspace(self.time[0], self.time[-1], nr_points)
        kwargs.pop("x", None)
        kwargs.pop("y", None)
        kwargs.pop("kind", None)
        wf = self.copy()
        wf.data = interp1d(wf.time, wf.data, kind=kind, **kwargs)(newtime)
        wf.time = newtime

        wf._recalc_attributes()
        return wf

    @compat_inplace
    def up_sample_fft(self, nr_points=None, factor=None) -> Waveform:
        """
        Upsamples the current signal with higher sampling rate by doing fft, extending fft and performing inverse fft.

        :param nr_points: The number of points to interpolate. Has to be greater than the current waveform length.
        :type nr_points: int
        :param factor: The upsample factor. Must be a positive integer.
        :type factor: int
        :return: The upsampled Waveform Object
        :raises ValueError: if nr_points is lower than waveform length.
        """
        if nr_points is not None:
            factor = nr_points / float(self.length)
        elif nr_points is None and factor is not None:
            nr_points = int(self.length * factor)
        elif nr_points is None and factor is None:
            return self

        if nr_points == self.length:
            return self
        if nr_points < self.length:
            raise ValueError("Cannot up-sample a signal with %d points to %d." % (self.length, nr_points))

        fft = self.fft()
        points_to_append = int(len(fft) * factor - len(fft))
        fft.extend(Waveform(time=np.arange(points_to_append), data=np.zeros(points_to_append)))
        fft._samplerate *= factor

        original = fft.ifft()
        wf = self.copy()
        wf.data = original.data
        wf.time = original.time
        wf._samplerate = original.samplerate
        del fft, original
        gc.collect()
        return wf

    def _recalc_attributes(self):
        if self.length < 2:
            self._samplerate = 0
        else:
            distances = np.diff(self.time.astype(np.float64), 1)
            distances -= distances[0]
            if self.type != self.TYPES.FFT:
                if np.issubdtype(distances.dtype, np.integer) or np.all(distances <= 2 * np.spacing(self.time).max()):
                    with warnings.catch_warnings():
                        warnings.simplefilter(action="ignore", category=RuntimeWarning)
                        try:
                            self._samplerate = float(self.length - 1) / np.ptp(self.time)
                        except Exception:
                            self._samplerate = 0
                else:
                    self._samplerate = 0

    def _asDict(self):
        """
        Returns a dict representing the waveform which contains the data vector in key "<name>_data" and
        a compressed time vector in key "<name>_time". The compressed time vector only consists of start and end
        value of the real time vector and can be restored easily.

        :rtype: dict[str, np.multiarray.ndarray]
        """
        if self.samplerate > 0:
            # If time vector is equidistant sampled just store start and stop time as time vector. It can be
            # reconstructed afterwards.
            return {
                "{}_time".format(self.getMeta("name")): np.array([self.time[0], self.time[-1]]),
                # Compress --> Only store start/stop time
                "{}_data".format(self.getMeta("name")): self.data[:],
                "{}_metaData".format(self.getMeta("name")): self.getMeta(),
            }

        return {
            "{}_time".format(self.getMeta("name")): self.time[:],
            "{}_data".format(self.getMeta("name")): self.data[:],
            "{}_metaData".format(self.getMeta("name")): self.getMeta(),
        }

    class TYPES:
        WAVEFORM = "Waveform"
        FFT = "FFT"
        HISTOGRAM = "Histogram"
        FIT = "Fit"
        LOGIC = "Logic"


if __name__ == "__main__":
    print("Done")
