from __future__ import annotations

import os
import typing as t
import warnings

import wrapt

if t.TYPE_CHECKING:
    from wavewatson import Waveform


@wrapt.decorator
def compat_inplace(wrapped, instance, args, kw) -> t.Callable[..., Waveform]:
    from wavewatson import Waveform, __version__

    MAJOR_VERSION = int(__version__.split(".")[0])

    # Env var has precedence over mode setting in decorator.
    WAVEWATSON_LEGACY_INPLACE = os.environ.get("WAVEWATSON_LEGACY_INPLACE", "").lower()
    if MAJOR_VERSION < 2:
        # Opt-In:   If users set WAVEWATSON_LEGACY_INPLACE to "0", "no", "false" or "off" (case-insensitive),
        #           all functions will return a waveform copy.
        if WAVEWATSON_LEGACY_INPLACE in ("0", "no", "false", "off") or not Waveform.legacy_inplace_behavior:
            copy = True  # force copy of waveforms
        else:
            copy = False
            warnings.warn(
                "The legacy default in-place operations of Waveform objects are deprecated and will be changed in "
                "v2.0.0 of WaveWatson. The mutating operations will be performed on a copy instead which will be "
                "returned by default. The original Waveform object will remain unchanged. "
                "Until v2.0.0 you can opt-in to the future default behavior by setting the environment variable "
                "WAVEWATSON_LEGACY_INPLACE to 0. With the release of v2.0.0 you can opt-out of the new behavior by "
                "setting WAVEWATSON_LEGACY_INPLACE to 1.",
                FutureWarning,
                stacklevel=2,
            )
    else:  # version >= 2.0.0
        # Opt-Out:  If users set WAVEWATSON_LEGACY_INPLACE to "1", "yes", "true" or "on" (case-insensitive),
        #           the default legacy behavior will be used.
        if WAVEWATSON_LEGACY_INPLACE in ("1", "yes", "true", "on") or Waveform.legacy_inplace_behavior:
            copy = False  # Use legacy
        else:
            copy = True  # force copy of waveforms

    returned_wf: Waveform = wrapped(*args, **kw)
    if copy:
        # Here we assume the wrapped function is correctly implemented and does not mutate the input waveform
        # but returned a new Waveform instance
        return returned_wf  # type: ignore

    src_wf: Waveform
    if hasattr(instance, "_w"):
        src_wf = instance._w
    elif hasattr(instance, "data") and hasattr(instance, "time"):
        src_wf = instance
    else:
        msg = f"Unsupported instance {instance}"
        raise TypeError(msg)

    src_wf.time = returned_wf.time
    src_wf.data = returned_wf.data
    src_wf.setMeta(**returned_wf.getMeta())  # type: ignore
    src_wf._recalc_attributes()
    return src_wf  # type: ignore
