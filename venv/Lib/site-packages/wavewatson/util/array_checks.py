from __future__ import annotations

from collections.abc import Iterable
from numbers import Number
from typing import Any

import numpy as np


def _scalar_support(array1: np.ndarray, array2: Any) -> np.ndarray:
    """
    Ensures that array2 has the same length as array1. array 2 thus can also be a scalar.
    """
    new_array: np.ndarray = np.atleast_1d(array2)
    if len(new_array) == 1:
        return np.linspace(new_array[0], new_array[0], len(array1))
    if len(new_array) == len(array1):
        return array2

    msg = f"Cannot compare array of shape {array2.shape!r} to array of shape {array1.shape!r}!"
    raise ValueError(msg)


def array_eq(array1: np.ndarray, array2: Any):
    """
    Checks if two arrays are equal.

    Background info:
        Equal means their difference is below or equal to 1 effective LSB of the datatype.
        Effective LSB means the step size between a number and the next greater/lower representable number. This means
        the effetive LSB depends on the number's scaling.
    """
    array2 = _scalar_support(array1, array2)
    # 1. Calculate the effective LSB of each array element (np.spacing)
    # 2. Take the maximum of both eff. LSB arrays (background: comparing large numbers with small numbers shall use the
    #    large numbers accuracy)
    spacing = np.abs(np.stack((np.spacing(array1), np.spacing(array2))).max(axis=0))
    # Arrays are equal if their difference is lower or equal 1 eff. LSB
    return np.all(np.abs(array1 - array2) <= spacing)


def array_ge(array1: np.ndarray, array2: Any):
    """
    Checks if array1 is greater or equal then array2

    Background info:
        Greater means that array1 is greater than array2 by more than one effective LSB of the datatype.
        Effective LSB means the step size between a number and the next greater/lower representable number. This means
        the effetive LSB depends on the number's scaling.
    """
    array2 = _scalar_support(array1, array2)
    spacing = np.abs(np.stack((np.spacing(array1), np.spacing(array2))).max(axis=0))
    return np.all(np.logical_or(array1 - array2 > spacing, np.abs(array1 - array2) <= spacing))


def array_le(array1: np.ndarray, array2: Any):
    """
    Checks if array1 is less or equal then array2

    Background info:
        Lower means that array1 is lower than array2 by more than one effective LSB of the datatype.
        Effective LSB means the step size between a number and the next greater/lower representable number. This means
        the effetive LSB depends on the number's scaling.
    """
    array2 = _scalar_support(array1, array2)
    spacing = np.abs(np.stack((np.spacing(array1), np.spacing(array2))).max(axis=0))
    return np.all(np.logical_or(array2 - array1 > spacing, np.abs(array2 - array1) <= spacing))


def array_gt(array1: np.ndarray, array2: Any):
    """
    Checks if array1 is greater than array2
    """
    array2 = _scalar_support(array1, array2)
    return np.all(array1 > array2)


def array_lt(array1: np.ndarray, array2: Any):
    """
    Checks if array1 is less than array2
    """
    array2 = _scalar_support(array1, array2)
    return np.all(array1 < array2)


def is_numeric(value):
    return isinstance(value, (Number, np.number))


def is_numeric_iterable(value):
    if isinstance(value, Iterable):
        return all(map(is_numeric, value))
    return False


if __name__ == "__main__":
    print(np.all(np.linspace(10e-12, 10e12, 1000) == np.linspace(10e-12, 10e12, 1000)))
    print(array_eq(np.linspace(10e-12, 10e12, 1000), np.linspace(10e-18, 10e6, 1000) * 1000000.0))
    print(array_eq(np.linspace(10e-12, 10e12, 1000), np.linspace(10e-6, 10e18, 1000) / 1000000.0))
    print(np.all(np.linspace(10e-12, 10e12, 1000) == np.linspace(10e-9, 10e15, 1000) / 1000.0))
