from __future__ import annotations

__all__ = ["TransientAnalysis", "DCAnalysis", "ACAnalysis", "NOISEAnalysis", "POPAnalysis", "PARAMS"]

import logging
import os
import sys
import weakref

import numpy as np
import PIL

from srd.internal.simulator.api import Api, ApiHDF5, ApiSimetrix
from srd.internal.simulator.simulator import AMSDesigner, Simetrix, Simplis, Simulator, SimulatorClass, Titan
from srd.internal.utils import enums, simulation_options
from srd.internal.utils.helperclasses import deprecated

# workaround to make this file compatible with odl and newer python versions
# https://stackoverflow.com/questions/53978542/how-to-use-collections-abc-from-both-python-3-8-and-python-2-7
try:
    import collections.abc as collectionsAbc
except ModuleNotFoundError:
    import collections as collectionsAbc

logging.captureWarnings(True)
# Fix for windows: Prevent from inheriting logger filehandles to Simetrix
if "win" in str(sys.platform):
    from msvcrt import get_osfhandle

    from win32api import SetHandleInformation
    from win32con import HANDLE_FLAG_INHERIT

# Weak references to current existing Analysis objects
_analyses_wrefs = []


# ------------- Analysis Objects -------- #


class Analysis:
    """
    Simulation scripting/data access object for an individual simulation / sweep

    Supply an appropriate simulation options instantiation as input to setup the analysis object correctly.

    """

    def __init__(self, options):
        """
        Analysis base class

        :param options: An object describing the analysis- and simulator-dependent settings.
        :type options: simulation_options._Options_Base
        """

        self._simulator = None
        self.__api = None

        self.setSimOptions(options)

        global _analyses_wrefs
        _analyses_wrefs.append(weakref.ref(self))

        if not os.path.exists(self._simulation_opts.workingdir):
            try:
                os.makedirs(self._simulation_opts.workingdir)
            except:
                msg = f"Could not create workingdir:{self._simulation_opts.workingdir}"
                raise OSError(msg)
        self.__setup_logger()

    def __del__(self):
        self.__destroy_logger()
        # self.api.discardloadedsimdatafiles()

    def set_logger(self, logger):
        if isinstance(logger, logging.Logger):
            self._LogSRD = logger

    __log_index = 0

    def __setup_logger(self):
        pyverify_logger = os.environ.get("SRD_USE_PYVERIFY_LOGGER", "")
        if pyverify_logger == "":
            self._LogSRD = logging.getLogger("srd.warnings")
            self._LogSRD.setLevel(logging.DEBUG if self._simulation_opts.verbose else logging.INFO)
            # Initialize logger
            for h in self._LogSRD.handlers:
                self._LogSRD.removeHandler(h)
            self._LogSRD.handlers.clear()

            self.__log_index += 1

            fmt = logging.Formatter("%(levelname)-7s|%(asctime)s.%(msecs)03d|  SRD - %(message)s", "%H:%M:%S")

            sh = logging.StreamHandler()  # add stdout
            sh.setLevel(logging.DEBUG if self._simulation_opts.verbose else logging.INFO)
            sh.setFormatter(fmt)
            self._LogSRD.addHandler(sh)

            logname = "%s_%s_%04d.log" % (
                self._simulation_opts.fileprefix,
                str(self.getSimOptions().__class__.__name__).replace("Options_", ""),
                self.__log_index,
            )
            logpath = os.path.join(self._simulation_opts.workingdir, logname)
            if len(logpath) > 260:
                raise OSError(r" SRD Console logfile path too long( >260) " + str(logpath))
            fh = logging.FileHandler(filename=logpath, mode="w")

            if "win" in str(sys.platform):
                # Fix for windows: Prevent from inheriting logger filehandles
                SetHandleInformation(get_osfhandle(fh.stream.fileno()), HANDLE_FLAG_INHERIT, 0)

            fh.setLevel(logging.DEBUG if self._simulation_opts.verbose else logging.INFO)
            fh.setFormatter(fmt)
            self._LogSRD.addHandler(fh)
        else:

            class SrdLoggerAdapter(logging.LoggerAdapter):
                def process(self, msg, kwargs):
                    return f"SRD - {msg}", kwargs

            self._LogSRD = SrdLoggerAdapter(logging.getLogger(pyverify_logger), {})

    def __destroy_logger(self):
        if os.environ.get("SRD_USE_PYVERIFY_LOGGER", "") == "" and isinstance(self._LogSRD, logging.Logger):
            for h in self._LogSRD.handlers:
                self._LogSRD.removeHandler(h)
            self._LogSRD.handlers.clear()

    @property
    def simulator(self):
        """
        :rtype: Simulator
        """
        return self._simulator

    @property
    def api(self):
        """

        :rtype: Api
        """
        return self.__api

    @property
    def ApiSXDAT(self):
        """

        :rtype: ApiSimetrix
        """
        return self.__api

    @property
    def simulatorSimetrix(self):
        """
        :rtype: Simetrix
        """
        return self._simulator

    @property
    def simulatorIFXspice(self):
        """
        :rtype: Titan
        """
        return self._simulator

    @property
    def simdataformatSxdat(self):
        """
        :rtype: ApiSimetrix
        """
        return self.__api

    @property
    def simdataformatHDF5(self):
        """
        :rtype: ApiHDF5
        """
        return self.__api

    def getSimOptions(self):
        """
        Receive currently loaded Simulation Options Object.

        :rtype: simulation_options._Options_Base
        """
        return self._simulation_opts

    def setSimOptions(self, options):
        """
        Overwrite the currently loaded Simulation Options Object.

        :param options: An object describing the analysis- and simulator-dependent settings.
        :type options: simulation_options._Options_Base
        """
        if not isinstance(options, simulation_options._Options_Base):
            msg = (
                "Argument 'options' has to be a transient simulation option instance. Use convenience methods (Options_SimetrixTran, Options_...)"
                "of class TransientAnalysis to create a simulation option instance!"
            )
            raise TypeError(msg)

        self._simulation_opts = options

        if isinstance(self.simulator, Simulator):  # Del previous simulator if exists
            self.simulator.__del__()

        if isinstance(self.api, Api):  # Del previous api if exists
            self.api.__del__()

        # Simetrix simulator
        if options._opts_container["simulator"] == enums.SimulatorType.Simetrix:
            self._simulator = Simetrix(ref_analysis=self)
            if options.simdata_format in enums.SupportedSimulationDatatype.simetrix_options:
                self.__api = ApiSimetrix(ref_analysis=self, options=options)
            else:
                msg = f"SimDataFormat '{options.simdata_format}' not supported for this sumlator!"
                raise Exception(
                    msg,
                    enums.SimulatorType.Simetrix,
                )
        # Titan/IFXspice simulator
        elif options._opts_container["simulator"] == enums.SimulatorType.Titan:
            self._simulator = Titan(ref_analysis=self)
            if options.simdata_format in enums.SupportedSimulationDatatype.titan_options:
                if options.simdata_format in enums.SimulationDatatype.HDF5:
                    self.__api = ApiHDF5(ref_analysis=self, options=options)
                else:
                    self.__api = ApiSimetrix(ref_analysis=self, options=options)
            else:
                msg = f"SimDataFormat '{options.simdata_format}' not supported for this sumlator!"
                raise Exception(
                    msg,
                    enums.SimulatorType.Titan,
                )
        # SIMPLIS simulator
        elif options._opts_container["simulator"] == enums.SimulatorType.Simplis:
            self._simulator = Simplis(ref_analysis=self)
            self.__api = ApiSimetrix(ref_analysis=self, options=options)
        # AMSdesigner
        elif options._opts_container["simulator"] == enums.SimulatorType.AMSDesigner:
            self._simulator = AMSDesigner(ref_analysis=self)
        else:
            msg = "Simulator '{}' not supported!".format(options._opts_container["simulator"])
            raise Exception(msg)

    def startSimulator(self):
        """
        Start simulator if not already running
        """
        return self.simulator.startSimulator(idnum=self._simulation_opts.idnum)

    def stopSimulator(self, timeout=None):
        """
        Closes simulator if any open schematic was modified, the user will be prompted to save them first
        """
        ret = self.simulator.stopSimulator(idnum=self._simulation_opts.idnum, timeout=timeout)
        self.api.handle = None
        return ret

    @deprecated()
    def start(self):
        """Start simulator if not already running"""
        return self.simulator.startSimulator(idnum=self._simulation_opts.idnum)

    def run(self, addProjectLibs=False, **kwargs):
        """
        Execute simulation/sweep

        Run simulation/sweep and loads resulting simulation data.
        """
        return self.simulator.run(addProjectLibs=addProjectLibs, **kwargs)

    def resume(self, addProjectLibs=False):
        """
        Resume analysis halted by interactive pause in analog simulator

        Log files  and probe-datasets are OVERWRITTEN!
        """
        return self.simulator.resume(addProjectLibs=addProjectLibs)

    def reload(self):
        """
        Reload data from previous analysis run

        Log files are called <workingdir>/results/<fileprefix>_<4-digit-runnum>/<fileprefix>.csv

        Simulation parameter files are called <basepathname>_<4-digit-runnum>.swparm

        Probe dataset files are called <workingdir>/results/<fileprefix>_<4-digit-runnum>/<fileprefix>.sxdat
        """
        self.getSimOptions()
        return self.simulator.reload()

    def probe(self, name, run_num=None, cache=True, simulator=None, division_index=0):
        """
        Access probed waveform trace(s)

        :param run_num: run number in sweep, None for last run
        :type run_num: int
        :param name: name of probe whose waveform is require.
            (None = timebase reference trace)
        :type name: string
        :param cache: Cache probe data so subsequent calls for same data don't create
            more copies or trigger a SIMetrix data group load
        :type cache: bool
        :param simulator: Define the name of the simulator, simulation data should be accessed from. This is necessary, when doing
            cosimulation and writing HDF5 output files for the analog and the digital simulation.
        :type simulator: string
        :param division_index: When using SIMetrix built-in SWEEP functionality, specify the division_index, you would like
            to read simulations results from. Note, that cache needs to be set to False, when utilizing this feature.
        :type division_index: int

        :return: probed data for specified probe
        :rtype: numpy.ndarray
        """

        return self.api._probe(name, run_num=run_num, cache=cache, simulator=simulator, division_index=division_index)

    def probes(self, run_num=None, group_name=None, simulator=None):
        """
        Get list of names probe waveforms for data group/ run

        :param run_num: Run number in sweep, None for last run
        :type run_num: int
        :param group_name: Name of data-group loaded in Analysis Object
        :type group_name: string

        :rtype: list[str]
        """

        return self.api._probes(run_num=run_num, group_name=group_name, simulator=simulator)

    def cleanup(self):
        """
        discard all loaded simdatafiles currently loaded into Analysis Object
        """
        return self.api.discardloadedsimdatafiles()

    def extractSchematicOptions(self):
        """
        Extract all available simulator and analysis options from the selected schematic and overwrite existing
        simulation_options container with these options.

        """
        return self.simulator._get_schematic_options()

    def getNumRuns(self):
        """
        Number of simulation runs for which analysis data is available

        :return: Number of runs (can be 0 - e.g. if no succesful run/rerun or reload)
        :rtype: int
        """

        if self._simulation_opts.runs is None:
            return 0
        else:
            return self._simulation_opts.runs

    def getSimParam(self, name=None, run_num=None):
        """
        Get simulation parameters for specific run number

        :param name: parameter name, omit/None for all
        :type name: string
        :param run_num: run number in sweep, omit/None for last run, 'all' for all runs
        :type run_num: int

        :return: dict of simparam sequences, dict of simparam values, simparam
            sequence, or simparam value
        :rtype: dict | list | str
        """

        if self._simulation_opts.sim_params is None:
            msg = "No (swept) simulation parameters set yet"
            raise Exception(msg)

        run_num = self._simulation_opts._default_run_num(run_num)

        if name is not None and name not in self._simulation_opts.sim_params:
            print("No such simulation parameter in simulation log: ", name)
            print("Simulation parameters specified last run:", ",".join(self._simulation_opts.sim_params.keys()))
            return None

        if run_num == "all":
            if name is None:
                return self._simulation_opts.sim_params
            else:
                return self._simulation_opts.sim_params[name]
        else:
            if name is None:
                return {name: values[run_num] for name, values in self._simulation_opts.sim_params.items()}
            else:
                return self._simulation_opts.sim_params[name][run_num]

    def findRunsMatching(self, runpred):
        """
        Find runs matching specified log and/or parameter values

        :param runpred: Predicate specified using PROBES, CSVLOGS or PARAMS classes.
        :type runpred: RunPred

        :return: Numbers of runs matching specified predicate
        :rtype: list[int]


        Examples
        --------
        >>> analysis.findRunsMatching(PARAMS({'V_IN' : 25.0}))
        [2,7]

        See Also
        --------
        PROBES, CSVLOGS, PARAMS, AND, OR, NOT
        """

        predicate = runpred.predicate(self)
        matching = []
        for r in range(self._simulation_opts.runs):
            if predicate(r):
                matching.append(r)
        return matching

    def start_redirect_console_output(self, console_log_path=None):
        """
        Redirect simulator/simulator framework console log to a specified logfile.

        :param console_log_path: Path to logfile
        :type console_log_path: str
        """
        return self.simulator._init_sx_log(console_log_path=console_log_path)

    def stop_redirect_console_output(self):
        """
        Stop to redirect simulator/simulator framework console log to a specified logfile.
        """
        return self.simulator._close_sx_log()

    def get_license_info(self):
        """
        Parse license string of simulator, e.g. SIMetrix and displays license feature to the user.
        It returns list of all checked out features which can be shown in SIMetrix product matrix:
        https://www.simetrix.co.uk/products/product-matrix.html

        :return: license feature
        :rtype: list[str]
        """
        return self.simulator._get_lic_info()

    def get_signal_probes(self, all_probes=False):
        """
        Parse signal names of probes which can be probed by SRD and default parameters which can be overwritten
        during simulation.

        :param bool all_probes:
        :return: signal names
        :rtype: dict

        Examples
        --------
        >>> analysis.get_signal_probes()
        {'Signal_label': 'Probe', 'Signal_label2': 'Probe2'}
        e.g.:
        {'V1_pos': 'V1_P', 'Probe2_NODE': 'C1_N'}
        wheras 'V1_pos' is the label of the probe in Simetrix and 'V1_P' the name of the net which can be probed

        Disabled probes in the schematic will be ignored by SRD per default. To probe all probes the option `all_probes`
        can be used:
        >>> analysis.get_signal_probes(all_probes=True)


        """
        return self.simulator._extract_signals(all_probes)

    def get_param_names(self):
        """
        Parse default parameter names which can be overwritten during scripted simulation.

        :return: parameter names and default values
        :rtype: dict

        Examples
        --------
        >>> analysis.get_param_names()
        {'Param_Name': 'DEFAULT_VALUE'}
        e.g.:
        {'Vout': '5'}
        wheras 'Vout' is the parameter name in Simetrix and '5' the default value which can be overwritten by SRD
        """
        return self.simulator._extract_params()

    # TODO: Give user an api for saving sim data afterwards in different format
    # def save_simdata_format(self, format=None):
    # """
    # Save all signals in a specific sim_data format, e.g. csv, vcd, or hdf5 instead using the default
    # data format.
    # This feature is useful for exporting simulation data to other tools like matlab/simulink which
    # can read only specific data formats.
    # """
    # return self.__api._save_simdata_format(format=format)


class TransientAnalysis(Analysis):
    """
    Data-access/simulation object for transient analyses

    """

    Options_SimetrixTran = simulation_options.Options_SimetrixTran
    Options_SimplisTran = simulation_options.Options_SimplisTran
    Options_TitanTran = simulation_options.Options_TitanTran
    Options_AMSDesignerTran = simulation_options.Options_AMSDesignerTran

    def __init__(self, options):
        """
        Create a transient analysis object.

        :key options: An object describing the analysis- and simulator-dependent settings.
                      Use TransientAnalysis class variables 'Options_SimetrixTran', 'Options_SimplisTran',
                      'Options_TitanTran', 'Options_AMSDesignerTran' etc
                      to create a simulation option instance.

                      E.g. TransientAnalysis.Options_SimetrixTran()
        :type options: simulation_options._Options_Base
        """
        if not isinstance(options, simulation_options._Options_Base):
            msg = (
                "Argument 'options' has to be a transient simulation option instance. Use convenience methods (Options_SimetrixTran, Options_TitanTran, Options_SimplisTran, ...)"
                "of class TransientAnalysis to create a simulation option instance!"
            )
            raise TypeError(msg)
        else:
            if options._opts_container["analysis"] != enums.AnalysisType.TRAN:
                msg = (
                    "Argument 'options' has to be a transient simulation option instance. Use convenience methods (Options_SimetrixTran, Options_TitanTran, Options_SimplisTran, ...)"
                    "of class TransientAnalysis to create a simulation option instance!"
                )
                raise TypeError(msg)

        Analysis.__init__(self, options)

    def getSimOptions(self):
        """
        :rtype: simulation_options.Options_SimetrixTran|simulation_options.Options_SimplisTran|
                simulation_options.Options_TitanTran|simulation_options.Options_AMSDesignerTran
        """
        return self._simulation_opts


class DCAnalysis(Analysis):
    """
    Data-access/simulation object for DC analyses

    """

    Options_SimetrixDC = simulation_options.Options_SimetrixDC
    # Options_SimplisDC = simulation_options.Options_SimplisDC
    Options_TitanDC = simulation_options.Options_TitanDC

    def __init__(self, options):
        """
        Create a DC analysis object.

        :key options: An object describing the analysis- and simulator-dependent settings.
                      Use DCAnalysis class variables 'Options_SimetrixDC', 'Options_SimplisDC', 'Options_TitanDC', etc
                      to create a simulation option instance.

                      E.g. TransientAnalysis.Options_SimetrixDC()
        :type options: simulation_options._Options_Base
        """
        if not isinstance(options, simulation_options._Options_Base):
            msg = (
                "Argument 'options' has to be a DC simulation option instance. Use convenience methods (Options_SimetrixDC, Options_TitanDC, Options_SimplisDC...)"
                "of class DCAnalysis to create a simulation option instance!"
            )
            raise TypeError(msg)
        else:
            if options._opts_container["analysis"] != enums.AnalysisType.DC:
                msg = (
                    "Argument 'options' has to be a DC simulation option instance. Use convenience methods (Options_SimetrixDC, Options_TitanDC, Options_SimplisDC...)"
                    "of class DCAnalysis to create a simulation option instance!"
                )
                raise TypeError(msg)

        Analysis.__init__(self, options)

    def getSimOptions(self):
        """
        :rtype: simulation_options.Options_SimetrixDC|simulation_options.Options_SimplisDC|simulation_options.Options_TitanDC
        """
        return self._simulation_opts


class ACAnalysis(Analysis):
    """
    Data-access/simulation object for AC analyses

    """

    Options_SimetrixAC = simulation_options.Options_SimetrixAC
    Options_SimplisAC = simulation_options.Options_SimplisAC
    Options_TitanAC = simulation_options.Options_TitanAC

    def __init__(self, options):
        """
        Create a AC analysis object.

        :key options: An object describing the analysis- and simulator-dependent settings.
                      Use DCAnalysis class variables 'Options_SimetrixAC', 'Options_SimplisAC', 'Options_TitanAC', etc
                      to create a simulation option instance.

                      E.g. TransientAnalysis.Options_SimetrixAC()
        :type options: simulation_options._Options_Base
        """
        if not isinstance(options, simulation_options._Options_Base):
            msg = (
                "Argument 'options' has to be a AC simulation option instance. Use convenience methods (Options_SimetrixAC, Options_TitanAC, Options_SimplisAC...)"
                "of class DCAnalysis to create a simulation option instance!"
            )
            raise TypeError(msg)
        else:
            if options._opts_container["analysis"] != enums.AnalysisType.AC:
                msg = (
                    "Argument 'options' has to be a AC simulation option instance. Use convenience methods (Options_SimetrixAC, Options_TitanAC, Options_SimplisAC...)"
                    "of class DCAnalysis to create a simulation option instance!"
                )
                raise TypeError(msg)

        Analysis.__init__(self, options)

    def getSimOptions(self):
        """
        :rtype: simulation_options.Options_SimetrixAC|simulation_options.Options_SimplisAC|simulation_options.Options_TitanAC
        """
        return self._simulation_opts


class NOISEAnalysis(Analysis):
    """
    Data-access/simulation object for NOISE analyses

    """

    Options_SimetrixNOISE = simulation_options.Options_SimetrixNOISE

    def __init__(self, options):
        """
        Create a NOISE analysis object.

        :key options: An object describing the analysis- and simulator-dependent settings.
                      Use NOISEAnalysis class variables 'Options_SimetrixNOISE', 'Options_TitanNOISE', etc
                      to create a simulation option instance.

                      E.g. TransientAnalysis.Options_SimetrixNOISE()
        :type options: simulation_options._Options_Base
        """
        if not isinstance(options, simulation_options._Options_Base):
            msg = (
                "Argument 'options' has to be a NOISE simulation option instance. Use convenience methods (Options_SimetrixNOISE, Options_TitanNOISE, ...)"
                "of class NOISEAnalysis to create a simulation option instance!"
            )
            raise TypeError(msg)
        else:
            if options._opts_container["analysis"] != enums.AnalysisType.NOISE:
                msg = (
                    "Argument 'options' has to be a NOISE simulation option instance. Use convenience methods (Options_SimetrixNOISE, Options_TitanNOISE, ...)"
                    "of class NOISEAnalysis to create a simulation option instance!"
                )
                raise TypeError(msg)

        Analysis.__init__(self, options)

    def getSimOptions(self):
        """
        :rtype: simulation_options.Options_SimetrixNOISE|simulation_options.Options_SimplisNOISE|simulation_options.Options_TitanNOISE
        """
        return self._simulation_opts


class POPAnalysis(Analysis):
    """
    Data-access/simulation object for POP analyses

    """

    Options_SimplisPOP = simulation_options.Options_SimplisPOP

    def __init__(self, options):
        """
        Create a POP analysis object.

        :key options: An object describing the analysis- and simulator-dependent settings.
                      Use POPAnalysis class variables 'Options_SimplisPOP', etc
                      to create a simulation option instance.

                      E.g. TransientAnalysis.Options_SimplisPOP()
        :type options: simulation_options._Options_Base
        """
        if not isinstance(options, simulation_options._Options_Base):
            msg = (
                "Argument 'options' has to be a POP simulation option instance. Use convenience methods (Options_SimplisPOP, ...)"
                "of class POPAnalysis to create a simulation option instance!"
            )
            raise TypeError(msg)
        else:
            if options._opts_container["analysis"] != enums.AnalysisType.POP:
                msg = (
                    "Argument 'options' has to be a POP simulation option instance. Use convenience methods (Options_SimplisPOP, ...)"
                    "of class POPAnalysis to create a simulation option instance!"
                )
                raise TypeError(msg)

        Analysis.__init__(self, options)

    def getSimOptions(self):
        """
        :rtype: simulation_options.Options_SimplisPOP
        """
        return self._simulation_opts


# --------------- Utility ---------------- #


def startSimulator(simulator_id, idnum=None):
    """
    Start instance of specified simulator (if it can be started seperately
    from executing a simulation run.

    :param simulator_id: string one of 'enums.SimulatorType'
    :type simulator_id: str
    :param idnum: Simulator instance id (to allow multiple instances to be started)
        default: 0
    :type idnum: int
    """
    # No analysis associated with Simulator entity...
    simcls = SimulatorClass(simulator_id)
    simcls.startSimulator(idnum)


def startSimetrix(idnum=None):
    """
    Start instance 'idnum' of SIMetrix if its not started already

    :param idnum: Instance id number (default: 0)
    :type idnum: int
    """
    startSimulator(enums.SimulatorType.Simetrix)


def startSimplis(idnum=None):
    """
    Start instance 'idnum' of SIMPLIS if its not started already

    :param idnum: Instance id number (default: 0)
    :type idnum: int
    """
    startSimulator(enums.SimulatorType.Simplis)


def stopSimulator(simulator_id, idnum=None):
    """
    Stop instance of specified simulator (if it can be started seperately
    from executing a simulation run.

    :param simulator_id: string one of 'enums.SimulatorType'
    :type simulator_id: str
    :param idnum: Simulator instance id (to allow multiple instances to be stopped)
        default: 0
    :type idnum: int
    """
    simcls = SimulatorClass(simulator_id)
    simcls.stopSimulator(idnum)


def stopSimetrix(idnum=None):
    """
    Stop instance 'idnum' of SIMetrix if its not started already

    :param idnum: Instance id number (default: 0)
    :type idnum: int
    """
    stopSimulator(enums.SimulatorType.Simetrix)


def stopSimplis(idnum=None):
    """
    Stop instance 'idnum' of SIMPLIS if its not started already

    :param idnum: Instance id number (default: 0)
    :type idnum: int
    """
    stopSimulator(enums.SimulatorType.Simplis)


def simetrixCmd(simetrix_cmd, idnum=None, launch=False):
    """
    Run a SIMetrix script command

    Run a SIMetrix command using its remote call interface
    .. note:: Remote command despatch is slow/ heavy-weight so multiple
    commands are best packaged in to a script for execution if possible.

    :param simetrix_cmd: SIMetrix script command to execute
    :type simetrix_cmd: str
    :param logger: Function for logging simetrix commands
    :type logger: callable
    :param idnum: Simetrix instance idnum (None uses default)
    :type idnum: int
    :param launch: Launch SIMetrix instance
    :type launch: bool

    :return: SxCommand return code for execution of simetrix_cmd
        (non-0 implies command execution failed or was aborted)
    :rtype: int
    """

    simcls = SimulatorClass(enums.SimulatorType.Simetrix)
    simcls._simetrix_cmd(simetrix_cmd=simetrix_cmd, idnum=idnum, launch=launch)


def save_schematic_screenshot(schematic, filename, width=1000, launch=False):
    simetrixCmd("OpenSchem " + schematic, launch=launch)
    simetrixCmd("Copyclipschem /format png")
    im_data = PIL.ImageGrab.grabclipboard()
    if im_data is None:
        print("Error: No image data in clipboard")
    else:
        im_data.save(filename)


# ----- Utility for FindRunsMatching ----- #


class RunPred:
    """
    Base class for run-selection predicates

    `Analysis` class allows runs (individual simulations in a sweep)
    to be selected based on predicates on results, log data files,
    simulaton parameters etc.

    SeeAlso
    -------

    RunDictPred, PARAMS, PROBES, AND, OR, NOT, CSVLOGS
    """


class RunDictPred(RunPred):
    """
    Base class for Value-matching dictionary predicates

    :param sweep_dict: Dictionary specifying match for the named quantities
    :type sweep_dict: dict
    :param rtol: Relative matching tolerance (see `numpy.isclose`)
    :type rtol: real
    :param atol: Absolute matching tolerance (see `numpy.isclose`)
    :type atol: real
    """

    def __init__(self, sweep_dict, atol=1e-9, rtol=1e-4, abstol=None, reltol=None):
        self.dict = sweep_dict
        if abstol is None:
            self.abstol = atol
        else:
            self.abstol = abstol
        if reltol is None:
            self.reltol = rtol
        else:
            self.reltol = reltol

    def __match__(self, _, pred_spec):
        if isinstance(pred_spec, collectionsAbc.Callable):
            return pred_spec
        elif isinstance(pred_spec, collectionsAbc.Mapping):
            colvalue = pred_spec["value"]
            if "abstol" in pred_spec:
                col_abstol = pred_spec["abstol"]
            elif "atol" in pred_spec:
                col_abstol = pred_spec["atol"]
            else:
                col_abstol = self.abstol
            if "reltol" in pred_spec:
                col_reltol = pred_spec["reltol"]
            elif "rtol" in pred_spec:
                col_reltol = pred_spec["rtol"]
            else:
                col_reltol = self.reltol
            return lambda x: np.isclose(x, colvalue, atol=col_abstol, rtol=col_reltol)
        elif isinstance(pred_spec, float):
            return lambda x: np.isclose(x, pred_spec, atol=self.abstol, rtol=self.reltol)
        else:
            return lambda x: x == pred_spec

    def accessorDictMatchPredicate(self, accessor):
        """
        Predicate for runs matching on ALL entries match dictionary

        :param accessor: Function accessing quantity for matching given specified results
            value object and run number
        :type accessor: callable
        """
        valuepreds = {}
        for name, pred_spec in self.dict.items():
            valuepreds[name] = self.__match__(name, pred_spec)

        # Closure: compute conjunction of individual per-key predicates
        # for fetched  by accessor (wrapped Analysis.param or
        # Analysis.csvlog) for run run_num
        def dict_predicate(run_num):
            res = True
            for v, predicate in valuepreds.items():
                match_val = accessor(v, run_num)
                matches = predicate(match_val)
                res = res and matches
            return res

        return dict_predicate


class PARAMS(RunDictPred):
    """
    Construct predicate for runs with specific parameter values
    """

    def __init__(self, pred_dict, abstol=1e-9, reltol=1e-4):
        RunDictPred.__init__(self, pred_dict, abstol, reltol)

    def predicate(self, analysis):
        """

        :param analysis: Analysis Object used to call this Method.
        :type Analysis
        :return:
        """

        def accessor(name, run_num):
            return analysis._simulation_opts.simparam(name, run_num)

        return self.accessorDictMatchPredicate(accessor)


class PROBES(RunDictPred):
    """
    Construct predicate for runs with log column values
    """

    def __init__(self, dictionary, abstol=1e-9, reltol=1e-4):
        RunDictPred.__init__(self, dictionary, abstol, reltol)

    def predicate(self, analysis):
        def accessor(name, run_num):
            analysis.probe(name, run_num)

        return self.accessorDictMatchPredicate(accessor)


class AND(RunPred):
    """
    Construct AND of run finding predicates
    """

    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def predicate(self, analysis):
        lhs_pred = self.lhs.predicate(analysis)
        rhs_pred = self.rhs.predicate(analysis)

        def AND_func(run_num):
            return lhs_pred(run_num) and rhs_pred(run_num)

        return AND_func


class OR(RunPred):
    """
    Construct OR of run finding predicates
    """

    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def predicate(self, analysis):
        lhs_pred = self.lhs.predicate(analysis)
        rhs_pred = self.rhs.predicate(analysis)

        def OR_func(run_num):
            return lhs_pred(run_num) or rhs_pred(run_num)

        return OR_func


class NOT(RunPred):
    """
    Construct NOT of run finding predicates
    """

    def __init__(self, neg):
        self.neg = neg

    def predicate(self, analysis):
        neg_pred = self.neg.predicate(analysis)

        def NOT_func(run_num):
            return neg_pred(run_num)

        return NOT_func
