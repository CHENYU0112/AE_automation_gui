from __future__ import annotations

from srd.internal.simulator.errors import UsageError


class Stimulus:
    """
    Base class for stimulus source wave-form definitions

    Typically used to define `sim_params` in `Analysis` for
    PowerMODEL scripteable source devices.
    """

    binding = None


class StaticStimulus(Stimulus):
    """
    Base class for static (non-reactive) time-domain stimulus

    :param binding: Binding strength for pretty-printing stimulus expression
    :type binding: None | int
    """

    binding = None

    def __add__(self, other):
        """Construct stimulus as sum of two sub-stimuli

        Stimuli in a sum are 0.0 when inactive.

        Examples
        --------
        Triangular pulse. Rising from 0 to 10 and back down to 0.

        >>> RAMP(0, 0, 1, 10) + RAMP(1, 10, 2, 0)
        """
        return SumStimulus(self, other)

    def __mul__(self, other):
        """
        Construct stimulus as product of two sub-stimuli

        Examples:

        100Hz sinusoid with amplitude pulse. Rising from 0 to 2 between 1 and 2sec
        and back to 0

        >>> RAMP(1, 2, 0, 10) * SINE(0,None,1e-2, 0.0)
        """

        return ProductStimulus(self, other)


class AtomicStaticStimulus(StaticStimulus):
    """
    Base class for  atomic static (non-reactive) time-domain stimulus

    Atomic time-domain stimulus primitive implemented
    by stimulus sequence pseudo-device expression mini-language

    :param begin: Time stimulus starts (exclusive)
    :type begin: real
    :param end: Time stimulus ends (exclusive); None is interpreted as 'unending'
    :type end: real
    """

    UNENDING = 1.0e99

    binding = 0

    def __init__(self, begin, end):
        """
        Constructor
        """

        self.begin = begin
        if end is None:
            self.end = AtomicStaticStimulus.UNENDING
        else:
            self.end = end

    def __str__(self):
        return rf"[{self.begin!r}:{self.end!r}]"


class CONSTANT(AtomicStaticStimulus):
    """
    Constant (non-reactive) atomic stimulus

    :param begin: Start time of constant signal (inclusive)
    :type begin: float
    :param end: Stop time of constant signal (exclusive)
    :type end: float
    :param value: Value of constant signal
    :type value: float

    """

    def __init__(self, begin, end, value):
        """
        Constant stimulus
        """
        AtomicStaticStimulus.__init__(self, begin, end)
        self.value = value

    def __repr__(self):
        return f"C({self.value!r},{self.begin!r},{self.end!r})"

    def __str__(self):
        return rf"C{AtomicStaticStimulus.__str__(self)} {self.value!r}"

    def __eq__(self, other):
        return (
            type(other) is CONSTANT
            and self.begin == other.begin
            and self.end == other.end
            and self.value == other.value
        )


def C(value, begin=0, end=None):
    """
    Construct CONSTANT AtomicStaticStimulus

    Wave-form is `value` from time `begin` (inclusive) to
    `end` (exclusive) and 0.0 otherwise.
    """
    return CONSTANT(begin, end, value)


class L_CHIRP(AtomicStaticStimulus):
    """
    Linear Chirp(non-reactive)

    :param begin: Start time of linear chirp signal (inclusive)
    :type begin: float
    :param end: Stop time of linear chirp signal (exclusive)
    :type end: float
    :param start_value: Start frequency of sinusoidal signal
    :type start_value: float
    :param end_value: Stop frequency of sinusoidal signal
    :type end_value: float
    """

    def __init__(self, begin, end, start_value, end_value):
        AtomicStaticStimulus.__init__(self, begin, end)
        self.start_value = start_value
        self.end_value = end_value

    def __repr__(self):
        return f"L_CHIRP({self.begin!r},{self.end!r},{self.start_value!r},{self.end_value!r})"

    def __str__(self):
        return rf"L{AtomicStaticStimulus.__str__(self)} {self.start_value!r} {self.end_value!r}"

    def __eq__(self, other):
        return (
            type(other) is L_CHIRP
            and self.begin == other.begin
            and self.end == other.end
            and self.start_value == other.start_value
            and self.end_value == other.end_value
        )


def L(start_value, end_value, begin, end):
    """
    Construct linear  RAMP AtomicStaticStimulus

    Wave-form is `start_value` at time `begin`,
    rising/falling uniformly to `end_value` at `end`
    and 0.0 otherwise
    """
    return L_CHIRP(begin, end, start_value, end_value)


class RAMP(AtomicStaticStimulus):
    """
    Linear ramp (non-reactive) wave-form

    :param begin: Start time of ramp signal (inclusive)
    :type begin: float
    :param end: Stop time of ramp signal (exclusive)
    :type end: float
    :param start_value: Wave-form value at beginning of Ramp
    :type start_value: float
    :param end_value: Wave-form value at the end of Ramp
    :type end_value: float
    """

    def __init__(self, begin, end, start_value, end_value):
        AtomicStaticStimulus.__init__(self, begin, end)
        self.start_value = start_value
        self.end_value = end_value

    def __repr__(self):
        return f"R({self.start_value!r},{self.end_value!r},{self.begin!r},{self.end!r})"

    def __str__(self):
        return rf"R{AtomicStaticStimulus.__str__(self)} {self.start_value!r} {self.end_value!r}"

    def __eq__(self, other):
        return (
            type(other) is RAMP
            and self.begin == other.begin
            and self.end == other.end
            and self.start_value == other.start_value
            and self.end_value == other.end_value
        )


def R(start_value, end_value, begin, end):
    """
    Construct linear  RAMP AtomicStaticStimulus

    Wave-form is `start_value` at time `begin`,
    rising/falling uniformly to `end_value` at `end`
    and 0.0 otherwise
    """
    return RAMP(begin, end, start_value, end_value)


class SINE(AtomicStaticStimulus):
    """
    Sinusoid (non-reactive) atomic stimulus

    :param begin: Start time of sinusoidal signal (inclusive)
    :type begin: float
    :param end: Stop time of sinusoidal signal (exclusive)
    :type end: float
    :param period: Period of sinusoidal signal
    :type period: float
    :param delay: Phase shift of the sinusoidal signal
    :type delay: float
    :param amplitude: Amplitude modifier of sinusoidal signal
    :type amplitude: float
    :param offset: Phase shift of the sinusoidal signal
    :type offset: float
    """

    def __init__(self, begin, end, period, delay, amplitude, offset):
        AtomicStaticStimulus.__init__(self, begin, end)
        self.period = period
        self.delay = delay
        self.amplitude = amplitude
        self.offset = offset

    def __repr__(self):
        return f"S({self.period!r},{self.delay!r},{self.amplitude!r},{self.offset!r},{self.begin!r},{self.end!r})"

    def __str__(self):
        return (
            f"S{AtomicStaticStimulus.__str__(self)} {self.period!r} {self.delay!r} {self.amplitude!r} {self.offset!r}"
        )

    def __eq__(self, other):
        return (
            type(other) is SINE
            and self.begin == other.begin
            and self.end == other.end
            and self.period == other.period
            and self.delay == other.delay
            and self.amplitude == other.amplitude
            and self.offset == other.offset
        )


def S(period, delay=0.0, amplitude=1.0, offset=0.5, begin=0, end=None):
    """
    Construct SINE AtomicStaticStimulus

    Waveform between  time `begin` (inclusive) and `end` (exclusive) is
    sine with with period `period` with phase offset by
    time `delay` (e.g. `delay`== `period`/4.0 means initial value of 1.0)
    of amplitude `amplitude` with zero offset `offset`

    Waveform is 0.0 outside [`begin`, `end`).
    """
    return SINE(begin, end, period, -delay, amplitude, offset)


class PWL(AtomicStaticStimulus):
    """
    Piece-Wise Linear (non-reactive) atomic stimulus

    :param begin: Start time of PWL signal (inclusive)
    :type begin: float
    :param end: Stop time of PWL signal (exclusive)
    :type end: float
    :param data: List of name, value pairs
    :type data: list()

    """

    def __init__(self, begin, end, data):
        AtomicStaticStimulus.__init__(self, begin, end)
        self.data = data

    def __repr__(self):
        return f"PWL({self.begin},{self.end},{self.data})"

    def __str__(self):
        ret = f"P{AtomicStaticStimulus.__str__(self)} "
        data = iter(self.data)
        for time, value in zip(data, data):
            ret += f"[{time} {value}]"
        ret += "E"
        return ret

    def __eq__(self, other):
        return type(other) is PWL and self.begin == other.begin and self.end == other.end and self.data == other.data


def _PWL_string(args):
    """
    Constructs piece-wise linear wave-form sequence from args a time-sequence of time/value points time_0, value_0,
    time_1, value_1, ... .

    Difference to the plain PWL method is that the return value of this function is already a string. Also, this
    function is implemented to improve performance when dealing with very large PWL sequences.

    A minimum of two points is required.

    The last value is held indefinitely.
    """

    if len(args) < 4:
        msg = "PWL stimulus wave-form definition requires at least two points"
        raise UsageError(msg)

    pwl_stim = str(RAMP(args[0], args[2], args[1], args[3]))
    lastend = args[2]
    lastto = args[3]

    for i in range(4, len(args), 2):
        end = args[i]
        to = args[i + 1]
        pwl_stim = pwl_stim + " " + str(RAMP(lastend, end, lastto, to)) + " +"
        lastend = end
        lastto = to
    return pwl_stim + " " + str(CONSTANT(lastend, None, lastto)) + " +"


class SumStimulus(StaticStimulus):
    """
    Stimulus composed of sum of stimuli

    .. note:: Use + operator from Static Stimulus to construct.

    Examples:

    Triangular pulse. Rising from 0 to 10 and back down to 0.

    >>> RAMP(0, 0, 1, 10) + RAMP(1, 10, 2, 0)

    """

    binding = 100

    def __init__(self, lhs, rhs):
        if not isinstance(lhs, StaticStimulus):
            msg = "SumStimulus requires lhs to be StaticSimulus"
            raise UsageError(msg)
        if not isinstance(rhs, StaticStimulus):
            msg = "SumStimulus requires rhs to be StaticSimulus"
            raise UsageError(msg)
        self.lhs = lhs
        self.rhs = rhs

    def __repr__(self):
        lhsstr = self.lhs.__repr__()
        rhsstr = self.rhs.__repr__()

        if self.lhs.binding > self.binding:
            lhsstr = "(" + lhsstr + ")"
        if self.rhs.binding > self.binding:
            rhsstr = "(" + rhsstr + ")"

        return lhsstr + " + " + rhsstr

    def __str__(self):
        lhsstr = self.lhs.__str__()
        rhsstr = self.rhs.__str__()
        return lhsstr + " " + rhsstr + " +"

    def __eq__(self, other):
        return type(other) is SumStimulus and self.lhs == other.lhs and self.rhs == other.rhs


class ProductStimulus(StaticStimulus):
    """
    Stimulus composed of product of stimuli

    .. note:: Use * operator from Static Stimulus to construct.
    .. note:: Added PowerMODEL-1.2.0

    Examples:

    1Mhz Sinusoid with triangular amplitude Rising from 0 to 10 and
    back down to 0.

    >>> SINE(0, None, 1e-6, 0.0) * (RAMP(0, 0, 1, 10) + RAMP(1, 10, 2, 0))

    """

    binding = 200

    def __init__(self, lhs, rhs):
        if not isinstance(lhs, StaticStimulus):
            msg = "SumStimulus requires lhs to be StaticSimulus"
            raise UsageError(msg)
        if not isinstance(rhs, StaticStimulus):
            msg = "SumStimulus requires rhs to be StaticSimulus"
            raise UsageError(msg)
        self.lhs = lhs
        self.rhs = rhs

    def __repr__(self):
        lhsstr = self.lhs.__repr__()
        rhsstr = self.rhs.__repr__()

        if self.lhs.binding > self.binding:
            lhsstr = "(" + lhsstr + ")"
        if self.binding > self.binding:
            rhsstr = "(" + rhsstr + ")"

        return lhsstr + " * " + rhsstr

    def __str__(self):
        lhsstr = self.lhs.__str__()
        rhsstr = self.rhs.__str__()
        return lhsstr + " " + rhsstr + " *"

    def __eq__(self, other):
        return type(other) is ProductStimulus and self.lhs == other.lhs and self.rhs == other.rhs
