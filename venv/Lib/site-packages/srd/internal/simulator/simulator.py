from __future__ import annotations

import configparser
import contextlib
import errno
import fileinput
import fnmatch
import functools
import os
import stat
import subprocess
import tempfile
import time
import traceback
import uuid
import weakref
from numbers import Number
from subprocess import PIPE, Popen

import psutil

from srd.exported import StaticStimulus, Stimulus
from srd.internal.utils import enums, spice_formatter
from srd.internal.utils import fast_shutil as shutil
from srd.internal.utils.simulation_options import (
    Options_SimetrixAC,
    Options_SimetrixDC,
    Options_SimetrixNOISE,
    Options_SimetrixTF,
    Options_SimetrixTran,
    Options_SimplisAC,
    Options_SimplisPOP,
    Options_SimplisTran,
    Options_TitanAC,
    Options_TitanDC,
    Options_TitanTran,
)
from srd.internal.utils.spice_formatter import spiceEval
from srd.internal.utils.telemetry import FEATURES, track_feature
from srd.util.ifxspice import find_ifxspice_and_update_env
from srd.util.simetrix import find_simetrix_and_update_env

from .errors import *

__all__ = ["Simetrix", "Simplis", "_Simetrix_Framework", "Titan", "AMSDesigner"]


class FileNotDeleted(Exception):
    pass


# Retry decorator with exponential backoff
def retry(ExceptionToCheck, tries=4, delay=3, backoff=2, logger=None):
    """Retry calling the decorated function using an exponential backoff.

    http://www.saltycrane.com/blog/2009/11/trying-out-retry-decorator-python/
    original from: http://wiki.python.org/moin/PythonDecoratorLibrary#Retry

    :param ExceptionToCheck: the exception to check. may be a tuple of
        exceptions to check
    :type ExceptionToCheck: Exception or tuple
    :param tries: number of times to try (not retry) before giving up
    :type tries: int
    :param delay: initial delay between retries in seconds
    :type delay: int
    :param backoff: backoff multiplier e.g. value of 2 will double the delay
        each retry
    :type backoff: int
    :param logger: logger to use. If None, print
    :type logger: logging.Logger instance
    """

    def deco_retry(f):
        @functools.wraps(f)
        def f_retry(*args, **kwargs):
            mtries, mdelay = tries, delay
            while mtries > 1:
                try:
                    return f(*args, **kwargs)
                except ExceptionToCheck as e:
                    msg = "%s, Retrying in %d seconds..." % (str(e), mdelay)
                    if logger:
                        logger.warning(msg)
                    else:
                        pass
                        # print(msg)
                    time.sleep(mdelay)
                    mtries -= 1
                    mdelay *= backoff
            return f(*args, **kwargs)

        return f_retry  # true decorator

    return deco_retry


@retry(FileNotDeleted, 5, 0.1, 2)
def delete(files, log=False):  # todo: refactor log
    def logerror(path):
        if log:
            log.warning(f"Error: Could not delete file '{path}'!", exc_info=True)

    def rmtreeErrHandler(func, path, exc):
        excvalue = exc[1]
        if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
            # change the file to be readable,writable,executable: 0777
            os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)
            # retry
        try:
            func(path)
        except:
            for _i in range(5):
                time.sleep(0.2)
                try:
                    func(path)
                    break
                except PermissionError as e:
                    log.error(str(e))
                    log.error("Please close processes related to Inicio!")
                    break
                except Exception:
                    log.error(f"Failed to remove '{path}' after several retries!")
        finally:
            if os.path.exists(path):
                msg = f"'{path}' could not be fully removed!"
                raise Exception(msg)

    if isinstance(files, (list, tuple, set)):
        pass
    else:
        files = [files]

    for f in files:
        if os.path.exists(f):
            if log:
                log.debug("Removing: " + f)

            if os.path.isfile(f):
                try:
                    os.remove(f)
                except:
                    logerror(f)
            elif os.path.isdir(f):
                try:
                    shutil.rmtree(path=f, onerror=rmtreeErrHandler)
                except:
                    logerror(f)
            elif f.endswith("."):
                try:
                    os.system(rf"del \\?\{f}")
                except:
                    logerror(f)
            if os.path.isfile(f) or os.path.isdir(f):
                raise FileNotDeleted


class Simulator:
    def __init__(self, ref_analysis, simulator_name):
        self._ref_analysis = weakref.proxy(ref_analysis) if ref_analysis is not None else None

        self._keep_netlists = True
        self._overwrite_run_index = None  # If != None the simulator will use this integer instead of automatic indexing

        self._simulator = simulator_name
        """:type : str"""

    def __del__(self):
        pass

    @property
    def _log(self):
        """
        :rtype: logging.Logger
        """
        return self._ref_analysis._LogSRD

    @classmethod
    def startSimulator(cls, idnum=None):
        """Start simulator front-end if not already running"""
        raise NotImplementedError

    def run(self, addProjectLibs=False, **kwargs):
        """
        Execute simulation/sweep

        Run simulation/sweep and loads resulting simulation data.
        Simulation/sweep parameters specified in constructor
        act as defaults.

        :param addProjectLibs: Defines, whether or not project specific libraries will be loaded into simulator before
                                    simulator run or not.
        :type addProjectLibs: bool
        """
        raise NotImplementedError

    @classmethod
    def stopSimulator(cls, idnum=None, timeout=None):
        """Quit simulator front-end if running"""
        raise NotImplementedError

    def _init_sx_log(self, console_log_path=None):
        """
        Redirect simulator/simulator framework console log to a specified logfile.
        """
        raise NotImplementedError

    def _close_sx_log(self):
        """
        Stop to redirect simulator/simulator framework console log to a specified logfile.
        """
        raise NotImplementedError

    def resume(self):
        """
        Resume analysis halted by interactive pause in analog simulator

        Log files and probe-datasets are OVERWRITTEN!
        Note: In order to use this functionality, an interactive python session is required
        """
        raise NotImplementedError

    def reload(self):
        """
        Reload data from a previous simulation analysis run

        """
        swpdat_pathname = os.path.join(self.simOpts.workingdir, self.simOpts.fileprefix + ".swpdat")
        with open(swpdat_pathname) as swpdat_file:
            from srd.exported import stimulus

            simdata = eval(swpdat_file.read(), stimulus.__dict__)
            """:type : dict """
        if "simulator" in simdata and "analysis" in simdata:
            if (
                simdata["simulator"] == self.simOpts._opts_container["simulator"]
                and simdata["analysis"] == self.simOpts._opts_container["analysis"]
            ):
                if "workingdir" in simdata:
                    del simdata["workingdir"]
                self.simOpts.update_options(**simdata)
                self.api.init_rundata()
            else:
                msg = "The simulation file selected to be reloaded does not match the current Analysis object. To load the simulation, please utilize an analysis object for analysis mode={0} and a simulation options object for analysis mode={0} and simulator={1}".format(
                    simdata["analysis"], simdata["simulator"]
                )
                raise TypeError(msg)
        else:
            msg = 'The simulation file selected does not have the mandatory keys "simulator" and "analysis".'
            raise AttributeError(msg)

    def _load_temp_library_files(self, libraries, library_type=enums.LibraryTypes.MODEL):
        """
        This function will load all temporary libraries passed to this function via libraries parameter into the
        selected simulator marking them as temporary. This will allow a clean removal after the simulation has been run.

        :param libraries: Defines the path to all temporary libraries, which need to be added.
        :type libraries: list[str]
        :param library_type: Defines what kind of library is to be added. Currently either a model or a symbol library
                             can be added.
        :type library_type: str
        """

        start_temp_tag = "--START-TEMP-MODEL-FILES--"
        end_temp_tag = "--END-TEMP-MODEL-FILES--"

        current_libs = self.get_loaded_libraries(library_type=library_type)
        nontemp_current = []
        temp_tagged = 0
        for cur_lib in current_libs:
            if temp_tagged:
                temp_tagged = cur_lib != end_temp_tag
            else:
                temp_tagged = cur_lib == start_temp_tag
                if not temp_tagged:
                    nontemp_current.append(cur_lib)

        libraries.insert(0, start_temp_tag)
        libraries.append(end_temp_tag)
        libraries.extend(nontemp_current)

        unchanged = len(current_libs) == len(libraries)
        if unchanged:
            unchanged = len(current_libs) == [i for i, j in zip(current_libs, libraries) if i == j]
        if not unchanged:
            self.remove_libraries(library_type=library_type, libraries=current_libs)
            self.add_libraries(library_type=library_type, libraries=libraries)

    def _unload_temp_library_files(self, library_type=enums.LibraryTypes.MODEL):
        """
        This function removes all temporary libraries from selected simulator.

        :param library_type: Defines what kind of library is to be added. Currently either a model or a symbol library
                             can be removed.
        :type library_type: str
        """
        start_temp_tag = "--START-TEMP-MODEL-FILES--"
        end_temp_tag = "--END-TEMP-MODEL-FILES--"

        current_libs = self.get_loaded_libraries(library_type=library_type)
        nontemp_current = []
        temp_tagged = 0
        for cur_lib in current_libs:
            if temp_tagged:
                temp_tagged = cur_lib != end_temp_tag
            else:
                temp_tagged = cur_lib == start_temp_tag
                if not temp_tagged:
                    nontemp_current.append(cur_lib)

        unchanged = len(current_libs) == len(nontemp_current)
        if unchanged:
            unchanged = len(current_libs) == [i for i, j in zip(current_libs, nontemp_current) if i == j]
        if not unchanged:
            self.remove_libraries(library_type=library_type, libraries=current_libs)
            self.add_libraries(library_type=library_type, libraries=nontemp_current)

    def get_loaded_libraries(self, library_type=enums.LibraryTypes.MODEL):
        """
        This function reads all loaded model files from selected simulator.

        :rtype list[str]
        """
        raise NotImplementedError

    def remove_libraries(self, libraries, library_type=enums.LibraryTypes.MODEL):
        """
        This function removes all libraries supplied in the libraries attribute from selected simulator.

        :param libraries: Defines the path to all libraries, which need to be removed.
        :type libraries: list[str]
        :param library_type: Defines what kind of library is to be added. Currently either a model or a symbol library
                             can be removed.
        :type library_type: str
        """
        raise NotImplementedError

    def add_libraries(self, libraries, library_type=enums.LibraryTypes.MODEL):
        """
        This function adds all libraries supplied in the libraries attribute from selected simulator.

        :param libraries: Defines the path to all libraries, which need to be added.
        :type libraries: list[str]
        :param library_type: Defines what kind of library is to be added. Currently either a model or a symbol library
                             can be added.
        :type library_type: str
        """
        raise NotImplementedError

    def _get_schematic_options(self):
        """
        Extract all available simulator and analysis options from the selected schematic and overwrite existing
        simulation_options container with these options.

        """
        raise NotImplementedError

    def _open_schem_change_workingdir(self):
        """
        Opens a schematic, defined in the schematic property of the simulation options container and changes current
        workingdir to workingdir, which is also defined in the simulation options container.
        """
        raise NotImplementedError

    def _set_sweep_option(self, index, option):
        option_prefix = "$SRD_OPTION$_"
        if option_prefix + option in self.simOpts.sim_params:
            return self.simOpts.sim_params[option_prefix + option][index]
        else:
            return self.simOpts._opts_container[option]

    def _write_swpdat(self, filename):
        with open(filename, "w") as swpdat_file:
            print(r"{", file=swpdat_file)
            for key in self.simOpts._opts_container:
                if type(self.simOpts._opts_container[key]) is str:
                    if key not in ["sim_params"]:
                        print(r"'" + key + "':r'" + str(self.simOpts._opts_container[key]) + "',", file=swpdat_file)
                    else:
                        print(
                            r"'" + key + "':r'" + str(self.simOpts._opts_container[key].sim_params) + "',",
                            file=swpdat_file,
                        )
                else:
                    if key not in ["sim_params"]:
                        print(r"'" + key + "':" + str(self.simOpts._opts_container[key]) + ",", file=swpdat_file)
                    else:
                        print(
                            r"'" + key + "':" + str(self.simOpts._opts_container[key].sim_params) + ",",
                            file=swpdat_file,
                        )
            print(r"}", file=swpdat_file)

    def _get_lic_info(self):
        """
        Parse license string of simulator, e.g. SIMetrix and displays license feature to the user
        """
        raise NotImplementedError

    def _extract_signals(self, all_probes):
        """
        Return signals probes from current schematic
        """
        raise NotImplementedError

    def _extract_params(self):
        """
        Return default parameter names and values from schematic
        """
        raise NotImplementedError

    @property
    def keep_netlists(self):
        """
        If False the .net and .out files will be deleted after the test run.
        """
        return self._keep_netlists

    @keep_netlists.setter
    def keep_netlists(self, value):
        self._keep_netlists = bool(value)

    @property
    def simOpts(self):
        """
        :rtype: _Options_Base
        """
        return self._ref_analysis.getSimOptions()

    @property
    def api(self):
        """
        :rtype: Analysis
        """
        return self._ref_analysis.api

    @property
    def simdir(self):
        if (self._simulator == "simetrix") or (
            self._simulator == "titan"
            and self.simOptsTit.mode
            in [enums.IFXspiceMode.Distributed_DE, enums.IFXspiceMode.Distributed_RE, enums.IFXspiceMode.Local_Windows]
        ):
            return os.path.dirname(os.path.abspath(self.simOpts.schematic))
        else:
            return self.simOpts.workingdir


def _unchecked_subprocess_call(*popenargs, timeout=None, **kwargs):
    with subprocess.Popen(*popenargs, stdout=PIPE, stderr=subprocess.STDOUT, **kwargs) as process:
        try:
            output, unused_err = process.communicate(None, timeout=timeout)
        except subprocess.TimeoutExpired:
            process.kill()
            output, unused_err = process.communicate()
            raise subprocess.TimeoutExpired(process.args, timeout, output=output)
        except:
            process.kill()
            process.wait()
            raise
        retcode = process.poll()
        return retcode, output


class _Simetrix_Framework(Simulator):
    _simetrix_command_logging = False

    _simetrix_command_log = []

    # _simetrix_bindir = None

    def __init__(self, ref_analysis, simulator_name):
        Simulator.__init__(self, ref_analysis, simulator_name)

        # List of Dictionaries of simulation logs (one per sweep point)
        self.logs = []
        """:type : list[dict[str, object]]"""

        find_simetrix_and_update_env()

    def __del__(self):
        Simulator.__del__(self)

    @property
    def simOpts(self):
        """
        :rtype: _Options_Simetrix
        """
        return self._ref_analysis.getSimOptions()

    @property
    def simOptsTit(self):
        """
        :rtype: _Options_Titan
        """
        return self._ref_analysis.getSimOptions()

    def generate_sweep_script(self):
        """Generate SIMetrix script for creating netlists for sweep

        Generator for SIMetrix script execute to netlist sweep for SweptRun
        see `SweptRun` for usage.
        """
        if self._overwrite_run_index is not None:  # For single run by PyVerify
            indexes = [int(self._overwrite_run_index)]
            sweep_len = indexes[0] + 1
        else:
            sweep_len = len(next(iter(self.simOpts.sim_params.values())))
            if self.simOpts.subset is None:
                indexes = list(range(sweep_len))
            elif type(self.simOpts.subset) == tuple:
                indexes = list(range(self.simOpts.subset[0], self.simOpts.subset[1] + 1))
            else:
                indexes = self.simOpts.subset

        for i in indexes:
            if i < 0 or i >= sweep_len:
                msg = f"Index for swept run out legal range 0-{sweep_len - 1}:{i}"
                raise UsageError(msg)

        netlist_script_path = os.path.join(self.simdir, self.simOpts.fileprefix + "_netlist.sxscr")
        outputbasepath = os.path.join(self.simdir, self.simOpts.fileprefix)
        with open(netlist_script_path, "w") as scr:
            print(r"* Code Generated by SRD.SweptRun", file=scr)
            print("Let global:SWEEPBASEPATHNAME =", Simetrix.simetrixString(outputbasepath), file=scr)
            print("Let global:sweep_params = [ ", file=scr, end="")
            print("'OUTPUTBASEPATH'", file=scr, end="")

            for name in self.simOpts.sim_params:
                print(", '" + name + "'", file=scr, end="")
            print(" ]", file=scr)
            print(
                "Let global:OUTPUTBASEPATH_values = [{}]".format(
                    ", ".join(
                        [
                            Simetrix.simetrixString(os.path.join(self.simdir, f"{self.simOpts.fileprefix}_{i:04d}"))
                            for i in indexes
                        ]
                    )
                ),
                file=scr,
            )

            for name, values in self.simOpts.sim_params.items():
                print("Let global:" + name + "_values", "= [ ", file=scr, end="")
                first = True
                for value in values:
                    if not first:
                        print(r", ", file=scr, end="")
                    else:
                        first = False
                    if type(value) is str:
                        print(Simetrix.simetrixString(value), file=scr, end="")
                    elif isinstance(value, StaticStimulus):
                        print(Simetrix.simetrixString(value.__str__()), file=scr, end="")
                    else:
                        print(value, file=scr, end="")
                print(" ]", file=scr)
            # Work-around SIMetrix script Windows-style quotation-chaos horrors
            print(r"Let workingdir=" + Simetrix.simetrixString(self.simdir), file=scr)
            print(r"Let fileprefix='" + self.simOpts.fileprefix + r"'", file=scr)
            print(r"Let simulator='" + self.simOpts._opts_container["simulator"] + r"'", file=scr)
            print(r"Let number_simruns='{}'".format(",".join(map(str, indexes))), file=scr)
            print(r"srd_create_netlist workingdir fileprefix number_simruns simulator", file=scr)

        return indexes

    def generate_execute_simulation_script(self, indexes):
        """Generate SIMetrix script for executing sweep

        Generator for SIMetrix script execute to perform sweep for SweptRun
        see `SweptRun` for usage.
        """
        exec_sim_script_name = os.path.join(self.simdir, self.simOpts.fileprefix + "_exec_sim.sxscr")
        with open(exec_sim_script_name, "w") as scr:
            print(r"* Code Generated by SRD._generate_execute_simulation_script", file=scr)
            # Work-around SIMetrix script Windows-style quotation-chaos horrors
            print(r"Let workingdir=" + Simetrix.simetrixString(self.simdir), file=scr)
            print(r"Let interactive_mode='" + str(self.simOpts.interactive) + r"'", file=scr)
            print(r"Let fileprefix='" + self.simOpts.fileprefix + r"'", file=scr)
            print(r"Let number_simruns='{}'".format(str(indexes).strip("[]").replace(" ", "")), file=scr)
            print(r"Let simulator='" + self.simOpts._opts_container["simulator"] + r"'", file=scr)
            print(r"srd_execute_simulation workingdir fileprefix number_simruns simulator interactive_mode", file=scr)

    @staticmethod
    def simetrixString(pystr):
        return "'{}'".format(pystr.replace("\\\\", "\\' & '\\"))

    @staticmethod
    def simetrixNetlistTemplateParam(param):
        """ """
        if param[0] == '"':
            return param.replace('"', '""')
        else:
            return param

    @classmethod
    def log_simetrix_cmd(cls, cmd):
        if cls._simetrix_command_logging:
            cls._simetrix_command_log.append(cmd)
            print(f"Calling: '{cmd}'")
            if len(cls._simetrix_command_log) > 1000:
                cls._simetrix_command_log = cls._simetrix_command_log[1:]

    def setVerbosity(self, level):
        """
        Set verbosity of logging of Python<->SIMetrix interaction

        Parameters
        ----------

        level : int
            0 - terse, 1 log commands sent to SIMetrix on stdout
        """
        self._simetrix_command_logging = level > 0

    @classmethod
    def _simetrix_cmd(cls, simetrix_cmd, idnum=None, launch=False, retry_for=4.0, diag=True, timeout=None):
        """
        Run a SIMetrix script command

        Run a SIMetrix command using its remote call interface
        .. note:: Remote command despatch is slow/ heavy-weight so multiple
        commands are best packaged in to a script for execution if possible.

        :param simetrix_cmd: SIMetrix script command to execute
        :type simetrix_cmd: str
        :param logger: Function for logging simetrix commands
        :type logger: callable
        :param idnum: Simetrix instance idnum (None uses default)
        :type idnum: int
        :param launch: Launch SIMetrix instance
        :type launch: bool

        :return: SxCommand return code for execution of simetrix_cmd
            (non-0 implies command execution failed or was aborted)
        :rtype: int
        """
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        opts = ["-sync", "0"]
        if idnum is not None:
            opts += ["-ident", f"{idnum}"]
        if launch:
            opts += ["-launch"]

        cls.log_simetrix_cmd(simetrix_cmd)

        retcode = 0
        backoff_time = 0.04
        cmdargs = [os.path.join("sxcommand.exe"), *opts, simetrix_cmd]
        while backoff_time < retry_for:
            retcode, _ = _unchecked_subprocess_call(cmdargs, startupinfo=startupinfo, timeout=timeout)

            if retcode == 0:
                # Success - nothing more to do
                break
            elif retcode == 6 or retcode == 1:
                # SxCommand return code 6 == SIMetrix busy, SxCommand return code 1
                # Wait a little and try again...
                # accumulated_time += backoff_time
                backoff_time *= 4.0
                time.sleep(backoff_time)
            else:
                # Fatal error indication - give up immediately
                break

        if retcode != 0 and diag:
            print("Call of SIMetrix command:", simetrix_cmd, "failed with return code", retcode)
        return retcode

    def call_simetrix_script(self, simetrix_script_path):
        """
        Wrapper function for SIMetrix script calls.
        """

        return 'Execute "' + simetrix_script_path + '"'

    def simetrixCmd(self, simetrix_cmd, idnum=None, launch=False, retry_for=4.0, diag=True, timeout=None):
        """Run a SIMetrix script command

        Run a SIMetrix command using its remote call interface
        .. note:: Remote command despatch is slow/ heavy-weight so multiple
        commands are best packaged in to a script for execution if possible.

        Parameters
        ----------
        simetrix_cmd : string
            SIMetrix script command to execute
        idnum : int
            Simetrix instance idnum (None uses default)
        launch : bool
            Launch SIMetrix instance

        Returns
        -------
        int
            SxCommand return code for execution of simetrix_cmd
            (non-0 implies command execution failed or was aborted)
        """
        return self._simetrix_cmd(
            simetrix_cmd, idnum=idnum, launch=launch, retry_for=retry_for, diag=True, timeout=timeout
        )

    @classmethod
    def startSimulator(cls, idnum=None):
        """Start simulator if not already running

        Parameters
        ----------
            idnum :int
                SIMetrix instance identifier
        """

        def nolog(_ignored):
            pass

        if os.name == "nt":
            status = cls._simetrix_cmd("echo Started from SRD...", idnum=idnum, launch=False, retry_for=0.5, diag=False)
            if status != 0:
                unique_id = uuid.uuid4()
                unique_filepath = os.path.join(os.environ["TEMP"], "SRD_simetrix_ack" + str(unique_id) + ".txt")
                cls._simetrix_cmd(
                    f"echo Launched from SRD...; echo /file {unique_filepath} Launched from SRD",
                    idnum=idnum,
                    launch=True,
                )
                count = 0.0
                while count < 10.0:
                    if os.path.isfile(unique_filepath):
                        delete(unique_filepath)
                        print("SIMetrix Framework successfully launched from SRD.")
                        break
                    time.sleep(0.02)
                    count += 0.02
                else:
                    msg = "Cound not successfully Launch SIMetrix Framework from SRD."
                    raise AssertionError(msg)

    def _init_sx_log(self, console_log_path=None):
        """
        Redirect SIMetrix Console messages to a base logfile to be able to see all errors displayed in the SIMetrix command shell windows.
        """
        print("Start Redirection of SIMetrix Console Log")
        if console_log_path is None:
            console_log_path = os.path.join(self.simOpts.workingdir, "".join([self.simOpts.fileprefix, "_console.log"]))

        if len(console_log_path) > 260:
            raise OSError(r" SIMetrix Console logfile path too long( >260) " + str(console_log_path))

        init_log_cmd = r"RedirectMessages dup " + r'"' + console_log_path + r'"'
        res = self.simetrixCmd(init_log_cmd, idnum=self.simOpts.idnum)
        if res != 0:
            raise SxCmdERRCodeError(res, init_log_cmd, r" Initialization of SIMetrix Console logfile failed")

    def _close_sx_log(self):
        """
        Stop to redirect SIMetrix Console messages to a base logfile.
        """
        # print("Stop Redirection of SIMetrix Console Log")
        close_log_cmd = r"RedirectMessages off"
        res = self.simetrixCmd(close_log_cmd, idnum=self.simOpts.idnum)
        if res != 0:
            raise SxCmdERRCodeError(res, close_log_cmd, r" Closing of SIMetrix Console logfile failed")

    def _get_lic_info(self):
        """
        Parse license string of simulator, e.g. SIMetrix and displays license feature to the user
        Check product matrix of Simetrix: https://www.simetrix.co.uk/products/product-matrix.html
        """
        # Redirect SImetrix console window and print license info
        logfile = os.environ["TEMP"] + os.sep + "simetrix_licinfo.txt"
        self._close_sx_log()
        self._init_sx_log(console_log_path=logfile)
        self.simetrixCmd("show getlicenseinfo()")
        self._close_sx_log()

        # read logfile and parse licensestring
        with open(logfile) as f:
            lines = f.readlines()
            features = ""
            for line in lines:
                # line with 7 indicates the checked out license features
                if line.strip().startswith("7"):
                    features = line.strip().split("\t")[1].strip("'")
                    print("Checked out features: " + features)

            # Check which license is checked out
            license_dict = enums.SimetrixLicenseFeatures.license_dict
            feature_list = []
            for lic in license_dict:
                if set(license_dict[lic]).issubset(set(features.split("|"))):
                    feature_list.append(lic)
                    # yeah we got the license and append it because the license features for SIMetrix
                    # and SIMPLIS are different. Simetrix shows only the highest license but it could
                    # be that e.g. SIMPLIS is checked out but not SIMetrix Pro. I will list all licenses.

        os.remove(logfile)
        print("Simetrix licenses: " + str(feature_list))
        return feature_list

    def check_sig_label(self, label):
        # Check if lable name is valid python variable name
        if label.strip().isidentifier():
            return label.strip()
        elif label.strip().replace("-", "_").isidentifier():
            return label.strip().replace("-", "_")
        else:
            return r"default_sig_label"

    def check_sig_name(self, name):
        # Check if signal name is valid and can be probed by SRD
        matches = ["(", ")"]
        if any(x in name for x in matches):
            msg = (
                f"[INFO] Skipping probe name {name} because it is not supported by SRD probing\n"
                f"Please use simple probes only with SRD and do the calculation inside python\n"
            )
            self.sim_status_dlg.add_text(text=msg)
            self.log.info(msg=msg)
            return True
        return False

    def _ifx_extract_schematic(self, schematic_name=""):
        """
        Extracts values (signals and parameters) from schematic in a txt file of the working dir of the schematic
        signals: '<schematic_path>/graph_extract.net'
        parameters: '<schematic_path>/extracted_scripting_parameters.txt'

        :param schematic_name: str
        :return: netlist, param_extract
        """
        # Check if Schematic path is given
        if schematic_name == r"":
            msg = r"No schematic path was given, cannot extract from schematic."
            raise AttributeError(msg)

        # Call simetrix script to prepare signal and parameter extraction from schematic
        sx_cmd = f"ifx_scripting_extract '{schematic_name}'"
        self.simetrixCmd(sx_cmd)

        netlist = os.path.join(os.path.dirname(schematic_name), "graph_extract.net")
        param_extract = os.path.join(os.path.dirname(schematic_name), "extracted_scripting_parameters.txt")

        return netlist, param_extract

    def _extract_signals(self, all_probes=False):
        """
        Return signal probes from current schematic which is needed for SRD probing
        """
        netlist, param_extract = self._ifx_extract_schematic(self.simOpts.schematic)

        sig_names = []
        sig_labels = []

        signal_dict = {}

        with open(netlist) as net:
            lines = net.read().splitlines()
            for line in lines:
                if ".GRAPH" in line:
                    # disable probe if it is disabled in schematic, or probe all probes if specified
                    if "disabled=false" in line or all_probes:
                        sig_name = line.split()[1]
                        if len(line.casefold().replace("=", "").split("curvelabel")) == 2:
                            sig_label = (
                                line[len(str(line.casefold().split("curvelabel=")[0])) + 11 :]
                                .strip(r" = ")
                                .split("=")[0]
                                .split(r" ")[0:-1]
                            )
                            if type(sig_label) == list:
                                sig_label = "".join(sig_label)
                        else:
                            msg = rf"The .GRAPH statement from netlist: {line} has an unexpected syntax."
                            raise SyntaxError(msg)

                        sig_label = sig_label.replace('"', "")
                        sig_name = sig_name.replace('"', "")

                        # Check if lable name is valid python variable
                        checked_sig_label = self.check_sig_label(label=sig_label)

                        # Check if signal name is valid srd probe
                        #
                        if self.check_sig_name(name=sig_name):
                            continue

                        # except:
                        #    continue

                        sig_labels.append(checked_sig_label)
                        sig_names.append(sig_name)

                        signal_dict[checked_sig_label] = sig_name
                        # print("Signal probe: " + sig_name)
                        # print("Signal label: " + checked_sig_label)
        os.remove(os.path.join(os.path.dirname(__file__), netlist))
        os.remove(os.path.join(os.path.dirname(__file__), param_extract))
        print(signal_dict)
        return signal_dict

    def _extract_params(self):
        """
        Return signal probes from current schematic which is needed for SRD probing
        """
        netlist, param_extract = self._ifx_extract_schematic(self.simOpts.schematic)

        param_dict = {}
        with open(param_extract) as params:
            lines = params.read().splitlines()
            if len(lines) != 1:
                msg = (
                    "Extracted Scripting Parameter input file is malefunctioning. Only one line should be present."
                    f"Number of lines is:{len(lines)}."
                )
                raise OSError(msg)
            scripting_params = lines[0]

        scripting_params = scripting_params.replace("%_params_%", "").split(",")

        # Reset parameters dict
        # self.cfg_dict['parameters'] = dict()

        if scripting_params != [""]:
            for scripting_param in scripting_params:
                name_value = scripting_param.split(":")
                value = name_value[1]
                if "{" in value:
                    # Warning: expressions are not supported for PARAMS and cannot be scripted
                    pass
                else:
                    with contextlib.suppress(Exception):
                        value = spiceEval(value)
                    # self.cfg_dict['parameters'][name_value[0]] = value
                    param_name = name_value[0]
                    param_dict[param_name] = value

                    # print("Default parameter name: " + name_value[0])
        os.remove(os.path.join(os.path.dirname(__file__), netlist))
        os.remove(os.path.join(os.path.dirname(__file__), param_extract))

        print(param_dict)
        return param_dict

    def _open_schem_change_workingdir(self):
        if self.simOpts.schematic is not None:
            abs_schematic = os.path.abspath(self.simOpts.schematic)
            open_cmd = r"OpenSchem /cd " + r'"' + abs_schematic + r'"'
            res = self.simetrixCmd(open_cmd, idnum=self.simOpts.idnum)
            if res != 0:
                raise SxCmdERRCodeError(res, open_cmd, r" schematic open failed")

            self._change_workingdir(self.simdir)

    def _change_workingdir(self, new_workingdir):
        change_dir_script_path = os.path.join(self.simdir, self.simOpts.fileprefix + r"_change_dir.sxscr")
        if not os.path.exists(os.path.dirname(change_dir_script_path)):
            try:
                os.makedirs(os.path.dirname(change_dir_script_path))
            except:
                msg = f"Could not create workingdir:{self.simdir}"
                raise OSError(msg)
        with open(change_dir_script_path, "w") as scr:
            print(r"* Code Generated by SRD change_workingdir", file=scr)
            print(f"Let chdir = ChangeDir('{new_workingdir}')", file=scr)

        res = self.simetrixCmd(self.call_simetrix_script(change_dir_script_path), self.simOpts.idnum)
        if res != 0:
            raise SxCmdERRCodeError(res, change_dir_script_path, r" Change workingdir failed")

    @classmethod
    def stopSimulator(cls, idnum=None, timeout=None):
        """
        Quit simulator if running
        """
        try:
            if os.name == "nt":
                try:
                    cls._simetrix_cmd("quit", idnum=idnum, timeout=timeout)
                except subprocess.TimeoutExpired:
                    for p in psutil.process_iter():
                        try:
                            if p.name() == "Sim.exe" or p.name() == "SIMetrix.exe":
                                p.kill()
                        except:
                            pass
        except:
            msg = "Could not quit simulator 'Simetrix'"
            raise Exception(msg)

    def getSIMETRIXcurdir(self, idnum=None):
        """Find SIMETRIX bin directory

        (DLLs implementing SIMetrix remote data interface live here)
        Works by finding Windows shell registery entry for SIMetrix schematic open
        """

        (handle, resultfile) = tempfile.mkstemp(text=True)
        os.close(handle)
        self.simetrixCmd(r"Echo /file " + resultfile + r" {GetCurDir()}", idnum=idnum)
        resultfile_seq = fileinput.input(resultfile)
        simetrix_cwd = next(resultfile_seq)
        resultfile_seq.close()
        delete(resultfile)
        return str.strip(simetrix_cwd)

    def run(self, addProjectLibs=False, **kwargs):
        self._open_schem_change_workingdir()

        timeout = kwargs.get("timeout", None)

        global workingdir_last_run
        self.create_netlist()
        (retcode, paused, indexes) = self.execute_simulation(resume=False, timeout=timeout)

        self.api.refreshLoadedDataGroups()

        if self.simOpts.schematic is not None:
            self._change_workingdir(os.path.dirname(self.simOpts.schematic))

        if retcode == 0:
            self.api.init_rundata()
            workingdir_last_run = self.simdir
            if paused:
                self.api._data_valid = False
                raise SxPaused(self.simdir, self.simOpts.schematic)
            else:
                self._cleanup_simfiles(indexes)
                if self.simOpts.simdata_format not in enums.SimulationDatatype.SXDAT:
                    self.api.convert_sim_data(indexes)
                if not self.keep_netlists:
                    netlists = []
                    root, _, filenames = next(iter(os.walk(os.path.dirname(self.simOpts.schematic))))
                    for filename in (
                        fnmatch.filter(filenames, "*.net")
                        + fnmatch.filter(filenames, "*.out")
                        + fnmatch.filter(filenames, "*.sxscr")
                        + fnmatch.filter(filenames, "*.txt")
                    ):  # Find all files with .net extension
                        netlists.append(os.path.join(root, filename))
                    for netlist in netlists:
                        delete(netlist)
        else:
            self.logs = None
            self.api._data_valid = False
            raise SxCmdERRCodeError(retcode, "sweep script", "see SIMetrix console")

    def _create_analysis_and_options_command(self, index):
        raise NotImplementedError

    def create_netlist(self):
        indexes = self.generate_sweep_script()

        create_netlist_script = self.simOpts.fileprefix + "_netlist"
        self.simetrixCmd(create_netlist_script, idnum=self.simOpts.idnum)

        self._preprocess_netlist()

        # Append .Keep and .PARAM statements, options and analysis command and imported models
        for i in indexes:
            (analysis_cmd, options_cmd) = self._create_analysis_and_options_command(index=i)

            try:
                with open(
                    os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + "_imported_models.net")
                ) as im:
                    imported_models = im.read()
            except:
                pass

            with open(os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net"), "a") as kpinc:
                print("** Keeps, Options and Params set by SRD", file=kpinc)
                for name in self.simOpts.keeps:
                    print(".keep " + name, file=kpinc)
                print(file=kpinc)
                for key, value in self.simOpts.sim_params.items():
                    if type(value) != str:
                        element = value[0] if self._overwrite_run_index is not None else value[i]
                        try:
                            conv = spice_formatter.spiceFormat(element)
                            print(".param " + key + "=" + conv, file=kpinc)
                        except:
                            pass
                print(analysis_cmd, file=kpinc)
                print(options_cmd, file=kpinc)
                print("** Imported Models from Netlist", file=kpinc)
                with contextlib.suppress(Exception):
                    print(imported_models, file=kpinc)
            with contextlib.suppress(Exception):
                delete(os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".net"))
            os.rename(
                os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net"),
                os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".net"),
            )

    def _preprocess_netlist(self):
        """
        Depending on the simulator, analysis_cmd and options_cmd from the original netlist will be replaced by
        the commands set by the user in the simulation_options object.
        """

        raise NotImplementedError

    def resume(self, addProjectLibs=False):
        """
        Resume analysis halted by interactive pause in analog simulator

        Log files and probe-datasets are OVERWRITTEN!
        """

        self._open_schem_change_workingdir()
        global workingdir_last_run

        (retcode, paused, indexes) = self.execute_simulation(resume=True)
        self.api.refreshLoadedDataGroups()

        if self.simOpts.schematic is not None:
            self._change_workingdir(os.path.dirname(self.simOpts.schematic))

        if retcode == 0:
            workingdir_last_run = self.simdir
            if paused:
                self.api._data_valid = False
                raise SxPaused(self.simdir, self.simOpts.schematic)
            else:
                self._cleanup_simfiles(indexes)
            self.simOpts.update_options(subset=None)
            self.api._data_valid = True
        else:
            self.api._data_valid = False
            raise SxCmdERRCodeError(retcode, "sweep script", "see SIMetrix console")

    def get_loaded_libraries(self, library_type=enums.LibraryTypes.MODEL):
        """
        This function reads all loaded model files from selected simulator.

        :rtype list[str]
        """

        lib_file_name = os.path.join(
            self.simdir, "".join([self.simOpts.fileprefix, "_", library_type, "_libraries_loaded.txt"])
        )
        get_lib_script_path = os.path.join(self.simdir, self.simOpts.fileprefix + "_get_libs.sxscr")
        with open(get_lib_script_path, "w") as scr:
            print(r"Let library_type='" + library_type + r"'", file=scr)
            print(r"Let lib_file_name='" + lib_file_name + r"'", file=scr)
            print(r"srd_get_loaded_libraries library_type lib_file_name", file=scr)

        self.simetrixCmd(os.path.basename(get_lib_script_path), idnum=self.simOpts.idnum)

        with open(os.path.abspath(lib_file_name)) as lib_file:
            lines = lib_file.readlines()
            if len(lines) == 1:
                for line in lines:
                    lib_paths = [x.strip() for x in line.split(";")]
            else:
                msg = "The loaded libraries file has an unsupported length. Only one line of content is expected."
                raise ValueError(msg)
        return lib_paths

    def add_libraries(self, libraries, library_type=enums.LibraryTypes.MODEL):
        """
        This function adds all libraries supplied in the libraries attribute from selected simulator.

        :param libraries: Defines the path to all libraries, which need to be added.
        :type libraries: list[str]
        :param library_type: Defines what kind of library is to be added. Currently either a model or a symbol library
                             can be added.
        :type library_type: str
        """
        lib_path_list = []
        for lib_path in libraries:
            lib_path = os.path.normpath(lib_path)
            lib_path_list.append("'" + lib_path + "'")
        lib_paths = "".join([r"[", " ".join(lib_path_list), r"]"])
        if library_type == enums.LibraryTypes.MODEL:
            self.simetrixCmd(r"echo Added {AddModelFiles( " + lib_paths + r")}", idnum=self.simOpts.idnum)
        elif library_type == enums.LibraryTypes.SYMBOL:
            self.simetrixCmd(r"echo Added {AddSymbolFiles( " + lib_paths + r")}", idnum=self.simOpts.idnum)
        else:
            msg = f"For parameter library_type, an unsupported value was defined. Supported values are:{enums.LibraryTypes(__dict__)}. Defined {library_type}"
            raise ValueError(msg)

    def remove_libraries(self, libraries, library_type=enums.LibraryTypes.MODEL):
        """
        This function removes all libraries supplied in the libraries attribute from selected simulator.

        :param libraries: Defines the path to all libraries, which need to be removed.
        :type libraries: list[str]
        :param library_type: Defines what kind of library is to be removed. Currently either a model or a symbol library
                             can be removed.
        :type library_type: str
        """
        lib_path_list = []
        for lib_path in libraries:
            lib_path = os.path.normpath(lib_path)
            lib_path_list.append("'" + lib_path + "'")
        lib_paths = "".join([r"[", " ".join(lib_path_list), r"]"])
        if library_type == enums.LibraryTypes.MODEL:
            self.simetrixCmd(r"echo Removed {RemoveModelFile(" + lib_paths + r")}", idnum=self.simOpts.idnum)
        elif library_type == enums.LibraryTypes.SYMBOL:
            self.simetrixCmd(r"echo Removed {RemoveSymbolFiles( " + lib_paths + r")}", idnum=self.simOpts.idnum)
        else:
            msg = f"For parameter library_type, an unsupported value was defined. Supported values are:{enums.LibraryTypes(__dict__)}. Defined {library_type}"
            raise ValueError(msg)

    def _remove_simfiles(self, files_to_remove, indexes):
        for file in files_to_remove:
            with contextlib.suppress(Exception):
                delete(os.path.join(self.simdir, self.simOpts.fileprefix + file))
            with contextlib.suppress(Exception):
                delete(os.path.join(self.simdir, self.simOpts.fileprefix + "_" + file))
            for idx in indexes:
                with contextlib.suppress(Exception):
                    delete(os.path.join(self.simdir, self.simOpts.fileprefix + f"_{idx:04d}" + file))

    def _copy_simfiles(self, files_to_copy, indexes):
        for file in files_to_copy:
            with contextlib.suppress(Exception):
                shutil.copy(
                    os.path.join(self.simdir, self.simOpts.fileprefix + file),
                    os.path.join(self.simOpts.workingdir, self.simOpts.fileprefix + file),
                )
            with contextlib.suppress(Exception):
                shutil.copy(
                    os.path.join(self.simdir, self.simOpts.fileprefix + "_" + file),
                    os.path.join(self.simOpts.workingdir, self.simOpts.fileprefix + "_" + file),
                )
            for idx in indexes:
                with contextlib.suppress(Exception):
                    shutil.copy(
                        os.path.join(self.simdir, self.simOpts.fileprefix + f"_{idx:04d}" + file),
                        os.path.join(self.simOpts.workingdir, self.simOpts.fileprefix + f"_{idx:04d}" + file),
                    )


class Simetrix(_Simetrix_Framework):
    def __init__(self, ref_analysis):
        _Simetrix_Framework.__init__(self, ref_analysis, "simetrix")
        self.opts_list = (
            "['ABSTOL','FASTPOINTTOL','FASTRELTOL','FLUXTOL','METHOD','POINTTOL','RELTOL','TEMP','TRTOL','VNTOL']"
        )

    def __del__(self):
        _Simetrix_Framework.__del__(self)

    def _create_step_spec_command(self, index):
        default_opts = [
            "step_spec",
            "start",
            "stop",
            "step",
            "num_points",
            "num_points_decade",
            "num_points_octave",
            "value_list",
        ]

        current_opts = {}
        for key in default_opts:
            current_opts[key] = self._set_sweep_option(option=key, index=index)

        step_spec_cmd = ""
        """:type : str"""

        if str(current_opts["step_spec"]) == "STP":
            step_spec_cmd = " ".join(
                ("STP", str(current_opts["start"]), str(current_opts["stop"]), str(current_opts["step"]))
            )
        if str(current_opts["step_spec"]) == "LIN":
            step_spec_cmd = " ".join(
                ("LIN", str(current_opts["num_points"]), str(current_opts["start"]), str(current_opts["stop"]))
            )
        if str(current_opts["step_spec"]) == "DEC":
            step_spec_cmd = " ".join(
                ("DEC", str(current_opts["num_points_decade"]), str(current_opts["start"]), str(current_opts["stop"]))
            )
        if str(current_opts["step_spec"]) == "OCT":
            step_spec_cmd = " ".join(
                ("OCT", str(current_opts["num_points_octave"]), str(current_opts["start"]), str(current_opts["stop"]))
            )
        if str(current_opts["step_spec"]) == "LIST":
            step_spec_cmd = " ".join(("LIST", current_opts["value_list"]))

        return str(step_spec_cmd)

    def _create_analysis_and_options_command(self, index):
        # SIMetrix options_cmd
        default_opts = {
            "abstol": [" + Abstol=", 1e-12],
            "fastpointtol": [" + Fastpointtol=", 1.0],
            "fastreltol": [" + Fastreltol=", 0.001],
            "fluxtol": [" + Fluxtol=", 1e-11],
            "method": [" + Method=", "trap"],
            "pointtol": [" + Pointtol=", 0.001],
            "reltol": [" + Reltol=", 0.001],
            "temp": [" + Temp=", 27],
            "trtol": [" + Trtol=", 7],
            "vntol": [" + Vntol=", 1e-6],
            "mpnumthreads": [" + mpnumthreads=", None],
            "mintimestep": [" + MINTIMESTEP ", None],
            "itl4": [" + itl4=", 10],
            "conv": [" + conv=", 0],
        }

        current_opts = {}
        for key in default_opts:
            current_opts[key] = self._set_sweep_option(option=key, index=index)

        options_cmd = r".OPTIONS"
        for key in default_opts:
            if current_opts[key] != default_opts[key][1]:
                options_cmd += os.linesep + default_opts[key][0] + str(current_opts[key])

        # SIMetrix tran analysis_cmd
        if isinstance(self.simOpts, Options_SimetrixTran):
            default_opts = [
                "tstep",
                "tstop",
                "tstart",
                "tmaxstep",
                "uic",
                "snapstep",
                "snapshot",
                "snapmode",
                "fast",
                "rtnstep",
                "rtnstop",
                "rtnstart",
                "runname",
                "sweep",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".TRAN"
            analysis_cmd += " " + str(current_opts["tstep"])
            analysis_cmd += " " + str(current_opts["tstop"])
            if current_opts["tstart"] is not None:
                analysis_cmd += " " + str(current_opts["tstart"])
            if current_opts["tmaxstep"] is not None:
                analysis_cmd += " " + str(current_opts["tmaxstep"])
            if current_opts["uic"] is not None and bool(current_opts["uic"]):
                analysis_cmd += " UIC"
            if current_opts["snapstep"] is not None or current_opts["snapshot"] is not None:
                if current_opts["snapmode"] is not None:
                    analysis_cmd += " SNAPMODE=" + str(current_opts["snapmode"])
            if current_opts["snapstep"] is not None:
                analysis_cmd += " SNAPSTEP " + " ".join(map(str, current_opts["snapstep"]))
            if current_opts["snapshot"] is not None:
                analysis_cmd += " SNAPSHOT " + " ".join(map(str, current_opts["snapshot"]))
            if current_opts["fast"] is not None:
                analysis_cmd += " FAST=" + str(current_opts["fast"])
            if current_opts["rtnstep"] is not None:
                analysis_cmd += " RTNSTEP=" + str(current_opts["rtnstep"])
                if current_opts["rtnstop"] is not None:
                    analysis_cmd += " RTNSTOP=" + str(current_opts["rtnstop"])
                if current_opts["rtnstart"] is not None:
                    analysis_cmd += " RTNSTART=" + str(current_opts["rtnstart"])
            if current_opts["runname"] is not None:
                analysis_cmd += " RUNNAME=" + str(current_opts["runname"])
            if current_opts["sweep"] is not None:
                analysis_cmd += " SWEEP " + str(current_opts["sweep"])

        # SIMetrix DC analysis_cmd
        elif isinstance(self.simOpts, Options_SimetrixDC):
            step_spec_cmd = self._create_step_spec_command(index=index)

            default_opts = [
                "sweep_mode",
                "device_name",
                "param_name",
                "model",
                "mod_param_name",
                "num_steps",
                "runname",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".DC"
            if str(current_opts["sweep_mode"]) == "DEVICE":
                analysis_cmd += " ".join((" DEVICE", str(current_opts["device_name"]), step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "TEMP":
                analysis_cmd += " ".join((" TEMP", step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "PARAM":
                analysis_cmd += " ".join((" PARAM", str(current_opts["param_name"]), step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "MODEL":
                analysis_cmd += " ".join(
                    (
                        " MODEL",
                        str(current_opts["model"]),
                        r"[PARAM]",
                        str(current_opts["mod_param_name"]),
                        step_spec_cmd,
                    )
                )
            elif str(current_opts["sweep_mode"]) == "MONTE":
                analysis_cmd += " ".join((" MONTE", str(current_opts["num_steps"])))
            if current_opts["runname"] is not None:
                analysis_cmd += " RUNNAME=" + str(current_opts["runname"])

        # SIMetrix AC analysis_cmd
        elif isinstance(self.simOpts, Options_SimetrixAC):
            step_spec_cmd = self._create_step_spec_command(index=index)

            default_opts = [
                "sweep_mode",
                "device_name",
                "frequency",
                "param_name",
                "model",
                "mod_param_name",
                "num_steps",
                "runname",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".AC"
            if str(current_opts["sweep_mode"]) == "DEVICE":
                analysis_cmd += " ".join(
                    (" DEVICE", str(current_opts["device_name"]), step_spec_cmd, "F=" + str(current_opts["frequency"]))
                )
            elif str(current_opts["sweep_mode"]) == "TEMP":
                analysis_cmd += " ".join((" TEMP", step_spec_cmd, "F=" + str(current_opts["frequency"])))
            elif str(current_opts["sweep_mode"]) == "PARAM":
                analysis_cmd += " ".join(
                    (" PARAM", str(current_opts["param_name"]), step_spec_cmd, "F=" + str(current_opts["frequency"]))
                )
            elif str(current_opts["sweep_mode"]) == "MODEL":
                analysis_cmd += " ".join(
                    (
                        " MODEL",
                        str(current_opts["model"]),
                        r"[PARAM]",
                        str(current_opts["mod_param_name"]),
                        step_spec_cmd,
                        "F=" + str(current_opts["frequency"]),
                    )
                )
            elif str(current_opts["sweep_mode"]) == "FREQ":
                analysis_cmd += " ".join((" ", step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "MONTE":
                analysis_cmd += " ".join(
                    (" MONTE", str(current_opts["num_steps"]), "F=" + str(current_opts["frequency"]))
                )
            if current_opts["runname"] is not None:
                analysis_cmd += " RUNNAME=" + str(current_opts["runname"])

        # SIMetrix NOISE analysis_cmd
        elif isinstance(self.simOpts, Options_SimetrixNOISE):
            step_spec_cmd = self._create_step_spec_command(index=index)

            default_opts = [
                "sweep_mode",
                "device_name",
                "frequency",
                "param_name",
                "model",
                "mod_param_name",
                "num_steps",
                "pos_node",
                "neg_node",
                "in_source",
                "runname",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".NOISE"
            if str(current_opts["sweep_mode"]) == "DEVICE":
                analysis_cmd += " ".join((" DEVICE", str(current_opts["device_name"]), step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "TEMP":
                analysis_cmd += " ".join((" TEMP", step_spec_cmd, "F=" + str(current_opts["frequency"])))
            elif str(current_opts["sweep_mode"]) == "PARAM":
                analysis_cmd += " ".join((" PARAM", str(current_opts["param_name"]), step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "MODEL":
                analysis_cmd += " ".join(
                    (
                        " MODEL",
                        str(current_opts["model"]),
                        r"[PARAM]",
                        str(current_opts["mod_param_name"]),
                        step_spec_cmd,
                    )
                )
            elif str(current_opts["sweep_mode"]) == "FREQ":
                analysis_cmd += " ".join((" FREQ", step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "MONTE":
                analysis_cmd += " ".join((" MONTE", str(current_opts["num_steps"])))

            if current_opts["pos_node"] is not None:
                analysis_cmd += " V=" + current_opts["pos_node"]
            if current_opts["neg_node"] is not None:
                analysis_cmd += " VN=" + current_opts["neg_node"]
            else:
                analysis_cmd += " VN=0"
            if current_opts["in_source"] is not None:
                analysis_cmd += " INSRC=" + current_opts["in_source"]
            if current_opts["frequency"] is not None:
                analysis_cmd += " F=" + str(current_opts["frequency"])

            if current_opts["runname"] is not None:
                analysis_cmd += " RUNNAME=" + str(current_opts["runname"])

        # SIMetrix TF analysis_cmd
        elif isinstance(self.simOpts, Options_SimetrixTF):
            step_spec_cmd = self._create_step_spec_command(index=index)

            default_opts = [
                "sweep_mode",
                "device_name",
                "frequency",
                "param_name",
                "model",
                "mod_param_name",
                "num_steps",
                "pos_node",
                "neg_node",
                "in_source",
                "runname",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".NOISE"
            if str(current_opts["sweep_mode"]) == "DEVICE":
                analysis_cmd += " ".join((" DEVICE", str(current_opts["device_name"]), step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "TEMP":
                analysis_cmd += " ".join((" TEMP", step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "PARAM":
                analysis_cmd += " ".join((" PARAM", str(current_opts["param_name"]), step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "MODEL":
                analysis_cmd += " ".join(
                    (
                        " MODEL",
                        str(current_opts["model"]),
                        r"[PARAM]",
                        str(current_opts["mod_param_name"]),
                        step_spec_cmd,
                    )
                )
            elif str(current_opts["sweep_mode"]) == "FREQ":
                analysis_cmd += " ".join((" FREQ", step_spec_cmd))
            elif str(current_opts["sweep_mode"]) == "MONTE":
                analysis_cmd += " ".join((" MONTE", str(current_opts["num_steps"])))

            if current_opts["pos_node"] is not None:
                analysis_cmd += " V=" + current_opts["pos_node"]
                if current_opts["neg_node"] is not None:
                    analysis_cmd += " VN=" + current_opts["neg_node"]
                else:
                    analysis_cmd += " VN=0"
            elif current_opts["source"] is not None:
                analysis_cmd += "I=" + current_opts["source"]
            if current_opts["in_source"] is not None:
                analysis_cmd += " INSRC=" + current_opts["in_source"]
            if current_opts["frequency"] is not None:
                analysis_cmd += " F=" + str(current_opts["frequency"])

            if current_opts["runname"] is not None:
                analysis_cmd += " RUNNAME=" + str(current_opts["runname"])
        else:
            # Use default analysis from schematic
            analysis_cmd = "NONE"

        return analysis_cmd, options_cmd

    def _preprocess_netlist(self):
        prep_netlists = []
        root, _, filenames = next(iter(os.walk(self.simdir)))
        for filename in fnmatch.filter(filenames, "*_raw.net"):  # Find all files with _prep.net extension
            prep_netlists.append(os.path.join(root, filename))

        keywords = (".TRAN", ".DC", ".AC", ".TF", ".NOISE")
        keywords += tuple(key.lower() for key in keywords)
        for netlist in prep_netlists:
            with open(netlist, "r+") as net:
                lines = net.readlines()
                keyword_found = False
                for i in range(len(lines)):
                    if lines[i].strip().startswith(keywords):
                        lines[i] = " ".join(["* Overwritten by SRD", lines[i]])
                        keyword_found = True
                    elif keyword_found:
                        if lines[i].strip().startswith("+"):
                            lines[i] = " ".join(["* Overwritten by SRD", lines[i]])
                        elif lines[i].strip().startswith(("\\r\\n", "\\n")):
                            pass
                        else:
                            keyword_found = False
                    else:
                        pass

            with open(netlist, "w") as net:
                net.writelines(lines)

    def _get_schematic_options(self):
        """
        Extract all available simulator and analysis options from the selected schematic and overwrite existing
        simulation_options container with these options.

        """
        self._open_schem_change_workingdir()
        get_schem_opts_script_path = os.path.join(self.simdir, self.simOpts.fileprefix + "_get_schem_opts.sxscr")
        schem_opts_file = os.path.join(self.simdir, self.simOpts.fileprefix + "_schem_opts.txt")
        schem_opts_netlist = self.simOpts.fileprefix + "_schem_opts.net"
        with open(get_schem_opts_script_path, "w") as scr:
            print(r"* Code Generated by SRD _get_schematic_options to extrace default options from schematic", file=scr)
            print(rf"Netlist {schem_opts_netlist}", file=scr)
            print(rf"Netlist {schem_opts_netlist}", file=scr)
            print(rf"Run /pauseAT 1f {schem_opts_netlist}", file=scr)
            print("let analysis_opts_names = GetAnalysisInfo('name')", file=scr)
            print(r"let analysis_opts_values = GetAnalysisInfo()", file=scr)
            print(rf"let simulator_opts_names = {self.opts_list}", file=scr)
            print(r"let simulator_opts_values = makeString(Length(simulator_opts_names))", file=scr)
            print(r"for idx=0 to Length(simulator_opts_names)-1", file=scr)
            print(r"    let opt_value = GetSimulatorOption(simulator_opts_names[idx])", file=scr)
            print(r"    let simulator_opts_values[idx] = opt_value", file=scr)
            print(r"next idx", file=scr)
            print(r"Reset", file=scr)
            print(
                rf"echo /file {schem_opts_file} %_ANALYSIS_OPTS_NAMES_%{{analysis_opts_names}}%_ANALYSIS_OPTS_NAMES_%",
                file=scr,
            )
            print(
                rf"echo /append {schem_opts_file} %_ANALYSIS_OPTS_VALUES_%{{analysis_opts_values}}%_ANALYSIS_OPTS_VALUES_%",
                file=scr,
            )
            print(
                rf"echo /append {schem_opts_file} %_SIMULATOR_OPTS_NAMES_%{{simulator_opts_names}}%_SIMULATOR_OPTS_NAMES_%",
                file=scr,
            )
            print(
                rf"echo /append {schem_opts_file} %_SIMULATOR_OPTS_VALUES_%{{simulator_opts_values}}%_SIMULATOR_OPTS_VALUES_%",
                file=scr,
            )
            print(
                rf"echo /append {schem_opts_file} %_SIMULATOR_OPTS_NAMES_%{{simulator_opts_names}}%_SIMULATOR_OPTS_NAMES_%",
                file=scr,
            )
            print(
                rf"echo /append {schem_opts_file} %_SIMULATOR_OPTS_VALUES_%{{simulator_opts_values}}%_SIMULATOR_OPTS_VALUES_%",
                file=scr,
            )

        self.simetrixCmd(os.path.basename(get_schem_opts_script_path), idnum=self.simOpts.idnum)

        with open(schem_opts_file) as opts_file:
            lines = opts_file.readlines()
            analysis_opts_names = lines[0].strip("%_ANALYSIS_OPTS_NAMES_%").split(" ")
            analysis_opts_values = lines[1].strip("%_ANALYSIS_OPTS_VALUES_%").split(" ")
            simulator_opts_names = lines[2].strip("%_SIMULATOR_OPTS_NAMES_%").split(" ")
            simulator_opts_values = lines[3].strip("%_SIMULATOR_OPTS_VALUES_%").split(" ")

        self.simOpts.set_schem_options(
            analysis_opts_names=analysis_opts_names,
            analysis_opts_values=analysis_opts_values,
            simulator_opts_names=simulator_opts_names,
            simulator_opts_values=simulator_opts_values,
        )

        if self.simOpts.schematic is not None:
            self._change_workingdir(os.path.dirname(self.simOpts.schematic))

    def execute_simulation(self, resume=False, timeout=None):
        opts = self.simOpts
        """:type : _Options_Simetrix"""

        feat = FEATURES.srd_runsim_simetrix
        if isinstance(opts, Options_SimetrixTran) and getattr(opts, "sweep", False):
            feat += "_sweep"

        sweep_data_fname = os.path.join(self.simdir, opts.fileprefix + ".swpdat")
        sweep_paused_fname = os.path.join(self.simdir, opts.fileprefix + ".sxpause")

        if self._overwrite_run_index is not None:  # For single run by PyVerify
            indexes = [int(self._overwrite_run_index)]
            sweep_len = indexes[0] + 1
        else:
            sweep_len = len(next(iter(opts.sim_params.values())))
            if opts.subset is None:
                indexes = list(range(sweep_len))
            elif type(opts.subset) == tuple:
                indexes = list(range(opts.subset[0], opts.subset[1] + 1))
            else:
                indexes = opts.subset

        for i in indexes:
            if i < 0 or i >= sweep_len:
                msg = f"Index for swept run out legal range 0-{sweep_len - 1}:{i}"
                raise UsageError(msg)

        # If run was paused and continuation is possible (same sweep parameters?)
        if resume:
            if not os.access(sweep_paused_fname, os.R_OK):
                msg = f"Cannot resume sweep {self.simdir} - was not paused!"
                raise Error(msg)
            with open(sweep_data_fname) as swpdat_file:
                paused_rundata = eval(swpdat_file.read())
            if paused_rundata != opts.__dict__:
                print(f"Cannot resume of sweep {self.simdir} - simulation parameters changed")
                print(-1, file=sweep_paused_fname)
                try_resume = False
            else:
                try_resume = True
        else:
            try_resume = False

        if not try_resume:
            # Clear any pause marker to ensure start-from-scratch o.k.
            with contextlib.suppress(Exception):
                delete(sweep_paused_fname)
            self.generate_execute_simulation_script(indexes)

        execute_simulation_script = opts.fileprefix + "_exec_sim"

        track_feature(FEATURES.srd_runsim_simetrix)
        runres = self.simetrixCmd(execute_simulation_script, idnum=opts.idnum, timeout=timeout)

        autoclose = False
        if opts.schematic is not None and autoclose:
            close_cmd = r"CloseSheet"
            closeres = self.simetrixCmd(close_cmd)
            if closeres != 0:
                raise SxCmdERRCodeError(closeres, close_cmd, r"unable to close schematic")
        paused = os.access(sweep_paused_fname, os.R_OK)

        if runres == 0:
            # print("WRITING: ", sweep_data_fname)
            self._write_swpdat(sweep_data_fname)

            # converting output data to desired format
            # if not isinstance(self.api, ApiSimetrix):
            #    for sweep in range(sweep_len):
            #        self.api.convert_sim_data(run_num=sweep)

        return runres, paused, indexes

    def _cleanup_simfiles(self, indexes):
        """
        Cleansdir folder after simulation was conducted; Copies and Removes all simulation files, dependent on the
        verbosity level defined within the simulation options container.
        """

        # Copy files from simdir to workingdir depending on verbosity level
        if self.simOpts.verbose == 0:
            files_to_copy = enums.CopyFiles.SIMetrix_verbose_0
        elif self.simOpts.verbose == 1:
            files_to_copy = enums.CopyFiles.SIMetrix_verbose_1
        else:
            files_to_copy = []
        self._copy_simfiles(files_to_copy, indexes)

        # Remove files from simdir
        files_to_remove = enums.CleanupFiles.SIMetrix
        self._remove_simfiles(files_to_remove, indexes)


class Simplis(_Simetrix_Framework):
    def __init__(self, ref_analysis):
        _Simetrix_Framework.__init__(self, ref_analysis, "simplis")

    def __del__(self):
        _Simetrix_Framework.__del__(self)

    def create_netlist(self):
        """
        The SIMPLIS netlist is created and prepared in several steps within this method.
        1. A basic SIMPLIS netlist is created via /simplis flag.
        2. All analysis and basic simplis options are commented out
        3. An analysis and options string is created utilizing the settings stored in the SIMPLIS options container
        4. These two string are added to the netlist at the correct position
        5. This modified netlist is now sent to the SIMetrix Preprocessnetlist function, which does final preparations for
           the SIMPLIS simulation.
        6. Finally, the original unpatched netlist is cleaned up.
        """
        indexes = self.generate_sweep_script()

        create_netlist_script = self.simOpts.fileprefix + "_netlist"
        self.simetrixCmd(create_netlist_script, idnum=self.simOpts.idnum)

        self._preprocess_netlist()

        # Append .Keep and .PARAM statements, options and analysis command and imported models
        for i in indexes:
            (analysis_cmd, options_cmd) = self._create_analysis_and_options_command(index=i)

            with open(
                os.path.join(
                    self.getSIMETRIXcurdir(idnum=self.simOpts.idnum), self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net"
                )
            ) as im:
                runset = im.read()

            with open(
                os.path.join(
                    self.getSIMETRIXcurdir(idnum=self.simOpts.idnum), self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net"
                ),
                "w",
            ) as kpinc:
                print("** Keeps, Options and Params set by SRD", file=kpinc)
                print(options_cmd, file=kpinc)
                print(analysis_cmd, file=kpinc)
                for name in self.simOpts.keeps:
                    print(".keep " + name, file=kpinc)

                for key, value in self.simOpts.sim_params.items():
                    if isinstance(value[0], Number):
                        print(".VAR " + key + "=" + str(value[i]), file=kpinc)

                print(runset, file=kpinc)
            with contextlib.suppress(Exception):
                delete(
                    os.path.join(
                        self.getSIMETRIXcurdir(idnum=self.simOpts.idnum), self.simOpts.fileprefix + f"_{i:04d}" + ".net"
                    )
                )

        # Create and execute script to search for pop trigger devices and perform prep-processing on netlists
        self.generate_prepnetlist_sweep_script(indexes)
        create_prepnetlist_script = self.simOpts.fileprefix + "_prepnetlist"
        self.simetrixCmd(create_prepnetlist_script, idnum=self.simOpts.idnum)

        for i in indexes:
            with contextlib.suppress(Exception):
                delete(
                    os.path.join(
                        self.getSIMETRIXcurdir(idnum=self.simOpts.idnum),
                        self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net",
                    )
                )

    def _create_analysis_and_options_command(self, index):
        # SIMPLIS base options_cmd
        default_opts = [
            "expand",
            "mapnode0",
            "no_force_data",
            "min_avg_topology_dur",
            "avg_topology_dur_measurement",
            "ignore_units",
            "new_analysis",
            "snapshot_npt",
            "snapshot_intvl",
            "psp_npt",
            "psp_start",
            "psp_stop",
        ]

        current_opts = {}
        for key in default_opts:
            current_opts[key] = self._set_sweep_option(option=key, index=index)

        options_cmd = r".OPTIONS"
        if current_opts["expand"] is not False:
            options_cmd += os.linesep + "+ EXPAND"
        if current_opts["mapnode0"] is not False:
            options_cmd += os.linesep + "+ MAPNODE0"
        if current_opts["no_force_data"] is not False:
            options_cmd += os.linesep + "+ NO_FORCED_DATA"
        if current_opts["min_avg_topology_dur"] is not None:
            options_cmd += os.linesep + "+ MIN_AVG_TOPOLOGY_DUR=" + str(current_opts["min_avg_topology_dur"])
        if current_opts["avg_topology_dur_measurement"] is not None:
            options_cmd += (
                os.linesep
                + "+ AVG_TOPOLOGY_DUR_MEASUREMENT_WINDOW="
                + str(current_opts["avg_topology_dur_measurement"])
            )
        if current_opts["ignore_units"] is not None:
            options_cmd += os.linesep + "+ IGNORE_UNITS"
        if current_opts["new_analysis"] is not None:
            options_cmd += os.linesep + "+ NEW_ANALYSIS"
        if current_opts["snapshot_npt"] is not None:
            options_cmd += os.linesep + "+ SNAPSHOT_NPT=" + str(current_opts["snapshot_npt"])
        if current_opts["snapshot_intvl"] is not None:
            options_cmd += os.linesep + "+ SNAPSHOT_INTVL=" + str(current_opts["snapshot_intvl"])
        if current_opts["psp_npt"] is not None:
            options_cmd += os.linesep + "+ PSP_NPT=" + str(current_opts["psp_npt"])
        if current_opts["psp_start"] is not None:
            options_cmd += os.linesep + "+ PSP_START=" + str(current_opts["psp_start"])
        if current_opts["psp_stop"] is not None:
            options_cmd += os.linesep + "+ PSP_END=" + str(current_opts["psp_stop"])

        # SIMPLIS tran analysis_cmd & options_cmd
        if isinstance(self.simOpts, Options_SimplisTran):
            default_opts = [
                "tstop",
                "tsave",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".TRAN"
            analysis_cmd = " ".join((analysis_cmd, str(current_opts["tstop"]), str(current_opts["tsave"])))

        # SIMPLIS POP analysis_cmd & options_cmd
        elif isinstance(self.simOpts, Options_SimplisPOP):
            default_opts = [
                "trig_gate",
                "trig_condition",
                "max_period",
                "convergence",
                "cycles_before_launch",
                "td_run_after_pop_fails",
                "pop_use_tran_snapshot",
                "pop_output_cycles",
                "pop_itrmax",
                "pop_showdata",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".POP"
            analysis_cmd += os.linesep + "+ TRIG_GATE=" + str(current_opts["trig_gate"])
            analysis_cmd += os.linesep + "+ TRIG_COND=" + str(current_opts["trig_condition"])
            analysis_cmd += os.linesep + "+ MAX_PERIOD=" + str(current_opts["max_period"])
            analysis_cmd += os.linesep + "+ CONVERGENCE=" + str(current_opts["convergence"])
            analysis_cmd += os.linesep + "+ CYCLES_BEFORE_LAUNCH=" + str(current_opts["cycles_before_launch"])
            analysis_cmd += os.linesep + "+ TD_RUN_AFTER_POP_FAILS=" + str(current_opts["td_run_after_pop_fails"])

            if current_opts["pop_use_tran_snapshot"] is True:
                options_cmd += os.linesep + "+ POP_USE_TRAN_SNAPSHOT"
            if current_opts["pop_output_cycles"] is not None:
                options_cmd += os.linesep + "+ POP_OUTPUT_CYCLES=" + str(current_opts["pop_output_cycles"])
            if current_opts["pop_itrmax"] is not None:
                options_cmd += os.linesep + "+ POP_ITRMAX=" + str(current_opts["pop_itrmax"])
            if current_opts["pop_showdata"] is True:
                options_cmd += os.linesep + "+ POP_SHOWDATA"

        # SIMPLIS AC analysis_cmd & options_cmd
        elif isinstance(self.simOpts, Options_SimplisAC):
            default_opts = [
                "sweep_mode",
                "n_pt",
                "start_freq",
                "stop_freq",
                "trig_gate",
                "trig_condition",
                "max_period",
                "convergence",
                "cycles_before_launch",
                "td_run_after_pop_fails",
                "pop_use_tran_snapshot",
                "pop_output_cycles",
                "pop_itrmax",
                "pop_showdata",
                "freq_domain",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".AC"
            analysis_cmd += " " + str(current_opts["sweep_mode"])
            analysis_cmd += " " + str(current_opts["n_pt"])
            analysis_cmd += " " + str(current_opts["start_freq"])
            analysis_cmd += " " + str(current_opts["stop_freq"])

            analysis_cmd += os.linesep + r".POP"
            analysis_cmd += os.linesep + "+ TRIG_GATE=" + str(current_opts["trig_gate"])
            analysis_cmd += os.linesep + "+ TRIG_COND=" + str(current_opts["trig_condition"])
            analysis_cmd += os.linesep + "+ MAX_PERIOD=" + str(current_opts["max_period"])
            analysis_cmd += os.linesep + "+ CONVERGENCE=" + str(current_opts["convergence"])
            analysis_cmd += os.linesep + "+ CYCLES_BEFORE_LAUNCH=" + str(current_opts["cycles_before_launch"])
            analysis_cmd += os.linesep + "+ TD_RUN_AFTER_POP_FAILS=" + str(current_opts["td_run_after_pop_fails"])

            if current_opts["pop_use_tran_snapshot"] is not None:
                options_cmd += os.linesep + "+ POP_USE_TRAN_SNAPSHOT"
            if current_opts["pop_output_cycles"] is not None:
                options_cmd += os.linesep + "+ POP_OUTPUT_CYCLES=" + str(current_opts["pop_output_cycles"])
            if current_opts["pop_itrmax"] is not None:
                options_cmd += os.linesep + "+ POP_ITRMAX=" + str(current_opts["pop_itrmax"])
            if current_opts["pop_showdata"] is not None:
                options_cmd += os.linesep + "+ POP_SHOWDATA"
            if current_opts["freq_domain"] is not None:
                options_cmd += os.linesep + "+ FREQ_DOMAIN=" + str(current_opts["freq_domain"])

        # Use default analysis and options from schematic
        else:
            analysis_cmd = "NONE"
            options_cmd = "NONE"

        return analysis_cmd, options_cmd

    def _preprocess_netlist(self):
        prep_netlists = []
        root, _, filenames = next(iter(os.walk(self.simdir)))
        for filename in fnmatch.filter(filenames, "*_raw.net"):  # Find all files with _raw.net extension
            prep_netlists.append(os.path.join(root, filename))

        keywords = (".TRAN", ".DC", ".AC", ".OPTIONS", ".POP")
        keywords += tuple(key.lower() for key in keywords)
        for netlist in prep_netlists:
            with open(netlist, "r+") as net:
                lines = net.readlines()
                keyword_found = False
                for i in range(len(lines)):
                    if lines[i].strip().startswith(keywords + tuple([x.lower() for x in keywords])):
                        lines[i] = " ".join(["* Overwritten by SRD", lines[i]])
                        keyword_found = True
                    elif keyword_found:
                        if lines[i].strip().startswith("+"):
                            lines[i] = " ".join(["* Overwritten by SRD", lines[i]])
                        elif lines[i].strip().startswith(("\\r\\n", "\\n")):
                            pass
                        else:
                            keyword_found = False
                    else:
                        pass

            with open(netlist, "w") as net:
                net.writelines(lines)

    def generate_prepnetlist_sweep_script(self, indexes=None):
        """
        Generate SIMetrix script for preprocessing netlists of a sweep

        Generator for SIMetrix script execute to preprocess netlists of a sweep.
        """
        opts = self.simOpts
        """:type : Options_SimplisAC"""

        prepnetlist_script_path = os.path.join(self.simdir, self.simOpts.fileprefix + "_prepnetlist.sxscr")

        trig_gate = "'" + opts.trig_gate.replace("{", "").replace("}", "") + "'"

        with open(prepnetlist_script_path, "w") as scr:
            print(r"* Code Generated by srd.internal.simulator.generate_prepnetlist_sweep_script", file=scr)
            print(r"Let error = 0", file=scr)
            print(r"Let popDeviceLine =''", file=scr)
            if opts._opts_container["analysis"] in [enums.AnalysisType.AC, enums.AnalysisType.POP]:
                print(f"Let scripted_trig_gate = {trig_gate}", file=scr)
                print(r"ifx_simplis_find_pop_trigger @popDeviceLine scripted_trig_gate @error", file=scr)
                print(r"if error then", file=scr)
                print(r"    echo ERROR when executing script: ifx_simplis_find_pop_trigger, exiting script!", file=scr)
                print(r"    exit all", file=scr)
                print(r"endif", file=scr)

            print(r"if popDeviceLine<>'' then", file=scr)
            for i in indexes:
                print(
                    " ".join(
                        [
                            "   PreprocessNetlist",
                            r"/importglobals",
                            r"/inAppend {popDeviceLine}",
                            '"' + os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net") + '"',
                            '"' + os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".net"),
                        ]
                    )
                    + '"',
                    file=scr,
                )
            print("else", file=scr)
            for i in indexes:
                print(
                    " ".join(
                        [
                            "   PreprocessNetlist",
                            r"/importglobals",
                            '"' + os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + "_raw.net") + '"',
                            '"' + os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".net"),
                        ]
                    )
                    + '"',
                    file=scr,
                )
            print("endif", file=scr)

    def execute_simulation(self, resume=False, timeout=None):
        opts = self.simOpts
        """:type : _Options_Simplis"""

        track_feature(FEATURES.srd_runsim_simplis)

        sweep_len = len(next(iter(opts.sim_params.values())))
        sweep_data_fname = os.path.join(self.simdir, opts.fileprefix + ".swpdat")
        sweep_paused_fname = os.path.join(self.simdir, opts.fileprefix + ".sxpause")

        if opts.subset is None:
            indexes = list(range(sweep_len))
        elif type(opts.subset) == tuple:
            indexes = list(range(opts.subset[0], opts.subset[1] + 1))
        else:
            indexes = opts.subset

        for i in indexes:
            if i < 0 or i >= sweep_len:
                msg = f"Index for swept run out legal range 0-{sweep_len - 1}:{i}"
                raise UsageError(msg)

        # If run was paused and continuation is possible (same sweep parameters?)
        if resume:
            if not os.access(sweep_paused_fname, os.R_OK):
                msg = f"Cannot resume sweep {self.simdir} - was not paused!"
                raise Error(msg)
            with open(sweep_data_fname) as swpdat_file:
                paused_rundata = eval(swpdat_file.read())
            if paused_rundata != opts.__dict__:
                print(f"Cannot resume of sweep {self.simdir} - simulation parameters changed")
                print(-1, file=sweep_paused_fname)
                try_resume = False
            else:
                try_resume = True
        else:
            try_resume = False

        if not try_resume:
            # Clear any pause marker to ensure start-from-scratch o.k.
            with contextlib.suppress(Exception):
                delete(sweep_paused_fname)
            self.generate_execute_simulation_script(indexes)

        execute_simulation_script = opts.fileprefix + "_exec_sim"
        runres = self.simetrixCmd(execute_simulation_script, idnum=opts.idnum, timeout=timeout)

        if runres == 0:
            # print("WRITING: ", sweep_data_fname)
            self._write_swpdat(sweep_data_fname)

        autoclose = False
        if opts.schematic is not None and autoclose:
            close_cmd = r"CloseSheet"
            closeres = self.simetrixCmd(close_cmd)
            if closeres != 0:
                raise SxCmdERRCodeError(closeres, close_cmd, r"unable to close schematic")
        paused = os.access(sweep_paused_fname, os.R_OK)

        return runres, paused, indexes

    def _cleanup_simfiles(self, indexes):
        """
        Cleansdir folder after simulation was conducted; Copies and Removes all simulation files, dependent on the
        verbosity level defined within the simulation options container.
        """

        # Remove files from simdir
        if self.simOpts.verbose == 0:
            files_to_remove = enums.CleanupFiles.SIMPLIS
            self._remove_simfiles(files_to_remove, indexes)


class Titan(_Simetrix_Framework):
    def __init__(self, ref_analysis):
        _Simetrix_Framework.__init__(self, ref_analysis, "titan")
        self.ifxspice_error = False

        find_ifxspice_and_update_env()

    def __del__(self):
        _Simetrix_Framework.__del__(self)

    def _create_step_spec_command(self, index):
        default_opts = [
            "step_spec",
            "num_points",
            "start",
            "stop",
            "num_points_decade",
            "num_points_octave",
        ]

        current_opts = {}
        for key in default_opts:
            current_opts[key] = self._set_sweep_option(option=key, index=index)

        step_spec_cmd = ""
        """:type : str"""

        if str(current_opts["step_spec"]) == "LIN":
            step_spec_cmd = " ".join(
                ("LIN", str(current_opts["num_points"]), str(current_opts["start"]), str(current_opts["stop"]))
            )
        if str(current_opts["step_spec"]) == "DEC":
            step_spec_cmd = " ".join(
                ("DEC", str(current_opts["num_points_decade"]), str(current_opts["start"]), str(current_opts["stop"]))
            )
        if str(current_opts["step_spec"]) == "OCT":
            step_spec_cmd = " ".join(
                ("OCT", str(current_opts["num_points_octave"]), str(current_opts["start"]), str(current_opts["stop"]))
            )

        return str(step_spec_cmd)

    def _create_analysis_and_options_command(self, index):
        default_opts = {"abstol": [" + Abstol=", 1e-12], "reltol": [" + Reltol=", 0.001], "vntol": [" + Vntol=", 1e-6]}

        current_opts = {}
        for key in default_opts:
            current_opts[key] = self._set_sweep_option(option=key, index=index)

        options_cmd = r".OPTIONS"

        for key in default_opts:
            if current_opts[key] != default_opts[key][1]:
                options_cmd += os.linesep + default_opts[key][0] + str(current_opts[key])

        # IFXspice tran analysis_cmd
        if isinstance(self.simOpts, Options_TitanTran):
            default_opts = [
                "tstep",
                "tstop",
                "tstart",
                "tmaxstep",
                "uic",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".TRAN"
            analysis_cmd += " " + str(current_opts["tstep"])
            analysis_cmd += " " + str(current_opts["tstop"])
            if current_opts["tstart"] is not None:
                analysis_cmd += " " + str(current_opts["tstart"])
            if current_opts["tmaxstep"] is not None:
                analysis_cmd += " " + str(current_opts["tmaxstep"])
            if current_opts["uic"] is not None and bool(current_opts["uic"]):
                analysis_cmd += " UIC"

        # IFXspice DC analysis_cmd
        elif isinstance(self.simOpts, Options_TitanDC):
            step_spec_cmd = self._create_step_spec_command(index)

            default_opts = [
                "device_name",
            ]

            current_opts = {}
            for key in default_opts:
                current_opts[key] = self._set_sweep_option(option=key, index=index)

            analysis_cmd = r".DC "
            analysis_cmd += " ".join((str(current_opts["device_name"]), step_spec_cmd))

        # IFXspice AC analysis_cmd
        elif isinstance(self.simOpts, Options_TitanAC):
            step_spec_cmd = self._create_step_spec_command(index)

            analysis_cmd = r".AC"
            analysis_cmd += "".join((" ", step_spec_cmd))

        else:
            # Use default analysis from schematic
            analysis_cmd = "NONE"

        return analysis_cmd, options_cmd

    def _preprocess_netlist(self):
        prep_netlists = []
        root, _, filenames = next(iter(os.walk(self.simdir)))
        for filename in fnmatch.filter(filenames, "*_raw.net"):  # Find all files with _prep.net extension
            prep_netlists.append(os.path.join(root, filename))

        keywords = (".TRAN", ".DC", ".AC")
        keywords += tuple(key.lower() for key in keywords)
        for netlist in prep_netlists:
            with open(netlist, "r+") as net:
                lines = net.readlines()
                keyword_found = False
                for i in range(len(lines)):
                    if lines[i].strip().startswith(keywords):
                        lines[i] = " ".join(["* Overwritten by SRD", lines[i]])
                        keyword_found = True
                    elif keyword_found:
                        if lines[i].strip().startswith("+"):
                            lines[i] = " ".join(["* Overwritten by SRD", lines[i]])
                        elif lines[i].strip().startswith(("\\r\\n", "\\n")):
                            pass
                        else:
                            keyword_found = False
                    else:
                        pass

            with open(netlist, "w") as net:
                net.writelines(lines)

    def _distrib_dispatch_simulation(self):
        opts = self.simOpts
        """:type: _Options_Titan """
        # Check if samba dir win exists, if not create it
        if not os.path.exists(opts.samba_win):
            os.makedirs(opts.samba_win)

        os.path.join(self.simdir, opts.fileprefix + ".swpdat")

        titan_version = os.path.basename(os.environ["IFXSPICE_VERSION"]).lstrip("inicio_ifxspice_").rsplit(".", 1)[0]

        # Execute Simulation Script
        if opts.no_job_cleanup is False:
            ifxspice_sweeprun_call = "{} {} {} {}".format(
                opts.ifxspice_root_unix + r"/ifxspice_sweeprun", opts.samba_unix, opts.fileprefix, titan_version
            )
        else:
            ifxspice_sweeprun_call = "{} {} {} {} {}".format(
                opts.ifxspice_root_unix + r"/ifxspice_sweeprun",
                opts.samba_unix,
                opts.fileprefix,
                titan_version,
                "nojobclean",
            )

        cmd_titan_unix_sim, env = self._set_cmd_linux_dispatch(lin_cmd=ifxspice_sweeprun_call)
        return self._exec_cmd_linux_dispatch(exec_cmd=cmd_titan_unix_sim, env=env)

    def distrib_netlist_dispatch(self, addProjectLibs=False, **kwargs):
        """
        In contrast to the run function, this only creates SIMetrix netlist, converts to a titan netlist, copies
        netlist + source files to linux mount and dispatches simulations. It does not copy back results after simulation
        has finished.

        This can come in quite handy when copying simulation results back to the local workspace fails due to OS/IT infrastructure instabilities.
        This only works for IFXspice distributed mode.
        """
        opts = self.simOpts
        """:type: _Options_Titan """
        if self.simOptsTit.mode == enums.IFXspiceMode.Distributed_DE:
            self._open_schem_change_workingdir()
            global workingdir_last_run
            self.create_netlist()

            if self._overwrite_run_index is not None:  # For single run by PyVerify
                indexes = [int(self._overwrite_run_index)]
                sweep_len = indexes[0] + 1
            else:
                sweep_len = len(next(iter(opts.sim_params.values())))
                if opts.subset is None:
                    indexes = list(range(sweep_len))
                elif type(opts.subset) == tuple:
                    indexes = list(range(opts.subset[0], opts.subset[1] + 1))
                else:
                    indexes = opts.subset
                for i in indexes:
                    if i < 0 or i >= sweep_len:
                        msg = f"Index for swept run out legal range 0-{sweep_len - 1}:{i}"
                        raise UsageError(msg)

            self._distrib_dispatch_simulation()

            self.api.refreshLoadedDataGroups()
            if self.simOpts.schematic is not None:
                self._change_workingdir(os.path.dirname(self.simOpts.schematic))
            self._cleanup_simfiles(indexes)
        else:
            msg = r"ERROR: Function dispatch_simulation can only be used, in distributed mode for IFXspice"
            raise ValueError(msg)

    def _distrib_copy_results(self, indexes=False):
        print(r"Started loading results from linux share...")
        opts = self.simOpts
        """:type: _Options_Titan """

        if indexes is False:
            if self._overwrite_run_index is not None:  # For single run by PyVerify
                indexes = [int(self._overwrite_run_index)]
                sweep_len = indexes[0] + 1
            else:
                sweep_len = len(next(iter(opts.sim_params.values())))
                if opts.subset is None:
                    indexes = list(range(sweep_len))
                elif type(opts.subset) == tuple:
                    indexes = list(range(opts.subset[0], opts.subset[1] + 1))
                else:
                    indexes = opts.subset
                for i in indexes:
                    if i < 0 or i >= sweep_len:
                        msg = f"Index for swept run out legal range 0-{sweep_len - 1}:{i}"
                        raise UsageError(msg)

        count = 0
        ifxspice_distri_de_run_ok = os.path.join(opts.samba_win, "srd.status.txt")
        while count != 36000:
            if os.path.isfile(ifxspice_distri_de_run_ok):
                with open(ifxspice_distri_de_run_ok) as status:
                    ifxspice_error_log = status.readlines()
                    if "OK" in ifxspice_error_log[-1].strip():
                        new_indexes = indexes
                        print(r"All IFXspice Distributed mode simulations passed")
                        break
                        # Simulation ran ok
                    else:
                        print(
                            r"ERROR:  IFXspice Distributed mode simulation failed. {} "
                            r"        For more information please look at: {}".format(
                                ifxspice_error_log[0], opts.samba_win + r"\srd.status.txt"
                            )
                        )
                        self.ifxspice_error = True
                        # Redefine indexes to only account for runs that were pass
                        new_indexes = []
                        for idx in range(1, len(ifxspice_error_log), 1):
                            if r"OK" in ifxspice_error_log[idx]:
                                new_indexes.append(idx - 1)
                        break
            time.sleep(1)
        else:
            print("Timeout occured after more then 10h.")

        print(r"All simulation results found under linux share.")

        # Convert Simulation Files from CSDF to SXDAT if SXDAT was selected
        if opts.simdata_format not in enums.SimulationDatatype.HDF5:
            print("Start Conversion from CSDF to SXDAT.")
            # write simetrix script to convert sim res data from sweep
            convert_to_sxdat_script_path = os.path.join(self.simdir, opts.fileprefix + "_convert_to_sxdat.sxscr")
            with open(convert_to_sxdat_script_path, "w") as scr:
                print(r"* Code Generated by SRD to convert IFXspice csdf to sxdat", file=scr)
                for i in new_indexes:
                    print(
                        " ".join(
                            [
                                "OpenRawFile /noerr /csdf",
                                os.path.join(
                                    opts.samba_win,
                                    f"run{i}",
                                    opts.fileprefix + f"_{i:04d}" + opts.simulation_result_suffix,
                                ),
                            ]
                        ),
                        file=scr,
                    )
                    print(
                        " ".join(
                            ["SaveGroup /force", os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".sxdat")]
                        ),
                        file=scr,
                    )

            self.simetrixCmd(os.path.basename(convert_to_sxdat_script_path), idnum=opts.idnum)

        # Copy .h5 files from Samba drive to workingdir
        else:
            print("Start Copy of .h5 files to workingdir.")
            # Setup Simulation Result file names
            if opts._opts_container["analysis"] == enums.AnalysisType.TRAN:
                output_hdf5_suffix = enums.TitanSuffix.Tran_HDF5
            elif opts._opts_container["analysis"] == enums.AnalysisType.DC:
                output_hdf5_suffix = enums.TitanSuffix.DC_HDF5
            elif opts._opts_container["analysis"] == enums.AnalysisType.AC:
                output_hdf5_suffix = enums.TitanSuffix.AC_HDF5
            else:
                msg = "Selected Analysis is not supported: {}".format(opts._opts_container["analysis"])
                raise ValueError(msg)
            for i in new_indexes:
                source_hdf5_path = os.path.join(
                    opts.samba_win, f"run{i}", opts.fileprefix + f"_{i:04d}" + output_hdf5_suffix
                )
                source_hdf5_path_compressed = os.path.join(
                    opts.samba_win, f"run{i}", opts.fileprefix + f"_{i:04d}" + output_hdf5_suffix + r"_c"
                )
                target_hdf5_path = os.path.join(opts.workingdir, opts.fileprefix + f"_{i:04d}" + output_hdf5_suffix)

                try:
                    shutil.copy(source_hdf5_path_compressed, target_hdf5_path)
                except:
                    shutil.copy(source_hdf5_path, target_hdf5_path)

        sweep_data_path = os.path.join(self.simdir, opts.fileprefix + ".swpdat")
        self._write_swpdat(sweep_data_path)

    def _set_cmd_linux_dispatch(self, lin_cmd):
        """
        Prepare provided cmd that shall be executed via selected windows2linux brigde. cmd is provided as an input argument.
        :param lin_cmd: Command string that shall be executed under linux
        :return: processed cmd string ready to be sent via subprocess, environment necessary to execute command using EoD or ssh.
        """
        opts = self.simOpts

        # Set variables to prepare the environment for linux dispatch
        mods2load = r"lsf/current"
        cmd2exe = r"/usr/bin/xterm"
        arg1 = r"-e"

        # Prepare environment for EoD and ssh
        my_env = os.environ.copy()
        my_env["WINDOWSRD_MOD2LOAD"] = mods2load
        my_env["WINDOWSRD_CMD2EXEC"] = cmd2exe
        my_env["WINDOWSRD_arg1"] = arg1
        my_env["WINDOWSRD_arg2"] = lin_cmd

        # Select connection to unix
        if opts.unix_connection in [r"EoD"]:
            if os.path.isfile(opts.EoD_binary):
                cmd = [opts.EoD_binary, opts.EoD_connectfile]
            else:
                msg = rf"ERROR: The specified path to EoD binary is incorrect: {opts.EoD_binary}"
                raise AttributeError(msg)

        elif opts.unix_connection in [r"ssh"]:
            ssh_bin = shutil.which(opts.ssh_binary)
            if os.path.isfile(ssh_bin):
                cmd = f'start "{lin_cmd}" cmd /c "{ssh_bin} {opts.ssh_opts} {opts.ssh_username}@{opts.ssh_host} {lin_cmd}"'
                print(cmd)
            else:
                msg = rf"ERROR: The specified path to ssh binary is incorrect: {opts.ssh_binary}"
                raise AttributeError(msg)

        elif opts.unix_connection in [r"ETX"]:
            if os.path.isfile(opts.ETX_IE_binary):
                # Select site
                if opts.ETX_site in enums.ETXAddresses.VIH:
                    cmd = f'"{opts.ETX_IE_binary}" "https://etxrnd.vih.infineon.com/etx/#profile=717&commandmacro=WINDOWSRD_MOD2LOAD={mods2load},WINDOWSRD_CMD2EXEC={cmd2exe},WINDOWSRD_arg1={arg1},WINDOWSRD_arg2={lin_cmd}"'
                elif opts.ETX_site in enums.ETXAddresses.SIN:
                    cmd = f'"{opts.ETX_IE_binary}" "https://etxrnd.sin.infineon.com/etx/#profile=155&commandmacro=WINDOWSRD_MOD2LOAD={mods2load},WINDOWSRD_CMD2EXEC={cmd2exe},WINDOWSRD_arg1={arg1},WINDOWSRD_arg2={lin_cmd}"'
                elif opts.ETX_site in enums.ETXAddresses.TEST:
                    # need url encoded form of linux command
                    url_lin_cmd = "%20".join(lin_cmd.split())
                    cmd = (
                        f'"{opts.ETX_IE_binary}" -action launch -url https://etxssdvih.infineon.com -profileid '
                        f"1eaf1a05-60b1-627c-968a-4744de522992 -commandmacro WINDOWSRD_MOD2LOAD={mods2load},"
                        f"WINDOWSRD_CMD2EXEC={cmd2exe},WINDOWSRD_arg1={arg1},WINDOWSRD_arg2={url_lin_cmd}"
                    )
                else:
                    msg = f"No valid site was specified: {opts.ETX_site}, valid sites are vih or sin"
                    raise AttributeError(msg)
            else:
                msg = rf"ERROR: The specified path to Internet Explorer binary is incorrect: {opts.ETX_IE_binary}"
                raise AttributeError(msg)
        else:
            msg = (
                rf"ERROR: Unsupported unix connection chosen: {opts.unix_connection}; supported is either 'ssh', 'ETX' "
                r"or 'EoD'"
            )
            raise AttributeError(msg)

        print(f"Processed command:{cmd}")
        return cmd, my_env

    def _exec_cmd_linux_dispatch(self, exec_cmd, env):
        """
        Execute command provided by exec_cmd via selected wind2lin interface.
        :param self:
        :param exec_cmd: Command to be sent to windows shell via python subprocess
        :param env: environment to be used in shell started by python subprocess, this is not necessary for ETX
        :return: subprocess object that executed command 'exec_cmd'
        """
        opts = self.simOpts

        # Execute Simulation Script
        print(r"Start IFXspice distributed simulation runs.")
        print(f"Executing command via subprocess:{exec_cmd}")
        if opts.unix_connection in [r"ETX"]:
            exec_titan_unix_cmd = Popen(exec_cmd, stdout=PIPE, stderr=PIPE)
            if opts.ETX_site in enums.ETXAddresses.TEST:
                exec_titan_unix_cmd.communicate()
        else:
            exec_titan_unix_cmd = Popen(exec_cmd, env=env, stdout=PIPE, stderr=PIPE, shell=True)
            exec_titan_unix_cmd.communicate()
        return exec_titan_unix_cmd

    def distri_load_results(self):
        """
        Copy simulation results from unix mount to local workspace.

        This can come in quite handy when copying simulation results back to the local workspace fails due to OS/IT infrastructure instabilities.
        This only works for IFXspice distributed mode.
        """
        self._distrib_copy_results()

        self.api.init_rundata()

        if not self.keep_netlists:
            netlists = []
            root, _, filenames = next(iter(os.walk(os.path.dirname(self.simOpts.schematic))))
            for filename in (
                fnmatch.filter(filenames, "*.net")
                + fnmatch.filter(filenames, "*.out")
                + fnmatch.filter(filenames, "*.sxscr")
                + fnmatch.filter(filenames, "*.txt")
            ):  # Find all files with .net extension
                netlists.append(os.path.join(root, filename))
            for netlist in netlists:
                delete(netlist)

    def run(self, addProjectLibs=False, **kwargs):
        if (
            self.simOpts.mode
            in [enums.IFXspiceMode.Local_Windows, enums.IFXspiceMode.Distributed_DE, enums.IFXspiceMode.Distributed_RE]
            and os.name == "nt"
        ):
            self._open_schem_change_workingdir()

        global workingdir_last_run
        self.create_netlist(**kwargs)
        (retcode, paused, indexes) = self.execute_simulation(resume=False)

        self.api.refreshLoadedDataGroups()
        if (
            self.simOpts.mode
            in [enums.IFXspiceMode.Local_Windows, enums.IFXspiceMode.Distributed_DE, enums.IFXspiceMode.Distributed_RE]
            and os.name == "nt"
        ):
            if self.simOpts.schematic is not None:
                self._change_workingdir(os.path.dirname(self.simOpts.schematic))

        # Copy sim data to workingdir
        if self.simOptsTit.mode not in enums.IFXspiceMode.Distributed_RE:
            self._cleanup_simfiles(indexes)

        if retcode == 0:
            self.api.init_rundata()
            workingdir_last_run = self.simdir
            if paused:
                self.api._data_valid = False
                raise SxPaused(self.simdir, self.simOpts.schematic)
            else:
                if not self.keep_netlists:
                    netlists = []
                    root, _, filenames = next(iter(os.walk(os.path.dirname(self.simOpts.schematic))))
                    for filename in (
                        fnmatch.filter(filenames, "*.net")
                        + fnmatch.filter(filenames, "*.out")
                        + fnmatch.filter(filenames, "*.sxscr")
                        + fnmatch.filter(filenames, "*.txt")
                    ):  # Find all files with .net extension
                        netlists.append(os.path.join(root, filename))
                    for netlist in netlists:
                        delete(netlist)
                if self.simOpts.simdata_format not in [enums.SimulationDatatype.SXDAT, enums.SimulationDatatype.HDF5]:
                    self.api.convert_sim_data(indexes)
        else:
            self.logs = None
            self.api._data_valid = False
            msg = r"An error occured during IFXspice Distributed Mode simulation."
            raise IFXspiceError(msg)

    def create_netlist(self, **kwargs):
        opts = self.simOpts
        """:type : _Options_Titan"""
        pverify_mode = kwargs.get("_temp_pverify_mode", False)

        if os.name == "nt":
            try:
                if pverify_mode is True:
                    pass
                else:
                    _Simetrix_Framework.create_netlist(self)

                config_file_path = os.path.join(self.simdir, opts.fileprefix + "_ifxspice.ini")
                with open(config_file_path, "w") as cfg:
                    config = configparser.ConfigParser()
                    config.add_section("IFXspice")
                    config.set("IFXspice", "voltage_plot", str(opts.store_voltage_signals))
                    config.set("IFXspice", "current_plot", str(opts.store_current_signals))
                    config.set("IFXspice", "accuracy", str(opts.accuracy))
                    config.set("IFXspice", "robust", str(opts.robustness))
                    config.set(
                        "IFXspice",
                        "win_dir",
                        str(opts.samba_win)
                        if opts.mode in [enums.IFXspiceMode.Distributed_DE]
                        else str(opts.workingdir),
                    )
                    config.set("IFXspice", "unix_dir", str(opts.samba_unix))
                    config.write(cfg)

                if self._overwrite_run_index is not None:  # For single run by PyVerify
                    indexes = [int(self._overwrite_run_index)]
                    sweep_len = indexes[0] + 1
                else:
                    sweep_len = len(next(iter(opts.sim_params.values())))
                    if opts.subset is None:
                        indexes = list(range(sweep_len))
                    elif type(opts.subset) == tuple:
                        indexes = list(range(opts.subset[0], opts.subset[1] + 1))
                    else:
                        indexes = opts.subset

                # #############################################################################################
                # Simulation Local Windows
                # #############################################################################################
                if opts.mode == enums.IFXspiceMode.Local_Windows:
                    converter_flags = ""
                    if opts.simdata_format == enums.SimulationDatatype.HDF5:
                        converter_flags = r"-P -U"
                    for i in indexes:
                        cmd_titan_netlist_conv = " ".join(
                            [
                                "tictac_simetrix",
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".net"),
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".tit"),
                                "".join(["-C", config_file_path]),
                                converter_flags,
                            ]
                        )

                        conv_netlist_proc = Popen(cmd_titan_netlist_conv, stdout=PIPE, stderr=PIPE)
                        conv_netlist_proc.communicate()
                        if conv_netlist_proc.returncode != 0:
                            msg = "IFXspice netlist converter didn't run correctly!"
                            raise OSError(msg)

                # #############################################################################################
                # Simulation Distributed RE
                # #############################################################################################
                elif opts.mode in [enums.IFXspiceMode.Distributed_RE]:
                    for i in indexes:
                        cmd_titan_netlist_conv = " ".join(
                            [
                                "tictac_simetrix",
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".net"),
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".tit"),
                                "".join(["-C", config_file_path]),
                                "-U -P",
                            ]
                        )

                        conv_netlist_proc = Popen(cmd_titan_netlist_conv, stdout=PIPE, stderr=PIPE)
                        conv_netlist_proc.communicate()
                        if conv_netlist_proc.returncode != 0:
                            msg = "IFXspice netlist converter didn't run correctly!"
                            raise OSError(msg)

                        cmd_titan_copy_files_to_samba = " ".join(
                            [os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".files.bat"), self.simdir]
                        )
                        copy_files_to_samba_proc = Popen(cmd_titan_copy_files_to_samba, stdout=PIPE, stderr=PIPE)
                        copy_files_to_samba_proc.communicate()
                        if copy_files_to_samba_proc.returncode != 0:
                            msg = (
                                "IFXspice copy simulation files to samba directory under windows exited with an error!"
                            )
                            raise OSError(msg)

                # #############################################################################################
                # Simulation Distributed DE
                # #############################################################################################
                elif opts.mode in [enums.IFXspiceMode.Distributed_DE]:
                    # Clean Samba Workspace
                    print("Cleanup Workspace")
                    # Check if samba dir win exists, if not create it
                    if not os.path.exists(opts.samba_win):
                        os.makedirs(opts.samba_win)

                    ifxspice_distri_clean = os.path.join(opts.samba_win, "srd.clean.txt")
                    if os.path.isfile(ifxspice_distri_clean):
                        os.remove(ifxspice_distri_clean)

                    # Execute Cleanup Script
                    ifxspice_clear_disc_call = rf"{opts.ifxspice_root_unix}/ifxspice_sweep_cleardir {opts.samba_unix}"

                    cmd_ifxspice_clear_disc, my_env = self._set_cmd_linux_dispatch(lin_cmd=ifxspice_clear_disc_call)
                    exec_titan_samba_clean = self._exec_cmd_linux_dispatch(exec_cmd=cmd_ifxspice_clear_disc, env=my_env)
                    if exec_titan_samba_clean.returncode not in [0, None]:
                        msg = f"IFXspice distributed mode cleanup script did not work correctly!\n{exec_titan_samba_clean._stderr_buff}"
                        raise OSError(msg)
                    count = 0
                    while count != 300:
                        if os.path.isfile(ifxspice_distri_clean):
                            os.remove(ifxspice_distri_clean)
                            break
                        time.sleep(1)
                        count += 1
                    else:
                        print("Timeout occured after more then 5 minutes.")

                    # Set flags for IFXspice converter depending on selected Dataformat
                    converter_flags = "-P" if opts.simdata_format not in enums.SimulationDatatype.HDF5 else "-P -U"

                    for i in indexes:
                        simetrix_netlist_path = os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".net")

                        cmd_titan_netlist_conv = " ".join(
                            [
                                "tictac_simetrix",
                                simetrix_netlist_path,
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".tit"),
                                "".join(["-C", config_file_path]),
                                converter_flags,
                            ]
                        )

                        conv_netlist_proc = Popen(cmd_titan_netlist_conv, env=my_env, stdout=PIPE, stderr=PIPE)
                        conv_netlist_proc.communicate()
                        if conv_netlist_proc.returncode != 0:
                            msg = "IFXspice netlist converter didn't run correctly!"
                            raise OSError(msg)

                        cmd_titan_copy_files_to_samba = " ".join(
                            [
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".files.bat"),
                                os.path.abspath(os.path.join(opts.samba_win, f"run{i}")),
                            ]
                        )
                        # Test workaround
                        old_dir = os.getcwd()
                        os.chdir(self.simdir)

                        copy_files_to_samba_proc = Popen(
                            cmd_titan_copy_files_to_samba, env=my_env, stdout=PIPE, stderr=PIPE
                        )
                        copy_files_to_samba_proc.communicate()
                        if copy_files_to_samba_proc.returncode != 0:
                            msg = (
                                "IFXspice copy simulation files to samba directory under windows exited with an error!"
                            )
                            raise OSError(msg)

                        # Copy additional files to each run directory
                        if opts.copy_additional_files_distributed_de is not None:
                            print("Copying additional files to run directory.")
                            for file in opts.copy_additional_files_distributed_de:
                                # Check if file dir exists on target location, if not create it
                                target_file_path = os.path.abspath(os.path.join(opts.samba_win, f"run{i}", file))
                                if not os.path.exists(os.path.dirname(target_file_path)):
                                    os.makedirs(os.path.dirname(target_file_path))

                                shutil.copy(os.path.join(self.simdir, file), target_file_path)
                        # Test workaround
                        os.chdir(old_dir)
                # os.environ["PATH"] = os_env_prev
            except:
                # os.environ["PATH"] = os_env_prev
                msg = f"ERROR: netlist creation failed:\n{traceback.format_exc()}!"
                raise Exception(msg)

        elif os.name == "posix":
            if opts.mode == enums.IFXspiceMode.Distributed_RE:
                print(
                    "Titan netlisting skipped under unix, utilizing netlists stored in linked unix drive for simulation."
                )
            elif opts.mode == enums.IFXspiceMode.Local_Windows:
                msg = "Windows netlisting and simulation cannot be performed on a unix platform."
                raise OSError(msg)

    def execute_simulation(self, resume=False, timeout=None):
        opts = self.simOpts
        """:type: _Options_Titan """

        if self._overwrite_run_index is not None:  # For single run by PyVerify
            indexes = [int(self._overwrite_run_index)]
            sweep_len = indexes[0] + 1
        else:
            sweep_len = len(next(iter(opts.sim_params.values())))
            if opts.subset is None:
                indexes = list(range(sweep_len))
            elif type(opts.subset) == tuple:
                indexes = list(range(opts.subset[0], opts.subset[1] + 1))
            else:
                indexes = opts.subset
        if (os.name == "nt" and opts.mode in [enums.IFXspiceMode.Local_Windows, enums.IFXspiceMode.Distributed_DE]) or (
            os.name == "posix" and opts.mode in [enums.IFXspiceMode.Distributed_RE]
        ):
            for i in indexes:
                if i < 0 or i >= sweep_len:
                    msg = f"Index for swept run out legal range 0-{sweep_len - 1}:{i}"
                    raise UsageError(msg)

            # #############################################################################################
            # Simulation Local Windows
            # #############################################################################################
            if opts.mode == enums.IFXspiceMode.Local_Windows:
                track_feature(FEATURES.srd_runsim_titan + "_localwin")
                minimized = ""
                sweep_data_path = os.path.join(self.simdir, opts.fileprefix + ".swpdat")

                os_env_prev = os.environ["PATH"]
                try:
                    return_code_IFXspice_filename = os.path.join(self.simdir, "return_ifxspice_titan_bat.txt")
                    for i in indexes:
                        if opts.run_minimized:
                            minimized = "/MIN"
                        cmd_titan_win_sim = " ".join(
                            [
                                f"Start {minimized} /wait titan.bat",
                                os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".tit"),
                                "/alwaysexit",
                                "-savedir",
                                self.simdir,
                            ]
                        )
                        # cmd_titan_win_sim = " ".join(["Start /wait titan.bat", os.path.join(self.simdir, opts.fileprefix + "_{:04d}".format(i) + ".tit"), "-savedir", self.simdir])

                        conv_netlist_proc = Popen(
                            cmd_titan_win_sim, stdout=PIPE, stderr=PIPE, shell=True, cwd=self.simdir
                        )
                        conv_netlist_proc.communicate()
                        if conv_netlist_proc.returncode != 0:
                            msg = "Titan simulation didn't run correctly for run:{}. For more information please open file: {} and {}!".format(
                                i,
                                os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".tit.msg"),
                                os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".tit.lis"),
                            )
                            raise OSError(msg)
                        elif os.path.isfile(return_code_IFXspice_filename):
                            with open(return_code_IFXspice_filename) as file:
                                content = file.read()

                            os.remove(return_code_IFXspice_filename)
                            if len(content):
                                msg = "{} occured in IFXspice run {}. For more information please open file: {} and {}!".format(
                                    content,
                                    i,
                                    os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".tit.msg"),
                                    os.path.join(self.simdir, self.simOpts.fileprefix + f"_{i:04d}" + ".tit.lis"),
                                )
                                raise OSError(msg)

                    self._write_swpdat(sweep_data_path)

                    if opts.simdata_format not in enums.SimulationDatatype.HDF5:
                        # write simetrix script to convert sim res data from sweep
                        convert_to_sxdat_script_path = os.path.join(
                            self.simdir, opts.fileprefix + "_convert_to_sxdat.sxscr"
                        )
                        with open(convert_to_sxdat_script_path, "w") as scr:
                            print(r"* Code Generated by SRD to convert IFXspice csdf to sxdat", file=scr)
                            for i in indexes:
                                print(
                                    " ".join(
                                        [
                                            "OpenRawFile /noerr /csdf",
                                            os.path.join(
                                                self.simdir,
                                                opts.fileprefix + f"_{i:04d}" + opts.simulation_result_suffix,
                                            ),
                                        ]
                                    ),
                                    file=scr,
                                )
                                print(
                                    " ".join(
                                        [
                                            "SaveGroup /force",
                                            os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".sxdat"),
                                        ]
                                    ),
                                    file=scr,
                                )

                        self.simetrixCmd(os.path.basename(convert_to_sxdat_script_path), idnum=opts.idnum)
                    else:
                        # Setup Simulation Result file names
                        if opts._opts_container["analysis"] == enums.AnalysisType.TRAN:
                            output_scope_suffix = r".tr.ai_pl"
                            output_hdf5_suffix = r".tr.h5"
                        elif opts._opts_container["analysis"] == enums.AnalysisType.DC:
                            output_scope_suffix = r".dc.ai_pl"
                            output_hdf5_suffix = r".dc.h5"
                        elif opts._opts_container["analysis"] == enums.AnalysisType.AC:
                            output_scope_suffix = r".ac.ai_pl"
                            output_hdf5_suffix = r".dc.h5"

                        # convert the data
                        for i in indexes:
                            output_scope_name = os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}")
                            output_hdf5_name = os.path.join(
                                self.simdir, opts.fileprefix + f"_{i:04d}" + output_hdf5_suffix
                            )
                            cmd_titan_windows_hdf5_write = [
                                "IFXspiceWV.exe",
                                "-hdf5",
                                output_hdf5_name,
                                output_scope_name + output_scope_suffix,
                            ]
                            exec_titan_unix_hdf5_write = Popen(cmd_titan_windows_hdf5_write, stdout=PIPE, stderr=PIPE)
                            exec_titan_unix_hdf5_write.communicate()
                            if exec_titan_unix_hdf5_write.returncode != 0:
                                msg = f"Titan HDF5 writer didn't run correctly for run:{i}!"
                                raise OSError(msg)

                except:
                    os.environ["PATH"] = os_env_prev

                os.environ["PATH"] = os_env_prev

            # #############################################################################################
            # Simulation Distributed DE
            # #############################################################################################
            elif opts.mode == enums.IFXspiceMode.Distributed_DE:
                track_feature(FEATURES.srd_runsim_titan + "_distDE")

                exec_titan_unix_sim = self._distrib_dispatch_simulation()
                count = 0
                simulation_running = True
                while simulation_running:
                    if count > 36000:
                        msg = r"IFXspice distributed simulation ran over 10h, script aborted."
                        raise TimeoutError(msg)
                    time.sleep(0.5)
                    count = count + 1
                    proc_ret = exec_titan_unix_sim.poll()
                    if proc_ret is not None:
                        simulation_running = False

                if proc_ret not in [0]:
                    self.ifxspice_error = True

                self._distrib_copy_results(indexes=indexes)
                # if self.simOpts.simdata_format not in [enums.SimulationDatatype.SXDAT, enums.SimulationDatatype.HDF5]:
                # self.api.convert_sim_data(indexes)

            # #############################################################################################
            # Simulation Distributed RE
            # #############################################################################################
            elif opts.mode == enums.IFXspiceMode.Distributed_RE:
                track_feature(FEATURES.srd_runsim_titan + "_distRE")
                sweep_data_path = os.path.join(self.simdir, opts.fileprefix + ".swpdat")
                # 1.Set environment - tbd

                # Setup Simulation Result file names
                if opts._opts_container["analysis"] == enums.AnalysisType.TRAN:
                    output_scope_suffix = r".tr.ai_pl"
                elif opts._opts_container["analysis"] == enums.AnalysisType.DC:
                    output_scope_suffix = r".dc.ai_pl"
                elif opts._opts_container["analysis"] == enums.AnalysisType.AC:
                    output_scope_suffix = r".ac.ai_pl"
                else:
                    msg = "Selected Analysis is not supported: {}".format(opts._opts_container["analysis"])
                    raise ValueError(msg)
                for i in indexes:
                    output_scope_name = os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}")
                    output_hdf5_name = os.path.join(self.simdir, opts.fileprefix + "_Titan" + f"_{i:04d}" + ".h5")
                    cmd_titan_unix_sim = [
                        "titan",
                        "-info",
                        "wait",
                        "-ifxspice",
                        "-verbose",
                        "on",
                        "-o",
                        output_scope_name,
                        os.path.join(self.simdir, opts.fileprefix + f"_{i:04d}" + ".tit"),
                    ]
                    exec_titan_unix_sim = Popen(cmd_titan_unix_sim, stdout=PIPE, stderr=PIPE)
                    exec_titan_unix_sim.communicate()
                    if exec_titan_unix_sim.returncode != 0:
                        msg = f"Titan simulation didn't run correctly for run:{i}!"
                        raise OSError(msg)

                self._write_swpdat(sweep_data_path)

                # Call IFXspice waveviewer to convert sim data file to hdf5
                for i in indexes:
                    cmd_titan_unix_hdf5_write = [
                        r"/opt/titan/ifxspice/ifxwave/ifxwave",
                        "-local",
                        "-hdf5",
                        output_hdf5_name,
                        output_scope_name + output_scope_suffix,
                    ]
                    exec_titan_unix_hdf5_write = Popen(cmd_titan_unix_hdf5_write, stdout=PIPE, stderr=PIPE)
                    exec_titan_unix_hdf5_write.communicate()
                    if exec_titan_unix_hdf5_write.returncode != 0:
                        msg = f"Titan HDF5 writer didn't run correctly for run:{i}!"
                        raise OSError(msg)
                self._cleanup_simfiles(indexes)
        else:
            if opts.mode == enums.IFXspiceMode.Local_Windows:
                msg = "Cannot run IFXspice local windows mode simulation on a posix platform."
                raise OSError(msg)
            elif opts.mode == enums.IFXspiceMode.Distributed_RE:
                print("Simulation for mode IFXspice Distributed mode for Regression is skipped under windows.")
        runres = 1 if self.ifxspice_error is True else 0
        paused = False
        return runres, paused, indexes

    def resume(self):
        """
        Resume analysis halted by interactive pause in analog simulator

        Log files and probe-datasets are OVERWRITTEN!
        """

        msg = "Resume functionality is not available for IFXspice simulation."
        raise NotImplementedError(msg)

    def _cleanup_simfiles(self, indexes):
        """
        Cleansdir folder after simulation was conducted; Copies and Removes all simulation files, dependent on the
        verbosity level defined within the simulation options container.
        """
        opts = self.simOpts
        """:type: _Options_Titan """

        # Copy files from simdir to workingdir depending on verbosity level
        if self.simOpts.verbose == 0:
            files_to_copy = enums.CopyFiles.IFXspice_verbose_0
        elif self.simOpts.verbose == 1:
            files_to_copy = enums.CopyFiles.IFXspice_verbose_1
        else:
            files_to_copy = []
        self._copy_simfiles(files_to_copy, indexes)

        # Remove files from simdir
        if opts.mode != enums.IFXspiceMode.Distributed_RE:
            files_to_remove = enums.CleanupFiles.IFXspice
            self._remove_simfiles(files_to_remove, indexes)


class AMSDesigner(Simulator):
    def __init__(self, ref_analysis):
        Simulator.__init__(self, ref_analysis, simulator_name="amsdesigner")
        # self._simulator = "AMSDesigner"

    def startSimulator(cls, idnum=None):
        """Dummy function, no frontend needed."""

    def _init_sx_log(self, console_log_path=None):
        """
        Dummy function, runams output can't be redirected.
        """

    def _close_sx_log(self):
        """
        Dummy function, runams output can't be redirected.
        """

    def run(self, addProjectLibs=False, **kwargs):
        opts = self.simOpts
        """:type : _Options_AMSDesigner """

        if self._overwrite_run_index is not None:  # For single run by PyVerify
            indexes = [int(self._overwrite_run_index)]
            sweep_len = indexes[0] + 1
        else:
            sweep_len = len(next(iter(opts.sim_params.values())))
            if opts.subset is None:
                indexes = list(range(sweep_len))
            elif type(opts.subset) == tuple:
                indexes = list(range(opts.subset[0], opts.subset[1] + 1))
            else:
                indexes = opts.subset

        self._create_tcl_command_file(indexes)

        retcode = self.execute_simulation(indexes)

        # self.api.refreshLoadedDataGroups()

        if retcode == 0:
            self.api.init_rundata()
            if self.simOpts.verbose == 0:
                for i in indexes:
                    shutil.rmtree(os.path.join(self.simdir, "run_" + str(i)))
        else:
            self.logs = None
            self.api._data_valid = False
            msg = f"Simulation exited with errorcode: {retcode}"
            raise AMSDesignerError(msg)

    def stopSimulator(cls, idnum=None):
        """Dummy function, no frontend needed"""

    def _create_tcl_command_file(self, indexes):
        """
        Generate the tcl command file to control simulation run.
        This file defines all signals that will be stored.
        """
        opts = self.simOpts
        """ :type : _Options_AMSDesigner"""

        for i in indexes:
            tcl_command_script_path = os.path.join(
                self.simdir, "run_" + str(i), self.simOpts.fileprefix + "_command.tcl"
            )
            run_dir = os.path.join(self.simdir, "run_" + str(i), "psf")
            vcd_file_name = f"{self.simOpts.fileprefix}_{i:04d}.vcd"
            if not os.path.exists(os.path.dirname(tcl_command_script_path)):
                os.makedirs(os.path.dirname(tcl_command_script_path))
            with open(tcl_command_script_path, "w") as scr:
                print(r"# Code Generated by SRD", file=scr)
                print(r"# Database settings", file=scr)
                print(f"database -open srd_database -into {run_dir} -default -shm", file=scr)
                print("\n# Probe settings", file=scr)

                # Write net probe statements
                if opts.save_nets is not None:
                    save_nets = opts.save_nets
                    depth = save_nets[save_nets.index("-depth") + 1] if "-depth" in save_nets else "all"
                    domain = save_nets[save_nets.index("-domain") + 1] if "-domain" in save_nets else "analog"
                    if ("-all") in save_nets:
                        print(
                            rf"probe -create -emptyok -database srd_database -all -depth {depth} -domain {domain} {{{opts.cell}}}",
                            file=scr,
                        )
                    elif ("-ports") in save_nets:
                        if save_nets[save_nets.index("-ports") + 1] in ["inputs", "outputs"]:
                            ports = "-" + save_nets[save_nets.index("-ports") + 1]
                        else:
                            ports = r""
                        print(
                            rf"probe -create -emptyok -database srd_database -aicms -ports {ports} -depth {depth} -domain {domain} {{{opts.cell}}}",
                            file=scr,
                        )
                    else:
                        for net in save_nets:
                            print(rf"probe -create -emptyok {net}", file=scr)

                # Write connect module net probe statements
                if opts.save_connectmodules is not None:
                    save_connectmodules = opts.save_connectmodules
                    if ("-depth") in save_connectmodules:
                        depth = save_connectmodules[save_connectmodules.index("-depth") + 1]
                    else:
                        depth = "all"
                    if ("-all") in save_connectmodules:
                        print(
                            rf"probe -create -emptyok -database srd_database -aicms -all -depth {depth} {{{opts.cell}}}",
                            file=scr,
                        )
                    elif ("-ports") in save_connectmodules:
                        if save_connectmodules[save_connectmodules.index("-ports") + 1] in ["inputs", "outputs"]:
                            ports = r"-" + save_connectmodules[save_connectmodules.index("-ports") + 1]
                        else:
                            ports = r""
                        print(
                            rf"probe -create -emptyok -database srd_database -aicms -ports {ports} -depth {depth} {{{opts.cell}}}",
                            file=scr,
                        )
                    else:
                        for connectmodule in save_connectmodules:
                            print(rf"probe -create -emptyok {connectmodule}", file=scr)

                # Write current probe statements
                if opts.save_currents is not None:
                    save_currents = opts.save_currents
                    if ("-all") in save_currents:
                        depth = save_currents[save_currents.index("-depth") + 1] if "-depth" in save_currents else "all"
                        print(
                            rf"probe -create -emptyok -database srd_database -flow -ports -index -depth {depth} "
                            rf"{{{opts.cell}}}",
                            file=scr,
                        )
                    else:
                        for current in save_currents:
                            if current.endswith(r"_$flow"):
                                current = current.rsplit(r"_$flow", 1)[0]
                            print(rf"probe -create -emptyok -flow {current}", file=scr)

                # Write cdsglobals probe statements
                if opts.save_cdsglobals is True:
                    print(r"probe -create -emptyok -database srd_database -all cds_globals", file=scr)

                # Write custom tickle command
                if opts.user_tcl is not None:
                    print("\n# --- user defined TCL start ---", file=scr)
                    print(f"\n{opts.user_tcl}", file=scr)
                    print("\n# --- user defined TCL end ---", file=scr)
                if opts.tstop is not None:
                    print("\nrun -sync", file=scr)
                    print(f"analog -stop {opts.tstop}s", file=scr)
                    print(f"run {opts.tstop}s", file=scr)
                else:
                    print("\nrun", file=scr)
                print("\ndatabase -close srd_database", file=scr)
                print(
                    f"\ncatch {{simvisdbutil -vcd -overwrite -output {self.simdir}/{vcd_file_name} {run_dir}}} errmsg",
                    file=scr,
                )
                print("\nexit", file=scr)

    def _check_for_temp_option(self, rundir):
        """
        Check if in <rundir>/psf/irun.log an SFE-884 can be found if opt.temp is not None.
        Give warning if found.
        """
        if self.simOpts.temp is not None:
            irun_log_fn = os.path.join(rundir, "psf", "irun.log")
            try:
                with open(irun_log_fn) as irun_log:
                    while True:
                        line = irun_log.readline()
                        if not line:
                            break
                        if "SFE-884" in line:
                            warn_msg = irun_log_fn + ":\n" + line
                            for _i in range(3):
                                warn_msg += irun_log.readline()
                            self._log.warning(warn_msg)
                            break
            except:
                pass

    def _log_stdout_stderr(self, cmd_log, ret_code, current_rundir, header=None):
        """
        If verbose log stdout and stderr.
        Write stdout and stderr in case of a simulation error to files and log filenames.
        :param cmd_log: list
        :param ret_code: int
        :param current_rundir: string
        :param header: string
        :return: string
        """
        cmd_log_files = "runams stdout/stderr file(s):" if header is None else header
        if cmd_log[0] is not None:  # stdout
            self._log.debug(cmd_log[0].decode(errors="ignore"))
            if ret_code != 0:
                cmd_log_path = os.path.join(current_rundir, "runams_stdout.log")
                cmd_log_files += "\n   " + cmd_log_path
                with open(cmd_log_path, "w") as cmd_log_file:
                    print(cmd_log[0].decode(errors="ignore"), file=cmd_log_file)
        if cmd_log[1] is not None:  # stderr
            # Avoid error log otherwise Avenue will mark the run as failed
            self._log.warning(cmd_log[1].decode(errors="ignore"))
            if ret_code != 0:
                cmd_log_path = os.path.join(current_rundir, "runams_stderr.log")
                cmd_log_files += "\n   " + cmd_log_path
                with open(cmd_log_path, "w") as cmd_log_file:
                    print(cmd_log[1].decode(errors="ignore"), file=cmd_log_file)
        return cmd_log_files

    def execute_simulation(self, indexes):
        """
        Calls runams command to execute the simulation.
        """
        opts = self.simOpts
        """:type : _Options_AMSDesigner """

        sweep_dat_path = os.path.join(self.simOpts.workingdir, opts.fileprefix + ".swpdat")

        ##########################################################################################
        ## Setup runams_cmd
        ##########################################################################################

        runams_cmd = [None] * len(indexes)
        current_rundir = [None] * len(indexes)

        for idx, i in enumerate(indexes):
            current_rundir[idx] = os.path.join(self.simdir, "run_" + str(i))

            current_sim_params_list = []
            for key in opts.sim_params:
                val = opts.sim_params[key][idx]
                if isinstance(val, Stimulus):
                    stimfile = os.path.join(current_rundir[idx], self.simOpts.fileprefix + f"_{key}")
                    with open(stimfile, "w") as f:
                        f.write(str(val))
                    val = f'"{stimfile}"'
                elif isinstance(val, str):
                    try:
                        float(val)  # Try to convert to float/int if string value is a number
                        val = eval(val)
                    except:
                        val = f'"{val!s}"'
                if isinstance(val, str) and ":" in val:
                    self._log.warning(
                        f"Sim parameter '{key}' contains ':', so the following simulation is probably going to fail!"
                    )
                current_sim_params_list += ["=".join([key, str(val)])]
            current_sim_params = ":".join(current_sim_params_list)

            tcl_command_script_path = os.path.join(current_rundir[idx], self.simOpts.fileprefix + "_command.tcl")

            runams_cmd[idx] = [
                "runams",
                "-lib",
                opts.lib,
                "-cell",
                opts.cell,
                "-view",
                opts.view,
                "-netlist",
                "all",
                "-simulate",
                opts.sim_mode,
                "-state",
                opts.state,
                "-tclinput",
                tcl_command_script_path,
                "-desvar",
                current_sim_params,
                "-rundir",
                current_rundir[idx],
                "-log",
                os.path.join(current_rundir[idx], "runams.log"),
            ]

            if opts.temp is not None:
                opt_temp_fn = os.path.join(current_rundir[idx], "opt_temp.scs")
                with open(opt_temp_fn, "w") as opt_temp_file:
                    print(f"pv_temp options temp={opts.temp}", file=opt_temp_file)
                    runams_cmd[idx].extend(["-irunopts", opt_temp_fn])

            if opts.cdslib is not None:
                runams_cmd[idx].extend(["-cdslib", opts.cdslib])

            if opts.unit is not None:
                runams_cmd[idx].extend(["-iw_unit", opts.unit])

            if opts.sim_exec_mode == "local":
                runams_cmd[idx].extend(["-eh_local"])

            if opts.runams_opts is not None:
                additional_runams_opts = opts.runams_opts.split()
                runams_cmd[idx].extend(additional_runams_opts)

            self._log.debug("Runamscmd: '{}'".format("' '".join(runams_cmd[idx])))

        track_feature(FEATURES.srd_runsim_amsdesigner + f"_{opts.sim_exec_mode}")

        ##########################################################################################
        ## Sequential Sim Run Mode
        ##########################################################################################

        if opts.sim_exec_mode in ["sequential", "local"]:
            for idx, i in enumerate(indexes):
                process = subprocess.Popen(runams_cmd[idx], stdout=PIPE, stderr=PIPE)
                cmd_log = process.communicate()
                ret_code = process.returncode
                cmd_log_files = self._log_stdout_stderr(cmd_log, ret_code, current_rundir[idx])
                self._check_for_temp_option(current_rundir[idx])
                if ret_code != 0:
                    self._log.warning(cmd_log_files)
                    break

        ##########################################################################################
        ## Parallel Sim Run Mode
        ##########################################################################################

        elif opts.sim_exec_mode == "parallel":
            processes = [subprocess.Popen(runams_cmd[idx], stdout=PIPE, stderr=PIPE) for idx, i in enumerate(indexes)]

            exit_codes = [p.wait() for p in processes]
            cmd_log_files = None
            for idx, i in enumerate(indexes):
                cmd_log = processes[idx].communicate()
                cmd_log_files = self._log_stdout_stderr(cmd_log, exit_codes[idx], current_rundir[idx], cmd_log_files)
                self._check_for_temp_option(current_rundir[idx])

            # Write swpdat file
            if all(ret_code == 0 for ret_code in exit_codes):
                self._write_swpdat(sweep_dat_path)
                ret_code = 0
            else:
                self._log.warning(cmd_log_files)
                ret_code = 1

        return ret_code


def SimulatorClass(simulator_id):
    """

    Parameters
    ----------
    simulator_id
        string simulator identifier (one of 'enums.Simulator')
    Returns
    -------
        constructor for Simulator sub-class for simulator 'simulator_id'
    """
    if simulator_id == enums.SimulatorType.Simetrix:
        return Simetrix
    elif simulator_id == enums.SimulatorType.Simplis:
        return Simplis
    elif simulator_id == enums.SimulatorType.Titan:
        return Titan
    elif simulator_id == enums.SimulatorType.SystemC:
        msg = "Simulator 'SystemC' not yet supported"
        raise UsageError(msg)
    else:
        raise UsageError("Simulator '" + simulator_id + "' unknown")


def SimulatorFactory(simulator_id, *args, **kwargs):
    """
    Factory for 'Simulator' objects

    Parameters
    ----------
    simulator_id
        string simulator identifier (one of 'enums.Simulator')
    args
        positional args to pass to Simulator constructor
    kwargs
        keyword args for Simulator constructor

    Returns
    -------

    """
    return SimulatorClass(simulator_id)(*args, **kwargs)
