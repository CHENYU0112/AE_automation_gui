from __future__ import annotations

from ctypes import *

__all__ = [
    "BOOL",
    "VectorDataOptions",
    "ErrorCode",
    "OpMode",
    "O_None",
    "O_Literal",
    "O_All",
    "DataType",  # Type defs
    "Error",
    "IFCERRCodeError",
    "NumpyIfcError",
    "SxCmdERRCodeError",
    "UsageError",
    "SxPaused",
    "E",
    "V",
    "D",
    "AMSDesignerError",
    "IFXspiceError",
]


#   Create a class mirroring a C enumerated type
#    associating name strings and explanations strings with the defined constants
#
#    Constants are defined by a list of ((name,value),explanation) or (name,explantion)
#    tuples.
#
#    Instances of the resulting class have members self.name for each name in the last
#
#    As in C the default value for a name if none is explicitly given is
#    that of its predecessor + 1.  The default value for the first name is 0.
#
#    @param enum_name  Name of created class object
#    @param definitions definitions list of  ((name,value),explanation) or (name,explanation tuples
#    @c self.names(constant) returns name associated with constant
#
#   @c self.explanations(constant) returns explanation string associated with constant
def docenum(enum_name, definitions):
    """
    Create instance of class mirroring a C enumerated type

    self.<enum_const_from_definitions> returns value associate with enumerated constant

    self.names(constant) returns name associated with constant
    self.explanations(constant) returns explanation string associated with constant

    Parameters
    ----------
        enum_name : string
            Name of created class object
        definitions: list of  ((name,value),explanation) or (name,explanation) tuples
    Returns
    ------
        Instance of class enum_name

    """

    class_dict = {}
    explanation_dict = {}
    naming_dict = {}
    curvalue = 0
    for name_def, explanation in definitions:
        if type(name_def) == tuple:
            name = name_def[0]
            val = name_def[1]
            curvalue = val + 1
        else:
            name = name_def
            val = curvalue
            curvalue = curvalue + 1
        class_dict[name] = val
        naming_dict[val] = name
        explanation_dict[val] = explanation
    class_dict["naming_dict"] = naming_dict
    class_dict["explanation_dict"] = explanation_dict
    class_dict["names"] = lambda self, code: (self.naming_dict.get(code, "undefined"))
    class_dict["explanations"] = lambda self, code: (self.explanation_dict.get(code, "undefined"))
    return type(enum_name, (), class_dict)()


# ---------- Type definitions ----------
BOOL = c_ubyte
VectorDataOptions = c_uint
ErrorCode = c_uint
OpMode = c_uint
O_None = 0  # Don't return operating point values
O_Literal = 1  # Return op values for non-aliassed vectors only
O_All = 2  # return op values for all vectors. WARNING: can be a resource and time hungry operation
DataType = c_uint


# enum class mirroring SRD_ErrorCode
E = docenum(
    "SRD_ErrorCode",
    [
        ("Ok", "Ok"),
        ("ConnectionClosed", "Connection to SIMetrix is broken. Usually because SIMetrix is not running"),
        ("BadHandle", "An invalid handle was passed to an interface function"),
        ("BadVectorData", "Bad pointer to SRD_VectorData passed to destroyData"),
        ("BadVersion", "Interface version is not compatible"),
        ("BadArgs", "Arguments passed to interface function bad."),
        ("NoGroup", "Group name passed does not exist"),
        ("AllocFail", "Allocation failed in SIMetrix"),
        ("BadDivisionIndex", "Division index out of range"),
        ("BadOffset", "Offset out ofrange"),
        ("BadXVec", "Request for X-values but vector does not have any x-values (aka 'reference' see notes)"),
        ("NoVec", "Vector name unknown"),
        ("BadAlias", "Alias could not be resolved"),
        ("BadCommand", "Bad command sent to SIMetrix. (internal error) "),
        ("Exception", "SIMetrix threw an exception while handling the interface request (internal error) "),
        ("Unknown", "unknown error (internal error) "),
        ("UnexpectedReply", "Unexpected reply from SIMetrix (internal error) "),
        ("UnexpectedDataType", "Interface returned an unexpected data type (internal error)"),
        ("UnsupportedXDataType", "Interface returned an unexpected data type for the x-values (internal error) "),
        ("SXRDIF_Incompatible", "Wrong version of sxrdif is being used for SIMetrix"),
    ],
)


# enum class mirroring SRD_ErrorCode
V = docenum(
    "SRD_VectorDataOptions",
    [
        ("Y", "Return Y data only"),
        ("X", "Return X (ref) data only"),
        ("XY", "Return both X and Y data"),
        ("AliasLiteral", "If data is an alias, don't resolve the alias, just return its literal string value"),
    ],
)


D = docenum(
    "D_enum",
    [
        ("Real", "Data of type double"),
        ("Complex", "Data of type SRD_Complex"),
        ("String", "Data of type const char *"),
        ("Unknown", "Unknown data"),
    ],
)


# Error exception base-class
class Error(Exception):
    """
    Base class for SRD exceptions

    :var msg: Explanation of error
    :type msg: str
    """

    msg = "uninitialzed"

    def __repr__(self):
        return '<SRD.Error "' + self.msg + '">'

    def __str__(self):
        return "SRD.Error: " + self.msg

    def _repr_pretty_(self, p, _):
        return p.text('<SRD.Error "' + self.msg + '">')


# Error exception for error returns from C interface
class IFCERRCodeError(Error):
    """
    Exceptions raised in reponse to error returns from C interface:

    :var code: Error code
    :type code: int
    """

    def __init__(self, code, context):
        self.code = code
        name = E.names(code)
        explanation = E.explanations(code)
        callcontext = ""
        if context is not None:
            callcontext = " " + context
        self.msg = "SIMetrix Remote Data call%s failed: (%d) %s - %s" % (callcontext, code, name, explanation)


# Error exception for error returns from Numpy apaptation layer
class NumpyIfcError(Error):
    """
    Exceptions raised at C/Numpy interface adatpor level
    """

    def __init__(self, msg):
        self.msg = msg


class SxCmdERRCodeError(Error):
    """
    Exceptions raised when remotely trigger SIMetrix command fails:

    :var code: Error code
    :type code: int
    """

    def __init__(self, code, command, context):
        self.code = code
        self.msg = "SIMetrix Remote Command failure code %d: running: %s - %s " % (code, command, context)


class UsageError(Error):
    """
    Exceptions raised in reponse to error returns from C interface:
    """

    def __init__(self, explanation):
        self.msg = "Incorrect usage: " + explanation


class SxPaused(Error):
    """
    Exception raised when Simulation was manually paused
    """

    def __init__(self, basepathname, schematic):
        if schematic is None:
            schematic = "<current>"
        self.msg = (
            f"Simulation schematic {schematic}  to {basepathname} was paused - can be resumed using resume() function"
        )


class AMSDesignerError(Error):
    """
    Exception raised when AMSDesigner simulation exited with an error.
    """

    def __init__(self, msg):
        self.msg = msg


class IFXspiceError(Error):
    """
    Exception raised when IFXspice simulation exited with an error.
    """

    def __init__(self, msg):
        self.msg = msg
