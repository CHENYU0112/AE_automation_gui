from __future__ import annotations

import contextlib
import getpass
import itertools
import os
import re
import shutil
import sys

from srd.internal.simulator.errors import *
from srd.internal.utils import enums
from srd.internal.utils.helperclasses import CaseInsensitiveDict
from srd.internal.utils.spice_formatter import spiceEval
from srd.util.ifxspice import find_ifxspice_and_update_env

# workaround to make this file compatible with odl and newer python versions
# https://stackoverflow.com/questions/53978542/how-to-use-collections-abc-from-both-python-3-8-and-python-2-7
try:
    import collections.abc as collectionsAbc
except ModuleNotFoundError:
    import collections as collectionsAbc

BIT64 = sys.maxsize > 2**32

# --------------- Utility ---------------- #


class SimParamSweep:
    """
    Container for Parameter Sweeps. Several methods to manipulate the parameter sweep are available.
    """

    def __init__(self, param_dict=None):
        if param_dict is None:
            param_dict = {}
        if isinstance(param_dict, dict):
            self.sim_params = param_dict
            """ :type : dict() """
        elif isinstance(param_dict, SimParamSweep):
            self.sim_params = param_dict.sim_params
            """ :type : dict() """
        else:
            msg = (
                "The input to SimParamSweep class must be of type dictionary or SimParamSweep. "
                f"Input given is of type: {type(param_dict)}"
            )
            raise TypeError(msg)

    def addToSimParams(self, key, value):
        """Extend sweep sequence for simulation parameter

        Swept sequence for simulation parameter `key` is
        extended with `value` (set to `value` if no sequence
        is specified for `key`)
        """
        self.__seq_dict_append(self.sim_params, key, value)

    def __seq_dict_append(self, base, key, value):
        """Append value to sequence under key in dict-of-seq

        ``base[key]`` has ``value`` appended
        If `key` not already present ``base[key]`` is set to ``[value]``
        """
        existing = base.get(key)
        if existing is not None:
            existing += [value]
        else:
            base[key] = [value]

    def extendsweep(self, change_dict):
        """Extend sweep simulation parameters by an additional sweep point

        Sequences for existing parameters not specified in change_dict are
        extended to implied sweep length by replicating last value.
        Sequences for new parameters are extended by replicating specified
        value to match implied sweep length.

        Parameters
        ----------
        change_dict: dict string to real|string
            name-value dictionary of simulation parameters specified
            for new appended sweep point.
        """
        self.__seq_dict_extend(self.sim_params, change_dict)

    def __seq_dict_extend(self, base, extension):
        """Extend dict-of-seq by concatenating elements to each sequence

        Values in `extension`` are append to  sequences in `base` with same key
        Where no key exists a new singleton list entry is added to `base`

        Finally all sequences in base are extended to match length of longest
        sequence by replicating the last value.

        Non-sequence values in both dictionaries are handled as
        one-element sequences.

        Parameters
        ----------
        base: dict
            dictionary of sequences (possibly not all the same length)
        extension: dict
            dictionary specifying values/sequences to extend `base` with
        """

        for name, value in base.items():
            if not self.__nonstring_seq(value):
                base[name] = [value]

        for name, extval in extension.items():
            extval_l = self.__nonseq_to_singleton(extval)
            if name in base:
                base[name] += extval_l
            else:
                base[name] = extval_l[:]

        # Extending short sequences to full sweep length by replication
        max_len = 1
        for name, value in base.items():
            max_len = max(max_len, len(value))
        for name, value in base.items():
            value += [value[-1]] * (max_len - len(value))

    def __nonstring_seq(self, v):
        return isinstance(v, collectionsAbc.Sequence) and type(v) is not str

    def __nonseq_to_singleton(self, v):
        if self.__nonstring_seq(v):
            return v
        else:
            return [v]

    def productsweep(self, combine_dict):
        """Extend sweep simulation parameters  creating 'cross product'

        Sweep is change to sweep all *combinations* of existing sweep parameters
        settings with those in `colmbine_dict`


        Sequences for existing parameters not specified in change_dict are
        extended to implied sweep length by replicating last value.
        Sequences for new parameters are extended by replicating specified
        value to match implied sweep length.

        Examples
        --------
         >>> m = {'a':[1,2], 'b':[3,4]}
         >>> n = {'c':[5,6], 'd':[7,8]}
         >>> a = SimParamSweep()
         >>> a.extendsweep(m)
         >>> a.productsweep(n)
         >>> print a.sim_params
         {'a': [1, 1, 2, 2], 'c': [5, 6, 5, 6], 'b': [3, 3, 4, 4], 'd': [7, 8, 7, 8]}

        Parameters
        ----------
        combine_dict: dict string to seq
            name-value dictionary of simulation parameters specified
            for values whose combinations with existing sweep are to be covered.
        """

        self.sim_params = self.__seq_dict_product([self.sim_params, combine_dict])

    def __seq_dict_product(self, seq_of_dict_of_seq):
        """Create a 'cross product' sweep sequence from a sequence of sweep sequences

        Compute sweep sequence covering every combination of parameters of the
        component sweeps `seq_of_dict_of_seq`

        Individual dicts of seq in seq_of_dicts are first 'completed' (shorter sequences
        in dict are extended to length of longest by repeating last element).

        Examples
        --------

        >>> m = {'a':[1,2], 'b':[3,4]}
        >>> n = {'c':[5,6], 'd':[7,8]}
        >>> __seq_dict_product( [m,n] )
        {'a': [1, 1, 2, 2], 'c': [5, 6, 5, 6], 'b': [3, 3, 4, 4], 'd': [7, 8, 7, 8]}

        Notes
        -----
            Keys of elements of sec_dicts must be disjoint.

        Parameters
        ----------
        seq_of_dicts : seq of dict of seq
            sequence of dictionary of sequences (possibly not all the same length)

        Returns
        -------
        dict of seq
            Cross product of elements of seq_of_dicts.
        """

        def dict_merge(*dicts):
            """Merge multiple dictionaries (left to right)
            :param dicts:
                Zero or more dicts
            :return:
                merge of `dicts`
            """
            res = {}
            for d in dicts:
                res.update(d)
            return res

        def transpose(dict_of_seq, partial):
            """
                append tranpose of dict of sequences of same len to sequence of dicts with same keys to `partial`
            :param dict_of_seq:
            :param partial:
            :return:
                transpose with values
            """
            """
            :param dict_of_seq:
            :return:
            """
            if len(next(iter(dict_of_seq.values()))) == 0:
                return partial
            else:
                dict_of_first_elts = {v: s[0] for v, s in dict_of_seq.items()}
                dict_of_rest = {v: s[1:] for v, s in dict_of_seq.items()}
                partial.append(dict_of_first_elts)
                return transpose(dict_of_rest, partial)

        def rtranspose(seq_of_dict):
            """
                transpose sequence of dictionaries with identical keys to dict of sequences

            :param dict_of_seq:
            :return:
                the tranpose dict
            """

            if len(seq_of_dict) == 0:
                return {}
            if len(seq_of_dict) == 1:
                return seq_of_dict[0]

            res = {k: [v] for k, v in seq_of_dict[0].items()}
            for d in seq_of_dict[1:]:
                for k, v in d.items():
                    res[k].append(v)
            return res

        keys = set()
        for d in seq_of_dict_of_seq:
            if not keys.isdisjoint(d.keys()):
                msg = "seq_dict_product: dictionaries may not share key"
                raise UsageError(msg)
            keys = keys | set(d.keys())
        seq_of_dict_of_samelen_seq = [self.__complete_dict_of_seqs(dict_of_seq) for dict_of_seq in seq_of_dict_of_seq]
        seq_of_seq_of_dict = [transpose(dict_of_samelen_seq, []) for dict_of_samelen_seq in seq_of_dict_of_samelen_seq]
        xprod_seq_of_dict = [dict_merge(*xpelt) for xpelt in itertools.product(*seq_of_seq_of_dict)]
        return rtranspose(xprod_seq_of_dict)

    def complete_sim_params(self):
        """Extend simulation sweep parameter sequences

        Simulation parameter sequences are extended by replicating
        last value so that all sequences are the same length.
        """

        # Find sweep length from first list parameter
        # Life is much simpler/more consistent if empty sim_params is
        # is a single-simulation run with an (ignored) parameter

        self.sim_params = self.__complete_dict_of_seqs(self.sim_params)
        if self.sim_params == {}:
            self.sim_params = {"__dummySIMPARAM__": [0.0]}

    def __complete_dict_of_seqs(self, sim_params):
        longest = 0
        for v in sim_params.values():
            if self.__nonstring_seq(v):
                v_len = len(v)
                if v_len < 1:
                    msg = "SweptRun.run: cannot execute zero-point sweeps"
                    raise Exception(msg)
                longest = max(v_len, longest)
            else:
                longest = max(1, longest)

        extended_sim_params = {}
        for k, v in sim_params.items():
            if self.__nonstring_seq(v):
                extended_sim_params[k] = v + [v[-1]] * (longest - len(v))
            else:
                extended_sim_params[k] = [v] * longest
        return extended_sim_params


# ----------------- BASE ----------------- #


class _Options_Base:
    """
    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int
    """

    def __init__(self, simulator, analysis, dataformat, opts_dict, **kwargs):
        self._scriptable_options = []
        """:type : list[]"""

        self._opts_container = {}
        self._opts_container["simulator"] = simulator
        self._opts_container["analysis"] = analysis
        self._opts_container["relbasepath_dir"] = None
        self._opts_container["simdata_format"] = dataformat
        self._opts_container["opts_dict"] = opts_dict
        """:type : dict[]"""

        self._opts_container["verbose"] = kwargs.get("verbose", 0)
        self._opts_container["idnum"] = kwargs.get("idnum", None)
        param = kwargs.get("sim_params", SimParamSweep({}))
        if not isinstance(param, SimParamSweep):
            param = SimParamSweep(param)
        param.complete_sim_params()
        self._opts_container["sim_params"] = param
        """:type : SimParamSweep"""

        self._opts_container["subset"] = kwargs.get("subset", None)
        self._opts_container["workingdir"] = kwargs.get("workingdir", None)
        self._opts_container["fileprefix"] = kwargs.get("fileprefix", None)
        self._opts_container["schematic"] = kwargs.get("schematic", None)
        self._opts_container["keeps"] = kwargs.get("keeps", [])
        self._opts_container["interactive"] = kwargs.get("interactive", True)

    def update_options(self, **kwargs):
        """
        Method to update the simulations options.

        For keyword description refer to the option-class documentation.
        """

        kw = CaseInsensitiveDict(kwargs)
        for k, v in kw.items():
            if k == "sim_params":
                sim_params = SimParamSweep(v)
                sim_params.complete_sim_params()
                """ :type : SimParamSweep """
                self._opts_container[k] = sim_params
            elif k in self._opts_container:
                self._opts_container[k] = v
            else:
                msg = f"No key called '{k}' in the selected Simulation Options object."
                raise AttributeError(msg)

        self._check_mandatory_options()

    class _MissingOption(Exception):
        def __init__(self, option, *args, **kwargs):
            Exception.__init__(self, *args, **kwargs)
            self.option = option

        def __str__(self):
            return f"Missing mandatory option '{self.option}'!"

        def __repr__(self):
            return self.__str__()

    class _DefectiveOption(Exception):
        def __init__(self, option, errmsg, *args, **kwargs):
            Exception.__init__(self, *args, **kwargs)
            self.option = option
            self.errmsg = errmsg

        def __str__(self):
            return f"Defective option '{self.option}': {self.errmsg}"

        def __repr__(self):
            return self.__str__()

    def _check_mandatory_options(self):
        if self.workingdir is None:
            msg = "workingdir"
            raise self._MissingOption(msg)
        else:
            self._opts_container["workingdir"] = self.workingdir
        if self.fileprefix in [None, r""]:
            self._opts_container["fileprefix"], _ = os.path.splitext(os.path.basename(self.schematic))
        if " " in self.fileprefix:
            msg = (
                "name for fileprefix is not supported! Please do not use blanks. In case no fileprefix was defined, the "
                f"schematic name was taken as fileprefix. Utilised fileprefix was: {self.fileprefix}"
            )
            raise self._DefectiveOption(msg)
        list_verbose = [0, 1]
        if self.verbose not in list_verbose:
            print(
                f"Warning: the selected verbosity level {self.verbose} is not supported. Verbosity will be set to the highest "
                f"level available (1). Supported verbosity levels:{list_verbose}"
            )
            self._opts_container["verbose"] = list_verbose[-1]

    def _check_sweep_params(self):
        sim_params_defined = self.sim_params
        """:type : dict[]"""
        sim_opts_sweepable = self._scriptable_options
        for key in sim_params_defined:
            if "$SRD_OPTION$" in key:
                key = key.replace("$SRD_OPTION$_", "")
                if key not in sim_opts_sweepable:
                    msg = f"The swept SRD_OPTION: {key} is either not sweepable or available!"
                    raise ValueError(msg)

    @property
    def idnum(self):
        """
        Id of simulator instance to use (for parallel simulation)
        """
        return self._opts_container["idnum"]

    @property
    def sim_params(self):
        """
        Sweep simulation parameters.
        """
        params = self._opts_container["sim_params"]
        """ :type : SimParamSweep"""

        return params.sim_params

    @property
    def runs(self):
        """
        The number of simulations runs. This value depends on the current simulation parameters.
        """
        return len(next(iter(self.sim_params.items()))[1])

    @property
    def subset(self):
        """
        Tuple/list of indices defining subset of sim_params lists to simulate. None indicates entirety of sim_params.

        For tuple: tuple[0] acts as start index and tuple[1] as stop index.
        """
        return self._opts_container["subset"]

    @property
    def workingdir(self):
        """
        The directory where Simulator dumps its simulation results
        """
        return self._opts_container["workingdir"]

    @property
    def fileprefix(self):
        """
        The prefix each file gets
        """
        return self._opts_container["fileprefix"]

    @property
    def schematic(self):
        """
        Schematic to open for run
        """
        return self._opts_container["schematic"]

    @property
    def keeps(self):
        """
        SIMetrix signal specs and KEEPS flags to control retained
        simulaton data (default - netlist default)
        Note that if keeps contains signal names or wildcards then
        KeepNone is automatically set so ONLY the specified signals are
        retained.

        See SIMetrix Simulator Reference Manual.
        """
        return self._opts_container["keeps"]

    @property
    def simdata_format(self):
        """
        The simdata format which is written and read by Analysis Object.
        """
        return self._opts_container["simdata_format"]

    @property
    def verbose(self):
        """
        Set verbosity level. The verbosity level has an influence on how many simulation files will be
        stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
        set verbose to 1.
        """
        return self._opts_container["verbose"]

    @property
    def interactive(self):
        """
        Interactive run - do not DelGroup the temporary results vector
        once results have been saved
        """
        return self._opts_container["interactive"]

    def set_schem_options(self, analysis_opts_names, analysis_opts_values, simulator_opts_names, simulator_opts_values):
        """
        Set Analysis and Simulator Options extracted from the simulator as default values for simulation_options container.

        :param analysis_opts_names: List of strings containing names of all analysis options.
        :type analysis_opts_names: list[str]
        :param analysis_opts_values: List of strings containing values of all analysis options.
        :type analysis_opts_values: list[str]
        :param simulator_opts_names: List of strings containing names of all simulator options.
        :type simulator_opts_names: list[str]
        :param simulator_opts_values: List of strings containing values of all simulator options.
        :type simulator_opts_values: list[str]

        """
        if len(analysis_opts_names) != len(analysis_opts_values):
            msg = (
                f"Length of analysis_opts_names and analysis_opts_values are not the same! {len(analysis_opts_names)}; "
                f"{len(analysis_opts_values)}"
            )
            raise ValueError(msg)
        if len(simulator_opts_names) != len(simulator_opts_values):
            msg = (
                f"Length of simulator_opts_names and simulator_opts_values are not the same! {len(simulator_opts_names)}; "
                f"{len(simulator_opts_values)}"
            )
            raise ValueError(msg)
        schem_dict = {}
        opts_dict = self._opts_container["opts_dict"]
        for key, value in opts_dict.items():
            if key in analysis_opts_names:
                sim_value = analysis_opts_values[analysis_opts_names.index(key)]
                if sim_value != "":
                    if sim_value.lower() == "true":
                        sim_value = True
                    elif sim_value.lower() == "false":
                        sim_value = False
                    else:
                        with contextlib.suppress(Exception):
                            sim_value = spiceEval(sim_value)
                    schem_dict[value] = sim_value
            if key in simulator_opts_names:
                sim_value = simulator_opts_values[simulator_opts_names.index(key)]
                if sim_value != "":
                    if sim_value.lower() == "true":
                        sim_value = True
                    elif sim_value.lower() == "false":
                        sim_value = False
                    else:
                        with contextlib.suppress(Exception):
                            sim_value = spiceEval(sim_value)
                    schem_dict[value] = sim_value

        self.update_options(**schem_dict)

    def _default_run_num(self, run_num):
        if run_num is None:
            return self.runs - 1
        else:
            return run_num

    def simparam(self, name=None, run_num=None):
        """Get simulation parameters for specific run number


        Parameters
        ----------
        name : string, optional
            parameter name, omit/None for all
        run_num :int
            run number in sweep, omit/None for last run, 'all' for all runs

        Returns
        -------
        dict | list | string
        dict of simparam sequences, dict of simparam values, simparam
        sequence, or simparam value

        """

        if self.sim_params is None:
            msg = "No (swept) simulation parameters set yet"
            raise UsageError(msg)

        run_num = self._default_run_num(run_num)

        if name is not None and name not in self.sim_params:
            print("No such simulation parameter in simulation log: ", name)
            print("Simulation parameters specified last run:", self.sim_params.keys())
            return None

        if run_num == "all":
            if name is None:
                return self.sim_params
            else:
                return self.sim_params[name]
        else:
            if name is None:
                return {name: values[run_num] for name, values in self.sim_params.items()}
            else:
                return self.sim_params[name][run_num]


# --------------- SIMETRIX --------------- #


class _Options_Simetrix(_Options_Base):
    """
    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simetrix Only Options:

    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key fastpointtol: Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
    :type fastpointtol: float
    :key fastreltol: Value for RELTOL used during 'Fast transient start'
    :type fastreltol: float
    :key fluxtol: Unit = V.secs The absolute flux tolerance for inductors.
    :type fluxtol: float
    :key method: Numerical integration method. Either TRAP (default) or GEAR".
    :type method: string
    :key pointtol: Factor used to control the extent to which the maximum value attained by
                    a signal is used to control its tolerance.
    :type pointtol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key temp: Operating temperature of circuit. Note this value can be overridden locally for
                some devices. You can also use .TEMP for this.
    :type temp: float
    :key trtol: This only affects transient analysis. It is a relative value that is used to
                determine an acceptable value for the 'local truncation error' before an
                analysis point is accepted. Reducing this value cause the simulator to
                model the effects of energy storage elements more accurately at the expense of simulation time.
    :type trtol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key mpnumthreads: Define the number of cores used for a single step simulation.
    :type mpnumthreads: str
    :key mintimestep: Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
    :type mintimestep: str
    :key itl4:  Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different
                in SIMetrix than other SPICE based simulators.
    :type itl4: int
    """

    def __init__(self, analysis, opts_dict, **kwargs):
        _Options_Base.__init__(
            self,
            enums.SimulatorType.Simetrix,
            analysis,
            kwargs.get("simdata_format", enums.SimulationDatatype.SXDAT),
            opts_dict,
            **kwargs,
        )

        self._scriptable_options.extend(
            [
                "abstol",
                "fastpointtol",
                "fastreltol",
                "fluxtol",
                "method",
                "pointtol",
                "reltol",
                "temp",
                "trtol",
                "vntol",
            ]
        )

        self._opts_container["abstol"] = kwargs.get("abstol", 1e-12)
        self._opts_container["fastpointtol"] = kwargs.get("fastpointtol", 1.0)
        self._opts_container["fastreltol"] = kwargs.get("fastreltol", 0.001)
        self._opts_container["fluxtol"] = kwargs.get("fluxtol", 1e-11)
        self._opts_container["method"] = kwargs.get("method", "trap")
        self._opts_container["pointtol"] = kwargs.get("pointtol", 0.001)
        self._opts_container["reltol"] = kwargs.get("reltol", 0.001)
        self._opts_container["temp"] = kwargs.get("temp", 27)
        self._opts_container["trtol"] = kwargs.get("trtol", 7)
        self._opts_container["vntol"] = kwargs.get("vntol", 1e-6)
        self._opts_container["mpnumthreads"] = kwargs.get("mpnumthreads", None)
        self._opts_container["mintimestep"] = kwargs.get("mintimestep", None)
        self._opts_container["itl4"] = kwargs.get("itl4", 10)
        self._opts_container["conv"] = kwargs.get("conv", enums.ConvergenceOptions.normal)

    def _check_mandatory_options(self):
        if self.schematic is None:
            msg = "schematic"
            raise self._MissingOption(msg)
        else:
            self._opts_container["schematic"] = self.schematic
        if self.method.lower() == "trap" or self.method.lower() == "gear":
            pass
        else:
            msg = "method"
            raise self._DefectiveOption(
                msg, 'The supplied argument is not one of the two allowed options: "trap" or "gear"'
            )

        _Options_Base._check_mandatory_options(self)

    @property
    def abstol(self):
        """
        The absolute current error tolerance.
        """
        return self._opts_container["abstol"]

    @property
    def method(self):
        """
        Numerical integration method. Either TRAP (default) or GEAR".
        """
        return self._opts_container["method"]

    @property
    def pointtol(self):
        """
        Factor used to control the extent to which the maximum value attained by a signal is used to control its tolerance.
        """
        return self._opts_container["pointtol"]

    @property
    def reltol(self):
        """
        This is the relative tolerance that must be met for each analysis point.
        """
        return self._opts_container["reltol"]

    @property
    def temp(self):
        """
        Operating temperature of circuit.
        """
        return self._opts_container["temp"]

    @property
    def trtol(self):
        """
        This only affects transient analysis. It is a relative value that is used to
        determine an acceptable value for the 'local truncation error' before an analysis point is accepted.
        """
        return self._opts_container["trtol"]

    @property
    def vntol(self):
        """
        The absolute voltage error tolerance. Circuits with large voltages present
        (>100) may benefit from an increase in this value.
        """
        return self._opts_container["vntol"]

    @property
    def fluxtol(self):
        """
        The absolute flux tolerance for inductors.
        """
        return self._opts_container["fluxtol"]

    @property
    def fastpointtol(self):
        """
        Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
        """
        return self._opts_container["fastpointtol"]

    @property
    def fastreltol(self):
        """
        Value for RELTOL used during 'Fast transient start'
        """
        return self._opts_container["fastreltol"]

    @property
    def mpnumthreads(self):
        """
        Define the number of cores used for a single step simulation.
        """
        return self._opts_container["mpnumthreads"]

    @property
    def mintimestep(self):
        """
        Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
        """
        return self._opts_container["mintimestep"]

    @property
    def itl4(self):
        """
        Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different in SIMetrix
        than other SPICE based simulators.
        """
        return self._opts_container["itl4"]

    @property
    def conv(self):
        """
        Modify convergence options to fix convergence issues.
        Use these options if you get one of the error messages:

        No convergence in transient analysis
        Cannot find DC operating point - ...

        Try "Extended precision" first as this option has no disadvantages other than a small speed loss.

          * Normal mode (fastest)           : "0"
          * Advanced iteration              : "2"
          * Extended precision              : "4"
          * Extended/quad precision         : "6"
          * Full quad precision (slowest)   : "8"

        https://help.simetrix.co.uk/8.4/simetrix/user_manual/topics/analysismodes_convergence.htm?hl=convergence
        """
        return self._opts_container["conv"]


class Options_SimetrixTran(_Options_Simetrix):
    """
    Simulation option object for transient simulation with Simetrix

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simetrix Only Options:

    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key fastpointtol: Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
    :type fastpointtol: float
    :key fastreltol: Value for RELTOL used during 'Fast transient start'
    :type fastreltol: float
    :key fluxtol: Unit = V.secs The absolute flux tolerance for inductors.
    :type fluxtol: float
    :key method: Numerical integration method. Either TRAP (default) or GEAR".
    :type method: string
    :key pointtol: Factor used to control the extent to which the maximum value attained by
                    a signal is used to control its tolerance.
    :type pointtol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key temp: Operating temperature of circuit. Note this value can be overridden locally for
                some devices. You can also use .TEMP for this.
    :type temp: float
    :key trtol: This only affects transient analysis. It is a relative value that is used to
                determine an acceptable value for the 'local truncation error' before an
                analysis point is accepted. Reducing this value cause the simulator to
                model the effects of energy storage elements more accurately at the expense of simulation time.
    :type trtol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key mpnumthreads: Define the number of cores used for a single step simulation.
    :type mpnumthreads: str
    :key mintimestep: Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
    :type mintimestep: str
    :key itl4:  Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different
                in SIMetrix than other SPICE based simulators.
    :type itl4: int

    Simetrix Tran Options:

    :key tstep: This defines the interval for tabulated results specified by the
                .PRINT statement. It also defines the output interval for all data
                if the NORAW option is specified. If there are no .PRINT
                statements in the netlist and NORAW is not being used, this can
                be set to zero or omitted altogether as in form 1 above. If set to
                zero it defaults to (tstop-tstart)/50
                tstep is also used to define default values for pulse and
                exponential stimuli.
                Note that if tstep and NORAW are specified a time point is
                forced at tstep intervals to calculate the output. This differs from
                other SPICE programs which generate output at tstep by
                interpolation.
                tstep does not control the time step used by the simulator. This is
                controlled automatically according to circuit activity.
    :type tstep: float
    :key tstop: Stop time. Note that if running in GUI mode, a transient analysis
                can be restarted from the front end using the RestartTran
                command. See User's Manual for details.
    :type tstop: float
    :key tstart: Start time. This is the time at which the storage of transient
                 analysis outputs commences. It is not the time at which the
                 analysis begins; this is always zero. tstart is zero if it is omitted.
    :type tstart: float
    :key tmaxstep: Maximum time step. The simulator uses the largest time step
                   possible to achieve the required accuracy but will not increase it
                   beyond this value. If not specified it is set to (tstop-tstart)/50 .
    :type tmaxstep: float
    :key uic: If specified a DC operating point is not calculated and initial
              condition specifications are used instead
    :type uic: bool
    :key snapstep: tuple of 3 values:

                   sstart - Time at which snapshot saving begins. See below for
                   information on snapshots.

                   sstop - Time at which snapshot saving stops. See below for information
                   on snapshots

                   sstep - Interval between snapshot points. See below for information on
                   snapshots
    :type snapstep: (float, float, float)
    :key snapshot: slist - One or more values defining absolute times at which snap shots
                       are saved. See below for information on snapshots
    :type snapshot: list[float]
    :key snapmode: DCOP|SAVESTATE|ALL

                   Snapshot mode. The default is DCOP

                   - DCOP: Saves bias point information only.

                   - SAVESTATE: Saves state of circuit for subsequent reload for small signal analysis

                   - ALL: Both of the above
    :type snapmode: str
    :key fast: If specified, the simulation will run at reduced accuracy but
               higher speed for the time specified by this parameter. The
               reduced accuracy is implemented by altering a number of
               tolerances and internal parameters. See notes below for more
               details.
    :type fast: float
    :key rtnstep: If this parameter is specified, Real Time Noise analysis will be
                  enabled. Note that this feature is not available with all versions
                  of the program. rtnstep specifies the step size of the noise
                  generators. See "Real Time Noise Analysis" on page 267.
    :type rtnstep: float
    :key rtnstart: Specifies time at which real time noise generators are switched on.
    :type rtnstart: float
    :key rtnstop: Specifies time at which real time noise generators are switched off.
    :type rtnstop: float
    :key runname: If specified, the value for runname will be passed to the
                  simulation data group as a string variable with name
                  UserRunName. This may be used to identify which analysis
                  generated the data which is useful when running netlists with
                  multiple analyses defined
    :type runname: str
    :key sweep: Enables sweeps on SIMetrix level utilizing SIMetrix built-in SWEEP functionality. Give the appropriate
                SIMetrix Syntax to the argument except for the SWEEP keyword itself.
                E.g.:
                SIMetrix analysis string: .TRAN 200u SWEEP DEVICE V1 STP 0 5 0.1
                This will perform a transient analysis over 200u and will sweep the device V1's voltage from 0 to 5 with
                 a step size of 0.1.
                 sweep argument: DEVICE V1 STP 0 5 0.1

    :type sweep: str
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simetrix.__init__(self, enums.AnalysisType.TRAN, enums.SimulatorAnalysisOpts.Simetrix_TRAN, **kwargs)

        self._scriptable_options.extend(
            [
                "tstop",
                "tstart",
                "tstep",
                "tmaxstep",
                "uic",
                "snapstep",
                "snapshot",
                "snapmode",
                "fast",
                "rtnstep",
                "rtnstart",
                "rtnstop",
                "sweep",
            ]
        )

        self._opts_container["tstop"] = kwargs.get("tstop", 1e-3)
        self._opts_container["tstart"] = kwargs.get("tstart", 0.0)
        self._opts_container["tstep"] = kwargs.get("tstep", (self.tstop - self.tstart) / 50.0)
        self._opts_container["tmaxstep"] = kwargs.get("tmaxstep", (self.tstop - self.tstart) / 50.0)

        self._opts_container["uic"] = kwargs.get("uic", False)
        self._opts_container["snapstep"] = kwargs.get("snapstep", None)
        self._opts_container["snapshot"] = kwargs.get("snapshot", None)
        self._opts_container["snapmode"] = kwargs.get("snapmode", "DCOP")
        self._opts_container["fast"] = kwargs.get("fast", None)
        self._opts_container["rtnstep"] = kwargs.get("rtnstep", None)
        self._opts_container["rtnstart"] = kwargs.get("rtnstart", None)
        self._opts_container["rtnstop"] = kwargs.get("rtnstop", self.tstop)
        self._opts_container["runname"] = kwargs.get("runname", None)
        self._opts_container["sweep"] = kwargs.get("sweep", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simetrix._check_mandatory_options(self)
        if self.snapstep is not None and len(self.snapstep) != 3:
            msg = "snapstep"
            raise self._DefectiveOption(
                msg, "Argument SNAPSTEP has to be a tuple/list of 3 values: sstart, sstop, sstep."
            )

        list_mandatory_options = ["tstep", "tstop"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

        if self.rtnstep in [None, 0.0]:
            [self._opts_container["rtnstart"], self._opts_container["rtnstep"], self._opts_container["rtnstop"]] = [
                None,
                None,
                None,
            ]

    @property
    def tstep(self):
        """
        This defines the interval for tabulated results specified by the
        .PRINT statement. It also defines the output interval for all data
        if the NORAW option is specified. If there are no .PRINT
        statements in the netlist and NORAW is not being used, this can
        be set to zero or omitted altogether as in form 1 above. If set to
        zero it defaults to (tstop-tstart)/50
        tstep is also used to define default values for pulse and
        exponential stimuli.
        Note that if tstep and NORAW are specified a time point is
        forced at tstep intervals to calculate the output. This differs from
        other SPICE programs which generate output at tstep by
        interpolation.
        tstep does not control the time step used by the simulator. This is
        controlled automatically according to circuit activity.
        """
        return self._opts_container["tstep"]

    @property
    def tstop(self):
        """
        Stop time. Note that if running in GUI mode, a transient analysis
        can be restarted from the front end using the RestartTran
        command. See User's Manual for details.
        """
        return self._opts_container["tstop"]

    @property
    def uic(self):
        """
        If specified a DC operating point is not calculated and initial
        condition specifications are used instead
        """
        return self._opts_container["uic"]

    @property
    def tstart(self):
        """
        Start time. This is the time at which the storage of transient
        analysis outputs commences. It is not the time at which the
        analysis begins; this is always zero. tstart is zero if it is omitted.
        """
        return self._opts_container["tstart"]

    @property
    def tmaxstep(self):
        """
        Maximum time step. The simulator uses the largest time step
        possible to achieve the required accuracy but will not increase it
        beyond this value. If not specified it is set to (tstop-tstart)/50 .
        """
        return self._opts_container["tmaxstep"]

    @property
    def snapstep(self):
        """ "
        tuple of 3 values:

        sstart - Time at which snapshot saving begins. See below for
                    information on snapshots.

        sstop - Time at which snapshot saving stops. See below for information
                   on snapshots

        sstep - Interval between snapshot points. See below for information on
                   snapshots
        """
        return self._opts_container["snapstep"]

    @property
    def snapshot(self):
        """
        slist - One or more values defining absolute times at which snap shots
                are saved. See below for information on snapshots
        """
        return self._opts_container["snapstep"]

    @property
    def snapmode(self):
        """
        DCOP|SAVESTATE|ALL

        Snapshot mode. The default is DCOP

        - DCOP: Saves bias point information only.

        - SAVESTATE: Saves state of circuit for subsequent reload for small signal analysis

        - ALL: Both of the above
        """
        return self._opts_container["snapmode"]

    @property
    def fast(self):
        """
        If specified, the simulation will run at reduced accuracy but
        higher speed for the time specified by this parameter. The
        reduced accuracy is implemented by altering a number of
        tolerances and internal parameters. See notes below for more
        details.
        """
        return self._opts_container["fast"]

    @property
    def rtnstep(self):
        """
        If this parameter is specified, Real Time Noise analysis will be
        enabled. Note that this feature is not available with all versions
        of the program. rtnstep specifies the step size of the noise
        generators. See "Real Time Noise Analysis" on page 267.
        """
        return self._opts_container["rtnstep"]

    @property
    def rtnstart(self):
        """
        Specifies time at which real time noise generators are switched on.
        """
        return self._opts_container["rtnstart"]

    @property
    def rtnstop(self):
        """
        Specifies time at which real time noise generators are switched off.
        """
        return self._opts_container["rtnstop"]

    @property
    def runname(self):
        """
        If specified, the value for runname will be passed to the
        simulation data group as a string variable with name
        UserRunName. This may be used to identify which analysis
        generated the data which is useful when running netlists with
        multiple analyses defined
        """
        return self._opts_container["runname"]

    @property
    def sweep(self):
        """
        Enables sweeps on SIMetrix level utilizing SIMetrix built-in SWEEP functionality.
        """
        return self._opts_container["sweep"]

    @property
    def conv(self):
        """
        Modify convergence options to fix convergence issues.
        Use these options if you get one of the error messages:

        No convergence in transient analysis
        Cannot find DC operating point - ...

        Try "Extended precision" first as this option has no disadvantages other than a small speed loss.

          * Normal mode (fastest)           : "0"
          * Advanced iteration              : "2"
          * Extended precision              : "4"
          * Extended/quad precision         : "6"
          * Full quad precision (slowest)   : "8"

        https://help.simetrix.co.uk/8.4/simetrix/user_manual/topics/analysismodes_convergence.htm?hl=convergence
        """
        return self._opts_container["conv"]


class Options_SimetrixDC(_Options_Simetrix):
    """
    Simulation option object for DC analysis with SIMetrix

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simetrix Only Options:

    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key fastpointtol: Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
    :type fastpointtol: float
    :key fastreltol: Value for RELTOL used during 'Fast transient start'
    :type fastreltol: float
    :key fluxtol: Unit = V.secs The absolute flux tolerance for inductors.
    :type fluxtol: float
    :key method: Numerical integration method. Either TRAP (default) or GEAR".
    :type method: string
    :key pointtol: Factor used to control the extent to which the maximum value attained by
                    a signal is used to control its tolerance.
    :type pointtol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key temp: Operating temperature of circuit. Note this value can be overridden locally for
                some devices. You can also use .TEMP for this.
    :type temp: float
    :key trtol: This only affects transient analysis. It is a relative value that is used to
                determine an acceptable value for the 'local truncation error' before an
                analysis point is accepted. Reducing this value cause the simulator to
                model the effects of energy storage elements more accurately at the expense of simulation time.
    :type trtol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key mpnumthreads: Define the number of cores used for a single step simulation.
    :type mpnumthreads: str
    :key mintimestep: Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
    :type mintimestep: str
    :key itl4:  Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different
                in SIMetrix than other SPICE based simulators.
    :type itl4: int

    Options SIMetrix DC:

    :key sweep_mode: There are 5 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, MONTE) with the following syntax:

                        DEVICE device_name step_spec

                        TEMP step_spec

                        PARAM param_name step_spec

                        MODEL model [PARAM] mod_param_name step_spec

                        MONTE num_steps

    :type sweep_mode: str
    :key device_name: Name of device to be swept. The following components may be swept:
                        Capacitors, all controlled sources, fixed current source, fixed
                        voltage source, inductors and resistors.
    :type device_name: str
    :key param_name: Name of parameter used in expression. Expressions may be
                        used to define an instance or model parameter and may also be
                        used in arbitrary sources.
    :type param_name: str
    :key model: Name of model containing parameter to be swept
    :type model: str
    :key mod_param_name: Name of model parameter
    :type mod_param_name: str
    :key num_steps: Number of steps to be performed for Monte Carlo sweep.
    :type num_steps: int
    :key step_spec: Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

                    STP start stop step

                    LIN num_points start stop

                    DEC num_points_decade start stop

                    OCT num_points_octave start stop

                    LIST val1 [ val2 ... ]

    :type step_spec: str
    :key start: First value
    :type start: float|int
    :key stop: End Value
    :type stop:
    :key step: Step size
    :type step:
    :key num_points: Total number of points
    :type num_points: int
    :key num_points_decade: Number of points per decade
    :type num_points_decade: int
    :key num_points_octave: Number of points per octave
    :type num_points_octave: int
    :key value_list: List of points that wil be swept
    :type value_list: list[]
    :key runname: If specified, the value for runname will be passed to the
                    simulation data group as a string variable with name
                    UserRunName. This may be used to identify which analysis
                    generated the data which is useful when running netlists with
                    multiple analyses defined
    :type runname: string

    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simetrix.__init__(self, enums.AnalysisType.DC, None, **kwargs)

        self._scriptable_options.extend(
            [
                "sweep_mode",
                "device_name",
                "param_name",
                "model",
                "mod_param_name",
                "num_steps",
                "step_spec",
                "start",
                "stop",
                "step",
                "num_points",
                "num_points_decade",
                "num_points_octave",
                "value_list",
            ]
        )

        self._opts_container["sweep_mode"] = kwargs.get("sweep_mode", "DEVICE")
        self._opts_container["device_name"] = kwargs.get("device_name", None)
        self._opts_container["param_name"] = kwargs.get("param_name", None)
        self._opts_container["model"] = kwargs.get("model", None)
        self._opts_container["mod_param_name"] = kwargs.get("mod_param_name", None)
        self._opts_container["num_steps"] = kwargs.get("num_steps", None)
        self._opts_container["step_spec"] = kwargs.get("step_spec", None)
        self._opts_container["start"] = kwargs.get("start", None)
        self._opts_container["stop"] = kwargs.get("stop", None)
        self._opts_container["step"] = kwargs.get("step", None)
        self._opts_container["num_points"] = kwargs.get("num_points", None)
        self._opts_container["num_points_decade"] = kwargs.get("num_points_decade", None)
        self._opts_container["num_points_octave"] = kwargs.get("num_points_octave", None)
        self._opts_container["value_list"] = kwargs.get("value_list", None)
        self._opts_container["runname"] = kwargs.get("runname", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simetrix._check_mandatory_options(self)

        if self.sweep_mode == "DEVICE":
            list_mandatory_options = ["device_name"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "PARAM":
            list_mandatory_options = ["param_name"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MODEL":
            list_mandatory_options = ["model", "mod_param_name"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MONTE":
            list_mandatory_options = ["num_steps"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        elif self.sweep_mode == "TEMP":
            pass
        else:
            msg = "sweep_mode"
            raise self._DefectiveOption(
                msg, "None of the five legal Sweep Modes: DEVICE, PARAM, MODEL, MONTE or TEMP was selected."
            )

        if self.step_spec == "STP":
            list_mandatory_options = ["start", "stop", "step"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIN":
            list_mandatory_options = ["num_points", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "DEC":
            list_mandatory_options = ["num_points_decade", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "OCT":
            list_mandatory_options = ["num_points_octave", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIST":
            list_mandatory_options = ["value_list"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        else:
            msg = "step_spec"
            raise self._DefectiveOption(
                msg, "None of the five legal Step_specs: STP, LIN, DEC, OCT or LIST was selected."
            )

    @property
    def sweep_mode(self):
        """
        There are 5 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, MONTE) with the following syntax:

        DEVICE device_name step_spec

        TEMP step_spec

        PARAM param_name step_spec

        MODEL model [PARAM] mod_param_name step_spec

        MONTE num_steps
        """
        return self._opts_container["sweep_mode"]

    @property
    def device_name(self):
        """
        Name of device to be swept. The following components may be swept:
        Capacitors, all controlled sources, fixed current source, fixed
        voltage source, inductors and resistors.
        """
        return self._opts_container["device_name"]

    @property
    def param_name(self):
        """
        Name of parameter used in expression. Expressions may be
        used to define an instance or model parameter and may also be
        used in arbitrary sources.
        """
        return self._opts_container["param_name"]

    @property
    def model(self):
        """
        Name of model containing parameter to be swept
        """
        return self._opts_container["model"]

    @property
    def mod_param_name(self):
        """
        Name of model parameter
        """
        return self._opts_container["mod_param_name"]

    @property
    def num_steps(self):
        """
        Number of steps to be performed for Monte Carlo sweep.
        """
        return self._opts_container["num_steps"]

    @property
    def step_spec(self):
        """
        Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

        STP start stop step

        LIN num_points start stop

        DEC num_points_decade start stop

        OCT num_points_octave start stop

        LIST val1 [ val2 ... ]
        """
        return self._opts_container["step_spec"]

    @property
    def start(self):
        """
        First value
        """
        return self._opts_container["start"]

    @property
    def stop(self):
        """
        End Value
        """
        return self._opts_container["stop"]

    @property
    def step(self):
        """
        Step size
        """
        return self._opts_container["step"]

    @property
    def num_points(self):
        """
        Total number of points
        """
        return self._opts_container["num_points"]

    @property
    def num_points_decade(self):
        """
        Number of points per decade
        """
        return self._opts_container["num_points_decade"]

    @property
    def num_points_octave(self):
        """
        Number of points per octave
        """
        return self._opts_container["num_points_octave"]

    @property
    def value_list(self):
        """
        List of points that wil be swept
        """
        return self._opts_container["value_list"]

    @property
    def runname(self):
        """
        If specified, the value for runname will be passed to the
        simulation data group as a string variable with name
        UserRunName. This may be used to identify which analysis
        generated the data which is useful when running netlists with
        multiple analyses defined
        """
        return self._opts_container["runname"]

    @property
    def conv(self):
        """
        Modify convergence options to fix convergence issues.
        Use these options if you get one of the error messages:

        No convergence in transient analysis
        Cannot find DC operating point - ...

        Try "Extended precision" first as this option has no disadvantages other than a small speed loss.

          * Normal mode (fastest)           : "0"
          * Advanced iteration              : "2"
          * Extended precision              : "4"
          * Extended/quad precision         : "6"
          * Full quad precision (slowest)   : "8"

        https://help.simetrix.co.uk/8.4/simetrix/user_manual/topics/analysismodes_convergence.htm?hl=convergence
        """
        return self._opts_container["conv"]


class Options_SimetrixAC(_Options_Simetrix):
    """
    Simulation option object for AC analysis with SIMetrix

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simetrix Only Options:

    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key fastpointtol: Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
    :type fastpointtol: float
    :key fastreltol: Value for RELTOL used during 'Fast transient start'
    :type fastreltol: float
    :key fluxtol: Unit = V.secs The absolute flux tolerance for inductors.
    :type fluxtol: float
    :key method: Numerical integration method. Either TRAP (default) or GEAR".
    :type method: string
    :key pointtol: Factor used to control the extent to which the maximum value attained by
                    a signal is used to control its tolerance.
    :type pointtol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key temp: Operating temperature of circuit. Note this value can be overridden locally for
                some devices. You can also use .TEMP for this.
    :type temp: float
    :key trtol: This only affects transient analysis. It is a relative value that is used to
                determine an acceptable value for the 'local truncation error' before an
                analysis point is accepted. Reducing this value cause the simulator to
                model the effects of energy storage elements more accurately at the expense of simulation time.
    :type trtol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key mpnumthreads: Define the number of cores used for a single step simulation.
    :type mpnumthreads: str
    :key mintimestep: Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
    :type mintimestep: str
    :key itl4:  Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different
                in SIMetrix than other SPICE based simulators.
    :type itl4: int

    Options SIMetrix AC:

    :key sweep_mode: There are 6 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, FREQ, MONTE) with the following syntax:

                        DEVICE device_name step_spec F frequency

                        TEMP step_spec F frequency

                        PARAM param_name step_spec F frequency

                        MODEL model [PARAM] mod_param_name step_spec F frequency

                        FREQ step_spec

                        MONTE num_steps F frequency

    :type sweep_mode: str
    :key device_name: Name of device to be swept. The following components may be swept:
                        Capacitors, all controlled sources, fixed current source, fixed
                        voltage source, inductors and resistors.
    :type device_name: str
    :key param_name: Name of parameter used in expression. Expressions may be
                        used to define an instance or model parameter and may also be
                        used in arbitrary sources.
    :type param_name: str
    :key model: Name of model containing parameter to be swept
    :type model: str
    :key mod_param_name: Name of model parameter
    :type mod_param_name: str
    :key num_steps: Number of steps to be performed for Monte Carlo sweep.
    :type num_steps: int
    :key frequency: Specified frequency for which .NOISE, .AC and .TF analyses are to be performed. May be zero for .AC and .TF.
    :type frequency: float
    :key step_spec: Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

                    STP start stop step

                    LIN num_points start stop

                    DEC num_points_decade start stop

                    OCT num_points_octave start stop

                    LIST val1 [ val2 ... ]

    :type step_spec: str
    :key start: First value
    :type start: float|int
    :key stop: Last value
    :type stop: float|int
    :key step: Step size
    :type step: float|int
    :key num_points: Total number of points
    :type num_points: int
    :key num_points_decade: Number of points per decade
    :type num_points_decade: int
    :key num_points_octave: Number of points per octave
    :type num_points_octave: int
    :key runname: If specified, the value for runname will be passed to the
                    simulation data group as a string variable with name
                    UserRunName. This may be used to identify which analysis
                    generated the data which is useful when running netlists with
                    multiple analyses defined
    :type runname: str
    :key value_list: List of points that wil be swept
    :type value_list: list[]
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simetrix.__init__(self, enums.AnalysisType.AC, None, **kwargs)

        self._scriptable_options.extend(
            [
                "sweep_mode",
                "device_name",
                "param_name",
                "model",
                "mod_param_name",
                "frequency",
                "num_steps",
                "step_spec",
                "start",
                "stop",
                "step",
                "num_points",
                "num_points_decade",
                "num_points_octave",
                "value_list",
            ]
        )

        self._opts_container["sweep_mode"] = kwargs.get("sweep_mode", None)
        self._opts_container["device_name"] = kwargs.get("device_name", None)
        self._opts_container["param_name"] = kwargs.get("param_name", None)
        self._opts_container["model"] = kwargs.get("model", None)
        self._opts_container["mod_param_name"] = kwargs.get("mod_param_name", None)
        self._opts_container["frequency"] = kwargs.get("frequency", None)
        self._opts_container["num_steps"] = kwargs.get("num_steps", None)
        self._opts_container["step_spec"] = kwargs.get("step_spec", None)
        self._opts_container["start"] = kwargs.get("start", None)
        self._opts_container["stop"] = kwargs.get("stop", None)
        self._opts_container["step"] = kwargs.get("step", None)
        self._opts_container["num_points"] = kwargs.get("num_points", None)
        self._opts_container["num_points_decade"] = kwargs.get("num_points_decade", None)
        self._opts_container["num_points_octave"] = kwargs.get("num_points_octave", None)
        self._opts_container["runname"] = kwargs.get("runname", None)
        self._opts_container["value_list"] = kwargs.get("value_list", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simetrix._check_mandatory_options(self)
        if self.sweep_mode == "DEVICE":
            list_mandatory_options = ["device_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "PARAM":
            list_mandatory_options = ["param_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MODEL":
            list_mandatory_options = ["model", "mod_param_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "TEMP":
            list_mandatory_options = ["frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MONTE":
            list_mandatory_options = ["num_steps", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        elif self.sweep_mode == "FREQ":
            pass
        else:
            msg = "sweep_mode"
            raise self._DefectiveOption(
                msg, "None of the six legal Sweep Modes: DEVICE, PARAM, MODEL, MONTE, FREQ or TEMP was selected."
            )

        if self.step_spec == "STP":
            list_mandatory_options = ["start", "stop", "step"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIN":
            list_mandatory_options = ["num_points", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "DEC":
            list_mandatory_options = ["num_points_decade", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "OCT":
            list_mandatory_options = ["num_points_octave", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIST":
            list_mandatory_options = ["value_list"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        else:
            msg = "step_spec"
            raise self._DefectiveOption(
                msg, "None of the five legal Step_specs: STP, LIN, DEC, OCT or LIST was selected."
            )

    @property
    def sweep_mode(self):
        """
        There are 6 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, FREQ, MONTE) with the following syntax:

        DEVICE device_name step_spec F frequency

        TEMP step_spec F frequency

        PARAM param_name step_spec F frequency

        MODEL model [PARAM] mod_param_name step_spec F frequency

        FREQ step_spec

        MONTE num_steps F frequency
        """
        return self._opts_container["sweep_mode"]

    @property
    def device_name(self):
        """
        Name of device to be swept. The following components may be swept:
        Capacitors, all controlled sources, fixed current source, fixed
        voltage source, inductors and resistors.
        """
        return self._opts_container["device_name"]

    @property
    def param_name(self):
        """
        Name of parameter used in expression. Expressions may be
        used to define an instance or model parameter and may also be
        used in arbitrary sources.
        """
        return self._opts_container["param_name"]

    @property
    def model(self):
        """
        Name of model containing parameter to be swept
        """
        return self._opts_container["model"]

    @property
    def mod_param_name(self):
        """
        Name of model parameter
        """
        return self._opts_container["mod_param_name"]

    @property
    def frequency(self):
        """
        Specified frequency for which .NOISE, .AC and .TF analyses are to be performed. May be zero for .AC and .TF.
        """
        return self._opts_container["frequency"]

    @property
    def num_steps(self):
        """
        Number of steps to be performed for Monte Carlo sweep.
        """
        return self._opts_container["num_steps"]

    @property
    def step_spec(self):
        """
        Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

        STP start stop step

        LIN num_points start stop

        DEC num_points_decade start stop

        OCT num_points_octave start stop

        LIST val1 [ val2 ... ]
        """
        return self._opts_container["step_spec"]

    @property
    def start(self):
        """
        First value
        """
        return self._opts_container["start"]

    @property
    def stop(self):
        """
        Last value
        """
        return self._opts_container["stop"]

    @property
    def step(self):
        """
        Step size
        """
        return self._opts_container["step"]

    @property
    def num_points(self):
        """
        Total number of points
        """
        return self._opts_container["num_points"]

    @property
    def num_points_decade(self):
        """
        Number of points per decade
        """
        return self._opts_container["num_points_decade"]

    @property
    def num_points_octave(self):
        """
        Number of points per octave
        """
        return self._opts_container["num_points_octave"]

    @property
    def runname(self):
        """
        If specified, the value for runname will be passed to the
        simulation data group as a string variable with name
        UserRunName. This may be used to identify which analysis
        generated the data which is useful when running netlists with
        multiple analyses defined
        """
        return self._opts_container["runname"]

    @property
    def value_list(self):
        """
        List of points that wil be swept
        """
        return self._opts_container["value_list"]

    @property
    def conv(self):
        """
        Modify convergence options to fix convergence issues.
        Use these options if you get one of the error messages:

        No convergence in transient analysis
        Cannot find DC operating point - ...

        Try "Extended precision" first as this option has no disadvantages other than a small speed loss.

          * Normal mode (fastest)           : "0"
          * Advanced iteration              : "2"
          * Extended precision              : "4"
          * Extended/quad precision         : "6"
          * Full quad precision (slowest)   : "8"

        https://help.simetrix.co.uk/8.4/simetrix/user_manual/topics/analysismodes_convergence.htm?hl=convergence
        """
        return self._opts_container["conv"]


class Options_SimetrixNOISE(_Options_Simetrix):
    """
    Simulation option object for NOISE analysis with SIMetrix

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: string
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simetrix Only Options:

    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key fastpointtol: Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
    :type fastpointtol: float
    :key fastreltol: Value for RELTOL used during 'Fast transient start'
    :type fastreltol: float
    :key fluxtol: Unit = V.secs The absolute flux tolerance for inductors.
    :type fluxtol: float
    :key method: Numerical integration method. Either TRAP (default) or GEAR".
    :type method: string
    :key pointtol: Factor used to control the extent to which the maximum value attained by
                    a signal is used to control its tolerance.
    :type pointtol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key temp: Operating temperature of circuit. Note this value can be overridden locally for
                some devices. You can also use .TEMP for this.
    :type temp: float
    :key trtol: This only affects transient analysis. It is a relative value that is used to
                determine an acceptable value for the 'local truncation error' before an
                analysis point is accepted. Reducing this value cause the simulator to
                model the effects of energy storage elements more accurately at the expense of simulation time.
    :type trtol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key mpnumthreads: Define the number of cores used for a single step simulation.
    :type mpnumthreads: str
    :key mintimestep: Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
    :type mintimestep: str
    :key itl4:  Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different
                in SIMetrix than other SPICE based simulators.
    :type itl4: int

    Options SIMetrix NOISE:

    :key sweep_mode: There are 6 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, FREQ, MONTE) with the following syntax:

                        DEVICE device_name step_spec

                        TEMP step_spec

                        PARAM param_name step_spec

                        MODEL model [PARAM] mod_param_name step_spec

                        FREQ step_spec

                        MONTE num_steps

    :type sweep_mode: string
    :key device_name: Name of device to be swept. The following components may be swept:
                        Capacitors, all controlled sources, fixed current source, fixed
                        voltage source, inductors and resistors.
    :type device_name: str
    :key param_name: Name of parameter used in expression. Expressions may be
                        used to define an instance or model parameter and may also be
                        used in arbitrary sources.
    :type param_name: str
    :key model: Name of model containing parameter to be swept
    :type model: str
    :key mod_param_name: Name of model parameter
    :type mod_param_name: str
    :key num_steps: Number of steps to be performed for Monte Carlo sweep.
    :type num_steps: int
    :key frequency: Specified frequency for which .NOISE, .AC and .TF analyses are to be performed. May be zero for .AC and .TF.
    :type frequency: float
    :key step_spec: Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

                    STP start stop step

                    LIN num_points start stop

                    DEC num_points_decade start stop

                    OCT num_points_octave start stop

                    LIST val1 [ val2 ... ]

    :type step_spec: str
    :key start: First value
    :type start: float|int
    :key stop: Last value
    :type stop: float|int
    :key step: Step size
    :type step: float|int
    :key num_points: Total number of points
    :type num_points: int
    :key num_points_decade: Number of points per decade
    :type num_points_decade: int
    :key num_points_octave: Number of points per octave
    :type num_points_octave: int
    :key runname: If specified, the value for runname will be passed to the
                    simulation data group as a string variable with name
                    UserRunName. This may be used to identify which analysis
                    generated the data which is useful when running netlists with
                    multiple analyses defined
    :type runname: str
    :key pos_node: Node on circuit at which noise is measured.
    :type pos_node: str
    :key neg_node: Node to which outputnode is referenced. Defaults to ground if omitted.
    :type neg_node: str
    :key in_source: Input source (i.e. voltage or current) to which the input noise measurement is referred.
    :type in_source: str
    :key value_list: List of points that wil be swept
    :type value_list: list[]

    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simetrix.__init__(self, enums.AnalysisType.NOISE, None, **kwargs)

        self._scriptable_options.extend(
            [
                "sweep_mode",
                "device_name",
                "param_name",
                "model",
                "mod_param_name",
                "frequency",
                "num_steps",
                "step_spec",
                "start",
                "stop",
                "step",
                "num_points",
                "num_points_decade",
                "num_points_octave",
                "value_list",
                "pos_node",
                "neg_node",
                "in_source",
            ]
        )

        self._opts_container["sweep_mode"] = kwargs.get("sweep_mode", None)
        self._opts_container["device_name"] = kwargs.get("device_name", None)
        self._opts_container["param_name"] = kwargs.get("param_name", None)
        self._opts_container["model"] = kwargs.get("model", None)
        self._opts_container["mod_param_name"] = kwargs.get("mod_param_name", None)
        self._opts_container["frequency"] = kwargs.get("frequency", None)
        self._opts_container["num_steps"] = kwargs.get("num_steps", None)
        self._opts_container["step_spec"] = kwargs.get("step_spec", None)
        self._opts_container["start"] = kwargs.get("start", None)
        self._opts_container["stop"] = kwargs.get("stop", None)
        self._opts_container["step"] = kwargs.get("step", None)
        self._opts_container["num_points"] = kwargs.get("num_points", None)
        self._opts_container["num_points_decade"] = kwargs.get("num_points_decade", None)
        self._opts_container["num_points_octave"] = kwargs.get("num_points_octave", None)
        self._opts_container["runname"] = kwargs.get("runname", None)
        self._opts_container["value_list"] = kwargs.get("value_list", None)
        self._opts_container["pos_node"] = kwargs.get("pos_node", None)
        self._opts_container["neg_node"] = kwargs.get("neg_node", None)
        self._opts_container["in_source"] = kwargs.get("in_source", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simetrix._check_mandatory_options(self)

        if self.sweep_mode == "DEVICE":
            list_mandatory_options = ["device_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "PARAM":
            list_mandatory_options = ["param_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MODEL":
            list_mandatory_options = ["model", "mod_param_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "TEMP":
            list_mandatory_options = ["frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MONTE":
            list_mandatory_options = ["num_steps", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        elif self.sweep_mode == "FREQ":
            pass
        else:
            msg = "sweep_mode"
            raise self._DefectiveOption(
                msg, "None of the six legal Sweep Modes: DEVICE, PARAM, MODEL, MONTE, FREQ or TEMP was selected."
            )

        if self.step_spec == "STP":
            list_mandatory_options = ["start", "stop", "step"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIN":
            list_mandatory_options = ["num_points", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "DEC":
            list_mandatory_options = ["num_points_decade", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "OCT":
            list_mandatory_options = ["num_points_octave", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIST":
            list_mandatory_options = ["value_list"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        else:
            msg = "step_spec"
            raise self._DefectiveOption(
                msg, "None of the five legal Step_specs: STP, LIN, DEC, OCT or LIST was selected."
            )

        list_mandatory_options = ["pos_node"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

    @property
    def sweep_mode(self):
        """
        There are 6 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, FREQ, MONTE) with the following syntax:

        DEVICE device_name step_spec

        TEMP step_spec

        PARAM param_name step_spec

        MODEL model [PARAM] mod_param_name step_spec

        FREQ step_spec

        MONTE num_steps
        """
        return self._opts_container["sweep_mode"]

    @property
    def device_name(self):
        """
        Name of device to be swept. The following components may be swept:
        Capacitors, all controlled sources, fixed current source, fixed
        voltage source, inductors and resistors.
        """
        return self._opts_container["device_name"]

    @property
    def param_name(self):
        """
        Name of parameter used in expression. Expressions may be
        used to define an instance or model parameter and may also be
        used in arbitrary sources.
        """
        return self._opts_container["param_name"]

    @property
    def model(self):
        """
        Name of model containing parameter to be swept
        """
        return self._opts_container["model"]

    @property
    def mod_param_name(self):
        """
        Name of model parameter
        """
        return self._opts_container["mod_param_name"]

    @property
    def frequency(self):
        """
        Specified frequency for which .NOISE, .AC and .TF analyses are to be performed. May be zero for .AC and .TF.
        """
        return self._opts_container["frequency"]

    @property
    def num_steps(self):
        """
        Number of steps to be performed for Monte Carlo sweep.
        """
        return self._opts_container["num_steps"]

    @property
    def step_spec(self):
        """
        Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

        STP start stop step

        LIN num_points start stop

        DEC num_points_decade start stop

        OCT num_points_octave start stop

        LIST val1 [ val2 ... ]
        """
        return self._opts_container["step_spec"]

    @property
    def start(self):
        """
        First value
        """
        return self._opts_container["start"]

    @property
    def stop(self):
        """
        Last value
        """
        return self._opts_container["stop"]

    @property
    def step(self):
        """
        Step size
        """
        return self._opts_container["step"]

    @property
    def num_points(self):
        """
        Total number of points
        """
        return self._opts_container["num_points"]

    @property
    def num_points_decade(self):
        """
        Number of points per decade
        """
        return self._opts_container["num_points_decade"]

    @property
    def num_points_octave(self):
        """
        Number of points per octave
        """
        return self._opts_container["num_points_octave"]

    @property
    def runname(self):
        """
        If specified, the value for runname will be passed to the
        simulation data group as a string variable with name
        UserRunName. This may be used to identify which analysis
        generated the data which is useful when running netlists with
        multiple analyses defined
        """
        return self._opts_container["runname"]

    @property
    def value_list(self):
        """
        List of points that wil be swept
        """
        return self._opts_container["value_list"]

    @property
    def pos_node(self):
        """
        Node on circuit at which noise is measured.
        """
        return self._opts_container["pos_node"]

    @property
    def neg_node(self):
        """
        Node to which outputnode is referenced. Defaults to ground if omitted.
        """
        return self._opts_container["neg_node"]

    @property
    def in_source(self):
        """
        Input source (i.e. voltage or current) to which the input noise measurement is referred.
        """
        return self._opts_container["in_source"]

    @property
    def conv(self):
        """
        Modify convergence options to fix convergence issues.
        Use these options if you get one of the error messages:

        No convergence in transient analysis
        Cannot find DC operating point - ...

        Try "Extended precision" first as this option has no disadvantages other than a small speed loss.

          * Normal mode (fastest)           : "0"
          * Advanced iteration              : "2"
          * Extended precision              : "4"
          * Extended/quad precision         : "6"
          * Full quad precision (slowest)   : "8"

        https://help.simetrix.co.uk/8.4/simetrix/user_manual/topics/analysismodes_convergence.htm?hl=convergence
        """
        return self._opts_container["conv"]


class Options_SimetrixTF(_Options_Simetrix):
    """
    Simulation option object for TF analysis with SIMetrix

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simetrix Only Options:

    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key fastpointtol: Value for POINTTOL used during 'Fast transient start'. See POINTTOL below.
    :type fastpointtol: float
    :key fastreltol: Value for RELTOL used during 'Fast transient start'
    :type fastreltol: float
    :key fluxtol: Unit = V.secs The absolute flux tolerance for inductors.
    :type fluxtol: float
    :key method: Numerical integration method. Either TRAP (default) or GEAR".
    :type method: str
    :key pointtol: Factor used to control the extent to which the maximum value attained by
                    a signal is used to control its tolerance.
    :type pointtol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key temp: Operating temperature of circuit. Note this value can be overridden locally for
                some devices. You can also use .TEMP for this.
    :type temp: float
    :key trtol: This only affects transient analysis. It is a relative value that is used to
                determine an acceptable value for the 'local truncation error' before an
                analysis point is accepted. Reducing this value cause the simulator to
                model the effects of energy storage elements more accurately at the expense of simulation time.
    :type trtol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key mpnumthreads: Define the number of cores used for a single step simulation.
    :type mpnumthreads: str
    :key mintimestep: Unit = Seconds Minimum transient time step. Simulation will abort if it reaches this value.
    :type mintimestep: str
    :key itl4:  Normal transient timepoint iteration limit. The behaviour of this parameter is slightly different
                in SIMetrix than other SPICE based simulators.
    :type itl4: int

    Options SIMetrix TF:

    :key sweep_mode: There are 6 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, FREQ, MONTE) with the following syntax:

                        DEVICE device_name step_spec

                        TEMP step_spec

                        PARAM param_name step_spec

                        MODEL model [PARAM] mod_param_name step_spec

                        FREQ step_spec

                        MONTE num_steps

    :type sweep_mode: str
    :key device_name: Name of device to be swept. The following components may be swept:
                        Capacitors, all controlled sources, fixed current source, fixed
                        voltage source, inductors and resistors.
    :type device_name: str
    :key param_name: Name of parameter used in expression. Expressions may be
                        used to define an instance or model parameter and may also be
                        used in arbitrary sources.
    :type param_name: str
    :key model: Name of model containing parameter to be swept
    :type model: str
    :key mod_param_name: Name of model parameter
    :type mod_param_name: str
    :key num_steps: Number of steps to be performed for Monte Carlo sweep.
    :type num_steps: int
    :key frequency: Specified frequency for which .NOISE, .AC and .TF analyses are to be performed. May be zero for .AC and .TF.
    :type frequency: float
    :key step_spec: Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

                    STP start stop step

                    LIN num_points start stop

                    DEC num_points_decade start stop

                    OCT num_points_octave start stop

                    LIST val1 [ val2 ... ]

    :type step_spec: str
    :key start: First value
    :type start: float|int
    :key stop:
    :type stop:
    :key step:
    :type step:
    :key num_points: Total number of points
    :type num_points: int
    :key num_points_decade: Number of points per decade
    :type num_points_decade: int
    :key num_points_octave: Number of points per octave
    :type num_points_octave: int
    :key runname: If specified, the value for runname will be passed to the
                    simulation data group as a string variable with name
                    UserRunName. This may be used to identify which analysis
                    generated the data which is useful when running netlists with
                    multiple analyses defined
    :type runname: str
    :key pos_node: Node on circuit at which noise is measured.
    :type pos_node: str
    :key neg_node: Node to which outputnode is referenced. Defaults to ground if omitted.
    :type neg_node: str
    :key in_source: Input source (i.e. voltage or current) to which the input noise measurement is referred.
    :type in_source: str
    :key source: Voltage source to specify output current.
    :type source: str

    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simetrix.__init__(self, enums.AnalysisType.NOISE, None, **kwargs)

        self._scriptable_options.extend(
            [
                "sweep_mode",
                "device_name",
                "param_name",
                "model",
                "mod_param_name",
                "frequency",
                "num_steps",
                "step_spec",
                "start",
                "stop",
                "step",
                "num_points",
                "num_points_decade",
                "num_points_octave",
                "value_list",
                "pos_node",
                "neg_node",
                "in_source",
                "source",
            ]
        )

        self._opts_container["sweep_mode"] = kwargs.get("sweep_mode", None)
        self._opts_container["device_name"] = kwargs.get("device_name", None)
        self._opts_container["param_name"] = kwargs.get("param_name", None)
        self._opts_container["model"] = kwargs.get("model", None)
        self._opts_container["mod_param_name"] = kwargs.get("mod_param_name", None)
        self._opts_container["frequency"] = kwargs.get("frequency", None)
        self._opts_container["num_steps"] = kwargs.get("num_steps", None)
        self._opts_container["step_spec"] = kwargs.get("step_spec", None)
        self._opts_container["start"] = kwargs.get("start", None)
        self._opts_container["stop"] = kwargs.get("stop", None)
        self._opts_container["step"] = kwargs.get("step", None)
        self._opts_container["num_points"] = kwargs.get("num_points", None)
        self._opts_container["num_points_decade"] = kwargs.get("num_points_decade", None)
        self._opts_container["num_points_octave"] = kwargs.get("num_points_octave", None)
        self._opts_container["runname"] = kwargs.get("runname", None)
        self._opts_container["value_list"] = kwargs.get("value_list", None)
        self._opts_container["pos_node"] = kwargs.get("pos_node", None)
        self._opts_container["neg_node"] = kwargs.get("neg_node", None)
        self._opts_container["in_source"] = kwargs.get("in_source", None)
        self._opts_container["source"] = kwargs.get("source", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simetrix._check_mandatory_options(self)

        if self.sweep_mode == "DEVICE":
            list_mandatory_options = ["device_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "PARAM":
            list_mandatory_options = ["param_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MODEL":
            list_mandatory_options = ["model", "mod_param_name", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "TEMP":
            list_mandatory_options = ["frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.sweep_mode == "MONTE":
            list_mandatory_options = ["num_steps", "frequency"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        elif self.sweep_mode == "FREQ":
            pass
        else:
            msg = "sweep_mode"
            raise self._DefectiveOption(
                msg, "None of the six legal Sweep Modes: DEVICE, PARAM, MODEL, MONTE, FREQ or TEMP was selected."
            )

        if self.step_spec == "STP":
            list_mandatory_options = ["start", "stop", "step"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIN":
            list_mandatory_options = ["num_points", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "DEC":
            list_mandatory_options = ["num_points_decade", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "OCT":
            list_mandatory_options = ["num_points_octave", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "LIST":
            list_mandatory_options = ["value_list"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        else:
            msg = "step_spec"
            raise self._DefectiveOption(
                msg, "None of the five legal Step_specs: STP, LIN, DEC, OCT or LIST was selected."
            )

        if getattr(self, "source", None) in [None, r""] and (
            getattr(self, "pos_node", None) in [None, r""] or getattr(self, "neg_node", None) in [None, r""]
        ):
            msg = "source, pos_node"
            raise self._DefectiveOption(
                msg,
                'None of the two legal modes: Voltage source to specify output current or Output Node, which require Parameter "pos_node" or "source" was selected.',
            )

    @property
    def sweep_mode(self):
        """
        There are 6 different sweep algorithms available for a DC analysis in SIMetrix (DEVICE, TEMP, PARAM, MODEL, FREQ, MONTE) with the following syntax:

        DEVICE device_name step_spec

        TEMP step_spec

        PARAM param_name step_spec

        MODEL model [PARAM] mod_param_name step_spec

        FREQ step_spec

        MONTE num_steps
        """
        return self._opts_container["sweep_mode"]

    @property
    def device_name(self):
        """
        Name of device to be swept. The following components may be swept:
        Capacitors, all controlled sources, fixed current source, fixed
        voltage source, inductors and resistors.
        """
        return self._opts_container["device_name"]

    @property
    def param_name(self):
        """
        Name of parameter used in expression. Expressions may be
        used to define an instance or model parameter and may also be
        used in arbitrary sources.
        """
        return self._opts_container["param_name"]

    @property
    def model(self):
        """
        Name of model containing parameter to be swept
        """
        return self._opts_container["model"]

    @property
    def mod_param_name(self):
        """
        Name of model parameter
        """
        return self._opts_container["mod_param_name"]

    @property
    def frequency(self):
        """
        Specified frequency for which .NOISE, .AC and .TF analyses are to be performed. May be zero for .AC and .TF.
        """
        return self._opts_container["frequency"]

    @property
    def num_steps(self):
        """
        Number of steps to be performed for Monte Carlo sweep.
        """
        return self._opts_container["num_steps"]

    @property
    def step_spec(self):
        """
        Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

        STP start stop step

        LIN num_points start stop

        DEC num_points_decade start stop

        OCT num_points_octave start stop

        LIST val1 [ val2 ... ]
        """
        return self._opts_container["step_spec"]

    @property
    def start(self):
        """
        First value
        """
        return self._opts_container["start"]

    @property
    def stop(self):
        """
        Last value
        """
        return self._opts_container["stop"]

    @property
    def step(self):
        """
        Step size
        """
        return self._opts_container["step"]

    @property
    def num_points(self):
        """
        Total number of points
        """
        return self._opts_container["num_points"]

    @property
    def num_points_decade(self):
        """
        Number of points per decade
        """
        return self._opts_container["num_points_decade"]

    @property
    def num_points_octave(self):
        """
        Number of points per octave
        """
        return self._opts_container["num_points_octave"]

    @property
    def runname(self):
        """
        If specified, the value for runname will be passed to the
        simulation data group as a string variable with name
        UserRunName. This may be used to identify which analysis
        generated the data which is useful when running netlists with
        multiple analyses defined
        """
        return self._opts_container["runname"]

    @property
    def value_list(self):
        """
        List of points that wil be swept
        """
        return self._opts_container["value_list"]

    @property
    def pos_node(self):
        """
        Node on circuit at which noise is measured.
        """
        return self._opts_container["pos_node"]

    @property
    def neg_node(self):
        """
        Node to which outputnode is referenced. Defaults to ground if omitted.
        """
        return self._opts_container["neg_node"]

    @property
    def in_source(self):
        """
        Input source (i.e. voltage or current) to which the input noise measurement is referred.
        """
        return self._opts_container["in_source"]

    @property
    def source(self):
        """
        Voltage source to specify output current.
        """
        return self._opts_container["source"]

    @property
    def conv(self):
        """
        Modify convergence options to fix convergence issues.
        Use these options if you get one of the error messages:

        No convergence in transient analysis
        Cannot find DC operating point - ...

        Try "Extended precision" first as this option has no disadvantages other than a small speed loss.

          * Normal mode (fastest)           : "0"
          * Advanced iteration              : "2"
          * Extended precision              : "4"
          * Extended/quad precision         : "6"
          * Full quad precision (slowest)   : "8"

        https://help.simetrix.co.uk/8.4/simetrix/user_manual/topics/analysismodes_convergence.htm?hl=convergence
        """
        return self._opts_container["conv"]


# --------------- SIMPLIS --------------- #


class _Options_Simplis(_Options_Base):
    """
    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simplis Only Options:

    :key keeps: Simplis signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See Simplis/SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key expand: Show the entire circuit after all subcircuit calls have been instantiated.
                    The listing of this expanded circuit is shown in the
                    file “XXXX.lst” where XXXX is the name of the input file. The
                    default is not to show the expanded circuit.
    :type expand: bool
    :key mapnode0: MAPNODE0 By default, node 0 is not allowed to appear as an external node
                    in the definition of a subcircuit and node 0 in a subcircuit is
                    considered the same node as node 0 in the main circuit. If
                    MAPNODE0 is specified as an option, node 0 in a subcircuit
                    would not be considered as the same node as node 0 in the main
                    circuit. In such a case, node 0 in the subcircuit is appropriately
                    mapped for each subcircuit instantiation and it is allowed to
                    appear as an external node in the subcircuit definition.
    :type mapnode0: bool
    :key no_force_data: Disable forcing data points before and after each switching instant.
                        This option does not take any value. It is either turned
                        ON (option present) or turned OFF (option not present). If it is
                        turned ON, SIMPLIS will not generate data points before and
                        after each switching instant. If it is turned OFF, SIMPLIS will
                        create data points each side of a switching instant.

                        Example - turn option ON:

                        .OPTIONS NO_FORCED_DATA

                        Under most circumstances, this option should remain turned
                        OFF. For very long simulations that generate extremely large
                        data sets, the waveform viewer may be slow responding to
                        user commands. In such cases, turning ON the NO_FORCED
                        _DATA option will reduce the number of simulation data points
                        displayed in the waveform viewer during each switching cycle.
                        For long simulations that involve many switching instants in one
                        switching cycle this reduction can be significant. Enabling this
                        option in no way degrades the accuracy of the SIMPLIS solution,
                        but it can potentially reduce the fidelity of the displayed
                        waveforms within each switching cycle.
    :type no_force_data: bool
    :key min_avg_topology_dur: SIMPLIS calculates the average time it spends in each toplogy
                                over a number of topologies defined by AVG_TOPOLOGY
                                _DUR_MEASUREMENT_WINDOW. If this value falls below
                                MIN_AVG_TOPOLOGY_DUR, the simulation aborts. The
                                default value is 1e-18.

                                The purpose of this is to resolve problems with the simulation
                                apparently getting 'stuck' in situations where there are unexpected
                                very high speed oscillations.
    :type min_avg_topology_dur: float
    :key avg_topology_dur_measurement: Default value = 128. See MIN_AVG_TOPOLOGY_DUR above for details.
    :type avg_topology_dur_measurement: int
    :key ignore_units: If it is turned ON, SIMPLIS will ignore any trailing units or strings when it is looking for a
                        floating-point number. For example, in specifying the voltage of
                        a DC voltage source, SIMPLIS would not complain the trailing
                        'V' here 1.23V if this options is turned ON.
                        The default is to not to turn ON this option and SIMPLIS would
                        then complain about the trailing string or units. To turn ON
                        this option, the line in the following “Example” section should
                        be output to the SIMPLIS simulation input deck.
    :type ignore_units: bool
    :key new_analysis: Force new analysis. This option does not take on any value. It is
                        either turned ON or turned OFF. If it is turned ON, SIMPLIS
                        will ignore any relevant data files from a previous simulation,
                        even if the circuit and the initial conditions between the two
                        simulation runs are the same. If this option is turned OFF,
                        SIMPLIS will try to take advantage of any relevant data files
                        from the previous simulation if the circuit and the initial conditions
                        have not changed from the previous simulation run.
                        To turn ON this option, the line in the following “Example”
                        section should be output to the SIMPLIS simulation input deck.
    :type new_analysis: bool
    :key snapshot_npt: SNAPSHOT_NPT Maximum number of saved snapshots. This sets the maximum
                        number of snapshots that SIMPLIS would save. If there is a
                        conflict between the values set for the SNAPSHOT_NPT and
                        SNAPSHOT_INTVL options, the value set for the SNAPSHOT
                        _NPT option will override the value set for the SNAPSHOT
                        _INTVL option.

                        If set, the option value must be a non-negative number between
                        11 and 201, inclusively.

                        If this option is not set, SIMPLIS will not save any snapshot.
    :type snapshot_npt: int
    :key snapshot_intvl: Minimum duration between snapshots. This instructs SIMPLIS
                            to save a snapshot of the internal state of the simulation at
                            intervals no smaller than the option value set for SNAPSHOT
                            _INTVL.
                            If set, the option value must be a non-negative floating-point
                            number. Engineering prefixes are allowed.
                            If this option is not set, it defaults to zero. If this option is not
                            set, or if the option is set to zero, SIMPLIS would not save any
                            snapshots at all.
    :type snapshot_intvl: float
    :key tstop: is a positive floating-point number in seconds to stand for the
                time instant at which the time-domain transient analysis stops
    :type tstop: float
    :key tsave: is a positive floating-point number smaller than tstop. It defines the time, simulation data is started to be saved.
    :type tsave: float
    :key psp_start: PSP_START = t1 For time-domain transient analysis, the print variables are generated
                    for time values larger than or equal to the value of t1. “PSP
                    _START=” is the ten-character keyword “PSP_START=” and
                    t1 is a nonnegative floating-point number. If this option is not
                    specified, the default value for t1 is the time the simulation starts
                    saving data for the transient analysis. Refer to the .TRAN statement
                    for details of the transient analysis.
    :type psp_start: float
    :key psp_end: PSP_END = t2 For time-domain transient analysis, the print variables are generated
                    for time values up to but not larger than the value of t2.
                    “PSP_END=” is the eight-character keyword “PSP_END=”
                    and t2 is a positive number larger than the value of t1. If this
                    option is not specified, the default value for t2 is the stop time
                    of the transient analysis as specified in the .TRAN statement.
                    If the value of t2 in PSP_END is smaller than the value for t1
                    in PSP_START, no output print file will be generated for the
                    transient analysis.
    :type psp_end: float
    :key psp_npt: PSP_NPT = n Set the minimum number of data points generated for printing
                    the output variables during the transient analysis. “PSP
                    _NPT=” is an eight-character keyword and n is an integer
                    between 2 and 100000001, inclusively. (PSP_END - PSP
                    _START)/(PSP_NPT - 1) is the step size of the time variable
                    in the print file generated for the transient analysis. If PSP
                    _NPT is not specified, no output print file will be generated for
                    the transient analysis.
    :type psp_npt: int
    """

    def __init__(self, analysis, opts_dict, **kwargs):
        _Options_Base.__init__(
            self,
            enums.SimulatorType.Simplis,
            analysis,
            kwargs.get("simdata_format", enums.SimulationDatatype.SXDAT),
            opts_dict,
            **kwargs,
        )

        self._scriptable_options.extend(
            [
                "expand",
                "mapnode0",
                "no_force_data",
                "min_avg_topology_dur",
                "avg_topology_dur_measurement",
                "ignore_units",
                "new_analysis",
                "snapshot_npt",
                "snapshot_intvl",
                "tstop",
                "tsave",
                "psp_start",
                "psp_stop",
                "psp_npt",
                "trig_gate",
            ]
        )

        self._opts_container["expand"] = kwargs.get("expand", False)
        self._opts_container["mapnode0"] = kwargs.get("mapnode0", False)
        self._opts_container["no_force_data"] = kwargs.get("no_force_data", False)
        self._opts_container["min_avg_topology_dur"] = kwargs.get("min_avg_topology_dur", 1e-18)
        self._opts_container["avg_topology_dur_measurement"] = kwargs.get("avg_topology_dur_measurement", 128)
        self._opts_container["ignore_units"] = kwargs.get("ignore_units", False)
        self._opts_container["new_analysis"] = kwargs.get("new_analysis", False)
        self._opts_container["snapshot_npt"] = kwargs.get("snapshot_npt", 11)
        self._opts_container["snapshot_intvl"] = kwargs.get("snapshot_intvl", None)
        self._opts_container["tstop"] = kwargs.get("tstop", 1e-3)
        self._opts_container["tsave"] = kwargs.get("tsave", 1e-4)
        self._opts_container["psp_start"] = kwargs.get("psp_start", self.tsave)
        self._opts_container["psp_stop"] = kwargs.get("psp_stop", self.tstop)
        self._opts_container["psp_npt"] = kwargs.get("psp_npt", 20001)
        self._opts_container["trig_gate"] = kwargs.get("trig_gate", "{TRIG_GATE}")

    def _check_mandatory_options(self):
        _Options_Base._check_mandatory_options(self)

        if self.schematic in [None, r""]:
            msg = "schematic"
            raise self._MissingOption(msg)
        else:
            self.__schematic = self.schematic

    @property
    def expand(self):
        """
        Show the entire circuit after all subcircuit calls have been instantiated.
        """
        return self._opts_container["expand"]

    @property
    def mapnode0(self):
        """
        MAPNODE0 By default, node 0 is not allowed to appear as an external node
        in the definition of a subcircuit and node 0 in a subcircuit is
        considered the same node as node 0 in the main circuit. If
        MAPNODE0 is specified as an option, node 0 in a subcircuit
        would not be considered as the same node as node 0 in the main circuit.
        """
        return self._opts_container["mapnode0"]

    @property
    def no_force_data(self):
        """
        Disable forcing data points before and after each switching instant.
        """
        return self._opts_container["no_force_data"]

    @property
    def min_avg_topology_dur(self):
        """
        SIMPLIS calculates the average time it spends in each toplogy
        over a number of topologies defined by AVG_TOPOLOGY_DUR_MEASUREMENT_WINDOW.
        If this value falls below MIN_AVG_TOPOLOGY_DUR, the simulation aborts.
        """
        return self._opts_container["min_avg_topology_dur"]

    @property
    def avg_topology_dur_measurement(self):
        """
        Default value = 128. See MIN_AVG_TOPOLOGY_DUR above for details.
        """
        return self._opts_container["avg_topology_dur_measurement"]

    @property
    def ignore_units(self):
        """
        If it is turned ON, SIMPLIS will ignore any trailing units or strings when it is looking for a floating-point number.
        """
        return self._opts_container["ignore_units"]

    @property
    def new_analysis(self):
        """
        If it is turned ON, SIMPLIS will ignore any relevant data files from a previous simulation,
        even if the circuit and the initial conditions between the two simulation runs are the same.
        """
        return self._opts_container["new_analysis"]

    @property
    def snapshot_npt(self):
        """
        Maximum number of saved snapshots.
        """
        return self._opts_container["snapshot_npt"]

    @property
    def snapshot_intvl(self):
        """
        Minimum duration between snapshots.
        """
        return self._opts_container["snapshot_intvl"]

    @property
    def psp_start(self):
        """
        For time-domain transient analysis, the print variables are generated
        for time values larger than or equal to the value of psp_start.
        """
        return self._opts_container["psp_start"]

    @property
    def psp_stop(self):
        """
        For time-domain transient analysis, the print variables are generated
        for time values up to but not larger than the value of psp_stop.
        """
        return self._opts_container["psp_stop"]

    @property
    def psp_npt(self):
        """
        Set the minimum number of data points generated for printing
        the output variables during the transient analysis.
        """
        return self._opts_container["psp_npt"]

    @property
    def tstop(self):
        """
        is a positive floating-point number in seconds to stand for the
        time instant at which the time-domain transient analysis stops
        """
        return self._opts_container["tstop"]

    @property
    def tsave(self):
        """
        is a positive floating-point number smaller than tstop. It defines the time, simulation data is started to be saved.
        """
        return self._opts_container["tsave"]

    @property
    def trig_gate(self):
        """
        Device name of a defined logic gate. This device is considered
        the triggering gate of the POP analysis.
        """
        return self._opts_container["trig_gate"]


class Options_SimplisTran(_Options_Simplis):
    """
    Simulation option object for transient simulation with Simplis

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simplis Only Options:

    :key keeps: Simplis signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See Simplis/SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key expand: Show the entire circuit after all subcircuit calls have been instantiated.
                    The listing of this expanded circuit is shown in the
                    file “XXXX.lst” where XXXX is the name of the input file. The
                    default is not to show the expanded circuit.
    :type expand: bool
    :key mapnode0: MAPNODE0 By default, node 0 is not allowed to appear as an external node
                    in the definition of a subcircuit and node 0 in a subcircuit is
                    considered the same node as node 0 in the main circuit. If
                    MAPNODE0 is specified as an option, node 0 in a subcircuit
                    would not be considered as the same node as node 0 in the main
                    circuit. In such a case, node 0 in the subcircuit is appropriately
                    mapped for each subcircuit instantiation and it is allowed to
                    appear as an external node in the subcircuit definition.
    :type mapnode0: bool
    :key no_force_data: Disable forcing data points before and after each switching instant.
                        This option does not take any value. It is either turned
                        ON (option present) or turned OFF (option not present). If it is
                        turned ON, SIMPLIS will not generate data points before and
                        after each switching instant. If it is turned OFF, SIMPLIS will
                        create data points each side of a switching instant.

                        Example - turn option ON:

                        .OPTIONS NO_FORCED_DATA

                        Under most circumstances, this option should remain turned
                        OFF. For very long simulations that generate extremely large
                        data sets, the waveform viewer may be slow responding to
                        user commands. In such cases, turning ON the NO_FORCED
                        _DATA option will reduce the number of simulation data points
                        displayed in the waveform viewer during each switching cycle.
                        For long simulations that involve many switching instants in one
                        switching cycle this reduction can be significant. Enabling this
                        option in no way degrades the accuracy of the SIMPLIS solution,
                        but it can potentially reduce the fidelity of the displayed
                        waveforms within each switching cycle.
    :type no_force_data: bool
    :key min_avg_topology_dur: SIMPLIS calculates the average time it spends in each toplogy
                                over a number of topologies defined by AVG_TOPOLOGY
                                _DUR_MEASUREMENT_WINDOW. If this value falls below
                                MIN_AVG_TOPOLOGY_DUR, the simulation aborts. The
                                default value is 1e-18.

                                The purpose of this is to resolve problems with the simulation
                                apparently getting 'stuck' in situations where there are unexpected
                                very high speed oscillations.
    :type min_avg_topology_dur: float
    :key avg_topology_dur_measurement: Default value = 128. See MIN_AVG_TOPOLOGY_DUR above for details.
    :type avg_topology_dur_measurement: int
    :key ignore_units: If it is turned ON, SIMPLIS will ignore any trailing units or strings when it is looking for a
                        floating-point number. For example, in specifying the voltage of
                        a DC voltage source, SIMPLIS would not complain the trailing
                        'V' here 1.23V if this options is turned ON.
                        The default is to not to turn ON this option and SIMPLIS would
                        then complain about the trailing string or units. To turn ON
                        this option, the line in the following “Example” section should
                        be output to the SIMPLIS simulation input deck.
    :type ignore_units: bool
    :key new_analysis: Force new analysis. This option does not take on any value. It is
                        either turned ON or turned OFF. If it is turned ON, SIMPLIS
                        will ignore any relevant data files from a previous simulation,
                        even if the circuit and the initial conditions between the two
                        simulation runs are the same. If this option is turned OFF,
                        SIMPLIS will try to take advantage of any relevant data files
                        from the previous simulation if the circuit and the initial conditions
                        have not changed from the previous simulation run.
                        To turn ON this option, the line in the following “Example”
                        section should be output to the SIMPLIS simulation input deck.
    :type new_analysis: bool
    :key snapshot_npt: SNAPSHOT_NPT Maximum number of saved snapshots. This sets the maximum
                        number of snapshots that SIMPLIS would save. If there is a
                        conflict between the values set for the SNAPSHOT_NPT and
                        SNAPSHOT_INTVL options, the value set for the SNAPSHOT
                        _NPT option will override the value set for the SNAPSHOT
                        _INTVL option.

                        If set, the option value must be a non-negative number between
                        11 and 201, inclusively.

                        If this option is not set, SIMPLIS will not save any snapshot.
    :type snapshot_npt: int
    :key snapshot_intvl: Minimum duration between snapshots. This instructs SIMPLIS
                            to save a snapshot of the internal state of the simulation at
                            intervals no smaller than the option value set for SNAPSHOT
                            _INTVL.
                            If set, the option value must be a non-negative floating-point
                            number. Engineering prefixes are allowed.
                            If this option is not set, it defaults to zero. If this option is not
                            set, or if the option is set to zero, SIMPLIS would not save any
                            snapshots at all.
    :type snapshot_intvl: float
    :key tstop: is a positive floating-point number in seconds to stand for the
                time instant at which the time-domain transient analysis stops
    :type tstop: float
    :key tsave: is a positive floating-point number smaller than tstop. It defines the time, simulation data is started to be saved.
    :type tsave: float
    :key psp_start: PSP_START = t1 For time-domain transient analysis, the print variables are generated
                    for time values larger than or equal to the value of t1. “PSP
                    _START=” is the ten-character keyword “PSP_START=” and
                    t1 is a nonnegative floating-point number. If this option is not
                    specified, the default value for t1 is the time the simulation starts
                    saving data for the transient analysis. Refer to the .TRAN statement
                    for details of the transient analysis.
    :type psp_start: float
    :key psp_end: PSP_END = t2 For time-domain transient analysis, the print variables are generated
                    for time values up to but not larger than the value of t2.
                    “PSP_END=” is the eight-character keyword “PSP_END=”
                    and t2 is a positive number larger than the value of t1. If this
                    option is not specified, the default value for t2 is the stop time
                    of the transient analysis as specified in the .TRAN statement.
                    If the value of t2 in PSP_END is smaller than the value for t1
                    in PSP_START, no output print file will be generated for the
                    transient analysis.
    :type psp_end: float
    :key psp_npt: PSP_NPT = n Set the minimum number of data points generated for printing
                    the output variables during the transient analysis. “PSP
                    _NPT=” is an eight-character keyword and n is an integer
                    between 2 and 100000001, inclusively. (PSP_END - PSP
                    _START)/(PSP_NPT - 1) is the step size of the time variable
                    in the print file generated for the transient analysis. If PSP
                    _NPT is not specified, no output print file will be generated for
                    the transient analysis.
    :type psp_npt: int
    :key trig_gate: Device name of a defined logic gate. This device is considered
                    the triggering gate of the POP analysis. Together with the parameter
                    value of TRIG_COND, it determines the condition that constitutes
                    the start of a new switching cycle in the POP analysis.
    :type trig_gate: str

    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simplis.__init__(self, enums.AnalysisType.TRAN, None, **kwargs)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simplis._check_mandatory_options(self)


class Options_SimplisAC(_Options_Simplis):
    """
    Simulation option object for AC analysis with Simplis

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simplis Only Options:

    :key keeps: Simplis signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See Simplis/SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key expand: Show the entire circuit after all subcircuit calls have been instantiated.
                    The listing of this expanded circuit is shown in the
                    file “XXXX.lst” where XXXX is the name of the input file. The
                    default is not to show the expanded circuit.
    :type expand: bool
    :key mapnode0: MAPNODE0 By default, node 0 is not allowed to appear as an external node
                    in the definition of a subcircuit and node 0 in a subcircuit is
                    considered the same node as node 0 in the main circuit. If
                    MAPNODE0 is specified as an option, node 0 in a subcircuit
                    would not be considered as the same node as node 0 in the main
                    circuit. In such a case, node 0 in the subcircuit is appropriately
                    mapped for each subcircuit instantiation and it is allowed to
                    appear as an external node in the subcircuit definition.
    :type mapnode0: bool
    :key no_force_data: Disable forcing data points before and after each switching instant.
                        This option does not take any value. It is either turned
                        ON (option present) or turned OFF (option not present). If it is
                        turned ON, SIMPLIS will not generate data points before and
                        after each switching instant. If it is turned OFF, SIMPLIS will
                        create data points each side of a switching instant.

                        Example - turn option ON:

                        .OPTIONS NO_FORCED_DATA

                        Under most circumstances, this option should remain turned
                        OFF. For very long simulations that generate extremely large
                        data sets, the waveform viewer may be slow responding to
                        user commands. In such cases, turning ON the NO_FORCED
                        _DATA option will reduce the number of simulation data points
                        displayed in the waveform viewer during each switching cycle.
                        For long simulations that involve many switching instants in one
                        switching cycle this reduction can be significant. Enabling this
                        option in no way degrades the accuracy of the SIMPLIS solution,
                        but it can potentially reduce the fidelity of the displayed
                        waveforms within each switching cycle.
    :type no_force_data: bool
    :key min_avg_topology_dur: SIMPLIS calculates the average time it spends in each toplogy
                                over a number of topologies defined by AVG_TOPOLOGY
                                _DUR_MEASUREMENT_WINDOW. If this value falls below
                                MIN_AVG_TOPOLOGY_DUR, the simulation aborts. The
                                default value is 1e-18.

                                The purpose of this is to resolve problems with the simulation
                                apparently getting 'stuck' in situations where there are unexpected
                                very high speed oscillations.
    :type min_avg_topology_dur: float
    :key avg_topology_dur_measurement: Default value = 128. See MIN_AVG_TOPOLOGY_DUR above for details.
    :type avg_topology_dur_measurement: int
    :key ignore_units: If it is turned ON, SIMPLIS will ignore any trailing units or strings when it is looking for a
                        floating-point number. For example, in specifying the voltage of
                        a DC voltage source, SIMPLIS would not complain the trailing
                        'V' here 1.23V if this options is turned ON.
                        The default is to not to turn ON this option and SIMPLIS would
                        then complain about the trailing string or units. To turn ON
                        this option, the line in the following “Example” section should
                        be output to the SIMPLIS simulation input deck.
    :type ignore_units: bool
    :key new_analysis: Force new analysis. This option does not take on any value. It is
                        either turned ON or turned OFF. If it is turned ON, SIMPLIS
                        will ignore any relevant data files from a previous simulation,
                        even if the circuit and the initial conditions between the two
                        simulation runs are the same. If this option is turned OFF,
                        SIMPLIS will try to take advantage of any relevant data files
                        from the previous simulation if the circuit and the initial conditions
                        have not changed from the previous simulation run.
                        To turn ON this option, the line in the following “Example”
                        section should be output to the SIMPLIS simulation input deck.
    :type new_analysis: bool
    :key snapshot_npt: SNAPSHOT_NPT Maximum number of saved snapshots. This sets the maximum
                        number of snapshots that SIMPLIS would save. If there is a
                        conflict between the values set for the SNAPSHOT_NPT and
                        SNAPSHOT_INTVL options, the value set for the SNAPSHOT
                        _NPT option will override the value set for the SNAPSHOT
                        _INTVL option.

                        If set, the option value must be a non-negative number between
                        11 and 201, inclusively.

                        If this option is not set, SIMPLIS will not save any snapshot.
    :type snapshot_npt: int
    :key snapshot_intvl: Minimum duration between snapshots. This instructs SIMPLIS
                            to save a snapshot of the internal state of the simulation at
                            intervals no smaller than the option value set for SNAPSHOT
                            _INTVL.
                            If set, the option value must be a non-negative floating-point
                            number. Engineering prefixes are allowed.
                            If this option is not set, it defaults to zero. If this option is not
                            set, or if the option is set to zero, SIMPLIS would not save any
                            snapshots at all.
    :type snapshot_intvl: float
    :key tstop: is a positive floating-point number in seconds to stand for the
                time instant at which the time-domain transient analysis stops
    :type tstop: float
    :key tsave: is a positive floating-point number smaller than tstop. It defines the time, simulation data is started to be saved.
    :type tsave: float
    :key psp_start: PSP_START = t1 For time-domain transient analysis, the print variables are generated
                    for time values larger than or equal to the value of t1. “PSP
                    _START=” is the ten-character keyword “PSP_START=” and
                    t1 is a nonnegative floating-point number. If this option is not
                    specified, the default value for t1 is the time the simulation starts
                    saving data for the transient analysis. Refer to the .TRAN statement
                    for details of the transient analysis.
    :type psp_start: float
    :key psp_end: PSP_END = t2 For time-domain transient analysis, the print variables are generated
                    for time values up to but not larger than the value of t2.
                    “PSP_END=” is the eight-character keyword “PSP_END=”
                    and t2 is a positive number larger than the value of t1. If this
                    option is not specified, the default value for t2 is the stop time
                    of the transient analysis as specified in the .TRAN statement.
                    If the value of t2 in PSP_END is smaller than the value for t1
                    in PSP_START, no output print file will be generated for the
                    transient analysis.
    :type psp_end: float
    :key psp_npt: PSP_NPT = n Set the minimum number of data points generated for printing
                    the output variables during the transient analysis. “PSP
                    _NPT=” is an eight-character keyword and n is an integer
                    between 2 and 100000001, inclusively. (PSP_END - PSP
                    _START)/(PSP_NPT - 1) is the step size of the time variable
                    in the print file generated for the transient analysis. If PSP
                    _NPT is not specified, no output print file will be generated for
                    the transient analysis.
    :type psp_npt: int

    Options SIMPLIS AC:

    :key sweep_mode: Three sweeping algorithms are available in SIMPLIS: DEC, OCT and LIN.
                        More information on these modes can be found in the SIMetrix Simulator Reference Manual.
    :type sweep_mode: str
    :key n_pt: If "sweep_mode" is set to "DEC", the frequency of analysis will be
                swept in a logarithmic manner and n_pt represents the number of points per decade in the swept
                frequency.

                If "sweep_mode" is set to "OCT", the frequency of analysis will be swept in a
                logarithmic manner and n_pt represents the number of points per octave in the swept
                frequency.

                If "sweep_mode" is set to "LIN", the frequency of analysis is swept in a linear manner
                and n_pt represents the total number of points in the linear frequency sweep.
                Also in this case, n_pt must be an integer larger than one.
    :type n_pt: int
    :key start_freq: Is a positive floating-point number representing the starting frequency of the sweep.
    :type start_freq: float
    :key stop_freq: Is a positive floating-point number representing the stopping frequency of the sweep.
    :type stop_freq: float
    :key freq_domain: Option statement associated with theSIMPLIS-FX (AC) small-signal frequency-domain analysis.
                        It can either be set to 'S' indicating the continuous domain or 'Z' indicating the discrete domain.
    :type freq_domain: str
    :key trig_gate: Device name of a defined logic gate. This device is considered
                    the triggering gate of the POP analysis. Together with the parameter
                    value of TRIG_COND, it determines the condition that constitutes
                    the start of a new switching cycle in the POP analysis.
    :type trig_gate: str
    :key trig_condition: There are two modi available: 0_TO_1 and 1_TO_0, which refer to falling or rising edge.
    :type trig_condition: str
    :key max_period: Is a positive floating-point number, which limits the periodic duration to this value.
    :type max_period: float
    :key convergence: Sets the convergence criteria for the periodic operating point analysis.
                        The convergence criteria is satisfied when the relative change in each
                        state variable, between the start and end of a switching cycle, is less
                        than this parameter. The value is a positive floating point number between
                        1.0e-06 and 1.0e-14, inclusive. The default value for convergence is 1p.
    :type convergence: float
    :key cycles_before_launch: Defines, how many switching cycles should be performed before starting the POP analysis.
    :type cycles_before_launch: int
    :key td_run_after_pop_fails: Controls behaviour if the POP analysis fails to converge. This has
                                three modes of operation as follows:

                                tran_after_pop_fail = 0: Display error message then abort.

                                tran_after_pop_fail = -1: Start a transient analysis with a run time
                                equal to 100 x max_period (see above).

                                tran_after_pop_fail = t, t > 0: Start a transient analysis with a run
                                time equal to t.
    :type td_run_after_pop_fails: float
    :key pop_use_tran_snapshot: This option instructs POP to take advantage of the last data point
                                    of a previous transient simulation, assuming the circuit and the
                                    initial conditions remained the same between the two simulation
                                    runs.
    :type pop_use_tran_snapshot: bool
    :key pop_output_cycles: Number of cycles of steady-state POP Data to show. After a successful
                            POP analysis, SIMPLIS will generate the steady-state timedomain
                            waveforms for an integral number switching cycles.
                            If set, the option value must be a positive integer between 1 and 16,
                            inclusively.
    :type pop_output_cycles: int
    :key pop_itrmax: Sets the maximum number of iterations for the periodic operating
                        point analysis. It is a positive integer between 1 and 100. The default value for n is
                        20.
    :type pop_itrmax: int
    :key pop_showdata: Display POP Data. In general, this option is turned on as a
                        debugging aid if a Periodic Operating Point (POP) analysis
                        fails.
                        This option does not take on any value. It is either turned ON
                        or turned OFF. If it is turned ON, the progress of the periodic
                        operating point analysis is output and the resulting waveforms
                        may be viewed in the same manner as for the POP cycles.
    :type pop_showdata: bool
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simplis.__init__(self, enums.AnalysisType.AC, None, **kwargs)

        self._scriptable_options.extend(
            [
                "sweep_mode",
                "n_pt",
                "start_freq",
                "stop_freq",
                "freq_domain",
                "trig_condition",
                "max_period",
                "convergence",
                "cycles_before_launch",
                "td_run_after_pop_fails",
                "pop_use_tran_snapshot",
                "pop_output_cycles",
                "pop_itrmax",
                "pop_showdata",
            ]
        )

        self._opts_container["sweep_mode"] = kwargs.get("sweep_mode", None)
        self._opts_container["n_pt"] = kwargs.get("n_pt", None)
        self._opts_container["start_freq"] = kwargs.get("start_freq", None)
        self._opts_container["stop_freq"] = kwargs.get("stop_freq", None)
        self._opts_container["freq_domain"] = kwargs.get("freq_domain", "Z")
        self._opts_container["trig_condition"] = kwargs.get("trig_condition", "0_TO_1")
        self._opts_container["max_period"] = kwargs.get("max_period", 1e-6)
        self._opts_container["convergence"] = kwargs.get("convergence", 1e-12)
        self._opts_container["cycles_before_launch"] = kwargs.get("cycles_before_launch", 5)
        self._opts_container["td_run_after_pop_fails"] = kwargs.get("td_run_after_pop_fails", -1)
        self._opts_container["pop_use_tran_snapshot"] = kwargs.get("pop_use_tran_snapshot", False)
        self._opts_container["pop_output_cycles"] = kwargs.get("pop_output_cycles", 5)
        self._opts_container["pop_itrmax"] = kwargs.get("pop_itrmax", 20)
        self._opts_container["pop_showdata"] = kwargs.get("pop_showdata", True)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simplis._check_mandatory_options(self)

        if self.sweep_mode == "DEC" or self.sweep_mode == "OCT" or self.sweep_mode == "LIN":
            pass
        else:
            msg = "sweep_mode"
            raise self._DefectiveOption(msg, "None of the three legal Sweep Modes: DEC, OCT or LIN was selected.")

        if self.freq_domain == "Z" or self.freq_domain == "S":
            pass
        else:
            msg = "freq_domain"
            raise self._DefectiveOption(msg, "None of the two legal frequency domains: S or Z was selected.")

        list_mandatory_options = ["start_freq", "stop_freq", "n_pt"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

        list_mandatory_options = ["trig_gate"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

        if self.trig_condition not in ["0_TO_1", "1_TO_0"]:
            msg = "trig_condition"
            raise self._DefectiveOption(msg, "None of the two legal Trigger Modes: 0_TO_1 or 1_TO_0 was selected.")

        if not 1.0e-14 <= self.convergence <= 1.0e-06:
            msg = "convergence"
            raise self._DefectiveOption(
                msg, "The value specified for convergence exceeds the permitted range of [1.0e-14 to 1.0e-06]."
            )

        if not 1 <= self.pop_output_cycles <= 16:
            msg = "convergence"
            raise self._DefectiveOption(
                msg, "The value specified for convergence exceeds the permitted range of [1 to 16]."
            )

        if not 1 <= self.pop_itrmax <= 100:
            msg = "convergence"
            raise self._DefectiveOption(
                msg, "The value specified for convergence exceeds the permitted range of [1 to 100]."
            )

    @property
    def sweep_mode(self):
        """
        Three sweeping algorithms are available in SIMPLIS: DEC, OCT and LIN.
        More information on these modes can be found in the SIMetrix Simulator Reference Manual.
        """
        return self._opts_container["sweep_mode"]

    @property
    def n_pt(self):
        """
        If "sweep_mode" is set to "DEC", the frequency of analysis will be
        swept in a logarithmic manner and n_pt represents the number of points per decade in the swept
        frequency.

        If "sweep_mode" is set to "OCT", the frequency of analysis will be swept in a
        logarithmic manner and n_pt represents the number of points per octave in the swept
        frequency.

        If "sweep_mode" is set to "LIN", the frequency of analysis is swept in a linear manner
        and n_pt represents the total number of points in the linear frequency sweep.
        Also in this case, n_pt must be an integer larger than one.
        """
        return self._opts_container["n_pt"]

    @property
    def start_freq(self):
        """
        Is a positive floating-point number representing the starting frequency of the sweep.
        """
        return self._opts_container["start_freq"]

    @property
    def stop_freq(self):
        """
        Is a positive floating-point number representing the stopping frequency of the sweep.
        """
        return self._opts_container["stop_freq"]

    @property
    def freq_domain(self):
        """
        Option statement associated with theSIMPLIS-FX (AC) small-signal frequency-domain analysis.
        It can either be set to 'S' indicating the continuous domain or 'Z' indicating the discrete domain.
        """
        return self._opts_container["freq_domain"]

    @property
    def trig_condition(self):
        """
        There are two modi available: 0_TO_1 and 1_TO_0, which refer to falling or rising edge.
        """
        return self._opts_container["trig_condition"]

    @property
    def max_period(self):
        """
        Is a positive floating-point number, which limits the periodic duration to this value.
        """
        return self._opts_container["max_period"]

    @property
    def convergence(self):
        """
        Sets the convergence criteria for the periodic operating point analysis.
        """
        return self._opts_container["convergence"]

    @property
    def cycles_before_launch(self):
        """
        Defines, how many switching cycles should be performed before starting the POP analysis.
        """
        return self._opts_container["cycles_before_launch"]

    @property
    def td_run_after_pop_fails(self):
        """
        Controls behaviour if the POP analysis fails to converge.
        """
        return self._opts_container["td_run_after_pop_fails"]

    @property
    def pop_use_tran_snapshot(self):
        """
        This option instructs POP to take advantage of the last data point
        of a previous transient simulation, assuming the circuit and the
        initial conditions remained the same between the two simulation runs.
        """
        return self._opts_container["pop_use_tran_snapshot"]

    @property
    def pop_output_cycles(self):
        """
        Number of cycles of steady-state POP Data to show.
        """
        return self._opts_container["pop_output_cycles"]

    @property
    def pop_itrmax(self):
        """
        Sets the maximum number of iterations for the periodic operating point analysis.
        """
        return self._opts_container["pop_itrmax"]

    @property
    def pop_showdata(self):
        """
        Display POP Data.
        """
        return self._opts_container["pop_showdata"]


class Options_SimplisPOP(_Options_Simplis):
    """
    Simulation option object for POP (Periodic-Operating-Point) analysis with Simplis

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Simplis Only Options:

    :key keeps: Simplis signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See Simplis/SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key expand: Show the entire circuit after all subcircuit calls have been instantiated.
                    The listing of this expanded circuit is shown in the
                    file “XXXX.lst” where XXXX is the name of the input file. The
                    default is not to show the expanded circuit.
    :type expand: bool
    :key mapnode0: MAPNODE0 By default, node 0 is not allowed to appear as an external node
                    in the definition of a subcircuit and node 0 in a subcircuit is
                    considered the same node as node 0 in the main circuit. If
                    MAPNODE0 is specified as an option, node 0 in a subcircuit
                    would not be considered as the same node as node 0 in the main
                    circuit. In such a case, node 0 in the subcircuit is appropriately
                    mapped for each subcircuit instantiation and it is allowed to
                    appear as an external node in the subcircuit definition.
    :type mapnode0: bool
    :key no_force_data: Disable forcing data points before and after each switching instant.
                        This option does not take any value. It is either turned
                        ON (option present) or turned OFF (option not present). If it is
                        turned ON, SIMPLIS will not generate data points before and
                        after each switching instant. If it is turned OFF, SIMPLIS will
                        create data points each side of a switching instant.

                        Example - turn option ON:

                        .OPTIONS NO_FORCED_DATA

                        Under most circumstances, this option should remain turned
                        OFF. For very long simulations that generate extremely large
                        data sets, the waveform viewer may be slow responding to
                        user commands. In such cases, turning ON the NO_FORCED
                        _DATA option will reduce the number of simulation data points
                        displayed in the waveform viewer during each switching cycle.
                        For long simulations that involve many switching instants in one
                        switching cycle this reduction can be significant. Enabling this
                        option in no way degrades the accuracy of the SIMPLIS solution,
                        but it can potentially reduce the fidelity of the displayed
                        waveforms within each switching cycle.
    :type no_force_data: bool
    :key min_avg_topology_dur: SIMPLIS calculates the average time it spends in each toplogy
                                over a number of topologies defined by AVG_TOPOLOGY
                                _DUR_MEASUREMENT_WINDOW. If this value falls below
                                MIN_AVG_TOPOLOGY_DUR, the simulation aborts. The
                                default value is 1e-18.

                                The purpose of this is to resolve problems with the simulation
                                apparently getting 'stuck' in situations where there are unexpected
                                very high speed oscillations.
    :type min_avg_topology_dur: float
    :key avg_topology_dur_measurement: Default value = 128. See MIN_AVG_TOPOLOGY_DUR above for details.
    :type avg_topology_dur_measurement: int
    :key ignore_units: If it is turned ON, SIMPLIS will ignore any trailing units or strings when it is looking for a
                        floating-point number. For example, in specifying the voltage of
                        a DC voltage source, SIMPLIS would not complain the trailing
                        'V' here 1.23V if this options is turned ON.
                        The default is to not to turn ON this option and SIMPLIS would
                        then complain about the trailing string or units. To turn ON
                        this option, the line in the following “Example” section should
                        be output to the SIMPLIS simulation input deck.
    :type ignore_units: bool
    :key new_analysis: Force new analysis. This option does not take on any value. It is
                        either turned ON or turned OFF. If it is turned ON, SIMPLIS
                        will ignore any relevant data files from a previous simulation,
                        even if the circuit and the initial conditions between the two
                        simulation runs are the same. If this option is turned OFF,
                        SIMPLIS will try to take advantage of any relevant data files
                        from the previous simulation if the circuit and the initial conditions
                        have not changed from the previous simulation run.
                        To turn ON this option, the line in the following “Example”
                        section should be output to the SIMPLIS simulation input deck.
    :type new_analysis: bool
    :key snapshot_npt: SNAPSHOT_NPT Maximum number of saved snapshots. This sets the maximum
                        number of snapshots that SIMPLIS would save. If there is a
                        conflict between the values set for the SNAPSHOT_NPT and
                        SNAPSHOT_INTVL options, the value set for the SNAPSHOT
                        _NPT option will override the value set for the SNAPSHOT
                        _INTVL option.

                        If set, the option value must be a non-negative number between
                        11 and 201, inclusively.

                        If this option is not set, SIMPLIS will not save any snapshot.
    :type snapshot_npt: int
    :key snapshot_intvl: Minimum duration between snapshots. This instructs SIMPLIS
                            to save a snapshot of the internal state of the simulation at
                            intervals no smaller than the option value set for SNAPSHOT
                            _INTVL.
                            If set, the option value must be a non-negative floating-point
                            number. Engineering prefixes are allowed.
                            If this option is not set, it defaults to zero. If this option is not
                            set, or if the option is set to zero, SIMPLIS would not save any
                            snapshots at all.
    :type snapshot_intvl: float
    :key tstop: is a positive floating-point number in seconds to stand for the
                time instant at which the time-domain transient analysis stops
    :type tstop: float
    :key tsave: is a positive floating-point number smaller than tstop. It defines the time, simulation data is started to be saved.
    :type tsave: float
    :key psp_start: PSP_START = t1 For time-domain transient analysis, the print variables are generated
                    for time values larger than or equal to the value of t1. “PSP
                    _START=” is the ten-character keyword “PSP_START=” and
                    t1 is a nonnegative floating-point number. If this option is not
                    specified, the default value for t1 is the time the simulation starts
                    saving data for the transient analysis. Refer to the .TRAN statement
                    for details of the transient analysis.
    :type psp_start: float
    :key psp_end: PSP_END = t2 For time-domain transient analysis, the print variables are generated
                    for time values up to but not larger than the value of t2.
                    “PSP_END=” is the eight-character keyword “PSP_END=”
                    and t2 is a positive number larger than the value of t1. If this
                    option is not specified, the default value for t2 is the stop time
                    of the transient analysis as specified in the .TRAN statement.
                    If the value of t2 in PSP_END is smaller than the value for t1
                    in PSP_START, no output print file will be generated for the
                    transient analysis.
    :type psp_end: float
    :key psp_npt: PSP_NPT = n Set the minimum number of data points generated for printing
                    the output variables during the transient analysis. “PSP
                    _NPT=” is an eight-character keyword and n is an integer
                    between 2 and 100000001, inclusively. (PSP_END - PSP
                    _START)/(PSP_NPT - 1) is the step size of the time variable
                    in the print file generated for the transient analysis. If PSP
                    _NPT is not specified, no output print file will be generated for
                    the transient analysis.
    :type psp_npt: int

    Options SIMPLIS POP:

    :key trig_gate: Device name of a defined logic gate. This device is considered
                    the triggering gate of the POP analysis. Together with the parameter
                    value of TRIG_COND, it determines the condition that constitutes
                    the start of a new switching cycle in the POP analysis.
    :type trig_gate: str
    :key trig_condition: There are two modi available: 0_TO_1 and 1_TO_0, which refer to falling or rising edge.
    :type trig_condition: str
    :key max_period: Is a positive floating-point number, which limits the periodic duration to this value.
    :type max_period: float
    :key convergence: Sets the convergence criteria for the periodic operating point analysis.
                        The convergence criteria is satisfied when the relative change in each
                        state variable, between the start and end of a switching cycle, is less
                        than this parameter. The value is a positive floating point number between
                        1.0e-06 and 1.0e-14, inclusive. The default value for convergence is 1p.
    :type convergence: float
    :key cycles_before_launch: Defines, how many switching cycles should be performed before starting the POP analysis.
    :type cycles_before_launch: int
    :key td_run_after_pop_fails: Controls behaviour if the POP analysis fails to converge. This has
                                three modes of operation as follows:

                                tran_after_pop_fail = 0: Display error message then abort.

                                tran_after_pop_fail = -1: Start a transient analysis with a run time
                                equal to 100 x max_period (see above).

                                tran_after_pop_fail = t, t > 0: Start a transient analysis with a run
                                time equal to t.
    :type td_run_after_pop_fails: float
    :key pop_use_tran_snapshot: This option instructs POP to take advantage of the last data point
                                    of a previous transient simulation, assuming the circuit and the
                                    initial conditions remained the same between the two simulation
                                    runs.
    :type pop_use_tran_snapshot: bool
    :key pop_output_cycles: Number of cycles of steady-state POP Data to show. After a successful
                            POP analysis, SIMPLIS will generate the steady-state timedomain
                            waveforms for an integral number switching cycles.
                            If set, the option value must be a positive integer between 1 and 16,
                            inclusively.
    :type pop_output_cycles: int
    :key pop_itrmax: Sets the maximum number of iterations for the periodic operating
                        point analysis. It is a positive integer between 1 and 100. The default value for n is
                        20.
    :type pop_itrmax: int
    :key pop_showdata: Display POP Data. In general, this option is turned on as a
                        debugging aid if a Periodic Operating Point (POP) analysis
                        fails.
                        This option does not take on any value. It is either turned ON
                        or turned OFF. If it is turned ON, the progress of the periodic
                        operating point analysis is output and the resulting waveforms
                        may be viewed in the same manner as for the POP cycles.
    :type pop_showdata: bool
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Simplis.__init__(self, enums.AnalysisType.POP, None, **kwargs)

        self._scriptable_options.extend(
            [
                "trig_condition",
                "max_period",
                "convergence",
                "cycles_before_launch",
                "td_run_after_pop_fails",
                "pop_use_tran_snapshot",
                "pop_output_cycles",
                "pop_itrmax",
                "pop_showdata",
            ]
        )

        self._opts_container["trig_condition"] = kwargs.get("trig_condition", "0_TO_1")
        self._opts_container["max_period"] = kwargs.get("max_period", 1e-6)
        self._opts_container["convergence"] = kwargs.get("convergence", 1e-12)
        self._opts_container["cycles_before_launch"] = kwargs.get("cycles_before_launch", 5)
        self._opts_container["td_run_after_pop_fails"] = kwargs.get("td_run_after_pop_fails", -1)
        self._opts_container["pop_use_tran_snapshot"] = kwargs.get("pop_use_tran_snapshot", False)
        self._opts_container["pop_output_cycles"] = kwargs.get("pop_output_cycles", 5)
        self._opts_container["pop_itrmax"] = kwargs.get("pop_itrmax", 20)
        self._opts_container["pop_showdata"] = kwargs.get("pop_showdata", True)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Simplis._check_mandatory_options(self)

        list_mandatory_options = ["trig_gate"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

        if self.trig_condition not in ["0_TO_1", "1_TO_0"]:
            msg = "trig_condition"
            raise self._DefectiveOption(msg, "None of the two legal Trigger Modes: 0_TO_1 or 1_TO_0 was selected.")

        if not 1.0e-14 <= self.convergence <= 1.0e-06:
            msg = "convergence"
            raise self._DefectiveOption(
                msg, "The value specified for convergence exceeds the permitted range of [1.0e-14 to 1.0e-06]."
            )

        if not 1 <= self.pop_output_cycles <= 16:
            msg = "convergence"
            raise self._DefectiveOption(
                msg, "The value specified for convergence exceeds the permitted range of [1 to 16]."
            )

        if not 1 <= self.pop_itrmax <= 100:
            msg = "convergence"
            raise self._DefectiveOption(
                msg, "The value specified for convergence exceeds the permitted range of [1 to 100]."
            )

    @property
    def trig_condition(self):
        """
        There are two modi available: 0_TO_1 and 1_TO_0, which refer to falling or rising edge.
        """
        return self._opts_container["trig_condition"]

    @property
    def max_period(self):
        """
        Is a positive floating-point number, which limits the periodic duration to this value.
        """
        return self._opts_container["max_period"]

    @property
    def convergence(self):
        """
        Sets the convergence criteria for the periodic operating point analysis.
        """
        return self._opts_container["convergence"]

    @property
    def cycles_before_launch(self):
        """
        Defines, how many switching cycles should be performed before starting the POP analysis.
        """
        return self._opts_container["cycles_before_launch"]

    @property
    def td_run_after_pop_fails(self):
        """
        Controls behaviour if the POP analysis fails to converge.
        """
        return self._opts_container["td_run_after_pop_fails"]

    @property
    def pop_use_tran_snapshot(self):
        """
        This option instructs POP to take advantage of the last data point
        of a previous transient simulation, assuming the circuit and the
        initial conditions remained the same between the two simulation runs.
        """
        return self._opts_container["pop_use_tran_snapshot"]

    @property
    def pop_output_cycles(self):
        """
        Number of cycles of steady-state POP Data to show.
        """
        return self._opts_container["pop_output_cycles"]

    @property
    def pop_itrmax(self):
        """
        Sets the maximum number of iterations for the periodic operating point analysis.
        """
        return self._opts_container["pop_itrmax"]

    @property
    def pop_showdata(self):
        """
        Display POP Data.
        """
        return self._opts_container["pop_showdata"]


# --------------- TITAN --------------- #


class _Options_Titan(_Options_Base):
    """
    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Titan Only Options:
    :key store_voltage_signals: Define which voltage signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_voltage_signals: str
    :key store_current_signals: Define which current signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_current_signals: str
    :key accuracy: Define general TITAN simulation accuracy. Options, which are set
                                specifically will overwrite these general settings.
    :type accuracy: str
    :key robustness: Define general TITAN settings regarding robustness of the simulation. Options, which are set
                                specifically will overwrite these general settings.
    :type robustness: str
    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key simulation_result_suffix: Simulation result file suffix, when simulating on Windows.
    :type simulation_result_suffix: str
    :key sim_data_access: Specify tooling for accessing simulation result data. Currently available: SIMetrix or pVerify.
    :type sim_data_access: str
    :key mode: Define the IFXspice Mode to be run. Supported runs: "local_win", "distrib_unix", "distrib_de", "distrib_re".
    :type mode: str
    :key samba_unix: Specify the location of the samba directory as unix path.
    :type samba_unix: str
    :key samba_win: Specify the location of the samba directory as windows path.
    :type samba_win: str
    :key no_job_cleanup: IFXspice Unix jobs will not be cleaned up before a new simulation start.
    :type no_job_cleanup: bool
    :key EoD_binary: Path to EoD binary. Default is "C:/Program Files/Hummingbird/Connectivity/Exceed onDemand Client 8 x64/ExceedonDemand.exe".
    :type EoD_binary: str
    :key EoD_connectfile: Name of IFXspice EoD connectfile. Default is "<IFXspice_install_path>/Windows_to_UNIX_VIH.eod8".
    :type EoD_connectfile: str
    :key ETX_IE_binary: Path to Internet Explorer binary. Default is "C:\Program Files\Internet Explorer\iexplore.exe".
    :type ETX_IE_binary: str
    :key ETX_site: Site of linux cluster that shall be accessed via ETX: 'vih'.
    :type ETX_site: str
    :key ssh_binary: Path to ssh binary. Default is "C:/Program Files/Git/usr/bin/ssh.exe".
    :type ssh_binary: str
    :key ssh_opts: Additional ssh options which can be specified to the ssh call, e.g. '-o StrictHostKeyChecking=no'
    :type ssh_opts: str
    :key ssh_username: Infineon username, defaults to currently logged on user.
    :type ssh_username: str
    :key ssh_host: Login host for ssh connection. Default is "login.vih.infineon.com".
    :type ssh_host: str
    :key ifxspice_root_unix: Path to IFXspice under unix. Default is "/opt/titan/ifxspice/bin".
    :type ifxspice_root_unix: str
    :key ifxspice_root_unix: Select which connection should be used to connect to unix, ssh(default) or EoD.
    :type ifxspice_root_unix: str
    :key unix_connection: Select which connection should be used to connect to unix, ETX(default), or ssh.
    :type unix_connection: str
    :key copy_additional_files_distributed_de: Define a list of files that additionally need to be copied to individual
                                                run folders for IFXspice distributed mode de.
    :type copy_additional_files_distributed_de: list
    :key run_minimized: Select how IFXspice submits its cmd window. Default is minimized to avoid distraction of the user during long sweep runs.
    :type run_minimized: bool

    """

    def __init__(self, analysis, windows_result_suffix, unix_result_suffix, opts_dict, **kwargs):
        mode = kwargs.get("mode", enums.IFXspiceMode.Local_Windows)
        if mode == enums.IFXspiceMode.Local_Windows:
            default_simdata_format = enums.SimulationDatatype.SXDAT
        elif mode == enums.IFXspiceMode.Distributed_RE:
            default_simdata_format = enums.SimulationDatatype.HDF5
        elif mode == enums.IFXspiceMode.Distributed_DE:
            default_simdata_format = enums.SimulationDatatype.SXDAT
        else:
            default_simdata_format = enums.SimulationDatatype.SXDAT
        _Options_Base.__init__(
            self,
            enums.SimulatorType.Titan,
            analysis,
            kwargs.get("simdata_format", default_simdata_format),
            opts_dict,
            **kwargs,
        )

        find_ifxspice_and_update_env()

        self._scriptable_options.extend(
            ["mode", "accuracy", "robustness", "abstol", "reltol", "vntol", "simulation_result_suffix"]
        )

        self._opts_container["mode"] = kwargs.get("mode", enums.IFXspiceMode.Local_Windows)
        self._opts_container["store_voltage_signals"] = kwargs.get("store_voltage_signals", "toplevel")
        self._opts_container["store_current_signals"] = kwargs.get("store_current_signals", None)
        self._opts_container["accuracy"] = kwargs.get("accuracy", "standard")
        self._opts_container["robustness"] = kwargs.get("robustness", "yes")
        self._opts_container["abstol"] = kwargs.get("abstol", 1e-12)
        self._opts_container["reltol"] = kwargs.get("reltol", 0.001)
        self._opts_container["vntol"] = kwargs.get("vntol", 1e-6)

        self._opts_container["samba_unix"] = kwargs.get("samba_unix", None)
        self._opts_container["samba_win"] = kwargs.get("samba_win", None)
        self._opts_container["no_job_cleanup"] = kwargs.get("no_job_cleanup", False)
        self._opts_container["EoD_binary"] = kwargs.get(
            "EoD_binary",
            r"C:\Program Files\Hummingbird\Connectivity\Exceed onDemand Client 8 x64\ExceedonDemand.exe"
            if BIT64
            else r"C:\Program Files\Hummingbird\Connectivity\Exceed onDemand Client 8\ExceedonDemand.exe",
        )
        self._opts_container["EoD_connectfile"] = kwargs.get(
            "EoD_connectfile", os.path.join(os.environ["TITAN_INSTALL_PATH"], r"Windows_to_UNIX_VIH.eod8")
        )
        self._opts_container["ETX_IE_binary"] = kwargs.get(
            "ETX_IE_binary", r"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
        )
        self._opts_container["ETX_site"] = kwargs.get("ETX_site", r"vih")
        self._opts_container["ssh_binary"] = kwargs.get("ssh_binary", shutil.which("ssh"))
        self._opts_container["ssh_opts"] = kwargs.get("ssh_opts", "")
        self._opts_container["ssh_username"] = kwargs.get("ssh_username", getpass.getuser().lower())
        self._opts_container["ssh_host"] = kwargs.get("ssh_host", r"login.vih.infineon.com")
        self._opts_container["ifxspice_root_unix"] = kwargs.get("ifxspice_root_unix", r"/opt/titan/ifxspice/bin")
        self._opts_container["unix_connection"] = kwargs.get("unix_connection", enums.UnixConnection.ETX)
        self._opts_container["copy_additional_files_distributed_de"] = kwargs.get(
            "copy_additional_files_distributed_de", None
        )
        self._opts_container["run_minimized"] = kwargs.get("run_minimized", True)

        self._opts_container["simulation_result_suffix"] = (
            windows_result_suffix
            if self.mode in [enums.IFXspiceMode.Local_Windows, enums.IFXspiceMode.Distributed_DE]
            else unix_result_suffix
        )

    def _check_mandatory_options(self):
        _Options_Base._check_mandatory_options(self)
        if self.store_voltage_signals not in [None, "toplevel", "all"]:
            msg = "store_voltage_signals"
            raise self._DefectiveOption(
                msg, 'store_voltage_signals is none of the allowed options: "None", "toplevel" or "all".'
            )
        if self.store_current_signals not in [None, "toplevel"]:
            msg = "store_current_signals"
            raise self._DefectiveOption(
                msg, 'store_current_signals is none of the allowed options: "None" or "toplevel".'
            )
        if self.accuracy not in ["high", "standard"]:
            msg = "accuracy"
            raise self._DefectiveOption(msg, 'accuracy is none of the allowed options: "standard" or "high".')
        if self.robustness not in ["yes", "no"]:
            msg = "robustness"
            raise self._DefectiveOption(msg, 'robustness is none of the allowed options: "yes" or "no".')
        if self.schematic in [None, r""]:
            msg = "schematic"
            raise self._MissingOption(msg)
        if self.mode not in [
            enums.IFXspiceMode.Local_Windows,
            enums.IFXspiceMode.Distributed_DE,
            enums.IFXspiceMode.Distributed_RE,
        ]:
            msg = "mode"
            raise self._DefectiveOption(
                msg, f"mode {self.mode} is none of the allowed options:{enums.IFXspiceMode.Local_Windows}"
            )
        if self.simdata_format not in enums.SupportedSimulationDatatype.titan_options:
            msg = "simdata_format"
            raise self._DefectiveOption(
                msg,
                f"simdata_format is none of the allowed options: {enums.SupportedSimulationDatatype.titan_options}.",
            )
        if self.mode == enums.IFXspiceMode.Distributed_RE and self.simdata_format != enums.SimulationDatatype.HDF5:
            msg = "mode"
            raise self._DefectiveOption(
                msg,
                "While simulating with IFXspice on Distributed mode for Regression, simdata format "
                'must be set to "hdf5".',
            )

        list_samba_modes = [enums.IFXspiceMode.Distributed_DE]
        list_samba_dirs = ["samba_unix", "samba_win"]
        if self.mode in list_samba_modes:
            if None in [self.samba_win, self.samba_unix]:
                msg = f"One of the following options weren't set: {list_samba_dirs}. In order to run IFXspice Mode:{list_samba_modes}, both need to be set."
                raise self._MissingOption(msg)
            if self.unix_connection not in enums.UnixConnection.Connections:
                msg = "unix_connection"
                raise self._DefectiveOption(
                    msg,
                    f"unix_connection {self.unix_connection} is none of the allowed options:{enums.UnixConnection.ETX}",
                )

    @property
    def store_voltage_signals(self):
        """
        Define which voltage signals should be stored in simulation data.
        """
        return self._opts_container["store_voltage_signals"]

    @property
    def store_current_signals(self):
        """
        Define which current signals should be stored in simulation data.
        """
        return self._opts_container["store_current_signals"]

    @property
    def accuracy(self):
        """
        Define general TITAN simulation accuracy.
        """
        return self._opts_container["accuracy"]

    @property
    def robustness(self):
        """
        Define general TITAN settings regarding robustness of the simulation.
        """
        return self._opts_container["robustness"]

    @property
    def abstol(self):
        """
        The absolute current error tolerance.
        """
        return self._opts_container["abstol"]

    @property
    def reltol(self):
        """
        This is the relative tolerance that must be met for each analysis point.
        """
        return self._opts_container["reltol"]

    @property
    def vntol(self):
        """
        The absolute voltage error tolerance. Circuits with large voltages present
        (>100) may benefit from an increase in this value.
        """
        return self._opts_container["vntol"]

    @property
    def mode(self):
        """
        Define the IFXspice Mode to be run. Supported runs: "local_win", "distrib_de", "distrib_re".
        """
        return self._opts_container["mode"]

    @property
    def samba_unix(self):
        """
        Specify the location of the samba directory as unix path.
        """
        return self._opts_container["samba_unix"]

    @property
    def samba_win(self):
        """
        Specify the location of the samba directory as windows path.
        """
        return self._opts_container["samba_win"]

    @property
    def no_job_cleanup(self):
        """
        IFXspice Unix jobs will not be cleaned up before a new simulation start.
        """
        return self._opts_container["no_job_cleanup"]

    @property
    def EoD_binary(self):
        """
        Path to EoD binary. Default is "C:\Program Files\Hummingbird\Connectivity\Exceed onDemand Client 8 x64\ExceedonDemand.exe".
        """
        return self._opts_container["EoD_binary"]

    @property
    def EoD_connectfile(self):
        """
        Name of IFXspice EoD connectfile. Default is "<IFXspice_install_path>\Windows_to_UNIX_VIH.eod8".
        """
        return self._opts_container["EoD_connectfile"]

    @property
    def ETX_IE_binary(self):
        """
        Path to Internet Explorer binary. Default is "C:\Program Files\Internet Explorer\iexplore.exe".
        """
        return self._opts_container["ETX_IE_binary"]

    @property
    def ETX_site(self):
        """
        Site of linux cluster that shall be accessed via ETX: 'vih'.
        """
        return self._opts_container["ETX_site"]

    @property
    def ssh_binary(self):
        """
        Path to ssh binary. Default is "C:/Program Files/Git/usr/bin/ssh.exe".
        """
        return self._opts_container["ssh_binary"]

    @property
    def ssh_opts(self):
        """
        Additional ssh options which can be specidief for the ssh call for distributed mode, e.g. '-o StrictHostKeyChecking=no'
        """
        return self._opts_container["ssh_opts"]

    @property
    def ssh_username(self):
        """
        Infineon username, defaults to currently logged on user.
        """
        return self._opts_container["ssh_username"]

    @property
    def ssh_host(self):
        """
        Login host for ssh connection. Default is "login.vih.infineon.com".
        """
        return self._opts_container["ssh_host"]

    @property
    def ifxspice_root_unix(self):
        """
        Path to IFXspice under unix. Default is "/opt/titan/ifxspice/bin".
        """
        return self._opts_container["ifxspice_root_unix"]

    @property
    def unix_connection(self):
        """
        Select which connection should be used to connect to unix, ETX(default), or ssh.
        """
        return self._opts_container["unix_connection"]

    @property
    def copy_additional_files_distributed_de(self):
        """
        Define a list of files that additionally need to be copied to individual run folders for IFXspice distributed mode de.
        """
        return self._opts_container["copy_additional_files_distributed_de"]

    @property
    def run_minimized(self):
        """
        Select how IFXspice submits its cmd window. Default is minimized to avoid distraction of the user during long sweep runs.
        """
        return self._opts_container["run_minimized"]

    @property
    def simulation_result_suffix(self):
        """
        Simulation result file suffix, when simulating on Windows.
        """
        return self._opts_container["simulation_result_suffix"]


class Options_TitanTran(_Options_Titan):
    """
    Simulation option object for transient simulation with Titan using IFXspice:

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Titan Only Options:
    :key store_voltage_signals: Define which voltage signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_voltage_signals: str
    :key store_current_signals: Define which current signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_current_signals: str
    :key accuracy: Define general TITAN simulation accuracy. Options, which are set
                                specifically will overwrite these general settings.
    :type accuracy: str
    :key robustness: Define general TITAN settings regarding robustness of the simulation. Options, which are set
                                specifically will overwrite these general settings.
    :type robustness: str
    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key simulation_result_suffix: Simulation result file suffix, when simulating on Windows.
    :type simulation_result_suffix: str
    :key sim_data_access: Specify tooling for accessing simulation result data. Currently available: SIMetrix or pVerify.
    :type sim_data_access: str
    :key mode: Define the IFXspice Mode to be run. Supported runs: "local_win", "distrib_unix", "distrib_de", "distrib_re".
    :type mode: str
    :key samba_unix: Specify the location of the samba directory as unix path.
    :type samba_unix: str
    :key samba_win: Specify the location of the samba directory as windows path.
    :type samba_win: str
    :key no_job_cleanup: IFXspice Unix jobs will not be cleaned up before a new simulation start.
    :type no_job_cleanup: bool
    :key EoD_binary: Path to EoD binary. Default is "C:/Program Files/Hummingbird/Connectivity/Exceed onDemand Client 8 x64/ExceedonDemand.exe".
    :type EoD_binary: str
    :key EoD_connectfile: Name of IFXspice EoD connectfile. Default is "<IFXspice_install_path>/Windows_to_UNIX_VIH.eod8".
    :type EoD_connectfile: str
    :key ssh_binary: Path to ssh binary. Default is "C:/Program Files/Git/usr/bin/ssh.exe".
    :type ssh_binary: str
    :key ssh_opts: Additional ssh options which can be specified to the ssh call, e.g. '-o StrictHostKeyChecking=no'
    :type ssh_opts: str
    :key ssh_username: Infineon username, defaults to currently logged on user.
    :type ssh_username: str
    :key ssh_host: Login host for ssh connection. Default is "login.vih.infineon.com".
    :type ssh_host: str
    :key ifxspice_root_unix: Path to IFXspice under unix. Default is "/opt/titan/ifxspice/bin".
    :type ifxspice_root_unix: str
    :key unix_connection: Select which connection should be used to connect to unix, ETX(default) or ssh.
    :type unix_connection: str
    :key copy_additional_files_distributed_de: Define a list of files that additionally need to be copied to individual
                                                run folders for IFXspice distributed mode de.
    :type copy_additional_files_distributed_de: list
    :key run_minimized: Select how IFXspice submits its cmd window. Default is minimized to avoid distraction of the user during long sweep runs.
    :type run_minimized: bool

    IFXspice Tran Options:

    :key tstep: This defines the interval for tabulated results specified by the
                .PRINT statement. It also defines the output interval for all data
                if the NORAW option is specified. If there are no .PRINT
                statements in the netlist and NORAW is not being used, this can
                be set to zero or omitted altogether as in form 1 above. If set to
                zero it defaults to (tstop-tstart)/50
                tstep is also used to define default values for pulse and
                exponential stimuli.
                Note that if tstep and NORAW are specified a time point is
                forced at tstep intervals to calculate the output. This differs from
                other SPICE programs which generate output at tstep by
                interpolation.
                tstep does not control the time step used by the simulator. This is
                controlled automatically according to circuit activity.
    :type tstep: float
    :key tstop: Stop time. Note that if running in GUI mode, a transient analysis
                can be restarted from the front end using the RestartTran
                command. See User's Manual for details.
    :type tstop: float
    :key tstart: Start time. This is the time at which the storage of transient
                 analysis outputs commences. It is not the time at which the
                 analysis begins; this is always zero. tstart is zero if it is omitted.
    :type tstart: float
    :key tmaxstep: Maximum time step. The simulator uses the largest time step
                   possible to achieve the required accuracy but will not increase it
                   beyond this value. If not specified it is set to (tstop-tstart)/50 .
    :type tmaxstep: float
    :key uic: If specified a DC operating point is not calculated and initial
              condition specifications are used instead
    :type uic: bool
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Titan.__init__(
            self, enums.AnalysisType.TRAN, enums.TitanSuffix.Tran_Windows, enums.TitanSuffix.Tran_Unix, None, **kwargs
        )

        self._scriptable_options.extend(["tstop", "tstart", "tstep", "tmaxstep", "uic"])

        self._opts_container["tstop"] = kwargs.get("tstop", 1e-3)
        self._opts_container["tstart"] = kwargs.get("tstart", 0.0)
        self._opts_container["tstep"] = kwargs.get("tstep", 0)
        self._opts_container["tmaxstep"] = kwargs.get("tmaxstep", (self.tstop - self.tstart) / 50.0)
        self._opts_container["uic"] = kwargs.get("uic", False)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Titan._check_mandatory_options(self)

        list_mandatory_options = ["tstep", "tstop"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

    @property
    def tstep(self):
        """
        This defines the interval for tabulated results specified by the
                .PRINT statement. It also defines the output interval for all data
                if the NORAW option is specified. If there are no .PRINT
                statements in the netlist and NORAW is not being used, this can
                be set to zero or omitted altogether as in form 1 above. If set to
                zero it defaults to (tstop-tstart)/50
                tstep is also used to define default values for pulse and
                exponential stimuli.
                Note that if tstep and NORAW are specified a time point is
                forced at tstep intervals to calculate the output. This differs from
                other SPICE programs which generate output at tstep by
                interpolation.
                tstep does not control the time step used by the simulator. This is
                controlled automatically according to circuit activity.
        """
        return self._opts_container["tstep"]

    @property
    def tstop(self):
        """
        Stop time. Note that if running in GUI mode, a transient analysis
        can be restarted from the front end using the RestartTran
        command. See User's Manual for details.
        """
        return self._opts_container["tstop"]

    @property
    def uic(self):
        """
        If specified a DC operating point is not calculated and initial
        condition specifications are used instead
        """
        return self._opts_container["uic"]

    @property
    def tstart(self):
        """
        Start time. This is the time at which the storage of transient
        analysis outputs commences. It is not the time at which the
        analysis begins; this is always zero. tstart is zero if it is omitted.
        """
        return self._opts_container["tstart"]

    @property
    def tmaxstep(self):
        """
        Maximum time step. The simulator uses the largest time step
        possible to achieve the required accuracy but will not increase it
        beyond this value. If not specified it is set to (tstop-tstart)/50 .
        """
        return self._opts_container["tmaxstep"]


class Options_TitanDC(_Options_Titan):
    """
    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Titan Only Options:
    :key store_voltage_signals: Define which voltage signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_voltage_signals: str
    :key store_current_signals: Define which current signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_current_signals: str
    :key accuracy: Define general TITAN simulation accuracy. Options, which are set
                                specifically will overwrite these general settings.
    :type accuracy: str
    :key robustness: Define general TITAN settings regarding robustness of the simulation. Options, which are set
                                specifically will overwrite these general settings.
    :type robustness: str
    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key simulation_result_suffix: Simulation result file suffix, when simulating on Windows.
    :type simulation_result_suffix: str
    :key sim_data_access: Specify tooling for accessing simulation result data. Currently available: SIMetrix or pVerify.
    :type sim_data_access: str
    :key mode: Define the IFXspice Mode to be run. Supported runs: "local_win", "distrib_unix", "distrib_de", "distrib_re".
    :type mode: str
    :key samba_unix: Specify the location of the samba directory as unix path.
    :type samba_unix: str
    :key samba_win: Specify the location of the samba directory as windows path.
    :type samba_win: str
    :key no_job_cleanup: IFXspice Unix jobs will not be cleaned up before a new simulation start.
    :type no_job_cleanup: bool
    :key EoD_binary: Path to EoD binary. Default is "C:/Program Files/Hummingbird/Connectivity/Exceed onDemand Client 8 x64/ExceedonDemand.exe".
    :type EoD_binary: str
    :key EoD_connectfile: Name of IFXspice EoD connectfile. Default is "<IFXspice_install_path>/Windows_to_UNIX_VIH.eod8".
    :type EoD_connectfile: str
    :key ssh_binary: Path to ssh binary. Default is "C:/Program Files/Git/usr/bin/ssh.exe".
    :type ssh_binary: str
    :key ssh_opts: Additional ssh options which can be specified to the ssh call, e.g. '-o StrictHostKeyChecking=no'
    :type ssh_opts: str
    :key ssh_username: Infineon username, defaults to currently logged on user.
    :type ssh_username: str
    :key ssh_host: Login host for ssh connection. Default is "login.vih.infineon.com".
    :type ssh_host: str
    :key ifxspice_root_unix: Path to IFXspice under unix. Default is "/opt/titan/ifxspice/bin".
    :type ifxspice_root_unix: str
    :key unix_connection: Select which connection should be used to connect to unix, ETX(default) or ssh.
    :type unix_connection: str
    :key copy_additional_files_distributed_de: Define a list of files that additionally need to be copied to individual
                                                run folders for IFXspice distributed mode de.
    :type copy_additional_files_distributed_de: list
    :key run_minimized: Select how IFXspice submits its cmd window. Default is minimized to avoid distraction of the user during long sweep runs.
    :type run_minimized: bool

    Simulation option object for DC analysis with Titan using IFXspice

    :key device_name: Name of device to be swept. The following components may be swept:
                        Capacitors, all controlled sources, fixed current source, fixed
                        voltage source, inductors and resistors.
    :type device_name: str

    :key step_spec: Determines the algorithm for determining the sweep steps according to one of the following (LIN, DEC, OCT):

                    LIN num_points start stop

                    DEC num_points_decade start stop

                    OCT num_points_octave start stop

    :type step_spec: str
    :key start: First value
    :type start: float|int
    :key stop: Last value
    :type stop: float|int
    :key num_points: Total number of points
    :type num_points: int
    :key num_points_decade: Number of points per decade
    :type num_points_decade: int
    :key num_points_octave: Number of points per octave
    :type num_points_octave: int

    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Titan.__init__(
            self, enums.AnalysisType.DC, enums.TitanSuffix.DC_Windows, enums.TitanSuffix.DC_Unix, None, **kwargs
        )

        self._scriptable_options.extend(
            ["device_name", "step_spec", "start", "stop", "num_points", "num_points_decade", "num_points_octave"]
        )

        self._opts_container["device_name"] = kwargs.get("device_name", None)
        self._opts_container["step_spec"] = kwargs.get("step_spec", None)
        self._opts_container["start"] = kwargs.get("start", None)
        self._opts_container["stop"] = kwargs.get("stop", None)
        self._opts_container["num_points"] = kwargs.get("num_points", None)
        self._opts_container["num_points_decade"] = kwargs.get("num_points_decade", None)
        self._opts_container["num_points_octave"] = kwargs.get("num_points_octave", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Titan._check_mandatory_options(self)
        list_mandatory_options = ["device_name"]
        for man_opt in list_mandatory_options:
            if getattr(self, man_opt, None) in [None, r""]:
                raise self._MissingOption(man_opt)

        if self.step_spec == "LIN":
            list_mandatory_options = ["num_points", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "DEC":
            list_mandatory_options = ["num_points_decade", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "OCT":
            list_mandatory_options = ["num_points_octave", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        else:
            msg = "step_spec"
            raise self._DefectiveOption(msg, "None of the three legal Step_specs: LIN, DEC or OCT was selected.")

    @property
    def device_name(self):
        """
        Name of device to be swept. The following components may be swept:
        Capacitors, all controlled sources, fixed current source, fixed
        voltage source, inductors and resistors.
        """
        return self._opts_container["device_name"]

    @property
    def step_spec(self):
        """
        Determines the algorithm for determining the sweep steps according to one of the following (LIN, DEC, OCT):

        LIN num_points start stop

        DEC num_points_decade start stop

        OCT num_points_octave start stop
        """
        return self._opts_container["step_spec"]

    @property
    def start(self):
        """
        First value
        """
        return self._opts_container["start"]

    @property
    def stop(self):
        """
        Last value
        """
        return self._opts_container["stop"]

    @property
    def num_points(self):
        """
        Total number of points
        """
        return self._opts_container["num_points"]

    @property
    def num_points_decade(self):
        """
        Number of points per decade
        """
        return self._opts_container["num_points_decade"]

    @property
    def num_points_octave(self):
        """
        Number of points per octave
        """
        return self._opts_container["num_points_octave"]


class Options_TitanAC(_Options_Titan):
    """
    Simulation option object for AC analysis with Titan using IFXspice

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    Titan Only Options:
    :key store_voltage_signals: Define which voltage signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_voltage_signals: str
    :key store_current_signals: Define which current signals should be stored in simulation data. .KEEP statements
                                will overwrite these general settings.
    :type store_current_signals: str
    :key accuracy: Define general TITAN simulation accuracy. Options, which are set
                                specifically will overwrite these general settings.
    :type accuracy: str
    :key robustness: Define general TITAN settings regarding robustness of the simulation. Options, which are set
                                specifically will overwrite these general settings.
    :type robustness: str
    :key keeps: SIMetrix signal specs and KEEPS flags to control retained
                simulaton data (default - netlist default)
                Note that if keeps contains signal names or wildcards then
                KeepNone is automatically set so ONLY the specified signals are
                retained.  See SIMetrix Simulator Reference Manual.
    :type keeps: str|list[str]
    :key interactive: Interactive run - do not DelGroup the temporary results vector
                        once results have been saved
    :type interactive: bool
    :key schematic: Name of the schematic selected for simulation
    :type schematic: str
    :key abstol: Units = A. The absolute current error tolerance. It
                    is sometimes desirable to increase this
                    for circuits that carry large currents
                    (>1A) to speed the solution and aid
                    convergence.
    :type abstol: float
    :key reltol: This is the relative tolerance that must be met for each analysis point.
                    Reducing this number will improve accuracy at the expense of simulation
                    time or/and convergence reliability. Simulation results can not be relied
                    upon if its value is increased beyond 0.01.
    :type reltol: float
    :key vntol: The absolute voltage error tolerance. Circuits with large voltages present
                (>100) may benefit from an increase in this value.
    :type vntol: float
    :key simulation_result_suffix: Simulation result file suffix, when simulating on Windows.
    :type simulation_result_suffix: str
    :key sim_data_access: Specify tooling for accessing simulation result data. Currently available: SIMetrix or pVerify.
    :type sim_data_access: str
    :key mode: Define the IFXspice Mode to be run. Supported runs: "local_win", "distrib_unix", "distrib_de", "distrib_re".
    :type mode: str
    :key samba_unix: Specify the location of the samba directory as unix path.
    :type samba_unix: str
    :key samba_win: Specify the location of the samba directory as windows path.
    :type samba_win: str
    :key no_job_cleanup: IFXspice Unix jobs will not be cleaned up before a new simulation start.
    :type no_job_cleanup: bool
    :key EoD_binary: Path to EoD binary. Default is "C:/Program Files/Hummingbird/Connectivity/Exceed onDemand Client 8 x64/ExceedonDemand.exe".
    :type EoD_binary: str
    :key EoD_connectfile: Name of IFXspice EoD connectfile. Default is "<IFXspice_install_path>/Windows_to_UNIX_VIH.eod8".
    :type EoD_connectfile: str
    :key ssh_binary: Path to ssh binary. Default is "C:/Program Files/Git/usr/bin/ssh.exe".
    :type ssh_binary: str
    :key ssh_opts: Additional ssh options which can be specified to the ssh call, e.g. '-o StrictHostKeyChecking=no'
    :type ssh_opts: str
    :key ssh_username: Infineon username, defaults to currently logged on user.
    :type ssh_username: str
    :key ssh_host: Login host for ssh connection. Default is "login.vih.infineon.com".
    :type ssh_host: str
    :key ifxspice_root_unix: Path to IFXspice under unix. Default is "/opt/titan/ifxspice/bin".
    :type ifxspice_root_unix: str
    :key unix_connection: Select which connection should be used to connect to unix, ETX(default) or ssh.
    :type unix_connection: str
    :key copy_additional_files_distributed_de: Define a list of files that additionally need to be copied to individual
                                                run folders for IFXspice distributed mode de.
    :type copy_additional_files_distributed_de: list
    :key run_minimized: Select how IFXspice submits its cmd window. Default is minimized to avoid distraction of the user during long sweep runs.
    :type run_minimized: bool

    Options for Titan AC
    :key step_spec: Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

                    LIN num_points start stop

                    DEC num_points_decade start stop

                    OCT num_points_octave start stop

    :type step_spec: str
    :key start: First value
    :type start: float|int
    :key stop: Last value
    :type stop: float|int
    :key num_points: Total number of points
    :type num_points: int
    :key num_points_decade: Number of points per decade
    :type num_points_decade: int
    :key num_points_octave: Number of points per octave
    :type num_points_octave: int
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_Titan.__init__(
            self, enums.AnalysisType.AC, enums.TitanSuffix.AC_Windows, enums.TitanSuffix.AC_Unix, None, **kwargs
        )

        self._scriptable_options.extend(
            ["step_spec", "start", "stop", "num_points", "num_points_decade", "num_points_octave"]
        )

        self._opts_container["step_spec"] = kwargs.get("step_spec", None)
        self._opts_container["start"] = kwargs.get("start", None)
        self._opts_container["stop"] = kwargs.get("stop", None)
        self._opts_container["num_points"] = kwargs.get("num_points", None)
        self._opts_container["num_points_decade"] = kwargs.get("num_points_decade", None)
        self._opts_container["num_points_octave"] = kwargs.get("num_points_octave", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_Titan._check_mandatory_options(self)

        if self.step_spec == "LIN":
            list_mandatory_options = ["num_points", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "DEC":
            list_mandatory_options = ["num_points_decade", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)

        elif self.step_spec == "OCT":
            list_mandatory_options = ["num_points_octave", "start", "stop"]
            for man_opt in list_mandatory_options:
                if getattr(self, man_opt, None) in [None, r""]:
                    raise self._MissingOption(man_opt)
        else:
            msg = "step_spec"
            raise self._DefectiveOption(msg, "None of the three legal Step_specs: LIN, DEC or OCT was selected.")

    @property
    def step_spec(self):
        """
        Determines the algorithm for determining the sweep steps according to one of the following (STP, LIN, DEC, OCT, LIST):

        LIN num_points start stop

        DEC num_points_decade start stop

        OCT num_points_octave start stop
        """
        return self._opts_container["step_spec"]

    @property
    def start(self):
        """
        First value
        """
        return self._opts_container["start"]

    @property
    def stop(self):
        """
        Last value
        """
        return self._opts_container["stop"]

    @property
    def num_points(self):
        """
        Total number of points
        """
        return self._opts_container["num_points"]

    @property
    def num_points_decade(self):
        """
        Number of points per decade
        """
        return self._opts_container["num_points_decade"]

    @property
    def num_points_octave(self):
        """
        Number of points per octave
        """
        return self._opts_container["num_points_octave"]


# --------------- AMSDesigner --------- #


class _Options_AMSDesigner(_Options_Base):
    """
    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    AMSDesigner options:

    :key cdslib: Path to cdslib, if set to None, the default Camino Project structure will be expected.
    :type cdslib: str
    :key unit: The name of the Camino unit. If set to None, a working directory in a unit is expected.
    :type unit: str
    :key save_nets: Define, which net should be saved.
                    To save all nets, set the attribute to '-all'.
                    To specify the port type of nets to be saved, add the statement '-ports <porttype>',
                        whereas <porttype> can be either input, output or all.
                    To specify the hierarchy of the nets to be saved, add the statement '-depth <hierarchyname>',
                        whereas <hierarchyname> can be all, none or specific hierarchy names.
                    To specify the domain of nets to be saved, add the statement '-domain <domaintype>',
                        whereas <domaintype> can be analog, digital or none.
                    To save specific nets only, set the attribute equal to a list including the names of all nets to
                        be saved.
    :type save_nets: list[str]
    :key save_currents: Define, which currents should be saved.
                        To save all nets, set the attribute to '-all'.
                        To specify the hierarchy of the currents to be saved, add the statement '-depth <hierarchyname>',
                            whereas <hierarchyname> can be all, none or specific hierarchy names.
                        To save specific currents only, set the attribute equal to a list including the names of all currents to
                            be saved. A '_$flow' at the end of an entry will be remove.
    :type save_currents: list[str]
    :key save_connectmodules: Define, which connect module nets should be saved.
                    To save all connect module nets, set the attribute to '-all'.
                    To specify the port type of connect module nets to be saved, add the statement '-ports <porttype>',
                        whereas <porttype> can be either input, output or all.
                    To specify the hierarchy of the connect module nets to be saved, add the statement '-depth <hierarchyname>',
                        whereas <hierarchyname> can be all, none or specific hierarchy names.
                    To save specific connect module nets only, set the attribute equal to a list including the names of
                        all connect modulenets to be saved.
    :type save_connectmodules: list[str]
    :key save_cdsglobals: Set to true to store all cdsglobals.
    :type save_cdsglobals: bool
    :key state: Name of the state to be simulated.
    :type state: str
    :key view: Name of the view to be simulated.
    :type view: str
    :key cell: Name of the cell to be simulated.
    :type cell: str
    :key lib: Name of the library containing cells to be simulated.
    :type lib: str
    :key schematic: Name of 'lib.cell:view#state' to be simulated.
                     This options sets accordingly the lib, cell, view, and state option
                     and takes precedence over setting lib, cell, view, or state directly.
    :type schematic: str
    :key sim_mode: Define simulation mode either 'batch' or 'gui' is available.
    :type sim_mode: str
    :key user_tcl: User defined TCL commands. Will passed to simulator.
    :type user_tcl: str
    :key temp: Simulation temperature. Make sure that the used state does not set the temperature!
    :type temp: float
    :key runams_opts: Define additional attributes that should be passed to the runams call.
    :type runams_opts: str
    :key sim_exec_mode: Select the simulation mode you would like to execute. Available modes are 'sequential', 'parallel' and 'local'.
    :type sim_exec_mode: str
    """

    def __init__(self, analysis, opts_dict, **kwargs):
        _Options_Base.__init__(
            self,
            enums.SimulatorType.AMSDesigner,
            analysis,
            kwargs.get("simdata_format", enums.SimulationDatatype.VCD),
            opts_dict,
            **kwargs,
        )

        self._scriptable_options.extend([])

        self._opts_container["cdslib"] = kwargs.get("cdslib", None)
        self._opts_container["unit"] = kwargs.get("unit", None)
        self._opts_container["save_nets"] = kwargs.get("save_nets", None)
        self._opts_container["save_currents"] = kwargs.get("save_currents", None)
        self._opts_container["save_connectmodules"] = kwargs.get("save_connectmodules", None)
        self._opts_container["save_cdsglobals"] = kwargs.get("save_cdsglobals", False)
        self._opts_container["state"] = kwargs.get("state", None)
        self._opts_container["schematic"] = kwargs.get("schematic", None)
        self._opts_container["view"] = kwargs.get("view", None)
        self._opts_container["cell"] = kwargs.get("cell", None)
        self._opts_container["lib"] = kwargs.get("lib", None)
        self._opts_container["sim_mode"] = kwargs.get("sim_mode", r"batch")
        self._opts_container["user_tcl"] = kwargs.get("user_tcl", None)
        self._opts_container["temp"] = kwargs.get("temp", None)
        self._opts_container["runams_opts"] = kwargs.get("runams_opts", None)
        self._opts_container["sim_exec_mode"] = kwargs.get("sim_exec_mode", "sequential")

        # Schematic has precedence over lib, cell, view, state
        if self._opts_container["schematic"] is not None:
            rex = re.compile("(\w+)\.(\w+):(\w+)#(\w+)")
            match = rex.match(self.schematic)
            if match is None:
                msg = "schematic"
                raise self._DefectiveOption(msg, 'Incorrect format, use "lib.cell:view#state"!')
            self._opts_container["lib"] = match.groups()[0]
            self._opts_container["cell"] = match.groups()[1]
            self._opts_container["view"] = match.groups()[2]
            self._opts_container["state"] = match.groups()[3]

        self._check_mandatory_options()
        self._check_sweep_params()

    def update_options(self, **kwargs):
        kw = CaseInsensitiveDict(kwargs)
        for k, v in kw.items():
            if k == "sim_params":
                sim_params = SimParamSweep(v)
                sim_params.complete_sim_params()
                """ :type : SimParamSweep """
                self._opts_container[k] = sim_params
            elif k in self._opts_container:
                self._opts_container[k] = v
            else:
                msg = f"No key called '{k}' in the selected Simulation Options object."
                raise AttributeError(msg)

        # Schematic has precedence over lib, cell, view, state
        if self._opts_container["schematic"] is not None:
            rex = re.compile("(\w+)\.(\w+):(\w+)#(\w+)")
            match = rex.match(self.schematic)
            if match is None:
                msg = "schematic"
                raise self._DefectiveOption(msg, 'Incorrect format, use "lib.cell:view#state"!')
            self._opts_container["lib"] = match.groups()[0]
            self._opts_container["cell"] = match.groups()[1]
            self._opts_container["view"] = match.groups()[2]
            self._opts_container["state"] = match.groups()[3]

        self._check_mandatory_options()

    def _check_mandatory_options(self):
        _Options_Base._check_mandatory_options(self)
        if self.state in [None, r""]:
            msg = "state"
            raise self._MissingOption(msg)
        if self.view in [None, r""]:
            msg = "view"
            raise self._MissingOption(msg)
        if self.cell in [None, r""]:
            msg = "cell"
            raise self._MissingOption(msg)
        if self.lib in [None, r""]:
            msg = "lib"
            raise self._MissingOption(msg)
        if self.sim_mode not in ["batch", "gui"]:
            msg = "sim_mode"
            raise self._DefectiveOption(msg)
        if self.sim_exec_mode not in ["sequential", "parallel", "local"]:
            msg = (
                f"Selected sim_exec_mode '{self.sim_mode}' is not supported, please select 'sequential', "
                "'parallel' or 'local'"
            )
            raise self._DefectiveOption(msg)

    @property
    def cdslib(self):
        """
        Path to cdslib, if set to None, the default Camino Project structure will be expected.
        """
        return self._opts_container["cdslib"]

    @property
    def unit(self):
        """
        Name of the unit, if unset the rundir must be in a Camino unit.
        """
        return self._opts_container["unit"]

    @property
    def save_nets(self):
        """
        Define, which net should be saved.

            To save all nets, set the attribute to '-all'.

            To specify the port type of nets to be saved, add the statement '-ports <porttype>',
            whereas <porttype> can be either input, output or all.

            To specify the hierarchy of the nets to be saved, add the statement '-depth <hierarchyname>',
            whereas <hierarchyname> can be all, none or specific hierarchy names.

            To specify the domain of nets to be saved, add the statement '-domain <domaintype>',
            whereas <domaintype> can be analog, digital or none.

            To save specific nets only, set the attribute equal to a list including the names of all nets to
            be saved.
        """
        return self._opts_container["save_nets"]

    @property
    def save_currents(self):
        """
        Define, which currents should be saved.

                To save all nets, set the attribute to '-all'.

                To specify the hierarchy of the currents to be saved, add the statement '-depth <hierarchyname>',
                whereas <hierarchyname> can be all, none or specific hierarchy names.

                To save specific currents only, set the attribute equal to a list including the names of all currents to
                be saved. A '_$flow' at the end of an entry will be remove.
        """
        return self._opts_container["save_currents"]

    @property
    def save_connectmodules(self):
        """
        Define, which connect module nets should be saved.

            To save all connect module nets, set the attribute to '-all'.

            To specify the port type of connect module nets to be saved, add the statement '-ports <porttype>',
            whereas <porttype> can be either input, output or all.

            To specify the hierarchy of the connect module nets to be saved, add the statement '-depth <hierarchyname>',
            whereas <hierarchyname> can be all, none or specific hierarchy names.

            To save specific connect module nets only, set the attribute equal to a list including the names of
            all connect module nets to be saved.
        """
        return self._opts_container["save_connectmodules"]

    @property
    def save_cdsglobals(self):
        """
        Set to true to store all cdsglobals.
        """
        return self._opts_container["save_cdsglobals"]

    @property
    def state(self):
        """
        Name of the ADE state to be simulated.
        """
        return self._opts_container["state"]

    @property
    def view(self):
        """
        Name of the view to be simulated.
        """
        return self._opts_container["view"]

    @property
    def cell(self):
        """
        Name of the cell to be simulated.
        """
        return self._opts_container["cell"]

    @property
    def lib(self):
        """
        Name of the library containing the cell view to be simulated.
        """
        return self._opts_container["lib"]

    @property
    def sim_mode(self):
        """
        Define simulation mode either 'batch' or 'gui' is available.
        """
        return self._opts_container["sim_mode"]

    @property
    def user_tcl(self):
        """
        User defined TCL commands.
        """
        return self._opts_container["user_tcl"]

    @property
    def temp(self):
        """
        Simulation temperature. Make sure that the used state does not set the temperature!
        """
        return self._opts_container["temp"]

    @property
    def runams_opts(self):
        """
        Define additional attributes that should be passed to the runams call.
        """
        return self._opts_container["runams_opts"]

    @property
    def sim_exec_mode(self):
        """
        Select the simulation mode you would like to execute. Available modes are 'sequential', 'parallel' and 'local'.
        """
        return self._opts_container["sim_exec_mode"]


class Options_AMSDesignerTran(_Options_AMSDesigner):
    """
    Simulation option object for transient simulation with AMS Designer:

    Base options:

    :key idnum: Id of simulator instance to use
    :type idnum: int
    :key sim_params: Swept simulation parameters Variable name -> list(float)
    :type sim_params: dict[]
    :key subset: Sequence of indexes defining subset of sim_params lists to
                    simulate.  None indicates entirety of sim_params
    :type subset: int|list
    :key workingdir: The directory where Simulator dumps its simulation results
    :type workingdir: str
    :key fileprefix: The prefix each file gets
    :type fileprefix: str
    :key verbose: Set verbosity level. The verbosity level has an influence on how many simulation files will be
                    stored. If set to 0 only the most important ones are kept. For debugging purposes, it is advised to
                    set verbose to 1.
    :type verbose: int

    AMSDesigner only options:

    :key tstop: Stop time.
    :type tstop: float
    """

    def __init__(self, attr_check=True, **kwargs):
        kwargs = CaseInsensitiveDict(kwargs)
        """:type : dict"""
        _Options_AMSDesigner.__init__(self, enums.AnalysisType.TRAN, None, **kwargs)

        self._scriptable_options.extend(["tstop"])
        self._opts_container["tstop"] = kwargs.get("tstop", None)

        if attr_check is True:
            self._check_mandatory_options()
        self._check_sweep_params()

    def _check_mandatory_options(self):
        _Options_AMSDesigner._check_mandatory_options(self)

    @property
    def tstop(self):
        """
        Stop time.
        """
        return self._opts_container["tstop"]
