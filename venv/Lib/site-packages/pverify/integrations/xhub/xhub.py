"""

Swagger API: https://xhub.intra.infineon.com/API/swagger/ui

"""
from __future__ import annotations

import json
import os
import re
import time
import webbrowser
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pverify.core.internals.specification import Specification


def conv_ticks(string: str):
    """
    Fixes strings for xHub web frontend because it fails displaying every string which contains '
    """
    return str(string).replace("'", '"')


def ensure_valid_identifier(identifier: str):
    identifier = re.sub(r"\'", '"', identifier)
    identifier = re.sub(r"[\W]", "_", identifier)
    identifier = re.sub("_{2,}", "_", identifier)
    return identifier.strip("_")


class xHub:
    class xHubError(Exception):
        pass

    class xHubFetchTaskTimeoutError(xHubError):
        pass

    class xHubNoCurrentTaskError(xHubError):
        pass

    class xHubControllerTerminated(xHubError):
        pass

    def __init__(self, baseclass):
        self.__baseclass = baseclass
        """:type : pverify.core.pyverify_base_test.PyVerifyBaseTest"""
        self._enabled = False  # Marks if the test is configured as xHub actor
        self.__name = ""  # The name of the actor displayed on the xHub page
        self.__desc = ""  # The description of the actor displayed on the xHub page
        self.__initialTimeout = 360.0
        self.__timeout = 10.0
        self.__open_xhub_page = True
        self.__session_id = None
        self.__actor_id = None
        self.__parent_task_id = None
        self._client = None
        self.__max_tasks = 5
        self.__awaiting_initial_task = True
        self.__tasks: list[dict[str, Any]] = []
        self.__current_task: dict[str, Any] = None
        self.__results = {}

    def configure(
        self,
        enable: bool,
        sessionId: str,
        initialTimeout=360.0,
        timeout=30.0,
        open_xhub_page=True,
        **kwargs,
    ):
        """
        Configures the current test as xHub actor.

        :param enable: If True AND sessionId is not None, then the xHub interface is enabled and the test
                       waits for new tasks from xHub
        :param sessionId: SessionId corresponding to your username.
        :param initialTimeout: The initial max. waiting time between test start and configuring/running
                               the controller from xHub. On timeout the test will tear down.
        :param timeout: The max. waiting time for the test to wait for new tasks from the xHub controller.
                        Depending on the controller complexity and iteration this time can go up to 30s.
                        On timeout the test will tear down.
        :keyword name: An alternative name for the actor. If not given it is a combination of TestcaseName and username
        :keyword description: An alternative description for the actor. If not given it is the test description
        :keyword max_tasks: The maximum number of tasks the actor is requesting from the controller at once
        """
        self._enabled = enable and (sessionId is not None)
        self.__name = kwargs.get("name", None) or self.__baseclass.Attributes.Testcase_Name + "_" + os.getlogin()
        self.__desc = kwargs.get("description", None) or self.__baseclass.Attributes.Test_Description
        self.__initialTimeout = float(initialTimeout)
        self.__max_tasks = int(kwargs.get("max_tasks", 5))
        self.__timeout = float(timeout)
        self.__session_id = str(sessionId)
        self.__open_xhub_page = bool(open_xhub_page)

        # Ensure $HOME/.xhub exists (fix for xhub_client that expects the directory to exist)
        xhubHome = Path("~").expanduser() / ".xHUB"
        xhubHome.mkdir(parents=True, exist_ok=True)

    def _register_actor(self):
        """
        Registers the actor and it's capabilities to xHub.
        """
        if self._client is None:
            try:
                from .xhub_client import XhubClient
            except ModuleNotFoundError:
                msg = "The xHub feature need an additional package installed."
                raise ModuleNotFoundError(msg)

            self._client = XhubClient()

        if self.__actor_id:
            return self.__actor_id

        # Set old actors with same name to inactive state
        actors_detail = self._client.actorGetBySessionId(self.__session_id)
        for i in actors_detail:
            if i["ActorType"] == "Default" and i["Status"] == "Active" and i["Name"] == self.__name:
                self.__baseclass.Utils.LogInfo(
                    f"Setting existing actor {self.__name} ({i['ActorId']} to status 'Inactive'."
                )
                self._client.actorUpdate(actor={"ActorId": i["ActorId"], "Status": "Inactive"})

        # Create capabilities description
        parameters = {}
        for _pname, pobj in self.__baseclass.Parameters.items():
            if pobj.Name not in ["DUT"] and not isinstance(pobj.DefaultValues[0], str):
                unit = f"[{pobj.Unit}] " if pobj.Unit not in [None, ""] else ""
                parameters[pobj.Name] = {
                    "type": "number",
                    "default": pobj.DefaultValues[0],
                    "description": conv_ticks(unit + pobj.Description),
                }
                if pobj.Min is not None:
                    parameters[pobj.Name]["minimum"] = pobj.Min
                if pobj.Max is not None:
                    parameters[pobj.Name]["maximum"] = pobj.Max

        responses = {}
        for _oname, oobj in self.__baseclass.Outputs.items():
            if oobj.dtype == oobj.OutputType.Scalar:  # Only scalar outputs supported
                unit = f"[{oobj.Unit}] " if oobj.Unit not in [None, ""] else ""
                responses[ensure_valid_identifier(oobj.Name)] = {
                    "type": "number",
                    "description": conv_ticks(unit + oobj.Description),
                }

        limit: Specification
        for limit in self.__baseclass.Limits:
            # Only specs that are always applicable may be used, otherwise the response would be missing for
            # certain parameter combinations
            if limit.alias != "" and limit.conditions is None:
                alias = ensure_valid_identifier(
                    limit.alias
                )  # Response names must not contains blanks (may be fixed in future)
                if alias in responses:
                    self.__baseclass.Utils.LogWarning(
                        f"Cannot use limit with alias {alias!r} for xHub because an output with "
                        f"the same name already exists!"
                    )
                else:
                    responses[alias] = {"type": "number", "description": conv_ticks(str(limit))}

        xhubActor = {
            "SessionId": self.__session_id,
            "Name": conv_ticks(self.__name[:50]),
            "Description": conv_ticks(self.__desc),
            "Capabilities": [
                {
                    "Name": "Capabilities",
                    "Description": "Influential factors and responses",
                    "Schema": {
                        "type": "object",
                        "properties": parameters,
                    },
                    "ResultSchema": {
                        "type": "object",
                        "properties": responses,
                    },
                }
            ],
        }

        # Register xHUB Actor
        self.__baseclass.Utils.LogInfo("Registering test as xHub actor ...")
        self.__actor_id = self._client.actorCreate(xhubActor)["Result"]

        Url = "https://xhub.intra.infineon.com/UI/#/actor/" + self.__actor_id
        self.__baseclass.Utils.LogInfo(f"... Registered test as xHub actor {self.__actor_id}")
        self.__baseclass.Utils.LogInfo("Opening the xHub web frontend...")
        if self.__open_xhub_page:
            webbrowser.open_new_tab(Url)
            return None
        return None

    def _pop_task_or_maybe_fetch(self) -> dict[str, Any]:
        """
        Pops a task from the task list or if empty, fetch new tasks from controller before
        """
        from .xhub_client import XhubNoNewTask

        t0 = time.time()
        try:
            self.__current_task: dict = self.__tasks.pop(0)
            self.__baseclass.Utils.LogInfo(f"Processing task {self.__current_task['TaskId']!r}...")
            self.__parent_task_id = self.__current_task["ParentTaskId"]
            if self.__awaiting_initial_task:
                ctrl = self._get_controller()
                self.__baseclass.Utils.LogInfo(f"Running with xHub controller {ctrl['Name']!r} ({ctrl['ActorId']})")
                self.__baseclass.Utils.LogInfo(f"Controller description: {ctrl['Description']}")

            self.__awaiting_initial_task = False
            self._clear_results()
            return self._get_current_task_parameters()

        except IndexError:  # If task list is empty, request new tasks
            if self.__awaiting_initial_task:
                self.__baseclass.Utils.LogInfo(
                    f"Waiting for xHUB controller to send initial tasks... (max. {self.__initialTimeout}s)"
                )
            else:
                self.__baseclass.Utils.LogInfo(
                    f"Waiting for xHUB controller to send more tasks... (max. {self.__timeout}s)"
                )

            actual_timeout = self.__initialTimeout if self.__awaiting_initial_task else self.__timeout
            while True:
                if time.time() - t0 > actual_timeout:
                    if self.__awaiting_initial_task:
                        msg = (
                            f"User did not start xHUB controller within specified timeout of {self.__initialTimeout}s!"
                        )
                        raise self.xHubFetchTaskTimeoutError(msg)

                    msg = f"A timeout ({self.__timeout}s) appeared when waiting for a new task!"
                    raise self.xHubFetchTaskTimeoutError(msg)

                tStatus = None
                if self.__parent_task_id is not None:
                    tStatus = self._client.taskGetByTaskId(self.__parent_task_id)["Status"]

                try:
                    new_tasks = self._client.taskGetByActorId(
                        actorId=self.__actor_id,
                        statuses=["New"],
                        startAt=None,
                        maxResults=self.__max_tasks,
                        newestOnTop=False,
                    )
                    for t in new_tasks:
                        self.__baseclass.Utils.LogInfo(f"Fetched new task {t['TaskId']!r} from xHub.")
                        self.__tasks.append(t)
                    if len(self.__tasks):
                        self.__parent_task_id = self.__tasks[0]["ParentTaskId"]

                        if self.__awaiting_initial_task:
                            ctrl = self._get_controller()
                            self.__baseclass.Utils.LogInfo(
                                f"Running with xHub controller {ctrl['Name']!r} ({ctrl['ActorId']})"
                            )
                            self.__baseclass.Utils.LogInfo(f"Controller description: {ctrl['Description']}")

                        tStatus = self._client.taskGetByTaskId(self.__parent_task_id)["Status"]
                        self.__baseclass.Utils.LogInfo(f"xHub Task Status: {tStatus!r}")

                    return self._pop_task_or_maybe_fetch()
                except XhubNoNewTask:
                    time.sleep(2.0)
                    self.__baseclass.Utils.SetBreakPoint("Waiting for new tasks from xHub controller...")

                if tStatus in [
                    "Success",
                ]:
                    msg = f"Controller terminated with status {tStatus!r}!"
                    raise self.xHubControllerTerminated(msg)

    def _post_results(self, statusMsg: str):
        """
        Reports the test results back to xHub.

        :param statusMsg: The potential error message
        """
        task = self._get_current_task()
        self.__baseclass.Utils.LogInfo(f"Posting results for task {task['TaskId']!r} to xHub ...")
        if statusMsg.startswith("Error"):
            self._client.resultCreate(task["TaskId"], statusMsg, {})
        else:
            self._client.resultCreate(task["TaskId"], statusMsg, self.__results)

    def _update_result(self, name, value):
        """
        Adds a current iteration results
        """
        self.__results[ensure_valid_identifier(name)] = value

    def _clear_results(self):
        """
        Clears the current iteration results
        """
        self.__results.clear()

    def _get_controller(self):
        if self.__parent_task_id is None:
            return None
        return self._client.actorGetByActorId(self._client.taskGetByTaskId(self.__parent_task_id)["ActorId"])

    def _shutdown_controller(self):
        """
        Change the status of the controller to cancelled
        """
        if self.__parent_task_id is not None:
            self.__baseclass.Utils.LogInfo(f"Shutting down xHub controller {self.__parent_task_id!r}")
            self._client.taskUpdate(self.__parent_task_id, "Cancelled")

    def _get_current_task(self) -> dict[str, Any]:
        if self.__current_task is None:
            raise self.xHubNoCurrentTaskError
        return self.__current_task

    def _get_current_task_parameters(self) -> dict[str, Any]:
        if self.__current_task is None:
            raise self.xHubNoCurrentTaskError
        return json.loads(self.__current_task["Body"])
