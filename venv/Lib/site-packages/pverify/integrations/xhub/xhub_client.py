#!/usr/bin/env python3
from __future__ import annotations

import sys

# check python version: we need >= 3.7
if sys.hexversion < 0x30700F0:
    raise ValueError("Need at least Python version 3.7.  Your version: " + sys.version)
import json
import os
import re
import time
import urllib.parse
from copy import deepcopy
from datetime import datetime
from tempfile import mkdtemp
from warnings import warn  # issue simple warnings

import requests

# this is a temporary hack to get NTLM to work on both
# * python3.10 with requests-ntlm 1.2.0 on WSL2/Ubuntu 22.04.3 LTS
# * python3.7  with requests-ntlm2 6.5.2 on the Linux farm and cygwin
try:
    from requests_ntlm import HttpNtlmAuth
except ModuleNotFoundError:
    from requests_ntlm2 import HttpNtlmAuth


def dbgprint(*args, **kwargs):
    ...


def _dbgprint(*args, **kwargs):
    ...


# for windows there is a special authentication method available. we try it
try:
    # raise ModuleNotFoundError  # uncomment to try requests_ntlm on windows
    from requests_negotiate_sspi import HttpNegotiateAuth

    def HttpAuth(username=None, password=None, domain=None):
        dbgprint_r(6, "Using requests_negotiate_sspi.HttpNegotiateAuth")
        dbgprint_r(
            6,
            "    username: {}  password: {}  domain: {}".format(
                username, "***" if password is not None else None, domain
            ),
        )
        return HttpNegotiateAuth(username=username, password=password, domain=domain)
except ModuleNotFoundError:

    def HttpAuth(username=None, password=None, domain=None):
        dbgprint_r(6, "Using requests_ntlm.HttpNtlmAuth")
        dbgprint_r(
            6,
            "    username: {}  password: {}  domain: {}".format(
                username, "***" if password is not None else None, domain
            ),
        )
        return HttpNtlmAuth(username=username, password=password)

#####################################################################################################

# GLOBAL VARIABLES

NTRY_POST = 5  # number of times to try post command
TWAIT_POST_RETRY = 5  # wait period between retries

# the higher the more debug info printed
DEBUG = int(os.environ.get("PYXHUB_DEBUG", 2))
DEBUG = int(os.environ.get("PYXHUB_CLIENT_DEBUG", DEBUG))

SSL_VERIFY_HOSTNAME = False
requests.urllib3.disable_warnings(requests.urllib3.exceptions.InsecureRequestWarning)

#####################################################################################################


def dbgprint_r(level, *args, debug=DEBUG, **kwargs):
    """Restrictied print debug info to stderr."""
    _dbgprint(DEBUG, level, *args, **kwargs)


#####################################################################################################
class XhubApiError(Exception):
    """Exceptions raised for xHUB API errors.

    The class variable xhubErrors is the error message dictionary.  The keys
    of xhubErrors are API commands.  The values are dictionaries with mapping
    error codes to error messages.  An extra key "Common" is used for common
    messages, that are not command-specific.

    """

    xhubErrors = {  # Error codes by command (class variable)
        "Actor/GetByActorId": {204: "Actor not found", 400: "Invalid actor ID", 500: "Failed to get Actor"},
        "Actor/GetByLabels": {400: "Invalid label", 404: "Actors not found", 500: "Failed to get Actors"},
        "Actor/GetByHostedProcessId": {
            400: "Invalid hosted process ID",
            404: "Actor not found",
            500: "Failed to get Actor",
        },
        "Actor/GetByStatus": {404: "Actors not found", 500: "Failed to get Actors"},
        "Actor/GetHostedProcesses": {404: "Controllers not found", 500: "Failed to get controllers"},
        "Actor/GetBySessionId": {
            400: "SessionId is missing or the format is incorrect",
            404: "Actors not found",
            500: "Failed to get Actors",
        },
        "Actor/Create": {
            204: "Actor not found",
            400: "At least one parameter is missing or invalid",
            500: "Failed to create the Actor",
        },
        "Attachment/GetByObjectId": {400: "The request is invalid"},
        "Attachment/LinkFile": {400: "The request is invalid"},
        "Attachment/MoveDatalakeArtifact": {400: "The request is invalid"},
        "Result/GetByActorId": {404: "Results not found", 500: "Failed to get Results"},
        "Result/GetByRunId": {404: "Results not found", 500: "Failed to get Results"},
        "Result/GetByTaskId": {400: "Invalid task ID", 204: "Results not found", 500: "Failed to get Results"},
        "Result/Create": {500: "Failed to create the Result"},
        "Result/UploadFile": {500: "Failed to create the Result"},
        "Result/LinkFile": {
            400: "Input parmeters do not exist",
            404: "Result not found",
            500: "Failed to get the Result",
        },
        "Session/GetByUsername": {204: "Sessions not found", 400: "Username is missing", 500: "Failed to get Sessions"},
        "Session/GetAll": {204: "Sessions not found", 500: "Failed to get Sessions"},
        "Session/GetByLabels": {404: "Session not found", 500: "Failed to get Session"},
        "Session/Create": {400: "Name is missing", 500: "Failed to create the Session"},
        "Task/GetByActorId": {
            204: "Tasks not found",
            400: "ActorId is missing",
            404: "Tasks not found",  # is this wrong? #yes
            500: "Failed to get Tasks",
        },
        "Task/GetByRunId": {
            204: "Tasks not found",
            400: "RunId is missing",
            404: "Tasks not found",
            500: "Failed to get Tasks",
        },
        "Task/GetBySessionId": {400: "SessionId is missing", 404: "Tasks not found", 500: "Failed to get Tasks"},
        "Task/GetByTaskId": {
            204: "Task not found",
            400: "TaskId is missing",
            404: "Task not found",
            500: "Failed to get the Task",
        },
        "Task/Create": {500: "Failed to create the Task"},
        "Task/Update": {500: "Failed to update the Task"},
        "Task/DeleteByTaskId": {200: "Task deleted", 400: "Invalid TaskId", 500: "Failed to delete the Task"},
        "Task/GetForAllHostedProcesses": {404: "Tasks not found", 500: "Failed to get Tasks"},
        "User/GetAll": {404: "Users not found", 405: "User not authorized", 500: "Failed to get users"},
        "Common": {  # common error codes
            400: "Incorrect input",
            405: "User not authorized",
        },
    }

    # ==================================================================

    def __init__(self, cmd, args, status):
        self.command = cmd
        self.cmd_args = args
        self.status = status
        # first look in the common errors dictionary for status to error message mapping
        if status in self.xhubErrors["Common"]:
            self.message = self.xhubErrors["Common"][status]
        else:  # look for command specific error message dictionary
            # get error message dictionary for the offending command or empty dict
            err_dict = self.xhubErrors.get(cmd, {})
            # If a dictionary is found, get the message for the status or set
            # message to unknown error.
            self.message = err_dict.get(status, "Unknown/undefined error")
        self.print()

    # ==================================================================

    def print(self):
        print(
            f"xHUB API ERROR: {self.status} {self.message}. Offending command: {self.command!s}{self.cmd_args!s}",
            file=sys.stderr,
        )


#####################################################################################################


class XhubNoNewTask(XhubApiError):
    """Exception raised when no new task is available."""

    def __init__(self, cmd, args, status):
        XhubApiError.__init__(self, cmd, args, status)

    def print(self):
        # print('No new task.', file=sys.stderr)
        pass


#####################################################################################################


def url_quote_trunc(s, max_len, len_head, max_iter=10):
    """Quote string for including in URL
    INPUT:
        s:            string to be quoted
        max_len:      maximum length for the quoted string
        len_head:     head length
    OUTPUT: quoted string

    ALG:
      1. We truncate string to the max length

      2. While the length of quoted string is greater than max length we
         reduce head and tail lengths proportionally by the ratio of unqoted
         to quoted string (the shrinking factor)

         In case the shinking factor is too close to 1 and the lengths do not
         shrink, we decrement the lengths of head and tail the to ensure the
         string is shrinking, while keeping the lengths greater than or equal
         to 1.
    """
    len_s = max_len  # current length of s
    len_tail = len_s - len_head  # lenth of tail
    if len(s) > len_s:
        s = s[:len_head] + s[-len_tail:]
    sq = urllib.parse.quote(s)
    it = 0
    dbgprint(6, "it  len_s  len(s)  len(sq)  rq  len_head  len_tail  sq")
    dbgprint(6, it, len_s, len(s), len(sq), sq)
    while len(sq) > max_len:  # iterative truncating process
        rq = len(s) / len(sq)  # ratio of lengths of original to quoted strings
        len_s = int(len_s * rq)  # reduce length of s by the quoting ratio
        len_head_new = int(len_head * rq)  # reduce len head by the quoting ratio
        len_tail_new = len_s - len_head_new
        len_head = max(1, min(len_head_new, len_head - 1))  # ensure shrinking
        len_tail = max(1, min(len_tail_new, len_tail - 1))  # ensure shrinking
        len_s = len_head + len_tail
        s = s[:len_head] + s[-len_tail:]
        sq = urllib.parse.quote(s)
        it = it + 1
        dbgprint(6, it, len_s, len(s), len(sq), rq, len_head, len_tail, sq)
        if it > max_iter:
            sq = None
            break
    return sq


# /def url_quote_trunc

#############################################################################


class XhubClient:
    # xHUB base url
    xhub_api_base_url = {
        "xhub-prod": "https://xhub.intra.infineon.com/API/",
        "vihsk1005": "https://vihsk1005.infineon.com/API/",
        "xhub-test": "https://xhub-test.intra.infineon.com/API/",
        "xhub-dev": "https://xhub-dev.intra.infineon.com/API/",
        "muctsa1086": "http://muctsa1086.infineon.com/ExperimentPlanner/api/",
        "vihtsa1022": "http://vihtsa1022.infineon.com/ExperimentPlanner/api/",
        "prodold": "http://xhub.intra.infineon.com/ExperimentPlanner/api/",
    }

    # ================================================================================================

    def __init__(self, **kwargs):
        self.init()
        self.update(**kwargs)
        self.login()
        dbgprint(2, f"New XhubClient object: {self}", depth=2)

    # ==================================================================================

    def __repr__(self):
        def hide_passwd(k, v):
            return "*****" if k.lower() == "password" else v

        args = [f"{k} = {hide_passwd(k, v)!r}" for k, v in self.__dict__.items() if not k.startswith("_")]
        return type(self).__name__ + "(" + ", ".join(args) + ")"

    # ================================================================================================

    def init(self):
        self.xhubUrl = XhubClient.xhub_api_base_url["xhub-prod"]
        self.password = None
        self.winuser = None
        self.domain = None
        self.pwfile = None
        self._pinst = re.compile("(https?://)(xhub[^.]*).(.*)")  # get xhub instance: xhub, xhub-dev or xhub-test
        self.ntry = NTRY_POST  # number of times to retry
        self.twait = TWAIT_POST_RETRY  # initial wait time (seconds)
        self.twait_max = 60  # maximum wait time (seconds)
        dbgprint(4, "ntry=", self.ntry, "twait=", self.twait, "twait_max=", self.twait_max)

    # ================================================================================================

    def update(self, xhubUrl=None, winuser=None, pwfile=None, domain=None):
        """Configure xhub client"""
        if xhubUrl is None:
            self.xhubUrl = os.environ.get("XHUB_URL", XhubClient.xhub_api_base_url["xhub-prod"])
        else:
            self.xhubUrl = xhubUrl
        if self.xhubUrl in XhubClient.xhub_api_base_url:
            self.xhubUrl = XhubClient.xhub_api_base_url[self.xhubUrl]
        if not self.xhubUrl.endswith("/"):
            self.xhubUrl = self.xhubUrl + "/"
        self.winuser = os.environ.get("XHUB_USER", winuser)
        self.domain = os.environ.get("XHUB_DOMAIN", domain)
        self.pwfile = os.environ.get("XHUB_PWFILE", pwfile)
        if self.pwfile is not None:
            with open(self.pwfile, "rU") as f:
                self.password = f.read().strip("\n")
        dbgprint_r(
            2,
            "update(): winuser: {}  password: {}  domain: {}".format(
                self.winuser, "***" if self.password is not None else None, self.domain
            ),
        )

    # ================================================================================================

    def login(self):
        # only try to self.get_win_cred() if all credential variables
        # are None (i.e., the user did not specify anything).
        if all(v is None for v in [self.winuser, self.password, self.domain]):
            # if we are using requests_ntlm we need user's windows credentials,
            # while if we are using requests_negotiate_sspi, we don't need them
            try:
                self.winuser, self.password, self.domain = self.get_win_cred()  # get windows credentials
            except Exception as e:
                if "requests_negotiate_sspi" in sys.modules:
                    self.winuser, self.password, self.domain = None, None, None  # don't need username and password
                    warn(f"Could not get windows credentials. We may be able to do without.\n{e}", stacklevel=1)
                else:
                    raise
        if "requests_negotiate_sspi" in sys.modules:
            dbgprint(2, "Using requests_negotiate_sspi.HttpNegotiateAuth")
        else:
            dbgprint(2, "Using requests_ntlm.HttpNtlmAuth")
        dbgprint_r(
            2,
            "    username: {}  password: {}  domain: {}".format(
                self.winuser, "***" if self.password is not None else None, self.domain
            ),
        )

    # ================================================================================================

    def get_win_cred(self):
        """get_win_cred(): get windows credentials

        usage: winuser, password, domain = get_win_cred()

        """

        dbgprint_r(5, "get_win_cred()")

        # set defaults for windows username and password
        winuser, password, domain = None, None, None
        dnsrc = None

        try:  # try to get domain name from env
            domain = os.environ["USERDOMAIN"]
            dnsrc = 'os.environ["USERDOMAIN"]'  # for debug info
        except KeyError:
            pass  # ignore failure to get domain name, we may not even need it

        missing_env_vars = []  # keep track of the missing env vars to inform user
        try:  # if we find USER environment variable, we're on unix-like system
            user = os.environ["USER"]
            home = os.environ.get("HOME", "/home/" + user)  # HOME is also most likely defined
            usrc = 'os.environ["USER"]'
        except KeyError as e:  # we're likely on windows
            missing_env_vars.extend(e.args)
            try:
                user = os.environ["USERNAME"]
                home = os.environ["HOMEDRIVE"] + os.environ["HOMEPATH"]
                usrc = 'os.environ["USERNAME"]'
            except KeyError as e:
                missing_env_vars.extend(e.args)
                msg = f"Failed to get environment variables {missing_env_vars}"
                raise Exception(msg)

        dbgprint_r(4, f"home='{home}'")
        self.pwfile = os.path.join(home, ".xHUB", "pass")
        wufile = os.path.join(home, ".xHUB", "winuser")
        dbgprint_r(4, f"pwfile='{self.pwfile}'")
        dbgprint_r(4, f"wufile='{wufile}'")

        with open(self.pwfile, "rU") as myfile:
            r = re.split("\n+", myfile.read().strip("\n"))

        if len(r) == 1:  # found one word in the password file
            password = r[0]  # take it as the password
            winuser = user  # use unix user
            wusrc = usrc
        elif len(r) == 2:  # found two words in the password file
            winuser = r[0]  # first is the username
            password = r[1]  # second is the password
            wusrc = self.pwfile
        else:
            msg = "Incorrect format of password file "
            raise Exception(msg, self.pwfile)

        ## tb_actors/xhub_client.py: tries to read windows user name from the
        ## ~/.xHUB/winuser file.
        ##
        ## For now I keep the feature that the user may put username in the
        ## ~/.xHUB/pass file but discourage it because it may break other xHUB
        ## clients that expect only password in ~/.xHUB/pass file.

        try:
            with open(wufile, "rU") as myfile:
                winuser = myfile.read().strip("\n")
                wusrc = wufile
        except Exception:
            pass

        dbgprint_r(3, f"winuser='{winuser}' from {wusrc}")
        dbgprint_r(3, f"password from {self.pwfile}")
        dbgprint_r(3, f"domain='{domain}' from {dnsrc}")
        # sys.exit();

        dbgprint_r(5, "/get_win_cred")

        return (winuser, password, domain)

    # /def get_win_cred

    # ================================================================================================

    def isdummy(self):
        """This is the real deal xHUB REST API library, not the dummy one."""
        return False

    # ================================================================================================

    def getXhubUrl(self):
        """Get xhubUrl"""
        return self.xhubUrl

    # ================================================================================================

    def xhub_post(self, command, args, **kwargs):
        """Post command with args and payload specified via keyword arguments, with
        retry on errors.

        PARAMETERS:

          command: xHUB API command

          args: arguments for the xHUB API command

          Keyword arguments:

            Required mutually exclusive keyword argument: exactly one of the
              following is required: data, files, payload

              data: data to be posted (passed verbatim to data kwarg of requests.post)

              payload: data to be posted as python object, it is passed to
                requests.post as data=json.dumps(payload)

              files: a dictionary { filename : filehandle } of files to be uploaded

            Optional keyword arguments:

              okList: list of ok response codes

              ntry: number of times to try to execute the requests.post command

              twait: initial time to wait before retrying.  Doubled at every retry.

        RETURN:

          response from requests.post

        EXCEPTIONS:

          Raises XhubApiError if the requests.post status code is not in okList
          after ntry tries.

        """

        # keys_mutex is the list of mutually exclusive keys (exactly one required)
        # kmgot is the list mutex keys we got in kwargs
        # if we get more than one mutex key in kwargs, we raise an exception
        ntry = kwargs.get("ntry", self.ntry)
        twait = kwargs.get("twait", self.twait)
        twait_max = kwargs.get("twait", self.twait_max)

        itry = 1
        keys_mutex = ["data", "files", "payload"]
        kmgot = [k for k in keys_mutex if k in kwargs]
        if len(kmgot) != 1:
            msg = "xhub_post() received {} {} exclusive arguments instead of exactly one required of {}".format(
                len(kmgot), kmgot, keys_mutex
            )
            raise Exception(msg)

        # process the required keyword argument and set the correct keyword
        # arguments for requests.post in kwargs_post

        if "payload" in kwargs:  # this is likely the most frequent
            kwargs_post = {
                "data": json.dumps(kwargs["payload"]),
                "headers": {"content-type": "application/json"},
            }
        elif "data" in kwargs:
            kwargs_post = {
                "data": kwargs["data"],
                "headers": {"content-type": "application/json"},
            }
        elif "files" in kwargs:
            kwargs_post = {"files": kwargs["files"]}

        # get optional kwargs or set defaults
        okList = kwargs.get("okList", [200])
        dbgprint(5, f"requests.post({self.xhubUrl + command + args!r} {kwargs_post})")
        while True:
            try:
                r = requests.post(
                    self.xhubUrl + command + args,
                    **kwargs_post,
                    verify=SSL_VERIFY_HOSTNAME,
                    auth=HttpAuth(self.winuser, self.password, self.domain),
                )
                if r.status_code == 401:
                    twait_max = 300
                elif r.status_code < 500 or itry >= ntry:
                    break
                else:
                    dbgprint(5, f"requests.post status code: {r.status_code}")
            except Exception as e:
                if itry < ntry:
                    dbgprint(2, str(e))
                else:
                    raise e
            time.sleep(twait)
            itry += 1
            # double the wait time for each retry up to twait_max
            twait = twait * 2 if twait < 0.5 * twait_max else twait_max
            dbgprint(2, f"post({command}{args}, ...) try {itry}/{ntry} wait {twait}")

        if r.status_code not in okList:
            raise XhubApiError(command, args, r.status_code)

        return r

    # /def xhub_post

    # ================================================================================================

    def req_get(self, *args, **kwargs):
        """crude requests.get wrapper with retry and timeout intended to be
        drop-in replacement for requests.get(), except auth kwarg is
        supplied.

        """
        ntry = kwargs.get("ntry", self.ntry)
        twait = kwargs.get("twait", self.twait)
        twait_max = kwargs.get("twait", self.twait_max)
        itry = 1
        while True:
            try:
                dbgprint(6, f"req_get: args: {args}")
                r = requests.get(
                    *args, **kwargs, verify=SSL_VERIFY_HOSTNAME, auth=HttpAuth(self.winuser, self.password, self.domain)
                )
                dbgprint(5, f"req_get: resp: {r!r}")
                dbgprint(5, f"requests.get status code: {r.status_code}")
                if r.status_code == 401:
                    twait_max = 300
                elif r.status_code < 500 or itry >= ntry:
                    break
                else:
                    dbgprint(2, f"requests.get status code: {r.status_code}")
            except Exception as e:
                if itry < ntry:
                    dbgprint(2, str(e))
                else:
                    raise e
            time.sleep(twait)
            itry += 1
            # double the wait time for each retry up to twait_max
            twait = twait * 2 if twait < 0.5 * twait_max else twait_max
            dbgprint(2, f"req_get({args}) try {itry}/{ntry} wait {twait}")
        return r

    # /def req_get

    # ================================================================================================

    def req_delete(self, *args, **kwargs):
        """crude requests.delete wrapper with retry and timeout intended to be
        drop-in replacement for requests.delete(), except auth kwarg is supplied."""

        ntry = kwargs.get("ntry", self.ntry)
        twait = kwargs.get("twait", self.twait)
        twait_max = kwargs.get("twait", self.twait_max)
        itry = 1
        while True:
            try:
                r = requests.delete(
                    *args, verify=SSL_VERIFY_HOSTNAME, auth=HttpAuth(self.winuser, self.password, self.domain), **kwargs
                )
                dbgprint(5, f"requests.delete status code: {r.status_code}")
                if r.status_code == 401:
                    twait_max = 300
                elif 200 <= r.status_code <= 299 or r.status_code == 400 or itry >= ntry:
                    break
                else:
                    dbgprint(2, f"requests.delete status code: {r.status_code}")
            except Exception as e:
                if itry < ntry:
                    dbgprint(2, str(e))
                else:
                    raise e
            time.sleep(twait)
            itry += 1
            # double the wait time for each retry up to twait_max
            twait = twait * 2 if twait < 0.5 * twait_max else twait_max
            dbgprint(2, f"req_delete({args}) try {itry}/{ntry} wait {twait}")
        return r

    # /def req_delete

    # ================================================================================================

    # ACTOR

    # ================================================================================================

    def actorGetByActorId(self, actorId):
        """Get full actor info from actor ID"""
        command = "Actor/GetByActorId"
        args = "?actorId=" + actorId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def actorGetByLabels(self, labels, sessionIds=None):
        """Get actors by labels"""
        command = "Actor/GetByLabels"
        args = "?"
        for x in labels:
            args += "labels=" + x + "&"
        if sessionIds is None:
            sessionIds = []
        for x in sessionIds:
            args += "SessionsIds=" + x + "&"
        args = args[:-1]
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def actorGetByHostedProcessId(self, hostedProcessId):
        """Get actors by its hosted process ID"""
        command = "Actor/GetByHostedProcessId"
        args = "?hostedProcessId=" + hostedProcessId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def actorGetByStatus(self, status, username=None):
        """Get actors by their status"""
        command = "Actor/GetByStatus"
        args = "?status=" + status
        if username is None:
            username = ""
        if len(username) != 0:
            args += "&username=" + username
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def actorGetHostedProcesses(self, hptype=None):
        """Get hosted processes"""
        command = "Actor/GetHostedProcesses"
        args = ""
        if hptype is None:
            hptype = ""
        if len(hptype) != 0:
            args = "?type=" + hptype
        print(self.xhubUrl + command + args)
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def actorGetBySessionId(self, sessionId):
        """Get actors for session by session ID"""
        command = "Actor/GetBySessionId"
        args = "?sessionId=" + sessionId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def actorCreate(self, actor):
        """Create xHUB actor"""
        command = "Actor/Create"
        args = ""
        return self.xhub_post(command, args, payload=actor).json()

    # ================================================================================================

    def actorUpdate(self, actor):
        """Update xHUB actor"""
        command = "Actor/Update"
        args = ""
        r = self.xhub_post(command, args, payload=actor)
        return r.status_code == 200

    # ================================================================================================

    def actorUpdateStatus(self, actorId, status):
        """Update status of xHUB actor"""
        command = "Actor/Update"
        args = ""
        r = self.xhub_post(command, args, payload={"ActorId": actorId, "Status": status})
        return r.status_code == 200

    # ================================================================================================

    def actorDeleteByActorId(self, actorId):
        command = "Actor/DeleteByActorId"
        args = "?actorId=" + actorId
        r = self.req_delete(self.xhubUrl + command + args)
        return r.status_code == 200

    # ================================================================================================

    # ACTOR STORAGE

    # ================================================================================================

    def actorStorageDefined(self, actorId):
        """Create xHUB actor storage"""
        command = "ActorStorage/defined"
        args = "?actorId=" + actorId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    def actorStorageHasSessionStorage(self, actorId):
        """Verify if actor has a storage"""
        command = "ActorStorage/HasSessionStorage"
        args = "?actorId=" + actorId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    def actorStorageAdd(self, info):
        """Get full actor storage info from actor ID"""
        command = "ActorStorage/add"
        args = ""
        r = self.xhub_post(command, args, payload=info)
        return r.json()

    def actorStorageGet(self, actorId):
        """Get full actor info from actor ID"""
        command = "ActorStorage/Get"
        args = "?actorId=" + actorId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    def actorStorageUpdate(self, info):
        """Update storage of xHUB actor"""
        command = "ActorStorage/update"
        args = ""
        r = self.xhub_post(command, args, payload=info)
        return r.status_code == 200

    def actorStorageDelete(self, IdActorStorage):
        """Delete storage of xHUB actor"""
        command = "ActorStorage/delete"
        args = "?IdActorStorage=" + IdActorStorage
        r = self.req_delete(self.xhubUrl + command + args)
        return r.status_code == 200

    # ================================================================================================

    # ATTACHMENT

    # ================================================================================================

    def attachmentUpload(self, objectId, filepath, name=None, description=None, custom_data=None):
        """Uploads a new file as attachment for an object."""
        command = "Attachment/Upload"
        args = ""
        name = "" if name is None else "&Name=" + url_quote_trunc(name, 250, 100)

        description = "" if description is None else "&Description=" + url_quote_trunc(description, 1020, 500)
        custom_data = "&CustomData=" + url_quote_trunc(name, 1020, 500) if custom_data is not None else ""
        args = "?ObjectId=" + objectId + name + description + custom_data
        filename = os.path.basename(filepath)
        with open(filepath, "rb") as f:
            r = self.xhub_post(command, args, files={filename: (filename, f)})
            return r.json()
        msg = "Shouldn't have gotten here"
        raise ValueError(msg)

    # ================================================================================================

    def _attachmentGetById1(self, fileId, file_path=None):
        """Download the file attached to the fileId."""
        command = "Attachment/GetById"
        args = "?fileId=" + fileId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        dbgprint(5, f"GET: {self.xhubUrl + command + args}")
        dbgprint(5, f"response headers {type(r.headers)}: {r.headers}")
        dbgprint(5, f"response encoding: {r.encoding}")
        # DON'T!!! dbgprint(5, 'response text: {}'.format(r.text))  -- this is the payload
        # DON'T!!! dbgprint(5, 'response json: {}'.format(r.json())) -- same as json.loads(r.text)
        try:
            local_filename = re.findall("filename=([^;]+)", r.headers.get("content-disposition"), re.IGNORECASE)[
                0
            ].strip('"')
        except TypeError:
            local_filename = fileId
        if local_filename == "issue.json":
            raise ValueError("Attachment not found: " + fileId)
        if file_path is None:
            tmp_dir = mkdtemp()
            file_path = os.path.join(tmp_dir, local_filename)
        with open(file_path, "wb") as f:
            for chunk in r.iter_content(chunk_size=None):
                if chunk:  # filter out keep-alive new chunks
                    f.write(chunk)
        return file_path

    # ================================================================================================

    def _attachmentGetById(self, fileId, file_path=None, ntry=3, twait=5, twait_max=300):
        for i in range(ntry):
            try:
                return self._attachmentGetById1(fileId, file_path)
            except Exception:
                if i == ntry - 1:
                    raise
                time.sleep(twait)
                # double the wait time for each retry up to twait_max
                twait = twait * 2 if twait < 0.5 * twait_max else twait_max
        return None

    # ================================================================================================

    def attachmentGetInfo(self, FileId):
        """Retrieves the file info."""
        command = "Attachement/GetInfo"
        args = "?FileId=" + FileId
        r = self.xhub_request.get(command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, r.status_code)
        return r.json()

    # ================================================================================================

    def attachmentGetById(self, fileId, file_path=None, ntry=3, twait=5, twait_max=300):
        """Download the file attached to the fileId."""
        try:
            return self._attachmentGetById(fileId, file_path, ntry, twait, twait_max)
        except Exception:
            return self._resultGetFilebyId(fileId, file_path, ntry, twait, twait_max)

    # ================================================================================================

    def attachmentDelete(self, fileId):
        """Deletes an Attachment and its dependencies."""
        command = "Attachment/Delete"
        args = "?fileID=" + fileId
        r = self.req_delete(self.xhubUrl + command + args)
        return r.status_code == 200

    # ================================================================================================

    def attachmentLink(self, sourceId, destinationId):
        """Updates the relationship from an object, and moves to another one. After that, retrieves the
        full list of affected items"""
        command = "Attachment/Link"
        args = "?SourceId=" + sourceId + "&DestinationId=" + destinationId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def attachmentLinkFile(self, fileId, containerId):
        """Links a file to a specified container."""
        command = "Attachment/LinkFile"
        args = "?FileId=" + fileId + "&ContainerId=" + containerId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def attachmentGetByObjectId(self, objectId):
        """Retrieves the full list of files attached to an object."""
        command = "Attachment/GetByObjectId"
        args = "?ObjectId=" + objectId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    # ================================================================================================

    # LOG

    # ================================================================================================

    def logLogAdd(self, info):
        """Add elastic logging"""
        command = "Log/LogAdd"
        args = ""
        r = requests.post(
            self.xhubUrl + command + args,
            data=json.dumps(info),
            headers={"content-type": "application/json"},
            verify=SSL_VERIFY_HOSTNAME,
            auth=HttpAuth(self.winuser, self.password, self.domain),
        )
        return r.json()

    # ================================================================================================

    def logLogGet(self, taskId, page, pageSize):
        """Get log file"""
        command = "Log/LogGet"
        args = "?taskId=" + taskId + "&page=" + page + "&pageSize=" + pageSize
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    # RESULT

    # ================================================================================================

    def resultCreate(self, taskid, status, details, links=None):
        """Creates a Result for a task and broadcasts the updating to SignalR connected clients."""
        if links is None:
            links = []
        command = "Result/Create"
        args = ""
        payload = {"TaskId": taskid, "Status": status, "Details": json.dumps(details), "Links": json.dumps(links)}
        self.xhub_post(command, args, payload=payload)
        return True

    # ================================================================================================

    def resultCreateRaw(self, result):
        """Post raw result"""
        command = "Result/Create"
        args = ""
        if isinstance(result["Details"], dict):
            result = deepcopy(result)  # do not modify input arg
            result["Details"] = json.dumps(result["Details"])
        r = self.xhub_post(command, args, payload=result)
        return r.status_code == 200

    # ================================================================================================

    def resultCreateMultiple(self, results):
        """Creates multiple Results for a task and broadcasts the updating to SignalR connected clients."""
        command = "Result/CreateMultiple"
        args = ""
        results = deepcopy(results)  # do not modify input arg
        for result in results:
            if isinstance(result["Details"], dict):
                result["Details"] = json.dumps(result["Details"])
        self.xhub_post(command, args, payload=results)
        return True

    # ================================================================================================

    def resultGetByActorId(self, actorId):
        """Gets all Results of an Actor."""
        command = "Result/GetByActorId"
        args = "?actorId=" + actorId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def resultGetByRunId(self, runId):
        """Gets all Results of a Session."""
        command = "Result/GetByRunId"
        args = "?runId=" + runId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def resultGetByTaskId(self, taskId):
        """Gets the Result of a Task."""
        command = "Result/GetByTaskId"
        args = "?taskId=" + taskId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def resultUploadFile(self, filepath, filename=None):
        """Upload file"""
        command = "Result/UploadFile"
        args = ""
        if filename is None:
            filename = os.path.basename(filepath)
        with open(filepath, "rb") as f:
            r = self.xhub_post(command, args, files={filename: (filename, f)})
            return r.status_code
        msg = "Shouldn't have gotten here"
        raise ValueError(msg)

    # ================================================================================================

    def resultAttachFile(self, task_id, filepath, name=None, description=None, custom_data=None):
        """Upload file from the attatched file of xHUB actor"""
        command = "Result/AttachFile"
        name = "" if name is None else "&name=" + url_quote_trunc(name, 250, 100)
        description = "" if description is None else "&description=" + url_quote_trunc(description, 1020, 500)
        custom_data = "&CustomData=" + url_quote_trunc(name, 1020, 500) if custom_data is not None else ""
        args = "?taskId=" + task_id + name + description
        filename = os.path.basename(filepath)
        with open(filepath, "rb") as f:
            r = self.xhub_post(command, args, files={filename: (filename, f)})
            return r.json()
        msg = "Shouldn't have gotten here"
        raise ValueError(msg)

    # ================================================================================================

    def _resultGetFilebyId1(self, fileId, file_path=None):
        """Download the file attached to the fileId."""
        command = "Result/GetFilebyId"
        args = "?fileId=" + fileId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        dbgprint(5, f"GET: {self.xhubUrl + command + args}")
        dbgprint(5, f"response headers {type(r.headers)}: {r.headers}")
        dbgprint(5, f"response encoding: {r.encoding}")
        # DON'T!!! dbgprint(5, 'response text: {}'.format(r.text))  -- this is the payload
        # DON'T!!! dbgprint(5, 'response json: {}'.format(r.json())) -- same as json.loads(r.text)
        try:
            local_filename = re.findall("filename=([^;]+)", r.headers.get("content-disposition"), re.IGNORECASE)[
                0
            ].strip('"')
        except TypeError:
            local_filename = fileId
        if local_filename == "issue.json":
            raise ValueError("Attachment not found: " + fileId)
        if file_path is None:
            tmp_dir = mkdtemp()
            file_path = os.path.join(tmp_dir, local_filename)
        with open(file_path, "wb") as f:
            for chunk in r.iter_content(chunk_size=None):
                if chunk:  # filter out keep-alive new chunks
                    f.write(chunk)
        return file_path

    # ================================================================================================

    def _resultGetFilebyId(self, fileId, file_path=None, ntry=3, twait=5, twait_max=300):
        for i in range(ntry):
            try:
                return self._resultGetFilebyId1(fileId, file_path)
            except Exception:
                if i == ntry - 1:
                    raise
                time.sleep(twait)
                # double the wait time for each retry up to twait_max
                twait = twait * 2 if twait < 0.5 * twait_max else twait_max
        return None

    # ================================================================================================

    def resultGetFileById(self, fileId, file_path=None, ntry=3, twait=5, twait_max=300):
        """Download the file attached to the fileId."""
        try:
            return self._resultGetFilebyId(fileId, file_path, ntry, twait, twait_max)
        except Exception:
            return self._attachmentGetById(fileId, file_path, ntry, twait, twait_max)

    resultGetFilebyId = resultGetFileById
    # ================================================================================================

    def resultLinkFile(self, fileId, taskId):
        """Links file to a Task."""
        command = "Result/LinkFile"
        args = "?FileId=" + fileId + "&taskId=" + taskId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def resultGetFilebyTaskId(self, taskId):
        """Gets File's by TaskId."""
        command = "Result/GetFilebyTaskId"
        args = "?taskId=" + taskId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def resultGetByParentTaskId(self, taskId):
        """Gets the Result of a Task."""
        command = "Result/GetByParentTaskId"
        args = "?parentTaskId=" + taskId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    # SESSION

    # ================================================================================================

    def sessionGetAll(self):
        command = "Session/GetAll"
        r = self.req_get(self.xhubUrl + command)
        if r.status_code != 200:
            raise XhubApiError(command, "", r.status_code)
        return r.json()

    # ================================================================================================

    def sessionGetByUsername(self, username):
        command = "Session/GetByUsername"
        args = "?username=" + username
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def sessionGetBySessionId(self, sessionId):
        command = "Session/GetBySessionId"
        args = "?sessionId=" + sessionId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def sessionCreate(self, name=None, description="", sessionJSON=None):
        """Create xHUB session"""
        command = "Session/Create"
        args = ""
        if sessionJSON is not None:
            session = sessionJSON
        elif name is not None:
            session = {"Name": name, "Description": description}
        else:
            msg = "XhubClient.sessionCreate called without name argument"
            raise ValueError(msg)
        return self.xhub_post(command, args, payload=session).json()

    # ================================================================================================

    def sessionDuplicate(self, sessionId):
        command = "Session/Duplicate"
        args = "?sessionId=" + sessionId
        return self.xhub_post(command, args, payload={}).json()["Result"]

    # ================================================================================================

    def sessionUpdateStatus(self, sessionId, status):
        command = "Session/Update"
        args = ""
        payload = {"SessionId": sessionId, "Status": status}
        self.xhub_post(command, args, payload=payload)
        return True

    # ================================================================================================

    def sessionUpdate(self, session, deprecating_status=None):
        """update session from dictionary argument session that shoud
        comply with the session data model"""
        command = "Session/Update"
        args = ""
        if isinstance(session, str) or deprecating_status is not None:
            warn(
                "The usage XhubClient.sessionUpdate(SessionId, Status) is being deprecated. "
                "Please use XhubClient.sessionUpdate(session) or XhubClient.sessionUpdateStatus(SessionId, Status)",
                stacklevel=1,
            )
            return self.sessionUpdateStatus(session, deprecating_status)
        self.xhub_post(command, args, payload=session)
        return True

    # ================================================================================================

    def sessionDeleteBySessionId(self, sessionId):
        command = "Session/DeleteBySessionId"
        args = "?sessionId=" + sessionId
        r = self.req_delete(self.xhubUrl + command + args)
        return r.status_code == 200

    # ================================================================================================

    def sessionGetByLabels(self, labels):
        command = "Session/GetByLabels"
        args = "?"
        for x in labels:
            args += "labels=" + x + "&"
        args = args[:-1]
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    # SESSION STORAGE

    # ================================================================================================

    def sessionStorageCreate(self, sessionId):
        """Create xHUB session storage"""
        command = "SessionStorage/defined"
        args = "?sessionId=" + sessionId
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    def getSessionStorage(self, sessionId):
        """Get full session info from session ID"""
        command = "SessionStorage/Get"
        args = "?sessionId=" + sessionId
        r = self.req_get(self.xhubUrl + command + args)
        return r.json()

    def addSessionStorage(self, info):
        """Get full session storage info from session ID"""
        command = "SessionStorage/add"
        args = ""
        r = self.xhub_post(command, args, payload=info)
        return r.json()

    def updateSessionStorage(self, info):
        """Update storage of xHUB session"""
        command = "SessionStorage/update"
        args = ""
        r = self.xhub_post(command, args, payload=info)
        return r.status_code == 200

    def sessionStorageDelete(self, IdSessionStorage):
        """Delete storage of xHUB session"""
        command = "SessionStorage/delete"
        args = "?IdSessionStorage=" + IdSessionStorage
        r = self.req_delete(self.xhubUrl + command + args)
        return r.status_code == 200

    # ================================================================================================

    # TASK

    # ================================================================================================

    def taskGetByActorId(self, actorId, statuses=None, startAt=None, maxResults=None, newestOnTop=None):
        "Get tasks by actor ID"
        p = "&statuses="
        s = ""
        startAt = "" if startAt is None else "&startAt=" + str(startAt)
        maxResults = "" if maxResults is None else "&maxResults=" + str(maxResults)
        newestOnTop = "" if newestOnTop is None else "&newestOnTop=" + str(newestOnTop)
        if statuses is not None:
            s = p + p.join(statuses)
        command = "Task/GetByActorId"
        args = "?actorId=" + actorId + s + startAt + maxResults + newestOnTop
        r = self.req_get(self.xhubUrl + command + args)
        try:
            tasklist = r.json()
        except Exception:
            tasklist = []
        if isinstance(tasklist, str) and tasklist == "":
            tasklist = []
        elif r.status_code in [400, 404] and isinstance(tasklist, dict) and tasklist.get("Message") == "Tasks not found":
            r.status_code = 200
            tasklist = []
        if r.status_code not in [200, 204]:
            raise XhubApiError(command, args, r.status_code)
        if len(tasklist) == 0 and statuses is not None and len(statuses) == 1 and statuses[0] == "New":
            raise XhubNoNewTask(command, args, r.status_code)
        return tasklist

    # ================================================================================================

    def taskGetBySessionId(
        self, sessionId, statuses=None, startAt=None, maxResults=None, userTasks=None, onlyParents=None
    ):
        "Get tasks by sessionID"
        p = "&statuses="
        s = ""
        startAt = "" if startAt is None else "&startAt=" + str(startAt)
        maxResults = "" if maxResults is None else "&maxResults=" + str(maxResults)
        userTasks = "" if userTasks is None else "&newestOnTop=" + str(userTasks)
        onlyParents = "" if onlyParents is None else "&newestOnTop=" + str(onlyParents)
        if statuses is not None:
            s = p + p.join(statuses)
        command = "Task/GetBySessionId"
        args = "?sessionId=" + sessionId + s + startAt + maxResults + userTasks + onlyParents
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def taskGetByRunId(self, runId, *statuses):
        "Get tasks by run ID"
        p = "&statuses="
        s = ""
        if len(statuses) > 0:
            s = p + p.join(statuses)
        command = "Task/GetByRunId"
        args = "?runId=" + runId + s
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def taskGetByTaskId(self, taskId):
        "Get tasks by Task ID"
        command = "Task/GetByTaskId"
        args = "?taskId=" + taskId
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def taskGetByFilter(
        self,
        startAt=None,
        maxResults=None,
        sessionID=None,
        sessionName=None,
        actorID=None,
        actorIDController=None,
        actorName=None,
        actorType=None,
        timeStart=None,
        timeEnd=None,
        sortBy=None,
        owner=None,
        showResults=None,
        status=None,
        parentTaskID=None,
        taskID=None,
        runID=None,
        expName=None,
    ):
        """Get the tasks filtered by the above fields."""
        saved_args = locals()
        saved_args.pop("self")
        command = "Task/GetByFilter"
        args = ""
        if any(argument is not None for argument in saved_args.values()):
            arguments = "?"
            for arg_name, arg_value in saved_args.items():
                if arg_value is not None:
                    if isinstance(arg_value, list):
                        p = "&" + str(arg_name) + "="
                        argument = str(arg_name) + "=" + p.join(arg_value) + "&"
                    else:
                        argument = str(arg_name) + "=" + str(arg_value) + "&"
                    arguments += argument
            args = arguments[:-1]  # remove last '&'
        r = self.req_get(self.xhubUrl + command + args)
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def taskGetByParentTaskId(self, parentTaskId, startAt=None, maxResults=None):
        """Got all Tasks of the ParentTaskId"""
        startAt = "" if startAt is None else "&startAt=" + str(startAt)
        maxResults = "" if maxResults is None else "&maxResults=" + str(maxResults)
        command = "Task/GetByParentTaskId"
        args = "?parentTaskId=" + parentTaskId + startAt + maxResults
        r = self.req_get(self.xhubUrl + command + args)
        return r.json()

    # ================================================================================================

    def taskCreate(self, actorId=None, param=None, parentTaskId=None, task=None):
        """Create task try a few times
        may be used two ways as in examples below:
           client.taskCreate(actorId="123", param={"A": 1.5, "B": 2})
        or
           client.taskCreate(task={ActorId: "123", "Body": {"A": 1.5, "B": 2}, "Name": "A task"})
        """
        command = "Task/Create"
        args = ""
        if task is not None and actorId is None and param is None and parentTaskId is None:
            payload = deepcopy(task)
            if isinstance(payload["Body"], dict):
                payload["Body"] = json.dumps(payload["Body"])
        elif task is None and actorId is not None and param is not None:
            payload = {"ActorId": actorId, "Body": json.dumps(param), "ParentTaskId": parentTaskId}
        else:
            msg = "XhubClient.taskCreate called with too many or too few arguments"
            raise ValueError(msg)
        resp = self.xhub_post(command, args, payload=payload).json()
        if isinstance(resp, dict):
            return resp["Result"]
        return resp

    # ================================================================================================

    def taskCreateMultiple(self, actorId=None, params=None, parentTaskId=None, taskids=None, tasks=None):
        """Create tasks from raw input or actorId and parameter list
        INPUT: either
          tasks: raw input for the endpoint, or
          actorId, params, parentTaskId:
             actorId: destination actor ID
             params: list of task parameters dictionaries either plain or json encoded
             parentTaskId: one parent task ID for all tasks, or
                           a list of parent task IDs witth the same length as params
         OUTPUT: JSON response from the post command
        """
        command = "Task/CreateMultiple"
        args = "" if taskids is None else "?taskids=" + ("true" if taskids else "false")
        if tasks is None:
            payload = []
            if parentTaskId is None:
                parentTaskId = [None] * len(params)
            elif not isinstance(parentTaskId, list):
                parentTaskId = [parentTaskId] * len(params)  # make parentTaskId list
            for p, ptid in zip(params, parentTaskId):
                payload.append({"ActorId": actorId, "Body": json.dumps(p), "ParentTaskId": ptid})
        else:
            payload = deepcopy(tasks)
            for task in payload:
                if isinstance(task["Body"], dict):
                    task["Body"] = json.dumps(task["Body"])
        return self.xhub_post(command, args, payload=payload).json()

    # ================================================================================================

    def taskUpdate(self, taskId, taskStatus, name=None, description=None, labels=None):
        """Update task"""
        command = "Task/Update"
        args = ""
        payload = {"TaskId": taskId, "Status": taskStatus}
        if name is not None:
            payload["Name"] = name
        if description is not None:
            payload["Description"] = description
        if labels is not None:
            payload["Labels"] = labels
        self.xhub_post(command, args, payload=payload)
        return True

    # ================================================================================================

    def taskUpdateMultiple(self, payload):
        """Update multiple tasks. payload should be an iterable with the tasks to update."""
        command = "Task/UpdateMultiple"
        args = ""
        self.xhub_post(command, args, payload=list(payload))
        return True

    # ================================================================================================

    def taskDeleteByTaskId(self, taskIds):
        command = "Task/DeleteByTaskId"
        args = "?"
        for id in taskIds:
            args += "taskId=" + id + "&"
        args = args[:-1]
        r = self.req_delete(self.xhubUrl + command + args)
        return r.status_code == 200

    # ================================================================================================

    def taskGetForAllHostedProcesses(self):
        command = "Task/GetForAllHostedProcesses"
        args = ""
        r = self.req_get(self.xhubUrl + command + args, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    def userGetAll(self):
        """Get all users"""
        command = "User/GetAll"
        args = ""
        r = self.req_get(self.xhubUrl + command, headers={"Accept": "application/json"})
        if r.status_code != 200:
            raise XhubApiError(command, args, r.status_code)
        return r.json()

    # ================================================================================================

    # Extra

    # ================================================================================================

    def download_file(self, url):
        local_filename = url.split("/")[-1]
        # NOTE the stream=True parameter below
        with requests.get(
            url, verify=SSL_VERIFY_HOSTNAME, auth=HttpAuth(self.winuser, self.password, self.domain)
        ) as r:
            r.raise_for_status()
            with open(local_filename, "wb") as f:
                for chunk in r.iter_content(chunk_size=None):
                    if chunk:  # filter out keep-alive new chunks
                        f.write(chunk)
                        # f.flush()
        return local_filename

    # ================================================================================================

    def error(self, message="", status=1):
        """Crude error handling.
        error(message, status=1):
        Abort execution with specified exit status after printing message to stderr.
        """
        if message:
            print("ERROR: ", message, file=sys.stderr)
        print(f'Please see "{sys.argv[0]} -h" for help.', file=sys.stderr)
        sys.exit(status)

    # ================================================================================================

    def newestSession(self, sessionList):
        """
        find the index of the newest session in the session list by LastUpdateDate
        """

        try:  # for catching datetime.strptime conversion error
            isess = 0
            tsess = None
            for i, s in enumerate(sessionList):  # get index and value
                ds = re.sub(r"\.\d+$", r"", s["LastUpdateDate"])  # remove any trailing fraction of second
                t = datetime.strptime(ds, "%Y-%m-%dT%H:%M:%S")  # noqa: DTZ007
                if not tsess:
                    tsess = t  # initalize tsess on the first pass
                if t > tsess:  # test if t larger than tsess
                    isess = i  # update index
                    tsess = t  # update value
        except ValueError:  # catch datetime.strptime conversion error
            isess = 0
            warn(f"Failed to convert datetime string from session {s}.\nUsing session {isess + 1}.", stacklevel=1)

        return isess

    # ================================================================================================

    def ttySelectSession(self, sessionList):
        """
        Ask user to select a session from sessionList. Must have terminal.
        Returns index in sessionList.
        """

        # print sessions with labels for user to select from
        for i, s in enumerate(sessionList):  # iterate over indexes and sessions in sessionList
            print("{}: {}\t{}\t{}\t{}".format(i + 1, s["Name"], s["SessionId"], s["Status"], s["Description"]))

        prompt = f"Please choose a session. Type its index between {1} and {len(sessionList)}: "
        havePatience = 3  # short-tempered

        while havePatience:
            havePatience -= 1  # loosing patience
            if not havePatience:
                prompt = prompt.upper()
            r = input(prompt)
            try:  # for catching int() conversion error or out of bounds user input
                i = int(r)  # convert user input to integer
                assert 1 <= i <= len(sessionList)  # check bounds (or raise exception)
                isess = i - 1  # set session index in sessionList
                break
            except Exception as e:  # catch exception from assert
                if not havePatience:
                    print("Refusenik user. " + str(e))  # abort if user is refusenik
                    raise e

        return isess

    # ================================================================================================

    def selectSessionId(self):
        """
        selectSessionId(): retun an xHUB session ID

        If the user has only one session, return its ID.

        Else if the user has no session, instruct the user to create one.

        Else, the user has more than one session:

          If this script is run from terminal (we have keyboard input), we
            ask the user to select the session she wants to use.

          Else, this script is run by another tool (e.g., from virtuoso),
            and we do not have keyboard input, we use the newest session.
        """

        # gets the list of sessions (as dictionaries)
        sessionList = self.sessionGetByUsername(self.winuser)

        # check if we have at least one session
        if len(sessionList) < 1:
            self.error("No session for user " + self.winuser + ". Please start a session.")

        if len(sessionList) == 1:  # one session only?
            isess = 0  # well, just use it
        else:  # more than one session
            isess = self.ttySelectSession(sessionList) if sys.stdin.isatty() else self.newestSession(sessionList)

        return sessionList[isess]["SessionId"]


#############################################################################

if __name__ == "__main__":
    # GLOBAL VARIABLES

    xhub_client = XhubClient()

    # =======================================================================

    # def usage
    def usage():
        import textwrap

        print(sys.argv[0])
        print(
            textwrap.dedent(
                """
        USAGE:

            client.py function arguments

        Execute xHUB client API function with specified arguments (for testing)

        Available functions:
        """
            )
        )
        for fn in functions:
            fun = getattr(XhubClient, fn)
            print(fun.__name__)
            print(fun.__doc__)
            print("*" * 77)
            print()

    # /def usage
    # =======================================================================

    # functions = { f for f in XhubClient.__dict__.values() if type(f) == types.FunctionType }
    functions = [func for func in dir(XhubClient) if callable(getattr(XhubClient, func)) and not func.startswith("__")]
    if len(sys.argv) < 2:
        print("ERROR: Required arguments missing.\n", file=sys.stderr)
        usage()
        sys.exit(1)

    fun_name = sys.argv[1]
    args = sys.argv[2:]

    if fun_name in functions:
        fl = [f for f in functions if f == fun_name]
        assert len(fl) == 1, f"more than one function with name {fun_name}?"
        fun = getattr(XhubClient, fun_name)
    elif fun_name in ["server", "servers", "base"]:
        kxhubUrl = ""
        for k, v in XhubClient.xhub_api_base_url.items():
            if v == xhub_client.getXhubUrl():
                kxhubUrl = f" ({k})"
            print(f"{k:<10} : {v}")
        print("{:<10} : {}{}".format("USING", xhub_client.getXhubUrl(), kxhubUrl))
        print("set XHUB_URL to use a different one")
        sys.exit(0)
    else:
        print(f"ERROR: unknown function: {fun_name}.\n", file=sys.stderr)
        usage()
        sys.exit(1)

    print(f"{fun_name}{tuple(str(arg) for arg in args)}", file=sys.stderr)

    r = fun(xhub_client, *args)

    print("Result:", file=sys.stderr)
    print(json.dumps(r, indent=4))
