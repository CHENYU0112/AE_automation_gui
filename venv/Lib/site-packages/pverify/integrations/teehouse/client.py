from __future__ import annotations

import atexit
import json
import logging
import threading
import traceback
from pathlib import Path
from typing import *

import zmq


class TEEHouseClientError(Exception):
    pass


class TEEHouseClient:
    def __init__(
        self,
        ctx_file: Union[str, Path] = None,
        log: Union[logging.Logger, str] | None = None,
        json_encoder_kwargs: dict | None = None,
    ):
        """
        Class initializer

        :param ctx_file: A path to an existing TEEHouse context file or None.
                         If None, the client will act in a simulation mode and execute all called functions
                         mocked. Properties like ctx or calibration_ctx will return an empty dict.
                         If given the file is loaded and its content will be available via the ctx property.
        :param log: Either a logging.Logger instance, a name of a logger instance or None.
                    If None, the default unconfigured logger "teehouse_client" will be used.
        :param json_encoder_kwargs: Keyword arguments that are passed on to json.dumps when sending requests
        """
        self._json_encoder_kwargs = json_encoder_kwargs or {}
        self._zmq_context: zmq.Context = None
        self._zmq_socket: zmq.Socket = None

        if ctx_file is None:
            self._mocked = True
            self._ctx_file = None
            self._ctx = {}
        else:
            self._mocked = False
            self._ctx_file = Path(ctx_file)
            if not self._ctx_file.exists():
                msg = f"TEEHouse context file {self._ctx_file} does not exist!"
                raise FileNotFoundError(msg)
            with open(self._ctx_file) as fp:
                self._ctx = json.load(fp)
        if isinstance(log, (logging.Logger, logging.LoggerAdapter)):
            self._log = log
        elif isinstance(log, str):
            self._log = logging.getLogger(log)
        else:
            self._log = logging.getLogger("teehouse_client")
        self._lock = threading.Lock()

    def __del__(self):
        self._disconnect()

    def __enter__(self) -> TEEHouseClient:
        """
        A context manager for convenience. Automatically connects upon entering the context and
        disconnects when leaving the context.

        Example::

            with TEEHouseClient(port=context["ctrl_ctx"]["comm_server_port"]) as client:
                client.send_startup()
                ...
        """
        self._connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._disconnect()

    @property
    def ctx(self):
        """
        The content of the TEEHouse context file as dictionary
        """
        return self._ctx

    @property
    def calibration_ctx(self) -> dict:
        """
        The calibration context from TEEHouse
        """
        return self._ctx.get("calibration_ctx", {})

    def _request(self, command: str, payload: dict | None = None, log=True):
        if self._zmq_socket is not None and not self._mocked:
            payload = payload or {}
            try:
                if log:
                    self._log.debug(f"Sending request {command!r}...")
                self._zmq_socket.send_json({"command": command, "payload": payload}, **self._json_encoder_kwargs)
                if log:
                    self._log.debug(f"Sent request {command!r} with payload {str(payload)[:100]}")
                    self._log.debug(f"Receiving response to {command!r}...")
                response = self._zmq_socket.recv_json()
                if log:
                    self._log.debug(f"Received response to {command!r}: {response}")
            except zmq.ZMQBaseError as e:
                self._log.warning(
                    f"No connection to TEEHouse (error: '{e}'). Continuing mocked...\n"
                    f"Traceback:\n{traceback.format_exc()}"
                )
                self._zmq_context = None
                self._zmq_socket = None
                self._mocked = True
                return None

            if response["status"] < 0:
                error = response.get("error", f"({response['status']}) unknown")
                self._log.error(error)
                raise TEEHouseClientError(error)
            return response
        return None

    def _connect(self):
        """
        Connect to the TEEHouse communication server
        """
        if self._mocked:
            return
        port = self.ctx["ctrl_ctx"]["comm_server_port"]

        self._zmq_context = zmq.Context()
        self._zmq_socket: zmq.Socket = self._zmq_context.socket(zmq.REQ)
        self._zmq_socket.setsockopt(zmq.LINGER, 100)
        self._zmq_socket.setsockopt(zmq.RCVTIMEO, 10000)
        self._zmq_socket.connect(f"tcp://localhost:{port}")
        if not self._check_alive():
            return

        self._log.info(f"Connected to TEEHouse version {self.ctx['static_ctx']['teehouse_version']} via port {port}")
        atexit.register(self._disconnect)

    def _disconnect(self):
        """
        Disconnect from the TEEHouse communication server
        """
        if self._mocked:
            return
        try:
            self._zmq_socket.close(linger=1000)
            self._zmq_context.term()
            self._zmq_socket = None
            self._zmq_context = None
            self._log.info("Disconnected from TEEHouse")
        except Exception:
            pass

    def _check_alive(self):
        """
        Check if the TEEHouse remote end is still alive. If not the runnable might decide to shutdown early.
        """
        if self._mocked:
            return True
        return self._request("is_stop_requested") is not None

    def _send_startup(self):
        """
        Communicate that the runnable is performing a startup
        """
        if self._mocked:
            return
        with self._lock:
            self._request("startup")

    def _send_iteration_started(self, n_iteration: int, total: int, parameters: dict):
        """
        Communicate that the runnable is entering a new parameter iteration.
        Simple Python scripts might only communicate a startup and teardown, but no internal iterations.

        :param n_iteration: The 0-based iteration index of the current iteration
        :param total: The total number of parameter iterations the runnable is executing
        :param parameters: The parameters of the current iteration as dictionary
        """
        if self._mocked:
            return
        assert n_iteration < total
        with self._lock:
            self._request("iteration_started", {"n_iteration": n_iteration, "n_total": total, "parameters": parameters})

    def _send_iteration_finished(
        self,
        internal_iteration_index: int,
        parameters: Dict[str, Tuple[Any, str]],
        data: Dict[str, Any],
        metadata: Dict[str, Any] = None,
    ):
        """
        Communicate that the runnable has finished a parameter iteration.
        Simple Python scripts might only communicate a startup and teardown, but no internal iterations.

        :param internal_iteration_index: The 0-based iteration index of the current iteration
        :param parameters: A dictionary of parameters of style ``dict(paramA=(1.23, "V"), paramB=("foo", ""))``
        :param metadata: A dictionary for metadata of this iteration, e.g. ``dict(metaA=1, metaB="bar")``
        :param data:    A dictionary that holds the results for the current iteration.
                        Its keys are the output/result names, its values again dictionaries which in turn
                        have a different structure for the type of result.

                        An example describes it best::

                            dict(
                                result_a=dict(data_type="scalar", unit="V", data=1, metadata=dict(z="z")),
                                result_b=dict(data_type="scalar", unit="", data="foo", metadata=None),
                                result_c=dict(data_type="scalar", unit="V", data=1.23, metadata=None),
                                result_d=dict(data_type="array", data=[[1, 2], [3, 4]], unit="", metadata=None),
                                result_e=dict(
                                    data_type="waveform",
                                    x_data=[0, 1],  # start- and end-points are enough for equidistant signals
                                    y_data=[0,1,2,3,4,5],
                                    x_unit="s",
                                    y_unit="V",
                                    metadata=None
                                ),
                                result_f=dict(
                                    data_type="waveform",
                                    x_data=[0, 1, 2, 3],
                                    y_data=[1, 2, 3, 4],
                                    x_unit="Hz",
                                    y_unit="A",
                                    metadata=None,
                                )
                            )
        """
        if self._mocked:
            return
        with self._lock:
            self._request(
                "iteration_finished",
                {
                    "internal_iteration_index": internal_iteration_index,
                    "parameters": parameters,
                    "data": data,
                    "metadata": metadata,
                },
            )

    def _send_teardown(self):
        """
        Communicate that the runnable is performing a teardown
        """
        if self._mocked:
            return
        with self._lock:
            self._request("teardown")

    def _send_failed(self, status_code=-1, error_message="", error_traceback=""):
        """
        Communicate that the runnable failed.

        :param status_code: The status code. Default is -1. Only negative integers allowed.
        :param error_message: A short message that describes the error
        :param error_traceback: A detailed traceback which may include where the error happened
        """
        if status_code >= 0:
            msg = "status_code must be a negative integer!"
            raise ValueError(msg)
        if self._mocked:
            return
        with self._lock:
            self._request(
                "failed",
                {
                    "status_code": int(status_code),
                    "error_message": str(error_message),
                    "error_traceback": str(error_traceback),
                },
            )

    def is_stop_requested(self) -> bool:
        """
        Ask TEEHouse if the user requested the execution to stop
        """
        if self._mocked:
            return False
        with self._lock:
            return bool(self._request("is_stop_requested", log=False)["stop_requested"])

    def send_log_message(self, message: str, level="info", source=""):
        """
        Tell TEEHouse to add a log entry in the application logger.

        :param message: The message to log
        :param level: The severity level. One of "debug", "info", "warning", "error"
        :param source: The source of the log message, to better differentiate against TEEHouse internal messages
        """
        if self._mocked:
            return
        with self._lock:
            assert level.lower() in ("debug", "info", "warning", "error", "critical")
            self._request("log_message", {"message": message, "source": source, "level": level.lower()})
