# Stdlib imports
from __future__ import annotations

import hashlib
from pathlib import Path
from typing import *
from typing import TYPE_CHECKING

import numpy as np

# 3rd party imports
from anasymod.analysis import Analysis

from pverify import Enums, PyVerifyBaseTest, Waveform
from pverify.core.hooks import DoE

if TYPE_CHECKING:
    from anasymod.sim_ctrl.ctrlapi import CtrlApi


class InstrumentConnectionError(Exception):
    pass


class PyVerifyFpgaTest(PyVerifyBaseTest):
    def __init__(self, **kwargs):
        self._analysis: Analysis = None
        self._ctrlapi: CtrlApi = None

        self._probed_signals: Dict[str, Waveform] = {}
        self._filewatcher_cache = {}  # A mapping between yaml file paths and file content hashes, to check if
        # files got changed

        self._analysis_kwargs = {}
        self._analysis_launch_kwargs = {"debug": True}
        self._analysis_simulate_kwargs = {"unit": "main", "id": "xrun"}

        super().__init__(**kwargs)

        if "input" not in self._analysis_kwargs:
            self._analysis_kwargs["input"] = str(Path(self._test_file_path).parent)

        if self.Attributes.ExecutionMode != Enums.ExecutionMode.PostProcOnly:
            self.Attributes.ExecutionMode = Enums.ExecutionMode.Lab

        self._log = self.Utils.GetLogger("FPGA Base: ")

    @DoE.Init(is_hook_wrapper=True, try_first=True)
    def fpga_init(self):
        """
        This method must not be overwritten and will be executed prior to user-specified "Init" stages

        Predefines several parameters like

            - active_target: Mode that shall be actively used. Default: sim
            - force_gen_bitstream: Set this to 1 if bitstream shall be always generated.
              Otherwise it's generated only if inputs are changed.
        """
        self.StorageOptions.ConfigureDLH5Handler(True)
        self.StorageOptions.ConfigureJsonHandler(False)
        self.StorageOptions.ConfigureLegacyHDF5Handler(False)

        self.Parameters.Add("active_target", "", "Mode that shall be actively used. Default: sim", ["sim"])
        self.Parameters.Add(
            "force_gen_bitstream",
            "",
            "Set this to 1 if bitstream shall be always generated."
            "Otherwise it's generated only if inputs are changed.",
            [0],
        )
        yield

    @DoE.Startup(is_hook_wrapper=True, try_first=True)
    def fpga_startup(self):
        """
        This method must not be overwritten and will be executed prior to user-specified "Startup" stages.

        It will instantiate the Analysis class (from anasymod.analysis) using the options configured by method
        *configure_anasymod_analysis*.
        """
        self._proj_root = Path(self._analysis_kwargs.get("input", ".")).absolute()
        if not self._proj_root.exists():
            msg = f"Analysis constructor argument 'input' is a non-existent path! ({self._proj_root})"
            raise Exception(msg)
        else:
            self._analysis_kwargs["input"] = str(self._proj_root)
        self._log.info(f"Using root directory {self._proj_root}")
        self._log.info("Creating Analysis instance")
        self._analysis = Analysis(**self._analysis_kwargs)
        yield

    @DoE.Iteration(is_hook_wrapper=True, try_first=True)
    def fpga_iteration(self):
        """
        This method must not be overwritten and will be partly executed prior and after user-specified "Iteration"
        stages.

        Functionality executed prior to user code:

        -   Setting the active target if "active_target" parameter changes between iterations.
        -   Re-generate the models and bitstream only when sources have changed
        -   Launching simulation (batch mode)/emulation (interactive mode)

        Functionality executed after user code:

        -   Probe all VCD signals (if not probed by user already using "probe_signals"),
            so user only has to call "get_signal" to get a signal as Waveform.

        """
        self._probed_signals.clear()

        target = self.Current_variation["active_target"]

        if self.Utils.VariationValueChanged("active_target"):
            self._log.info(f"Setting FPGA target to {target!r}")
            self.analysis.set_target(target_name=target)

        rebuild_required = (
            bool(self.Current_variation["force_gen_bitstream"])
            or self._get_build_config_out_of_date()
            or self.Utils.VariationValueChanged("active_target")
        )

        fpga_target = target in self.analysis.fpga_targets
        cpu_target = target in self.analysis.cpu_targets

        if rebuild_required:
            self._log.info("Generating functional models")
            self.analysis.gen_sources()  # generate functional models

        if fpga_target and not cpu_target:
            if rebuild_required:
                self._log.info("Building bitstream")
                self.analysis.build()  # generate bitstream for project
            self._log.info("Launching interactive analysis")
            self._ctrlapi = self.analysis.launch(**self._analysis_launch_kwargs)  # start interactive control
        elif cpu_target:
            self._ctrlapi = None
            self._log.info("Launching simulation ...")
            self.analysis.simulate(**self._analysis_simulate_kwargs)
            self._log.info("... simulation done!")
        else:
            msg = f"Unknown active_target {target!r}!"
            raise ValueError(msg)

        yield

        if not self._probed_signals:
            self._log.info("Auto-Probing signals...")
            self.probe_signals()
            self._log.info("...probed:" + "\n  ".join(self._probed_signals.keys()))
        else:
            self._log.info("Skipped Auto-Probing signals")

        self._ctrlapi = None

    @DoE.Iteration(try_first=True)
    def fpga_configure_launch(self):
        """
        This method may be overwritten do specify a custom control sequence for interactive mode on FPGA targets.
        If not overwritten a default sequence will be used (similar to plain/straight-forward simulation)
        that uses the predefined options from the yaml configuration files.
        """
        self._perform_default_interactive_control_sequence()

    def _perform_default_interactive_control_sequence(self):
        if self._ctrlapi is not None:
            self._log.info("Executing default control sequence")
            self.ctrlapi.set_reset(1)  # reset simulation
            if self.analysis.args.stop_time is None:
                decimation_ratio_float = 2
            else:
                decimation_ratio_float = (
                    (self.analysis.args.stop_time - self.analysis.args.start_time) / self.analysis._prj_cfg.cfg.dt
                ) / (self.analysis._prj_cfg.cfg.ila_depth / 2)
            self.ctrlapi.setup_trace_unit(
                trigger_name="time",
                trigger_operator="gt",
                trigger_value=float(self.analysis.args.start_time),
                sample_decimation=int(max(decimation_ratio_float, 2)),
            )  # config & arm trace unit

            self.ctrlapi.set_reset(0)  # start simulation

            self.ctrlapi.wait_on_and_dump_trace()

    @DoE.Teardown(is_hook_wrapper=True, try_first=True)
    def fpga_teardown(self):
        """
        This method must not be overwritten and will be executed prior to user-specified "Teardown" stages.
        """
        yield
        self._ctrlapi = None
        self._analysis = None

    @DoE.Error(is_hook_wrapper=True, try_first=True)
    def fpga_error(self):
        """
        This method must not be overwritten and will be executed prior to user-specified "Error" stages.
        """
        yield
        self._ctrlapi = None
        self._analysis = None

    @property
    def analysis(self) -> Analysis:
        """
        Returns the Analysis instance that was automatically created during Startup phase.
        """
        return self._analysis

    @property
    def ctrlapi(self) -> Optional[CtrlApi]:
        """
        Returns the CtrlApi instance that was automatically created during Iteration phase.
        This will return None for simulations/CPU targets which don't provide an interactive mode.
        """
        return self._ctrlapi

    def get_signal(self, name: str):
        """
        Return a signal as PyVerify Waveform. The waveform may contain NaN values for time stamps where the
        simulation/emulation failed probing.

        :raises Exception: If no signal with that name is available
        """
        if name in self._probed_signals:
            return Waveform(data=self._probed_signals[name][1], time=self._probed_signals[name][0]).convert_nan()
        msg = f"No signal named {name!r} available. Make sure it exists and that signals were probed!"
        raise Exception(msg)

    def probe_signals(self):
        """
        Probes all signals from VCD file and cache them for further usage.
        If this function is not called by user code after simulation/emulation, it is automatically invoked,
        to ensure that subsequent calls to "get_signal" work.
        """
        signal_names = self.analysis.probes()
        signals = {}
        for signal in signal_names:
            name = signal.split(".")[-1]
            raw = self.analysis.preserve(self.analysis.probe(name=signal, emu_time=True))
            signals[name + "_raw"] = raw
            signals[name] = np.array(np.where((raw == "x") | (raw == "z"), np.nan, raw), dtype="float")
        self._probed_signals = signals
        return self._probed_signals

    def configure_anasymod_analysis(self, **kwargs):
        """
        Configures the keyword arguments for the Analysis constructor.

        For more information please refer to the official ANASYEMU docs in Inicio.

        Make sure to provide the "input" keyword, this will act as the root directory and is required. If not given,
        the current working directory is used.

        :keyword input: Path to project root directory of the project that shall be opened and worked with.
        :keyword build_root: Path to project specific build root directory.
        :keyword simulator_name: Simulator that shall be used for logic simulation. default=icarus for windows,
                                 xrun for linux
        :keyword synthesizer_name: Synthesis engine that shall be used for FPGA synthesis. default=vivado
        :keyword viewer_name: Waveform viewer that shall be used for viewing result waveforms.
                              default=gtkwave for windows, simvision for linux
        :keyword preprocess_only: For icarus only, this will nur run the simulation, but only compile the netlist.
        :keyword active_target: Mode that shall be actively used. default='sim'
        :keyword build_firmware: When MetaX plugin defined. Only build the firmware for the active target.
                                 Hardware is only generated if the output directory of the hardware generator
                                 is not existing.
        """
        self._analysis_kwargs.update(kwargs)

    def configure_analysis_launch(self, **kwargs):
        """
        Configures the keyword arguments for the Analysis.launch method.

        Analysis.launch is used for all FPGA targets defined in the project configuration yaml file.

        It programs the bitstream to FPGA, sets up control infrastructure and waits for interactive commands.

        :keyword server_addr: (str) Address of Vivado hardware server used for communication to FPGA board
        :keyword debug: (bool) Enable or disable debug mode when running an interactive simulation
        """
        self._analysis_launch_kwargs.update(kwargs)

    def configure_analysis_simulate(self, **kwargs):
        """
        Configures the keyword arguments for the Analysis.simulate method.

        Analysis.simulate is used for all CPU targets defined in the project configuration yaml file.

        :keyword unit: name of the camino unit where the simulation may be hosted in (this is only relevant for xcelium)
        :keyword id: simulation id where simulation may be conducted (this is only relevant for xcelium)
        """
        self._analysis_simulate_kwargs.update(kwargs)

    def _get_build_config_out_of_date(self) -> bool:
        """
        Checks all yaml files and source files relevant for bitstream generation for their modified date to determine
        if they have been changed wrt. to the last test iteration.
        """
        assert self._proj_root is not None
        outofdate = False

        content = self._analysis.get_source_files()
        files = []

        # those are the source types, which are relevant for bitstream generation
        observed_source_types = [
            "verilog_sources",
            "verilog_headers",
            "vhdl_sources",
            "tcl_files",
            "bd_files",
            "edif_files",
            "functional_models",
            "include_dirs",
            "ip_repos",
            "metartlspecs",
            "xci_files",
            "xdc_files",
        ]

        # add all source files where a change could cause the bitstream to be out of date
        for source_type in observed_source_types:
            for source in getattr(content, source_type):
                files += source.files

        files += self._proj_root.rglob("*.yaml")
        for file in files:
            file = str(file.absolute()) if isinstance(file, Path) else str(file)  # noqa: PLW2901
            old_hash = self._filewatcher_cache.get(file, "")
            with open(file, "rb") as f:
                new_hash = hashlib.sha1(f.read()).hexdigest()

            if old_hash != new_hash:
                outofdate = True
            self._filewatcher_cache[file] = new_hash

        self._log.info("Build configuration is out of date. A rebuild is required.")
        return outofdate
