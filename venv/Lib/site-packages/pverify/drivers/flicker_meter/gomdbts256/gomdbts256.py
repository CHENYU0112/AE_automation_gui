from __future__ import annotations

import os
from pathlib import Path

from cffi import FFI

from pverify.core.lab.driver_identity import IdentityBasic

src_path = str((Path(__file__).parent / "src").resolve())
if src_path not in os.environ["PATH"]:
    os.environ["PATH"] += ";" + src_path

error_codes = {
    -5000: "general communication problem",
    -5001: "setup file not valid for BTS256",
    -5002: "setup file could not be opened",
    -5003: "config file not found",
    -5004: "az mode out of range (0 - 2 allowed)",
    -5005: "communication channel can not be opened",
    -5006: "firmwareversion to low",
    -5007: "communication send problem",
    -5008: "communication receive problem",
    -5009: "device returned error",
    -5010: "delta uv limit < 0",
    -5014: "error main data eeprom",
    -5015: "error color data eeprom",
    -5017: "error zero adjust integral amplifier",
    -5020: "error dark current measurement",
    -5023: "error BTS256 overload",
    -5024: "error user data eeprom",
    -5060: "wrong password",
    -5997: "no BTS256 connected",
    -5998: "device connected with different serial number",
    -5999: "unknown error",
    -5103: "wrong device type",
    -5105: "invalid handle. Execute connect(deviceName) method before!",
    # Warnings
    5011: "underload integral sensor",
    5012: "overload integral sensor",
    5025: "warning BTS256 low signal",
    5075: "a(Z) mode changed",
}


class GOmdbts256Error(Exception):
    def __init__(self, code):
        super().__init__(error_codes.get(code, f"unknown error code {code}"))

    @staticmethod
    def check(code):
        if code in error_codes:  #
            # print("Error code: ", code, "-->", error_codes.get(code))
            raise GOmdbts256Error(code)


class GOmdbts256:
    def __init__(self, password="Gvmjs=R2"):
        """
        Constructor

        :param password: The device password. Default password is for device of Peter Friesinger.
        """
        from .gomdbts256_cffi import ffi

        self._ffi = ffi
        self._dll = self._ffi.dlopen(str(Path(__file__).parent / "src" / "GOMDBTS256.dll"))
        self._handle = 0
        self.setPassword(password)

        self.__Initialized = False
        self.__Identity = IdentityBasic(fct_idn=self.__idn, fct_drv_rev=self.__drv_rev, fct_fw_rev=self.__fw_rev)

    def __idn(self):
        """
        Returns an identification string of the instrument
        """
        if self.Initialized:
            return self.getSerialNumber()
        else:
            return ""

    def __drv_rev(self):
        """
        Returns the driver version
        """
        return self.getDLLVersion()

    def __fw_rev(self):
        """
        Returns the FW revision of the instrument
        """
        if self.Initialized:
            return str(self.getFirmwareVersion())
        else:
            return ""

    @property
    def Initialized(self):
        """
        Shows if the instrument connection has been established
        """
        return self.isConnected()

    @property
    def Identity(self):
        """
        A pointer to the Identity interface
        """
        return self.__Identity

    def Initialize(self, ResourceName: str, *args, **kwargs):
        """
        Opens the I/O session to the instrument. Driver methods and properties
        that access the instrument are only accessible after Initialize is
        called. Initialize optionally performs a Reset and queries the
        instrument to validate the instrument model.

        :param ResourceName: string value which identifies the BTS256 device consisting of „BTS256_“ and the serial number of the device.
        „BTS256_0“ will initialize any connected BTS256 device.
        """
        self.connect(ResourceName)

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and
        properties that access the instrument are not accessible after Close
        is called.
        """
        if self.Initialized:
            self.disconnect()

    def setPassword(self, password: str):
        """
        int GOMDBTS256_setPassword(char* value);

        :param: the password of the SDK
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_setPassword(str(password).encode()))

    def connect(self, deviceName: str):
        """
        int GOMDBTS256_getHandle(char* device, int* handle);

        This method you have to call initially. You will receive an identifier, which you have to use in any further method call.

        :param deviceName: string value which identifies the BTS256 device consisting of „BTS256_“ and the serial number of the device.
        „BTS256_0“ will initialize any connected BTS256 device.
        """
        handle = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getHandle(str(deviceName).encode(), handle))
        self._handle = handle[0]

    def disconnect(self):
        """
        int GOMDBTS256_releaseHandle(int handle);

        This method has to be called at the end of your application to free all resources
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_releaseHandle(self._handle))
        self._handle = 0

    def isConnected(self) -> bool:
        """
        int GOMDBTS256_isConnected(int handle, bool* isConnected);

        This method checks if the device is still connected to the PC or has been disconnected

        :return: returns the connection status as a boolean value
        """
        isConnected = self._ffi.new("bool*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_isConnected(self._handle, isConnected))
        return bool(isConnected[0])

    def getDLLVersion(self) -> str:
        """
        int GOMDBTS256_getDLLVersion(char* value);

        Returns the version number of this DLL.

        :return: DLL version number
        """
        version = self._ffi.new("char[10]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getDLLVersion(version))
        return self._ffi.string(version).decode()

    def getTemperature(self) -> float:
        """
        int GOMDBTS256_getTemperature(int handle, double* value);

        This method returns the temperature of the internal temperature sensor in [°C].

        :return: temperature
        """
        temp = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getTemperature(self._handle, temp))
        return float(temp[0])

    def getFirmwareVersion(self) -> str:
        """
        int GOMDBTS256_getFirmwareVersion(int handle, char* value);

        Returns the firmware version of the connected BTS256.

        :return: firmware version of the connected BTS256
        """
        version = self._ffi.new("char[10]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getFirmwareVersion(self._handle, version))
        return self._ffi.string(version).decode()

    def getSerialNumber(self) -> str:
        """
        int GOMDBTS256_getSerialNumber(int handle, char* value);

        Returns the serial number of the connected BTS256.

        :return: serial number of the connected BTS256
        """
        value = self._ffi.new("char[10]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getSerialNumber(self._handle, value))
        return self._ffi.string(value).decode()

    def getType(self) -> str:
        """
        int GOMDBTS256_getType(int handle, char* value);

        Returns the device type of the connected BTS256.

        :return: type of the connected BTS256, e.g. "BTS256-EF"
        """
        value = self._ffi.new("char[30]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getType(self._handle, value))
        return self._ffi.string(value).decode()

    def switchLight(self, enabled: bool):
        """
        int GOMDBTS256_switchLight(int handle, bool value);

        Switches display light on/ off.

        :param enabled: light is turned on if set to True
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_switchLight(self._handle, bool(enabled)))

    def disableButtons(self, diabled: bool):
        """
        int GOMDBTS256_disableButtons(int handle, bool value);

        This method disables / enables the device buttons.

        :param diabled: disble buttons if set to True
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_disableButtons(self._handle, bool(diabled)))

    def loadConfig(self, filename: str):
        """
        int GOMDBTS256_loadConfig(int handle, char* filename);

        This method loads all previously set and saved values from the specified file (see the method saveConfig). If the
        configuration file does not belong to a BTS256 but rather to a different device, an error code is returned.

        :param filename: path to the configuration file
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_loadConfig(self._handle, str(filename).encode()))

    def saveConfig(self, filename: str):
        """
        int GOMDBTS256_saveConfig(int handle, char* filename);

        The currently set parameters are saved in a configuration file for later use. The values can be loaded using “loadConfig”.

        :param filename: path to the configuration file
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_saveConfig(self._handle, str(filename).encode()))

    def saveConfigAsDefault(self):
        """
        int GOMDBTS256_saveConfigAsDefault(int handle);

        The currently set parameters are saved in a configuration file for later use and are reloaded upon re-initialization of
        the BTS256.
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_saveConfigAsDefault(self._handle))

    def readCalibrationEntryInfo(self):
        """
        int GOMDBTS256_readCalibrationEntryInfo(int handle, int calibrationEntryNumber, char* calibrationName);

        Returns the name of the specified calibration entries. The calibration name is also defined in the device configuration file
        BTS256_<serialnumber>.goi, which is delivered with your system.

        :return: calibrationEntryNumber: Number of the selected calibration entry.
                                         0-9: factory calibration;
                                         10-19: user specific calibration
        """
        calibrationName = self._ffi.new("char[100]", b"")
        print("Available calibration entries: ")
        for n in range(52):
            try:
                GOmdbts256Error.check(self._dll.GOMDBTS256_readCalibrationEntryInfo(self._handle, n, calibrationName))
                if calibrationName != "\0":
                    print("Calibration Nr. %d -->" % n, self._ffi.string(calibrationName).decode())
            except GOmdbts256Error:
                pass

    def setCalibrationEntryNumber(self, calibrationEntryNumber: int):
        """
        int GOMDBTS256_setCalibrationEntryNumber(int handle, int calibrationEntryNumber);

        Your device is delivered with one or more calibrations. These are ideal for different measurement scenarios. This
        method enables you to select calibrations saved in EEPROM. A total of 20 calibration entries exist and not all
        have to be filled. To find all valid calibrations, the method 'readCalibrationEntryInfo' can be used. If a non-existent
        calibration index is selected, the method returns an error code.

        :param calibrationEntryNumber: Number of the calibration entry to load.
                                       0-9: factory calibration;
                                       10-19: user specific calibration
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_setCalibrationEntryNumber(self._handle, int(calibrationEntryNumber)))

    def getSelectedCalibrationEntryNumber(self) -> int:
        """
        int GOMDBTS256_getSelectedCalibrationEntryNumber(int handle, int* calibrationEntryNumber);

        Returns actual selected calibration entry number.

        :return: Number of the selected calibration entry.
                 0-9: factory calibration;
                 10-19: user specific calibration
        """
        calibrationEntryNumber = self._ffi.new("int*")
        GOmdbts256Error.check(
            self._dll.GOMDBTS256_getSelectedCalibrationEntryNumber(self._handle, calibrationEntryNumber)
        )
        return int(calibrationEntryNumber[0])

    def getMeasurementQuantity(self, calibrationEntryNumber: int) -> str:
        """
        int GOMDBTS256_getMeasurementQuantity(int handle, int calibrationEntry, char *quantity);

        Returns the quantity for the specified calibration entry number. Possible return values are “E”, “I” or “Phi”.

        :param calibrationEntryNumber: Number of the selected calibration entry.
                                       0-9: factory calibration
                                       10-19: user specific calibration
                                       Valid calibration entries can be obtained by the method 'readCalibrationEntryInfo'.
        :return: measurement quantity “E”, “I” or “Phi”
        """
        quantitiy = self._ffi.new("char[10]", b"")
        GOmdbts256Error.check(
            self._dll.GOMDBTS256_getMeasurementQuantity(self._handle, int(calibrationEntryNumber), quantitiy)
        )
        return self._ffi.string(quantitiy).decode()

    def getSelectedMeasurementQuantity(self) -> str:
        """
        int GOMDBTS256_getSelectedMeasurementQuantity(int handle, char *quantity);

        Returns the quantity of the actual selected calibration entry. Possible values are “E”, “I” or “Phi”.

        :return: measurement quantity “E”, “I” or “Phi”
        """
        quantitiy = self._ffi.new("char[10]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getSelectedMeasurementQuantity(self._handle, quantitiy))
        return self._ffi.string(quantitiy).decode()

    def isMeasurementQuantity(self, calibrationEntryNumber: int, quantity: str) -> bool:
        """
        int GOMDBTS256_isMeasurementQuantity(int handle, int calibrationEntryNumber, char *quantity, bool* isQuantity);

        Returns if the specified calibration entry is defined for a special quantity “E”, “I”, “Phi”. You can have a look in the
        device configuration file to see the defined calibration entries and their assigned quantities.

        :param calibrationEntryNumber: Number of the selected calibration entry.
                                       0-9: factory calibration;
                                       10-19: user specific calibration.
                                       Valid calibration entries can be obtained by the method 'readCalibrationEntryInfo'.
        :param quantity: the measurmeent quantity: “E”, “I” or “Phi”
        :return: bool value, showing if the selected calibration entry is defined for the given measurement quantity
        """
        isQuantity = self._ffi.new("bool*")
        GOmdbts256Error.check(
            self._dll.GOMDBTS256_isMeasurementQuantity(
                self._handle, int(calibrationEntryNumber), str(quantity).encode(), isQuantity
            )
        )
        return bool(isQuantity[0])

    def setDistance(self, distance: float = 1):
        """
        int GOMDBTS256_setDistance(int handle, double distance);

        If you selected a calibration entry for “Luminous Intensity” or “Radiant Intensity, then you must define the distance
        between your BTS256 measurement device and your “device under test”. Distance unit is [m].

        :param distance: distance between BTS256 and DUT in a "Luminous Intensity" or "Radiant Intensity" measurement (unit: m)
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_setDistance(self._handle, float(distance)))

    def getDistance(self) -> float:
        """
        int GOMDBTS256_getDistance(int handle, double* distance);

        Returns the distance between BTS256 and “device under test” set in method 'setDistance' in [m].

        :return: distance between BTS256 and DUT in a "Luminous Intensity" or "Radiant Intensity" measurement (unit: m)
        """
        distance = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getDistance(self._handle, distance))
        return float(distance[0])

    def setDeltaUVLimit(self, limit: float = 0.05):
        """
        int GOMDBTS256_setDeltaUVLimit(int handle, double limit);

        Defines the limit you want to set for calculation of CCT (correlated color temperature).
        If real values are outside limit, then CCT will not be calculated.

        :param limit: limit for calculation of CCT (correlated color temperature); Default value is 0.05.
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_setDeltaUVLimit(self._handle, float(limit)))

    def getDeltaUVLimit(self) -> float:
        """
        int GOMDBTS256_getDeltaUVLimit(int handle, double* limit);

        Returns the uv limit for calculation of CCT (correlated color temperature) set in method 'setDeltaUVLimit'

        :return: limit for calculation of CCT (correlated color temperature)
        """
        limit = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getDeltaUVLimit(self._handle, limit))
        return float(limit[0])

    def setAreaSize(self, area: float = 1):
        """
        int GOMDBTS256_setAreaSize(int handle, double value);

        --- Method only working with BTS256-HI ---
        If you selected a calibration entry for "Luminance" or "Radiance", then you must define the area size of your "device
        under test". The unit is [m^ 2].

        :param area: area of DUT in a "Luminance" or "Radiance" measurement (unit: m^2)
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_setAreaSize(self._handle, float(area)))

    def getAreaSize(self) -> float:
        """
        int GOMDBTS256_getAreaSize(int handle, double* value);

        --- Method only working with BTS256-HI ---
        Returns the previous set area size of your “device under test” in [m^ 2].

        :return: area of DUT
        """
        area = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getAreaSize(self._handle, area))
        return float(area[0])

    def integralSetIntegrationTimeInMs(self, timeInMs: int):
        """
        int GOMDBTS256_integralSetIntegrationTimeInMs(int handle, int timeInMs);

        This sets the integration time in milliseconds of the integral sensor to be measured. Minimum allowed time is 1ms
        and maximum time is 6000ms.

        :param timeInMs: integration time in ms; must be between 1ms and 6000ms
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralSetIntegrationTimeInMs(self._handle, int(timeInMs)))

    def integralGetIntegrationTimeInMs(self) -> int:
        """
        int GOMDBTS256_integralGetIntegrationTimeInMs(int handle, int* timeInMs);

        This method returns the integration time for the integral sensor in milliseconds.

        :return: integration time for the integral sensor in ms
        """
        timeInMs = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralGetIntegrationTimeInMs(self._handle, timeInMs))
        return int(timeInMs[0])

    def spectralSetIntegrationTimeInMs(self, timeInMs: int):
        """
        int GOMDBTS256_spectralSetIntegrationTimeInMs(int handle, int timeInMs);

        Defines the integration time in milliseconds, which will be used for spectral measurement. If set to “0” then BTS256
        device will calculate the best possible integration time dependent from your signal.

        :param timeInMs: integration time in ms
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralSetIntegrationTimeInMs(self._handle, int(timeInMs)))

    def spectralGetIntegrationTimeInMs(self) -> int:
        """
        int GOMDBTS256_spectralGetIntegrationTimeInMs(int handle, int* timeInMs);

        Returns the real integration time in milliseconds used for your spectral device during last measurement.

        :return: integration time in ms
        """
        timeInMs = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralGetIntegrationTimeInMs(self._handle, timeInMs))
        return int(timeInMs[0])

    def spectralEvaluateIntegrationTimeInM(self) -> int:
        """
        int GOMDBTS256_spectralEvaluateIntegrationTimeInMs(int handle, int* timeInMs);

        Performs a short measurement and returns the integration time that will be used for your spectral device, if dynamic
        evaluation of integration time is switched on (look at method 'spectralSetIntegrationTimeInMs'). If dynamic evaluation of
        integration time is switched off, then your predefined integration time will be returned.

        :return: integration time in ms
        """
        timeInMs = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralEvaluateIntegrationTimeInMs(self._handle, timeInMs))
        return int(timeInMs[0])

    def spectralSetEnabled(self, enabled: bool):
        """
        int GOMDBTS256_spectralSetEnabled(int handle, bool enabled);

        Activates / deactivates array for measurement. If array is deactivated, no a(z) correction factor is calculated. This
        means you should set a static a(z) value for integral correction.

        :param enabled: boolean value to enable / disable the spectral unit
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralSetEnabled(self._handle, bool(enabled)))

    def spectralIsEnabled(self) -> bool:
        """
        int GOMDBTS256_spectralIsEnabled(int handle, bool* enabled);

        Returns, if spectral unit is active or not active for measurements.

        :return: boolean value, staus of spectral unit
        """
        enabled = self._ffi.new("bool*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralIsEnabled(self._handle, enabled))
        return bool(enabled[0])

    def integralSetEnabled(self, enabled: bool):
        """
        int GOMDBTS256_integralSetEnabled(int handle, bool enabled);

        This activates/deactivates integral sensor for measurement. If deactivated, integral sensor won't be measured.

        :param enabled: boolean value to enable / disable the integral sensor
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralSetEnabled(self._handle, bool(enabled)))

    def integralIsEnabled(self) -> bool:
        """
        int GOMDBTS256_integralIsEnabled(int handle, bool* enabled);

        Checks if integral sensor is activated for measurement.

        :return: boolean value, staus of integral sensor
        """
        enabled = self._ffi.new("bool*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralIsEnabled(self._handle, enabled))
        return bool(enabled[0])

    def measure(self):
        """
        int GOMDBTS256_measure(int handle);

        Performs measurement with previous set configuration settings.
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_measure(self._handle))

    def getCWValue(self) -> float:
        """
        int GOMDBTS256_getCWValue(int handle, double* value);

        Returns calculated (calibration value, correction, ...) measurement value of integral device.

        :return: calculated measurement value of integral device
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getCWValue(self._handle, value))
        return float(value[0])

    def integralGetUnit(self, calibrationEntryNumber: int) -> str:
        """
        int GOMDBTS256_integralGetUnit(int handle, int calibrationEntryNumber, char* unit);

        Returns the unit, valid for integral measurements with a specified calibration entry.

        :param calibrationEntryNumber: Number of the calibration entry.
                                       0-9: factory calibration;
                                       10-19: user specific calibration
        :return: unit for integral measurements
        """
        unit = self._ffi.new("char[20]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralGetUnit(self._handle, int(calibrationEntryNumber), unit))
        return self._ffi.string(unit).decode()

    def spectralGetUnit(self, calibrationEntryNumber: int) -> str:
        """
        int GOMDBTS256_spectralGetUnit(int handle, int calibrationEntryNumber, char* unit);

        Returns the unit, valid for spectral measurements with a specified calibration entry.

        :param calibrationEntryNumber: Number of the calibration entry.
                                       0-9: factory calibration;
                                       10-19: user specific calibration
        :return: unit for spectral measurements
        """
        unit = self._ffi.new("char[20]", b"")
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralGetUnit(self._handle, int(calibrationEntryNumber), unit))
        return self._ffi.string(unit).decode()

    def spectralMeasureDarkOffset(self):
        """
        int GOMDBTS256_spectralMeasureDarkOffset(int handle, int value);

        This method is used to measure the dark offset. The shutter will be closed and the currently set integration time is used hereby.
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralMeasureDarkOffset(self._handle))  #

    def spectralDeleteDarkOffset(self):
        """
        int GOMDBTS256_spectralDeleteDarkOffset(int handle, int value);

        This method is used to delete the last measured dark offset.
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralDeleteDarkOffset(self._handle))

    def switchPowerAuxLED(self, powerOn: bool, current: int = 25):
        """
        int GOMDBTS256_switchPowerAuxLED(int handle, bool powerOn, int current);

        Switches internal auxiliary lamp on/off, which is needed when substitution correction measurements should be
        performed for the internal sphere of the device. When using an external sphere you have to switch on the auxiliary
        with the corresponding commands of the SDK for your power supply.

        Normally you don't need to use this method, because the LED will be switched on/off automatically when calling
        “substitutionMeasurementWithoutTestDevice” or “substitutionMeasurementWithTestDevice”

        :param powerOn: boolean value, True to switch On, False to switch Off
        :param current: The current in mA
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_switchPowerAuxLED(self._handle, bool(powerOn), int(current)))

    def setWavelengthRange(self, L1: float = 380, L2: float = 750, dL: float = 1):
        """
        int GOMDBTS256_setWavelengthRange(int handle, double L1, double L2, double dL);

        Defines the limiting factor used when “spectralGetCountsWavelength” or “spectralGetSpectrumCalibratedWavelength” is called.

        :param L1: minimum wavelenght in nm
                   min. possible value is 380 nm
        :param L2: maximum wavelength in nm
                   max. possible value is 750 nm
        :param dL: stepwidth in nm
                   value free of choice
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_setWavelengthRange(self._handle, float(L1), float(L2), float(dL)))

    def getWavelengthRange(self) -> dict:
        """
        int GOMDBTS256_getWavelengthRange(int handle, double* L1, double* L2, double* dL);

        Returns the wavelength range defined in "setWavelengthRange", which will be used when “spectralGetCountsWavelength” or
        “spectralGetSpectrumCalibratedWavelength” is called.

        :return: dictionary containing:
                 L1: minimum wavelenght in nm;
                 L2: maximum wavelength in nm;
                 dL: stepwidth in nm
        """
        types = ["L1", "L2", "dL"]
        L1 = self._ffi.new("double*")
        L2 = self._ffi.new("double*")
        dL = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getWavelengthRange(self._handle, L1, L2, dL))
        return dict(zip(types, [float(L1[0]), float(L2[0]), float(dL[0])]))

    def spectralGetSpecmax(self) -> int:
        """
        int GOMDBTS256_spectralGetSpecmax(int handle, int* value);

        Returns the number of values you get with “spectralGetCountsWavelength” or “spectralGetSpectrumCalibratedWavelength”
        The number of values depend on the wavelength range, you can set with “setWavelengthRange” and it is calculated with the formula:
        [(lastWavelength - firstWavelength) ÷ stepwidth] + 1

        :return: number of values
        """
        value = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralGetSpecmax(self._handle, value))
        return int(value[0])

    def spectralGetSpectrumCalibratedWavelength(self, maxElements: int) -> list:
        """
        int GOMDBTS256_spectralGetSpectrumCalibratedWavelength(int handle, double* spectrum);

        Returns the calculated values with calibration factors, substitution factor, and so on of your spectral unit. Number of
        values should be evaluated with “spectralGetSpecmax”

        1st element contains value for first wavelength interpolation point + 0 stepwidth
        2nd element contains value for first wavelength interpolation point + 1 stepwidth
        The wavelength interpolation points are defined by call of “setWavelengthRange”, where you can define the
        minimum wavelength, the maximum wavelength and the stepwidth.

        :param maxElements: will be obtained by function "spectralGetSpecmax"
        :return spectrum values
        """
        counts = self._ffi.new("double[%d]" % int(maxElements))
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralGetSpectrumCalibratedWavelength(self._handle, counts))
        return list(counts)

    def spectralGetCountsPixel(self) -> list:
        """
        int GOMDBTS256_spectralGetCountsPixel(int handle, double* counts);

        Returns the raw signal values of your spectral unit based on the single pixels of the devices.

        1st element contains counts for first pixel
        2nd element contains counts for second pixel

        :return: pixels of raw signal values of spectral unit
        """
        counts = self._ffi.new("double[256]")
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralGetCountsPixel(self._handle, counts))
        return list(counts)

    def spectralGetCountsWavelength(self, maxElements: int) -> list:
        """
        int GOMDBTS256_spectralGetCountsWavelength(int handle, double* counts);

        Returns the raw signal of your spectral unit. Number of values should be evaluated with “spectralGetSpecmax”, that
        preallocated array is big enough to hold all expected values. Labview users don't have to care about the number of
        values here.

        1st element contains counts for first wavelength interpolation point + 0 stepwidth
        2nd element contains counts for first wavelength interpolation point + 1 stepwidth
        The wavelength interpolation points are defined by call of “setWavelengthRange”, where you can define the minimum
        wavelength, the maximum wavelength and the stepwidth.

        :param maxElements: will be obtained by function "spectralGetSpecmax"
        :return: number of counts of the spectrum
        """
        counts = self._ffi.new("double[%d]" % int(maxElements))
        GOmdbts256Error.check(self._dll.GOMDBTS256_spectralGetCountsWavelength(self._handle, counts))
        return list(counts)

    def getColor(self) -> dict:
        """
        int GOMDBTS256_getColor(int handle, double* UpperX, double* UpperY, double* UpperZ, double* x, double* y, double* us, double* vs,
                                double* CCT, double* domWL);

        Returns all color informations for last measurement.

        :return: dictionary containing color information for last measurement
        """
        types = ["UpperX", "UpperY", "UpperZ", "x", "y", "us", "vs", "CCT", "domWL"]
        UpperX = self._ffi.new("double*")
        UpperY = self._ffi.new("double*")
        UpperZ = self._ffi.new("double*")
        x = self._ffi.new("double*")
        y = self._ffi.new("double*")
        us = self._ffi.new("double*")
        vs = self._ffi.new("double*")
        CCT = self._ffi.new("double*")
        domWL = self._ffi.new("double*")
        GOmdbts256Error.check(
            self._dll.GOMDBTS256_getColor(self._handle, UpperX, UpperY, UpperZ, x, y, us, vs, CCT, domWL)
        )
        return dict(
            zip(
                types,
                [
                    float(UpperX[0]),
                    float(UpperY[0]),
                    float(UpperZ[0]),
                    float(x[0]),
                    float(y[0]),
                    float(us[0]),
                    float(vs[0]),
                    float(CCT[0]),
                    float(domWL[0]),
                ],
            )
        )

    def getPeak(self) -> dict:
        """
        int GOMDBTS256_getPeak(int handle, double *lambda, double *power);

        Returns the peak value of the spectrum. It returns the power and the wavelength [nm], where the peak was detected.
        The unit of the power depends on the selected calibration entry and will be returned by call of “spectralGetUnit”.

        :return: dictionary containing wavelength and power of the peak of the spectrum
        """
        types = ["wavelength", "power"]
        wavelength = self._ffi.new("double*")
        power = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getPeak(self._handle, wavelength, power))
        return dict(zip(types, [float(wavelength[0]), float(power[0])]))

    def getFWHM(self) -> float:
        """
        int GOMDBTS256_getFWHM(int handle, double* value);

        Returns the FWHM (full width at half maximum) value.

        :return: full width at half maximum value
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getFWHM(self._handle, value))
        return float(value[0])

    def getCenterWavelength(self) -> float:
        """
        int GOMDBTS256_getCenterWavelength(int handle, double* value);

        Returns the center wavelength in [nm].

        :return: center wavelength in nm
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getCenterWavelength(self._handle, value))
        return float(value[0])

    def getCentroidWavelength(self) -> float:
        """
        int GOMDBTS256_getCentroidWavelength(int handle, double* value);

        Returns the centroid wavelength in [nm].

        :return: centroid wavelength in nm
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getCentroidWavelength(self._handle, value))
        return float(value[0])

    def getScotopic(self) -> float:
        """
        int GOMDBTS256_getScotopic(int handle, double* value);

        Returns the scotopic value in [lx].

        :return: scotopic value in lx
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getScotopic(self._handle, value))
        return float(value[0])

    def getScotopicPhotopic(self) -> float:
        """
        int GOMDBTS256_getScotopicPhotopic(int handle, double* value);

        Returns the ratio between scotopic and photopic value in [lx].

        :return: ratio between scotopic and photopic value in lx
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getScotopicPhotopic(self._handle, value))
        return value[0]

    def getEVE(self) -> float:
        """
        int GOMDBTS256_getEVE(int handle, double* value);

        Returns the EVE value, only valid for measurements with BTS256-E:

        :return: EVE value
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getEVE(self._handle, value))
        return float(value[0])

    def getFlicker(self) -> dict:
        """
        int GOMDBTS256_getFlicker(int handle, double* Emax, double* Emin, double* percent, double* index, double* frequency);

        Returns the flicker values, only valid for measurements with BTS256-EF

        :return: dictionary containing:
                 Emax: maximum measured intensity during integral measurement;
                 Emin: minimum measured intensity during integral measurement;
                 percent: the flicker percentage value 100% * (Emax - Emin) / (Emax + Emin);
                 index: the flicker index;
                 frequency: the flicker frequency
        """
        types = ["Emax", "Emin", "percent", "index", "frequency"]
        Emax = self._ffi.new("double*")
        Emin = self._ffi.new("double*")
        percent = self._ffi.new("double*")
        index = self._ffi.new("double*")
        frequency = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getFlicker(self._handle, Emax, Emin, percent, index, frequency))
        return dict(
            zip(types, [float(Emax[0]), float(Emin[0]), float(percent[0]), float(index[0]), float(frequency[0])])
        )

    def getFFT(self) -> dict:
        """
        int GOMDBTS256_getFFT(int handle, double* frequencies, double* percentages, double* resolution, double* frequencyMax);

        Besides calculation of the flicker parameters, the BTS256-EF also performs an internal FFT (Fast Fourier Transformation).
        This makes it possible to detect other frequency components in the signal. This method is valid only for
        measurements with BTS256-EF.

        :return: dictionary containing:
                 frequencies: frequency components which are part of the signal;
                 percentages: percentage values corresponding to the frequencies;
                 resolution: FFT resolution;
                 frequencyMax: maximum frequency;
        """
        types = ["frequencies", "percentages", "resolution", "frequencyMax"]
        frequencies = self._ffi.new("double[6]")
        percentages = self._ffi.new("double[6]")
        resolution = self._ffi.new("double*")
        frequencyMax = self._ffi.new("double*")
        GOmdbts256Error.check(
            self._dll.GOMDBTS256_getFFT(self._handle, frequencies, percentages, resolution, frequencyMax)
        )
        return dict(zip(types, [list(frequencies), list(percentages), float(resolution[0]), float(frequencyMax[0])]))

    def measureTLA(self, tactNumber: int, durationInMs: float):
        """
        int GOMDBTS256_measureTLA(int handle, int tactNumber, double durationInMs);

        Performs a TLA(temporal light artefacts) measurement. With this method the time behaviour of a light source can
        be measured. It first performs a spectral measurement with previous set configuration. Then the diode records the
        progression of the light signal with the parameters given with the function call.
        This method should be used, to record and calculate TLA values, especially PST, SVM and Assists Mp. After the
        measurement, the values can be collected with the method "getTLA"

        :param tactNumber: defines the sampling frequency
                           -9: 40kHz;
                           -3: 200kHz;
                           -2: 100kHz;
                           0: 25kHz;
                           1: 10kHz;
                           2: 5kHz;
                           3: 2kHz;
                           4: 1kHz;
        :param durationInMs: duration of the measurement in ms
        """
        GOmdbts256Error.check(self._dll.GOMDBTS256_measureTLA(self._handle, int(tactNumber), float(durationInMs)))

    def dequeueTLA(self, nrOfValues: int) -> dict:
        """
        int GOMDBTS256_dequeueTLA(int handle, int* nrOfValues, double* integralProgressionValues);

        This method is used to collect the progressions values of the TLA measurement while the measurement is performed.
        Call this method in a loop to get the whole signal of the light source. With this method each value can be
        collected only once.

        :param nrOfValues: the number of progression values to be returned
        :return: dictionary containing:
                 nrOfValues: the number of values that have actually been collected;
                 integralProgressionValues: progression results
        """
        types = ["nrOfValues", "integralProgressionValues"]
        integralProgressionValues = self._ffi.new("double[%d]" % int(nrOfValues))
        nrOfValues = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_dequeueTLA(self._handle, nrOfValues, integralProgressionValues))
        return dict(zip(types, [int(nrOfValues), list(integralProgressionValues)]))

    def getTLA(self) -> dict:
        """
        int GOMDBTS256_getTLA(int handle, double* PST, double* SVM);

        With the internal FFT (Fast Fourier Transformation) some additional TLA values (Temporal Light Artefacts) are
        calculated. P_ST and SVM can be collected with this method. Attention the calculation of the PST can be very
        memory consuming. Make sure enough RAM is available. (e.g calculation of PST for a TLA measurement with
        40kHz tact and 180s duration needs about 1GB of RAM)

        :return: dictionary containing:
                 PST: P_ST as defined in CIE TN 006:2016;
                 SVM: SVM as defined in IEC/TR 61547-1:2015
        """
        types = ["PST", "SVM"]
        PST = self._ffi.new("double*")
        SVM = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getTLA(self._handle, PST, SVM))
        return dict(zip(types, [float(PST[0]), float(SVM[0])]))

    def getJA10(self) -> dict:
        """
        int GOMDBTS256_getJA10(int handle, double* values);

        This methods collects the JA10 (standard by the California Energy Commission) values from the device.

        :return: JA10 values
        """
        frequencies = ["unfiltered", "1000Hz", "400Hz", "200Hz", "90Hz", "40Hz"]
        values = self._ffi.new("double[6]")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getJA10(self._handle, values))
        return dict(zip(frequencies, list(values)))

    def getAssistFlickerPerception(self) -> float:
        """
        int GOMDBTS256_getAssistFlickerPerception(int handle, double* Mp);

        With the internal FFT (Fast Fourier Transformation) some additional flicker values are calculated. The Flicker Perception
        Mp (recommended by ASSIST) can be collected with this method

        :return: Mp: Assist Flicker Percepction
        """
        Mp = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getAssistFlickerPerception(self._handle, Mp))
        return float(Mp[0])

    def getDeltaUV(self) -> float:
        """
        int GOMDBTS256_getDeltaUV(int handle, double* uv);

        Returns the real delta uv value of your last measurement.

        :return: uv: delta uv value for the last measurement
        """
        uv = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getDeltaUV(self._handle, uv))
        return float(uv[0])

    def getRadiometricValueOverWLRange(self) -> float:
        """
        int GOMDBTS256_getRadiometricValueOverWLRange(int handle, double* value);

        Returns the integral value over the wavelength range for your spectral measurement. The wavelength range must
        be defined with “setWavelengthRange”.

        :return: radiometric value over wavelenght range
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getRadiometricValueOverWLRange(self._handle, value))
        return float(value[0])

    def getCRI2(self) -> dict:
        """
        int GOMDBTS256_getCRI2(int handle, double* Ra, double* R1, double* R2, double* R3, double* R4, double* R5, double* R6, double* R7,
                                double* R8, double* R9, double* R10, double* R11, double* R12, double* R13, double* R14, double* R15);

        Color Rendering Index (CRI) (sometimes called color rendition index), is a quantitative measure of the ability of a
        light source to reproduce the colors of various objects faithfully in comparison with an ideal or natural light source.
        Light sources with a high CRI are desirable in color-critical applications such as photography and cinematography.
        It is defined by the International Commission on Illumination as follows:
        Color rendering: Effect of an illuminant on the color appearance of objects by conscious or subconscious comparison
        with their color appearance under a reference illuminant.
        This method needs firmware version >= 0.48.

        :return: dictionary containing:
                 Ra: average value of R1-R8
                 R1-R15: Color Rendering Index
        """
        types = ["Ra", "R1", "R2", "R3", "R4", "R5", "R6", "R7", "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"]
        Ra = self._ffi.new("double*")
        R1 = self._ffi.new("double*")
        R2 = self._ffi.new("double*")
        R3 = self._ffi.new("double*")
        R4 = self._ffi.new("double*")
        R5 = self._ffi.new("double*")
        R6 = self._ffi.new("double*")
        R7 = self._ffi.new("double*")
        R8 = self._ffi.new("double*")
        R9 = self._ffi.new("double*")
        R10 = self._ffi.new("double*")
        R11 = self._ffi.new("double*")
        R12 = self._ffi.new("double*")
        R13 = self._ffi.new("double*")
        R14 = self._ffi.new("double*")
        R15 = self._ffi.new("double*")
        GOmdbts256Error.check(
            self._dll.GOMDBTS256_getCRI2(
                self._handle, Ra, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15
            )
        )
        return dict(
            zip(
                types,
                [
                    float(Ra[0]),
                    float(R1[0]),
                    float(R2[0]),
                    float(R3[0]),
                    float(R4[0]),
                    float(R5[0]),
                    float(R6[0]),
                    float(R7[0]),
                    float(R8[0]),
                    float(R9[0]),
                    float(R10[0]),
                    float(R11[0]),
                    float(R12[0]),
                    float(R13[0]),
                    float(R14[0]),
                    float(R15[0]),
                ],
            )
        )

    def integralProgressionGetNrOfValues(self) -> int:
        """
        int GOMDBTS256_integralProgressionGetNrOfValues(int handle, int* value);

        This method returns the number of values which are stored to show you the chronological sequence of intensity
        values detected during integral measurement for flicker purpose. This value may change for each single measurement
        and depends on the integration time for your integral sensor. This method is valid only for measurements with
        BTS256-EF.

        :return: number of integral progression values
        """
        value = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralProgressionGetNrOfValues(self._handle, value))
        return int(value[0])

    def integralProgressionGetCalibratedValues(self, nrValues: int) -> list:
        """
        int GOMDBTS256_integralProgressionGetCalibratedValues(int handle, double* values);

        This method returns the complete signal progression which shows the chronological sequence of intensity values
        detected during integral measurement for flicker purpose. This method is valid only for measurements with BTS256-EF.

        :param nrValues: number of integral progression values according to method "integralProgressionGetNrOfValues"
        :return: integral progression values
        """
        values = self._ffi.new("double[%d]" % int(nrValues))
        GOmdbts256Error.check(self._dll.GOMDBTS256_integralProgressionGetCalibratedValues(self._handle, values))
        return list(values)

    def getBLH(self) -> float:
        """
        int GOMDBTS256_getBLH(int handle, double* value);

        This method returns the Blue Light Hazard value.

        :return: blue light hazard value
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getBLH(self._handle, value))
        return float(value[0])

    def getMelanopic(self) -> dict:
        """
        int GOMDBTS256_getMelanopic(int handle, double* Ev, double* Eez, double* Evmel);

        This method returns the alpha-opic Melanopic values after CIE S026: Melanopic Irradiance (Ee,mel) and Melanopic
        Daylight(D65) Equivalent Illuminance (Ev,mel,D65)

        :return: dictionary containing:
                 Ev: photopic value;
                 Eez: Melanopic Irradiance;
                 Evmel: Melanopic Daylight Equivalent Illuminance
        """
        types = ["Ev", "Eez", "Evmel"]
        Ev = self._ffi.new("double*")
        Eez = self._ffi.new("double*")
        Evmel = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getMelanopic(self._handle, Ev, Eez, Evmel))
        return dict(zip(types, [float(Ev[0]), float(Eez[0]), float(Evmel[0])]))

    def getBilirubin(self) -> dict:
        """
        int GOMDBTS256_getBilirubin(int handle, double* bilirubinIEC, double* bilirubinAAP);

        This method returns the values for Bilirubin IEC 60601-2-50 and Bilirubin AAP.

        :return: dictionary containing the measurment values for Bilirubin IEC60601-2-50 and Bilirubin AAP
        """
        types = ["bilirubinIEC", "bilirubinAAP"]
        bilirubinIEC = self._ffi.new("double*")
        bilirubinAAP = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getBilirubin(self._handle, bilirubinIEC, bilirubinAAP))
        return dict(zip(types, [float(bilirubinIEC[0]), float(bilirubinAAP[0])]))

    def getColorCIE170(self) -> dict:
        """
        int GOMDBTS256_getColorCIE170(int handle, double* L_MB, double* M_MB, double* S_MB, double* X_F, double* Y_F, double* Z_F);

        CIE 170-2 defines a "fundamental chromaticity diagram of which the coordinates correspond to physiologically
        significant axes" This method returns the coordinates L_MB, M_MB and S_MB of this new chromaricity diagram
        and the transformations to the tristimulus coordinates X_F, Y_F and Z_F

        :return: dictionary containing the coordinates according to CIE 170-2
        """
        types = ["L_MB", "M_MB", "S_MB", "X_F", "Y_F", "Z_F"]
        L_MB = self._ffi.new("double*")
        M_MB = self._ffi.new("double*")
        S_MB = self._ffi.new("double*")
        X_F = self._ffi.new("double*")
        Y_F = self._ffi.new("double*")
        Z_F = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getColorCIE170(self._handle, L_MB, M_MB, S_MB, X_F, Y_F, Z_F))
        return dict(
            zip(types, [float(L_MB[0]), float(M_MB[0]), float(S_MB[0]), float(X_F[0]), float(Y_F[0]), float(Z_F[0])])
        )

    def loggerGetTemperature(self) -> float:
        """
        int GOMDBTS256_loggerGetTemperature(int handle, double* value);

        This method returns the temperature of actual loaded logger index.

        :return: temperature of logger index
        """
        value = self._ffi.new("double*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_loggerGetTemperature(self._handle, value))
        return float(value[0])

    def getTypeNumber(self) -> int:
        """
        int GOMDBTS256_getTypeNumber(int handle, int* value);

        This method returns the type Number of the device.

        :return: type number of the device
        """
        value = self._ffi.new("int*")
        GOmdbts256Error.check(self._dll.GOMDBTS256_getTypeNumber(self._handle, value))
        return int(value[0])


def build():
    ffibuilder = FFI()
    ffibuilder.set_source("gomdbts256_cffi", None)
    with open(Path(__file__).parent / "src" / "gomdbts256_cffi.h") as f:
        ffibuilder.cdef(f.read())
    ffibuilder.compile(verbose=True)


if __name__ == "__main__":
    build()
