from __future__ import annotations

from threading import RLock

import pyvisa as visa
from pyvisa.constants import VI_ATTR_TERMCHAR, VI_ATTR_TMO_VALUE, VI_SUCCESS_MAX_CNT

from pverify.core.util.decorators import synchronized
from pverify.core.util.scanf import sscanf
from pverify.core.util.string_util import decode

visalock = RLock()


class BaseVisaInstrument:
    """Base class for all VISA drivers."""

    def __init__(self):
        self.ResourceName = ""
        self.__Initialized = 0
        self._instr = None
        self.termination = None
        self._Log = visa.logger
        self.__logLevel = self._Log.level
        self.__backend = None

    @synchronized(visalock)
    def vi_open(self, timeout=5000, rw_termination=None):
        rm = visa.ResourceManager("@" + self.backend) if self.backend else visa.ResourceManager()
        if rw_termination:
            self._instr = rm.open_resource(
                self.ResourceName,
                read_termination=rw_termination,
                write_termination=rw_termination,
            )
        else:
            self._instr = rm.open_resource(self.ResourceName)
        if False:
            from pyvisa.resources.messagebased import MessageBasedResource

            self._instr = MessageBasedResource()
        if rw_termination:
            self.termination = rw_termination
        else:
            self.termination = chr(self._instr.get_visa_attribute(VI_ATTR_TERMCHAR))
        self._instr.set_visa_attribute(VI_ATTR_TMO_VALUE, timeout)
        self._Log.debug(f"Opened visa connection to '{self.ResourceName}'.")
        self.__Initialized = 1

    @synchronized(visalock)
    def vi_setTimeout(self, timeout):
        """
        Configures the visa timeout.

        :param timeout: Timeout time in milliseconds
        :return:
        """
        self._instr.set_visa_attribute(VI_ATTR_TMO_VALUE, timeout)

    @synchronized(visalock)
    def vi_query(self, cmd, wformat="%s", rformat=""):
        """vi_query(cmd, wformat='', rformat='')
        If rformat is '' the answer is returned unchanged.
        Following scanf conversion formats are supported:
            d    decimal integer.
            i    integer.  The integer may be in octal (leading zero) or
                 hexadecimal (leading 0x or 0X).
            o    octal integer (with or without leading zero).
            x    hexadecimal integer (with or without leading 0x or 0X)
            c    characters.  The next input characters (default 1) are
                 placed at the indicated spot.  The normal skip over white space
                 is suppressed; to read the next non-white space character, use
                 %1s.
            s    character string (not quoted).
            f    floating-point number with optional sign and optional decimal point.
            %    literal %; no assignment is made."""
        if self.__Initialized:
            formattedCmd = wformat % cmd
            self._instr.write(formattedCmd, termination=self.termination)
            if self.__logLevel == 10:
                self._Log.debug(f"viWrite: '{formattedCmd}'")
            data = decode(self._instr.read(termination=self.termination))
            data = str(data).strip()
            if self.__logLevel == 10:
                self._Log.debug(f"viRead: '{data}'")
            if rformat:
                result = sscanf(data, rformat)
            else:
                return str(data).strip()

            if len(result) == 1:
                return result[0]
            else:
                return list(result)
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @synchronized(visalock)
    def vi_write(self, cmd, wformat="%s"):
        if self.__Initialized:
            formattedCmd = wformat % cmd
            self._instr.write(formattedCmd, termination=self.termination)
            if self.__logLevel == 10:
                self._Log.debug(f"viWrite: '{formattedCmd}'")
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @synchronized(visalock)
    def vi_read(self, rformat=""):
        if self.__Initialized:
            data = decode(self._instr.read(termination=self.termination))
            data = data.partition(self.termination)[0]
            if rformat:
                result = sscanf(data, rformat)
                if self.__logLevel == 10:
                    self._Log.debug(f"viRead: '{result}'")
            else:
                return data

            if len(result) == 1:
                return result[0]
            else:
                return list(result)
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @synchronized(visalock)
    def vi_read_raw(self):
        if self.__Initialized:
            with self._instr.visalib.ignore_warning(self._instr.session, VI_SUCCESS_MAX_CNT):
                ret = decode(self._instr.read_raw())
                if self.__logLevel == 10:
                    self._Log.debug(f"viRead: '{ret[:1024]!s}'")
            return ret
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @synchronized(visalock)
    def get_visa_attribute(self, AttributeName):
        if self.__Initialized:
            return self._instr.get_visa_attribute(AttributeName)
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @synchronized(visalock)
    def set_visa_attribute(self, AttributeName, Value):
        if self.__Initialized:
            self._instr.set_visa_attribute(AttributeName, Value)
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @synchronized(visalock)
    def vi_close(self):
        if self.__Initialized:
            self._Log.debug(f"Closed visa connection to '{self.ResourceName}'.")
            self._instr.close()
        else:
            msg = "Instrument session not initialized. Use Initialize()-Method first."
            raise Exception(msg)

    @property
    def backend(self):
        return self.__backend

    @backend.setter
    def backend(self, value):
        if value != "ni" and value != "py":
            msg = f"Instrument backend {value} unkown. Expecting 'ni' or'py'!"
            raise Exception(msg)
        self.__backend = value


class InstrumentError(Exception):
    def __init__(self, msg, id=None):
        super().__init__(str(msg))
        self.errorID = id


class InstrumentWarning(Warning):
    def __init__(self, msg, id=None):
        super().__init__(str(msg))
        self.errorID = id
