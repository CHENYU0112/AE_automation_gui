from __future__ import annotations

import inspect
import logging
import os
import re
import sys
import threading
import time
from multiprocessing import Lock

import arrow
import pandas as pd
from pyvisa import ResourceManager

from pverify.core.lab.driver_identity import Identity_SCPI, IdentityABC
from pverify.core.util.decorators import synchronized

from .enums import T2500Enums, key_by_value


class LIMITS_T2500:
    TEMP_HIGH = 230.0  # °C
    TEMP_LOW = -99.0  # °C
    FLOW_HIGH = 7.08  # unit: l/s -> 900 scfh
    FLOW_LOW = 1.60  # unit: l/s -> 200 scfh
    WINDOW_HIGH = 15.0  # unit: °C
    WINDOW_LOW = 0.1  # unit: °C
    RATE_HIGH = 999  # °C/minute
    RATE_LOW = 0  # °C/minute


SCFH_TO_LPS = 127.11
SCFM_TO_LPS = 2.11
DEF_NUM = -999
DEBUG = 0
ESE = 0b00111100
IDN_MATCH = re.compile("THERMONICS, ?T-?2500.*")
LOCK = Lock()


def scfh_to_lps(scfh: float | int) -> float:
    return pd.np.round(scfh / SCFH_TO_LPS, decimals=3)


def lps_to_scfh(lps: float | int) -> int:
    return int(lps * SCFH_TO_LPS)


class CommandError(Exception):
    pass


class ExecutionError(Exception):
    pass


class DeviceDependentError(Exception):
    pass


class QueryError(Exception):
    pass


class Parameter:
    def __init__(self, parent):
        """
        :type parent: thermonics_t2500
        """
        self._parent = parent

    @property
    def Mode(self) -> T2500Enums.MODE:
        """
        Set the temperature control mode.
        """
        if DEBUG:
            return self._parent._statecache["mode"]
        self._parent._statecache["mode"] = key_by_value(T2500Enums.MODE, int(self._parent._query("TCONTROL?")))
        return self._parent._statecache["mode"]

    @Mode.setter
    def Mode(self, mode: T2500Enums.MODE):
        """
        Set the temperature control mode.
        """
        if mode in T2500Enums.MODE:
            self._parent._write(f"TCONTROL {mode.value:d}")
            self._parent._statecache["mode"] = mode
        else:
            msg = "Unsupported mode!"
            raise ValueError(msg)

    @property
    def AirTemp(self) -> float:
        """
        The air temperature without offset.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("AIRTEMP?").replace("CEL", ""))

    @property
    def DutTemp(self) -> float:
        """
        The DUT temperature without offset.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("DUTTEMP?").replace("CEL", ""))

    @property
    def SetPoint(self) -> float:
        """
        The temperature setpoint
        """
        if DEBUG:
            return self._parent._statecache["setpoint"]
        self._parent._statecache["setpoint"] = float(self._parent._query("SETPOINT?").replace("CEL", ""))
        return self._parent._statecache["setpoint"]

    @SetPoint.setter
    def SetPoint(self, value: float):
        """
        The temperature setpoint
        """
        value = round(value, 1)
        check_floating_range(LIMITS_T2500.TEMP_LOW, LIMITS_T2500.TEMP_HIGH, value)

        self._parent._write(f"TEMP1 {value:.1f}")
        self._parent._write("GOTEMP1")

        self._parent._statecache["setpoint"] = value

    @property
    def Temp(self) -> float:
        """
        Get the dut temperature without offset. It returns the temp corresponding to the active mode eg. dut, air, etc.
        """
        if DEBUG:
            return DEF_NUM
        mode = self.Mode
        if mode == T2500Enums.MODE.AIR_CTRL:
            return self.AirTemp
        else:
            return self.DutTemp

    @property
    def Window(self) -> float:
        """
        Set the temperature window the Thermostream should try to stay in and use as acceptance criteria.

        Example: given value is 1.0 results in a window of setpoint - 1.0 and setpoint + 1.0 creating
        an effective range of 2.0 (°C) around the setpoint.
        """
        if DEBUG:
            return self._parent._statecache["window"]
        self._parent._statecache["window"] = float(self._parent._query("TEMPTOL?").replace("CEL", ""))
        return self._parent._statecache["window"]

    @Window.setter
    def Window(self, value: float):
        """
        Set the temperature window the Thermostream should try to stay in and use as acceptance criteria.

        Example: given value is 1.0 results in a window of setpoint - 1.0 and setpoint + 1.0 creating
        an effective range of 2.0 (°C) around the setpoint.
        """
        check_floating_range(LIMITS_T2500.WINDOW_LOW, LIMITS_T2500.WINDOW_HIGH, value)
        self._parent._write(f"TEMPTOL {value:.1f}")
        self._parent._statecache["window"] = value

    @property
    def RampRate(self) -> float:
        """
        Ramp rate of the device
        """
        if DEBUG:
            return self._parent._statecache["ramp_rate"]
        self._parent._statecache["ramp_rate"] = float(self._parent._query("RAMPRATE?"))
        return self._parent._statecache["ramp_rate"]

    @RampRate.setter
    def RampRate(self, value: float | int):
        """
        Ramp rate of the device
        """
        check_floating_range(LIMITS_T2500.RATE_LOW, LIMITS_T2500.RATE_HIGH, value)
        self._parent._write(f"RAMPRATE {value:.0f}")
        self._parent._statecache["ramp_rate"] = value

    @property
    def FlowRate(self) -> float:
        """
        Flow rate of the device in l/s. Sets both cold flow and hot flow.
        """
        if DEBUG:
            return self._parent._statecache["flow_rate"]
        self._parent._statecache["flow_rate"] = scfh_to_lps(float(self._parent._query("HOTFLOW?")))
        return self._parent._statecache["flow_rate"]

    @FlowRate.setter
    def FlowRate(self, value: float | int):
        """
        Flow rate of the device in l/s. Sets both cold flow and hot flow.
        """
        check_floating_range(LIMITS_T2500.FLOW_LOW, LIMITS_T2500.FLOW_HIGH, value)
        scfh = lps_to_scfh(value)
        self._parent._write(f"HOTFLOW {scfh:.0f}")
        self._parent._write(f"COLDFLOW {scfh:.0f}")
        self._parent._statecache["flow_rate"] = value

    @property
    def FlowState(self) -> bool:
        """
        Set the flow valve of the device. Head needs to be in the lower position for this to have an effect.
        """
        if DEBUG:
            return self._parent._statecache["flow_state"]
        self._parent._statecache["flow_state"] = bool(int(self._parent._query("FLOW?")))
        return self._parent._statecache["flow_state"]

    @FlowState.setter
    def FlowState(self, value: bool):
        """
        Set the flow valve of the device. Head needs to be in the lower position for this to have an effect.
        """
        value = bool(value)
        if value:
            if self.HeadPosition == T2500Enums.HEAD_POS.UP:
                msg = "Head needs to be lowered first before flow can be set to True."
                raise Exception(msg)
            else:
                self._parent._write("GOTEMP1")
        else:
            self._parent._write("AIROFF")
            time.sleep(1)
        self._parent._statecache["flow_state"] = value

    @property
    def CompressorState(self) -> bool:
        """
        Set the compressor state of the device. Turning the compressor on takes ~2 minutes, turning off about ~1s.

        If the flow state is ON when enabling the compressor, the flow is disabled during compressor startup.
        """
        if DEBUG:
            return self._parent._statecache["compressor_state"]
        self._parent._statecache["compressor_state"] = bool(int(self._parent._query("COMP?")))
        return self._parent._statecache["compressor_state"]

    @CompressorState.setter
    def CompressorState(self, state: bool):
        """
        Set the compressor state of the device. Turning the compressor on takes ~2 minutes, turning off about ~5s.

        If the flow state is ON when enabling the compressor, the flow is disabled during compressor startup.
        """
        state = bool(state)

        if state != self.CompressorState:
            if state:
                # apparently you can't turn on the compressor while the flow is on.
                if self.FlowState:
                    self.FlowState = False
                    self._parent._write("COMP 1")
                    self.FlowState = True
                else:
                    self._parent._write("COMP 1")
                # the instrument needs a minute to start the compressor
                if not DEBUG:
                    time.sleep(122)
            else:
                self._parent._write("COMP 0")
                time.sleep(5)

        # update state variable
        self._parent._statecache["compressor_state"] = state

    @property
    def CompressorTimerRemaining(self) -> int:
        msg = "Compressor timer is not supported!"
        raise NotImplementedError(msg)

    @property
    def CompressorTimer(self) -> int:
        msg = "Compressor timer is not supported!"
        raise NotImplementedError(msg)

    @CompressorTimer.setter
    def CompressorTimer(self, value: int):
        msg = "Compressor timer is not supported!"
        raise NotImplementedError(msg)

    @property
    def HeadLock(self) -> bool:
        msg = "Head lock is not supported!"
        raise NotImplementedError(msg)

    @HeadLock.setter
    def HeadLock(self, value: bool):
        msg = "Head lock is not supported!"
        raise NotImplementedError(msg)

    @property
    def HeadPosition(self) -> T2500Enums.HEAD_POS:
        """
        Controls the head position (up/down)
        """
        if DEBUG:
            return self._parent._statecache["head_pos"]
        headpos = int(self._parent._query("HEAD?"))
        self._parent._statecache["head_pos"] = key_by_value(T2500Enums.HEAD_POS, headpos)
        return self._parent._statecache["head_pos"]

    @HeadPosition.setter
    def HeadPosition(self, value: T2500Enums.HEAD_POS):
        """
        Controls the head position (up/down)
        """
        if value == self.HeadPosition:
            return
        if value == T2500Enums.HEAD_POS.UP:
            self._parent._write("HEAD 1")
            time.sleep(4.0)
        elif value == T2500Enums.HEAD_POS.DOWN:
            self._parent._write("HEAD 0")
            # this delay is essential, otherwise set_flow(False) will be without effect.
            time.sleep(4.0)
        else:
            raise Exception("Invalid position argument: " + str(value))
        self._parent._statecache["head_pos"] = value


class Templogger:
    def __init__(self, parent):
        """
        :type parent: thermonics_t2500
        """
        self._parent = parent
        self._logpath = None

    def config(self, logpath: str, period: float):
        """
        Configures the temperature logger, which is periodically querying the air and DUT temperature values from the device in a background thread.

        This method has to be called when initially starting the logging or whenever the logger was stopped and shall be re-started.

        :param logpath: The path of the log file where the data is stored
        :param period: The waiting time between samples
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._thread_templogger.destroy()
            del self._parent._thread_templogger
        self._parent._thread_templogger = ThreadTemperatureLogger(self._parent, logpath, period)
        self._logpath = logpath

    def start(self):
        """
        Start the temperature logging background process.
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._check_initialized()
            if not self._parent._thread_templogger.is_alive():
                try:
                    self._parent._thread_templogger.start()
                except RuntimeError:
                    msg = "You need to invoke Templogger.config() before you can use the start() method."
                    raise Exception(msg) from None
                self._parent._thread_templogger.log.disabled = False

    def pause(self):
        """
        Pauses the logging process (the background process still runs but the logging to file is disabled).
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._check_initialized()
            self._parent._thread_templogger.pause()

    def stop(self):
        """
        Stop the logging process.

        Please consider invoking Templogger.config(...) before starting the logging again.
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._thread_templogger.stop()

    def as_dataframe(self, logpath=None) -> pd.DataFrame:
        """
        Returns the logged temperature data as a Pandas dataframe

        :param logpath: The log file to parse. If None, the previously used logpath is used
        """
        if logpath is None:
            if self._logpath is not None:
                logpath = self._logpath
            else:
                msg = "No logpath provied."
                raise Exception(msg)
        else:
            if not os.path.exists(logpath):
                msg = "Provided logpath does not exist!"
                raise Exception(msg)

        with open(
            logpath
        ) as fh:  # read_csv cannot handle paths with non-ascii characters --> workaround by passing file handle
            # (https://github.com/pandas-dev/pandas/issues/15086)
            return pd.read_csv(fh, delimiter=";", converters={"Date": pd.to_datetime}, index_col=0)


class thermonics_t2500(IdentityABC):
    def __init__(self, logger: logging.Logger | None = None):
        self.__initialized = False
        self._inst = None
        """:type : pyvisa.resources.gpib.GPIBInstrument"""
        self._TYPE = None
        """:type : T2500Enums.TYPES"""
        if isinstance(logger, logging.Logger):
            self._log = logger
        else:
            self._log = logging.getLogger(self.__class__.__name__)
            if len(self._log.handlers) == 0:  # only add streamhandler if none exists
                self._log.addHandler(logging.StreamHandler(sys.stdout))
            self._log.setLevel(logging.INFO)
        self._thread_templogger = None  # type: ThreadTemperatureLogger

        self._statecache = {
            "mode": T2500Enums.MODE.AIR_CTRL,
            "setpoint": 0.0,
            "window": 0.0,
            "ramp_rate": 0.0,
            "flow_rate": 0.0,
            "flow_state": False,
            "compressor_state": False,
            "head_pos": T2500Enums.HEAD_POS.UP,
        }

        self.__Identity = Identity_SCPI(parent=self, rsrc_attr_name="_inst")
        self.__parameter = Parameter(parent=self)
        self.__Templogger = Templogger(parent=self)

    def __repr__(self):
        limits, _ = inspect.getsourcelines(LIMITS_T2500)
        return "Thermostream Limits:\n" + "".join(limits[1:])

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Templogger(self):
        """
        Returns a pointer to the Templogger subclass
        """
        return self.__Templogger

    @property
    def parameter(self):
        """
        Returns a pointer to the parameter subclass
        """
        return self.__parameter

    def _check_initialized(self):
        if not self.__initialized:
            msg = "Driver is not initialized!"
            raise Exception(msg)

    def Initialize(self, ResourceName, IdQuery=True, Reset=True, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
                             of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: Initialization options: "simulate=(true|false)"
        :type OptionString: str
        """
        global DEBUG  # noqa: PLW0603
        if "simulate=true" in OptionString.lower():
            DEBUG = True
            ResourceName = "GPIB0::1::INSTR"
            self._log.info("Instrument simulation activated!")

        if self.__initialized:
            return

        self._rm = ResourceManager("@sim" if DEBUG else "")
        self._inst = self._rm.open_resource(ResourceName)
        """:type : pyvisa.resources.gpib.GPIBInstrument"""
        self._inst.open()

        if IdQuery:
            idn = self._query("*IDN?")
            if not (DEBUG or IDN_MATCH.match(idn) is not None):
                msg = f"Unknown/Unsuported thermostream type '{idn}'!"
                raise Exception(msg)
            self._log.info(f"Successfully connected to thermostream {idn} @ {ResourceName}")
        else:
            self._log.info(f"Successfully connected to thermostream @ {ResourceName}")

        self._inst.write_termination = "\r"
        self._inst.read_termination = "\r"

        if Reset and not DEBUG:
            self._write("*RST")
            time.sleep(5)

        self.__initialized = True

        # Configure Event Status Register
        # bit 5 - command error (cme)
        # bit 4 - execution error (exe)
        # bit 3 - device dependent error (dde)
        # bit 2 - query error (qye)
        self._write("*CLS")
        self._write("TESE %d" % ESE)

        # Set the temperature limits to min/max
        self._write(f"MINTEMP {LIMITS_T2500.TEMP_LOW:.1f}")
        self._write(f"MAXTEMP {LIMITS_T2500.TEMP_HIGH:.1f}")

        # Initialize statecache
        self.__update_statecache()

    @synchronized(LOCK)
    def _write(self, message, termination=None, encoding=None):
        """Write a string message to the device.

        The write_termination is always appended to it.

        :param message: the message to be sent.
        :type message: unicode (Py2) or str (Py3)
        :return: number of bytes written.
        :rtype: int
        """
        return self._inst.write(message, termination, encoding)

    @synchronized(LOCK)
    def _query(self, message, delay=None):
        """A combination of write(message) and read()

        :param message: the message to send.
        :type message: str
        :param delay: delay in seconds between write and read operations.
                      if None, defaults to self.query_delay
        :returns: the answer from the device.
        :rtype: str
        """
        return self._inst.query(message, delay)

    def __update_statecache(self):
        _ = self.parameter.Mode
        _ = self.parameter.SetPoint
        _ = self.parameter.Window
        _ = self.parameter.RampRate
        _ = self.parameter.FlowState
        _ = self.parameter.CompressorState
        _ = self.parameter.HeadPosition
        _ = self.parameter.FlowRate

    def Close(self):
        self._check_initialized()
        self._write("%GL")
        self._inst.close()
        self.__initialized = False

    def CheckError(self):
        self._check_initialized()
        if DEBUG:
            return
        esr = int(self._query("*ESR?"))
        self._write("*CLS")
        if esr & ESE:
            if esr & 0b00100000:
                msg = ""
                raise CommandError(msg)
            elif esr & 0b00010000:
                msg = ""
                raise ExecutionError(msg)
            elif esr & 0b00001000:
                msg = ""
                raise DeviceDependentError(msg)  # DDE not available
            elif esr & 0b00000100:
                msg = ""
                raise QueryError(msg)

    @property
    def Enums(self):
        return T2500Enums

    @property
    def Initialized(self):
        return self.__initialized

    def WaitForTemp(
        self,
        timeout_s,
        target: float,
        window_k: float | None = None,
        flowrate: float | None = None,
        soaktime_m: int | None = None,
        disable_exception: bool = False,
    ) -> bool:
        """
        This method is useful if you want a blocking wait until a temperature is reached. Every parameter
        is optional except for timeout_s. Every 100ms the temperature is checked if in range. If not within
        range after timeout an exception is raised.

        :param timeout_s: Timeout in seconds.
        :param target: Target temperature.
        :param window_k: Accepted window around target in Kelvin.
        :param flowrate: Flow rate of the device.
        :param soaktime_m: Time in minutes to wait after target is reached.
        :param disable_exception: If False then exception is raised on timeout, if True then no exception will be raised and False is returned.
        :returns: Returns True if temperature in range before timeout and False otherwise only if exceptions are disabled.
        """

        # if target is not None set temperature.
        if target is not None:
            self.parameter.SetPoint = target

        # analog to target...
        if window_k is not None:
            self.parameter.Window = window_k

        # analog to target...
        if flowrate is not None:
            self.parameter.FlowRate = flowrate

        # initiate compressor and flow
        self.parameter.CompressorState = True
        self.parameter.FlowState = True

        # check temp periodically
        time_start = time.time()
        timeout_abs = time_start + timeout_s
        interval = 0.20
        progress = 0.0
        while True:
            # log progress
            cur_temp = self.parameter.Temp
            if time.time() > (time_start + (progress * timeout_s)):
                self._log.info(
                    "{:3d}% of wait time has passed. Cur: {:0.1f}°C\tTarget: {:0.1f}°C.".format(
                        int(progress * 100), cur_temp, self._statecache["setpoint"]
                    )
                )
                progress += interval

            # check if temp in range
            try:
                check_floating_range(
                    (self._statecache["setpoint"] - self._statecache["window"]),
                    (self._statecache["setpoint"] + self._statecache["window"]),
                    cur_temp,
                )
                within_range = True
            except Exception:
                within_range = False or DEBUG
            if time.time() > timeout_abs or within_range:
                break
            time.sleep(100e-3)

        # when in target range, soak and log progress
        if within_range:
            retval = True
            if soaktime_m is not None:
                self._log.info(f"Temperature is within range. Soaking for {soaktime_m} minute(s)...")
                time_start = time.time()
                timeout_abs = time_start + soaktime_m * 60.0
                interval = 0.20
                progress = 0.0
                while True:
                    if DEBUG:
                        break
                    if time.time() > (time_start + (progress * soaktime_m * 60.0)):
                        self._log.info(f"{int(progress * 100):3d}% of soaktime has passed.")
                        progress += interval
                    if time.time() > timeout_abs:
                        break
                    time.sleep(100e-3)
                self._log.info("Finished soaking. Moving on...")
            else:
                self._log.info("Temperature is within range. Moving on...")
        else:
            if disable_exception:
                retval = False
            else:
                msg = "Temperature not within range when timeout occurred."
                raise Exception(msg)
        return retval

    def configure(
        self,
        mode: T2500Enums.MODE,
        temp: float,
        window_k: float = 1.0,
        flowrate: float = 5.0,
        ramprate: float = 9999.0,
    ):
        """
        Convenience method to configure all essential aspects of the device.
        """
        self.parameter.Mode = mode
        self.parameter.SetPoint = temp
        self.parameter.Window = window_k
        self.parameter.FlowRate = flowrate
        self.parameter.RampRate = ramprate


def check_floating_range(llimit, ulimit, value, clip=False):
    """
    Check if value is within range including the limits.
    If clip is True the value will be clipped, otherwise an exception is raised.
    """
    # value = round(value, 1)
    if llimit <= value <= ulimit:
        return None
    elif clip:
        return max(llimit, min(ulimit, value))
    else:
        msg = f"Value ({value}) is out of valid input range ({llimit} - {ulimit})."
        raise Exception(msg)


class ThreadTemperatureLogger(threading.Thread):
    def __init__(self, drv: thermonics_t2500, logpath: str, period: float = 1.0):
        threading.Thread.__init__(self)
        self.drv = drv
        self.logpath = logpath
        self.period = float(period)
        self._pause = False
        self._exit = False

        self.log = logging.Logger(self.drv.__class__.__name__ + "_" + self.__class__.__name__)
        self.log.setLevel(logging.INFO)
        self.fh = logging.FileHandler(logpath, "w")
        self.fh.setLevel(logging.INFO)
        self.fh.setFormatter(logging.Formatter("%(message)s"))
        self.log.addHandler(self.fh)
        self.log.info("Date;AirTemp;DutTemp")
        self.log.disabled = False

    def destroy(self):
        for h in self.log.handlers:
            self.log.removeHandler(h)
        self.log.handlers = []

    def run(self):
        self.log.disabled = False
        while not self._exit:
            try:
                if DEBUG:
                    self.log.info(f"{arrow.now()};{1.0};{2.0}")
                else:
                    self.log.info(f"{arrow.now()};{self.drv.parameter.AirTemp:.2f};{self.drv.parameter.DutTemp:.2f}")
            except Exception as e:
                self.drv._log.error("An exception occurred in ThreadTemperatureLogger thread: " + str(e))
            finally:
                time.sleep(self.period)

    def pause(self):
        self.log.disabled = True

    def stop(self):
        self._exit = True
        self.join(self.period * 1.5)
