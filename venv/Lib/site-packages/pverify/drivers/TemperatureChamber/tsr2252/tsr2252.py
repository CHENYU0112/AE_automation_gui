from __future__ import annotations

import contextlib
import inspect
import logging
import os
import re
import sys
import threading
import time
from multiprocessing import Lock

import arrow
import pandas as pd
from pyvisa import ResourceManager

from pverify.core.lab.driver_identity import Identity_SCPI, IdentityABC
from pverify.core.util.decorators import synchronized

from . import limits
from .enums import StecEnums, key_by_value

DEF_NUM = -999
DEBUG = 0
ESE = 0b00111100
IDN_MATCH_TSR2252 = re.compile("TSR, ?2252.*.*")

LOCK = Lock()


class Parameter:
    def __init__(self, parent):
        """
        :type parent: tsr2252
        """
        self._parent = parent

    @property
    def Mode(self) -> StecEnums.MODE:
        """
        Set the temperature control mode.
        """
        if DEBUG:
            return self._parent._statecache["mode"]
        mode = key_by_value(StecEnums.MODE, int(self._parent._query("DUTM?")))
        self._parent._statecache["mode"] = mode
        if str(mode.name) == StecEnums.MODE.DUT_CTRL.name:
            sensor = key_by_value(StecEnums.SENSOR, int(self._parent._query("DSNS?")))
            self._parent._statecache["sensor"] = sensor
        return self._parent._statecache["mode"]

    @Mode.setter
    def Mode(self, mode: StecEnums.MODE):
        """
        Set the temperature control mode.
        Setting the DUT mode will also set the K-type sensor.
        """
        if mode in StecEnums.MODE:
            if mode == StecEnums.MODE.DUT_CTRL:
                self._parent._write("DSNS " + str(StecEnums.SENSOR.K.value))
                self._parent._statecache["sensor"] = StecEnums.SENSOR.K
            self._parent._write(f"DUTM {mode.value:d}")
            self._parent._statecache["mode"] = mode
        else:
            msg = "Unsupported mode!"
            raise ValueError(msg)

    @property
    def AirTemp(self) -> float:
        """
        The air temperature without offset.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("TMPA?"))

    @property
    def DutTemp(self) -> float:
        """
        The DUT temperature without offset.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("TMPD?"))

    @property
    def SetPoint(self) -> float:
        """
        The temperature setpoint
        """
        if DEBUG:
            return self._parent._statecache["setpoint"]
        self._parent._statecache["setpoint"] = float(self._parent._query("SETP?"))
        return self._parent._statecache["setpoint"]

    @SetPoint.setter
    def SetPoint(self, value: float):
        """
        The temperature setpoint
        """
        check_floating_range(self._parent._limits.TEMP_LOW, self._parent._limits.TEMP_HIGH, value)
        self._parent._write("SETP " + f"{value:.1f}")
        self._parent._statecache["setpoint"] = value

    @property
    def Temp(self) -> float:
        """
        Get the dut temperature without offset. It returns the temp corresponding to the active mode eg. dut, air, etc.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("TEMP?"))

    @property
    def Window(self) -> float:
        """
        The temperature window the Thermostream should try to stay in and use as acceptance criteria.

        Example: given value is 1.0 results in a window of setpoint - 1.0 and setpoint + 1.0 creating
        an effective range of 2.0 (°C) around the setpoint.
        """
        if DEBUG:
            return self._parent._statecache["window"]
        self._parent._statecache["window"] = float(self._parent._query("WNDW?"))
        return self._parent._statecache["window"]

    @Window.setter
    def Window(self, value: float):
        """
        The temperature window the Thermostream should try to stay in and use as acceptance criteria.

        Example: given value is 1.0 results in a window of setpoint - 1.0 and setpoint + 1.0 creating
        an effective range of 2.0 (°C) around the setpoint.
        """
        check_floating_range(self._parent._limits.WINDOW_LOW, self._parent._limits.WINDOW_HIGH, value)
        self._parent._write(f"WNDW {value:.1f}")
        self._parent._statecache["window"] = value

    @property
    def RampRate(self) -> float:
        """
        Ramp rate of the device
        """
        if DEBUG:
            return self._parent._statecache["ramp_rate"]
        self._parent._statecache["ramp_rate"] = float(self._parent._query("RAMP?"))
        return self._parent._statecache["ramp_rate"]

    @RampRate.setter
    def RampRate(self, value: float | int):
        """
        Ramp rate of the device
        """
        check_floating_range(self._parent._limits.RATE_LOW, self._parent._limits.RATE_HIGH, value)
        self._parent._write(f"RAMP {value:.1f}" if value <= 100 else f"RAMP {value:.0f}")
        self._parent._statecache["ramp_rate"] = value

    @property
    def FlowRate(self) -> float:
        """
        Flow rate of the device in l/s.
        """
        if DEBUG:
            return self._parent._statecache["flow_rate"]
        self._parent._statecache["flow_rate"] = float(self._parent._query("FLML?"))
        return self._parent._statecache["flow_rate"]

    @FlowRate.setter
    def FlowRate(self, value: float | int):
        """
        Flow rate of the device in l/s.
        """
        check_floating_range(self._parent._limits.FLOW_LOW, self._parent._limits.FLOW_HIGH, value)
        self._parent._write(f"FLML {value:.2f}")
        self._parent._statecache["flow_rate"] = value

    @property
    def FlowState(self) -> bool:
        """
        The flow valve of the device. Head needs to be in the lower position for this to have an effect.
        """
        if DEBUG:
            return self._parent._statecache["flow_state"]
        self._parent._statecache["flow_state"] = bool(int(self._parent._query("FLOW?")))
        return self._parent._statecache["flow_state"]

    @FlowState.setter
    def FlowState(self, value: bool):
        """
        The flow valve of the device. Head needs to be in the lower position for this to have an effect.
        """
        value = bool(value)
        if value:
            if self.HeadPosition == StecEnums.HEAD_POS.UP:
                msg = "Head needs to be lowered first before flow can be set to True."
                raise Exception(msg)
            else:
                self._parent._write("FLOW 1")
        else:
            self._parent._write("FLOW 0")
        self._parent._statecache["flow_state"] = value
        time.sleep(0.2)

    @property
    def CompressorState(self) -> bool:
        """
                Set the compressor state of the device. Turning the compressor on and off takes around 1 second.
        .
        """
        if DEBUG:
            return self._parent._statecache["compressor_state"]
        self._parent._statecache["compressor_state"] = bool(int(self._parent._query("COOL?")))
        return self._parent._statecache["compressor_state"]

    @CompressorState.setter
    def CompressorState(self, state: bool):
        """
        Set the compressor state of the device. Turning the compressor on and off takes around 1 second.

        """
        state = bool(state)

        if state != self.CompressorState:
            if state:
                self._parent._write("COOL 1")
                time.sleep(1)
            else:
                self._parent._write("COOL 0")
                time.sleep(1)

        # update state variable
        self._parent._statecache["compressor_state"] = state

    @property
    def CompressorTimerRemaining(self) -> int:
        """
        The remaining time in minutes the compressor is switched off by timer
        """
        msg = "Remaining compressor timer is not supported with TSR2252."
        raise NotImplementedError(msg)

    @property
    def CompressorTimer(self) -> int:
        """
        Timer in minutes to turn off the compressor.

        A value of 0 will turn the timer off. Valid values 15 - 12960.
        """
        msg = "Compressor timer is not supported with TSR2252."
        raise NotImplementedError(msg)

    @CompressorTimer.setter
    def CompressorTimer(self, value: int):
        """
        Timer in minutes to turn off the compressor.

        A value of 0 will turn the timer off. Valid values 15 - 12960.
        """
        msg = "Compressor timer is not supported with TSR2252."
        raise NotImplementedError(msg)

    @property
    def HeadLock(self) -> bool:
        """
        Sets the head lock to prevent accidental movement.

        If True head will be locked, if False head is unlocked.
        """
        if DEBUG:
            return self._parent._statecache["head_lock"]
        self._parent._statecache["head_lock"] = bool(int(self._parent._query("HDLK?")))
        return self._parent._statecache["head_lock"]

    @HeadLock.setter
    def HeadLock(self, value: bool):
        """
        Sets the head lock to prevent accidental movement.

        If True head will be locked, if False head is unlocked.
        """
        value = bool(value)
        if value is True:
            self._parent._write("HDLK 1")
        elif value is False:
            self._parent._write("HDLK 0")
        self._parent._statecache["head_lock"] = value

    @property
    def HeadPosition(self) -> StecEnums.HEAD_POS:
        """
        Controls the head position (up/down)
        """
        if DEBUG:
            return self._parent._statecache["head_pos"]
        headpos = int(self._parent._query("HEAD?"))
        self._parent._statecache["head_pos"] = key_by_value(StecEnums.HEAD_POS, headpos)
        return self._parent._statecache["head_pos"]

    @HeadPosition.setter
    def HeadPosition(self, value: StecEnums.HEAD_POS):
        """
        Controls the head position (up/down)
        """
        if self.HeadLock:
            msg = "Head is currently locked. You need to unlock it before moving."
            raise Exception(msg)

        if value == StecEnums.HEAD_POS.UP:
            self._parent._write("HEAD 0")
        elif value == StecEnums.HEAD_POS.DOWN:
            self._parent._write("HEAD 1")
            # this delay is essential, otherwise set_flow(False) will be without effect.
            time.sleep(2.5)
            self.FlowState = False
        else:
            raise Exception("Invalid position argument: " + str(value))
        self._parent._statecache["head_pos"] = value


class Templogger:
    def __init__(self, parent):
        """
        :type parent: tsr2252
        """
        self._parent = parent
        self._logpath = None

    def config(self, logpath: str, period: float):
        """
        Configures the temperature logger, which is periodically querying the air and DUT temperature values from the device in a background thread.

        This method has to be called when initially starting the logging or whenever the logger was stopped and shall be re-started.

        :param logpath: The path of the log file where the data is stored
        :param period: The waiting time between samples
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._thread_templogger.destroy()
            del self._parent._thread_templogger
        self._parent._thread_templogger = ThreadTemperatureLogger(self._parent, logpath, period)
        self._logpath = logpath

    def start(self):
        """
        Start the temperature logging background process.
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._check_initialized()
            if not self._parent._thread_templogger.is_alive():
                try:
                    self._parent._thread_templogger.start()
                except RuntimeError:
                    msg = "You need to invoke Templogger.config() before you can use the start() method."
                    raise Exception(msg) from None
                self._parent._thread_templogger.log.disabled = False

    def pause(self):
        """
        Pauses the logging process (the background process still runs but the logging to file is disabled).
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._check_initialized()
            self._parent._thread_templogger.pause()

    def stop(self):
        """
        Stop the logging process.

        Please consider invoking Templogger.config(...) before starting the logging again.
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._thread_templogger.stop()

    def as_dataframe(self, logpath=None) -> pd.DataFrame:
        """
        Returns the logged temperature data as a Pandas dataframe

        :param logpath: The log file to parse. If None, the previously used logpath is used
        """
        if logpath is None:
            if self._logpath is not None:
                logpath = self._logpath
            else:
                msg = "No logpath provied."
                raise Exception(msg)
        else:
            if not os.path.exists(logpath):
                msg = "Provided logpath does not exist!"
                raise Exception(msg)

        with open(
            logpath
        ) as fh:  # read_csv cannot handle paths with non-ascii characters --> workaround by passing file handle
            # (https://github.com/pandas-dev/pandas/issues/15086)
            return pd.read_csv(fh, delimiter=";", converters={"Date": pd.to_datetime}, index_col=0)


class tsr2252(IdentityABC):
    def __init__(self, logger: logging.Logger | None = None):
        self.__initialized = False
        self._inst = None
        """:type : pyvisa.resources.tcpip.TCPIPInstruments"""
        self._TYPE = None
        """:type : StecEnums.TYPES"""
        if isinstance(logger, logging.Logger):
            self._log = logger
        else:
            self._log = logging.getLogger(self.__class__.__name__)
            if len(self._log.handlers) == 0:  # only add streamhandler if none exists
                self._log.addHandler(logging.StreamHandler(sys.stdout))
            self._log.setLevel(logging.INFO)
        self._limits = limits.LIMITS_DEFAULT
        self._thread_templogger = None  # type: ThreadTemperatureLogger

        self._statecache = {
            "mode": StecEnums.MODE.AIR_CTRL,
            "setpoint": 0.0,
            "window": 0.0,
            "ramp_rate": 0.0,
            "flow_rate": 0.0,
            "flow_state": False,
            "compressor_state": False,
            "compressor_timer": 0.0,
            "head_pos": StecEnums.HEAD_POS.UP,
            "head_lock": False,
            "sensor": StecEnums.SENSOR.NONE,
        }

        self.__Identity = Identity_SCPI(parent=self, rsrc_attr_name="_inst")
        self.__parameter = Parameter(parent=self)
        self.__Templogger = Templogger(parent=self)

    def __repr__(self):
        limits, _ = inspect.getsourcelines(self._limits)
        return "Thermostream Limits:\n" + "".join(limits[1:])

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Templogger(self):
        """
        Returns a pointer to the Templogger subclass
        """
        return self.__Templogger

    @property
    def parameter(self):
        """
        Returns a pointer to the parameter subclass
        """
        return self.__parameter

    def _check_initialized(self):
        if not self.__initialized:
            msg = "Driver is not initialized!"
            raise Exception(msg)

    def Initialize(self, ResourceName, IdQuery=True, Reset=False, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
            of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: Initialization options: "simulate=(true|false)"
        :type OptionString: str
        """
        global DEBUG  # noqa: PLW0603
        if "simulate=true" in OptionString.lower():
            DEBUG = True
            ResourceName = "GPIB0::1::INSTR"
            self._log.info("Instrument simulation activated!")

        if self.__initialized:
            return

        self._rm = ResourceManager("@sim" if DEBUG else "")
        self._inst = self._rm.open_resource(ResourceName)
        """:type : pyvisa.resources.tcpip.TCPIPInstrument"""
        self._inst.write_termination = "\r"
        self._inst.read_termination = "\n"

        if IdQuery:
            idn = self._query("*IDN?")
            if DEBUG or (IDN_MATCH_TSR2252.match(idn) is not None and "Rev V15 Ver 02.2019" in idn):
                self._TYPE = StecEnums.TYPES.TSR2252
                self._limits = limits.LIMITS_TSR2252
            else:
                msg = f"Unknown/Unsupported thermostream type or firmware version '{idn}'!"
                raise Exception(msg)
            self._log.info(f"Successfully connected to thermostream {idn} @ {ResourceName}")
        else:
            self._TYPE = StecEnums.TYPES.TSR2252
            self._limits = limits.LIMITS_DEFAULT
            self._log.info(f"Successfully connected to thermostream @ {ResourceName}")

        if Reset:
            self._write("*RST")

        # Set the temperature limits to min/max
        self._write(f"LLIM {self._limits.TEMP_LOW:.1f}")
        self._write(f"ULIM {self._limits.TEMP_HIGH:.1f}")

        self.__initialized = True
        # Initialize statecache
        self.__update_statecache()

    @synchronized(LOCK)
    def _write(self, message, termination=None, encoding=None):
        """Write a string message to the device.

        The write_termination is always appended to it.
        A delay of 0.3 seconds is necessary after every write command.

        :param message: the message to be sent.
        :type message: unicode (Py2) or str (Py3)
        :return: number of bytes written.
        :rtype: int
        """
        time.sleep(0.3)
        return self._inst.write(message, termination, encoding)

    @synchronized(LOCK)
    def _query(self, message, delay=None):
        """A combination of write(message) and read()
        A delay of 0.3 seconds is necessary after every query command.

        :param message: the message to send.
        :type message: str
        :param delay: delay in seconds between write and read operations.
                      if None, defaults to self.query_delay
        :returns: the answer from the device.
        :rtype: str
        """
        time.sleep(0.3)
        return self._inst.query(message, delay)

    def __update_statecache(self):
        _ = self.parameter.Mode
        _ = self.parameter.SetPoint
        _ = self.parameter.Window
        _ = self.parameter.RampRate
        _ = self.parameter.FlowState
        _ = self.parameter.CompressorState
        _ = self.parameter.HeadPosition
        # will keep these try-except statements for further Stec thermostreams
        with contextlib.suppress(NotImplementedError):
            _ = self.parameter.HeadLock
        with contextlib.suppress(NotImplementedError):
            _ = self.parameter.CompressorTimer
        with contextlib.suppress(NotImplementedError):
            _ = self.parameter.FlowRate

    def Close(self):
        self._check_initialized()
        self._inst.close()
        self.__initialized = False

    def CheckError(self):
        """
        Curently not implemented for the TSR2252 thermostream
        """
        msg = "CheckError not compatible with TSR2252 thermostream"
        raise NotImplementedError(msg)

    @property
    def Enums(self):
        return StecEnums

    @property
    def Initialized(self):
        return self.__initialized

    def WaitForTemp(
        self,
        timeout_s,
        target: float,
        window_k: float | None = None,
        flowrate: float | None = None,
        soaktime_m: int | None = None,
        disable_exception: bool = False,
    ) -> bool:
        """
        This method is useful if you want a blocking wait until a temperature is reached. Every parameter
        is optional except for timeout_s. Every 100ms the temperature is checked if in range. If not within
        range after timeout an exception is raised.

        :param timeout_s: Timeout in seconds.
        :param target: Target temperature.
        :param window_k: Accepted window around target in Kelvin.
        :param flowrate: Flow rate of the device.
        :param soaktime_m: Time in minutes to wait after target is reached.
        :param disable_exception: If False then exception is raised on timeout, if True then no exception will be raised and False is returned.
        :returns: Returns True if temperature in range before timeout and False otherwise only if exceptions are disabled.
        """

        # if target is not None set temperature.
        if target is not None:
            self.parameter.SetPoint = target

        # analog to target...
        if window_k is not None:
            self.parameter.Window = window_k

        # analog to target...
        if flowrate is not None:
            try:
                self.parameter.FlowRate = flowrate
            except NotImplementedError as e:
                self._log.warning(e, exc_info=False)

        # initiate compressor and flow
        self.parameter.CompressorState = True
        self.parameter.FlowState = True
        self._write("SOAK 3")

        # check temp periodically
        time_start = time.time()
        timeout_abs = time_start + timeout_s
        interval = 0.20
        progress = 0.0
        while True:
            # log progress
            cur_temp = self.parameter.Temp
            if time.time() > (time_start + (progress * timeout_s)):
                self._log.info(
                    "{:3d}% of wait time has passed. Cur: {:0.1f}°C\tTarget: {:0.1f}°C.".format(
                        int(progress * 100), cur_temp, self._statecache["setpoint"]
                    )
                )
                progress += interval

            # check if temp in range
            try:
                check_floating_range(
                    (self._statecache["setpoint"] - self._statecache["window"]),
                    (self._statecache["setpoint"] + self._statecache["window"]),
                    cur_temp,
                )
                within_range = True
            except Exception:
                within_range = False or DEBUG
            if time.time() > timeout_abs or (within_range and self._query("TECR?").strip("+\n") == "1"):
                break
            time.sleep(100e-3)

        # when in target range, soak and log progress
        if within_range and self._query("TECR?").strip("+\n") == "1":
            retval = True
            if soaktime_m is not None:
                self._log.info(f"Temperature is within range. Soaking for {soaktime_m} minute(s)...")
                time_start = time.time()
                timeout_abs = time_start - 3 + soaktime_m * 60.0
                interval = 0.20
                progress = 0.0
                while True:
                    if DEBUG:
                        break
                    if time.time() > (time_start + (progress * soaktime_m * 60.0)):
                        self._log.info(f"{int(progress * 100):3d}% of soaktime has passed.")
                        progress += interval
                    if time.time() > timeout_abs:
                        break
                    time.sleep(100e-3)
                self._log.info("Finished soaking. Moving on...")
            else:
                self._log.info("Temperature is within range. Moving on...")
        else:
            if disable_exception:
                retval = False
            else:
                msg = "Temperature not within range when timeout occurred."
                raise Exception(msg)
        return retval

    def configure(
        self,
        mode: StecEnums.MODE,
        temp: float,
        window_k: float = 1.0,
        flowrate: float = 5.0,
        ramprate: float = 9999.0,
    ):
        """
        Convenience method to configure all essential aspects of the device.
        """
        self.parameter.Mode = mode
        self.parameter.SetPoint = temp
        self.parameter.Window = window_k
        self.parameter.FlowRate = flowrate
        self.parameter.RampRate = ramprate


def check_floating_range(llimit, ulimit, value, clip=False):
    """
    Check if value is within range including the limits.
    If clip is True the value will be clipped, otherwise an exception is raised.
    """
    # value = round(value, 1)
    if llimit <= value <= ulimit:
        return None
    elif clip:
        return max(llimit, min(ulimit, value))
    else:
        msg = f"Value ({value}) is out of valid input range ({llimit} - {ulimit})."
        raise Exception(msg)


class ThreadTemperatureLogger(threading.Thread):
    def __init__(self, drv: tsr2252, logpath: str, period: float = 1.0):
        threading.Thread.__init__(self)
        self.drv = drv
        self.logpath = logpath
        self.period = float(period)
        self._pause = False
        self._exit = False

        self.log = logging.Logger(self.drv.__class__.__name__ + "_" + self.__class__.__name__)
        self.log.setLevel(logging.INFO)
        self.fh = logging.FileHandler(logpath, "w")
        self.fh.setLevel(logging.INFO)
        self.fh.setFormatter(logging.Formatter("%(message)s"))
        self.log.addHandler(self.fh)
        self.log.info("Date;AirTemp;DutTemp")
        self.log.disabled = False

    def destroy(self):
        for h in self.log.handlers:
            self.log.removeHandler(h)
        self.log.handlers = []

    def run(self):
        self.log.disabled = False
        while not self._exit:
            try:
                if DEBUG:
                    self.log.info(f"{arrow.now()};{1.0};{2.0}")
                else:
                    self.log.info(f"{arrow.now()};{self.drv.parameter.AirTemp:.2f};{self.drv.parameter.DutTemp:.2f}")
            except Exception as e:
                self.drv._log.error("An exception occurred in ThreadTemperatureLogger thread: " + str(e))
            finally:
                time.sleep(self.period)

    def pause(self):
        self.log.disabled = True

    def stop(self):
        self._exit = True
        self.join(self.period * 1.5)
