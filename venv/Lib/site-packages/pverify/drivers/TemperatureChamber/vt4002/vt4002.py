from __future__ import annotations

from time import sleep

import arrow
import serial

from pverify.core.lab.driver_identity import *


class VT4002:
    def __init__(self):
        self.serial = None
        """:type : serial.Serial"""
        self.drivername = "VT4002"
        self.chamberaddress = "00"
        self.__Identity = IdentityBasic(
            fct_idn=lambda: "VT4002",
            fct_drv_rev=lambda: "unknown",
            fct_fw_rev=lambda: "unknown",
        )

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Initialized(self):
        return self.serial.isOpen() if self.serial else False

    def Initialize(self, ResourceName, IdQuery=1, Reset=0, **kwargs):
        self.serial = serial.Serial(ResourceName, baudrate=9600, timeout=1)
        self.serial.open()

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        self.serial.close()

    def Write(self, command):
        if self.Initialized:
            self.serial.write("$" + self.chamberaddress + command + "\r")
        else:
            msg = "Serial port not initialized!"
            raise Exception(msg)

    def Read(self):
        if self.Initialized:
            ret = self.serial.readline()
            return str(ret).strip()
        else:
            msg = "Serial port not initialized!"
            raise Exception(msg)

    def AutomaticProgramStart(self, number):
        self.Write("P%04d" % number)

    def AutomaticProgramStop(self):
        self.AutomaticProgramStart(0)

    def getTemperature(self):
        """
        :return: Tuple of (nominal temp, actual temp)
        :rtype: tuple[float]
        """
        self.Write("I")
        ret = self.Read()
        parts = ret.split(" ")
        return float(parts[0])

    def setTemperature(self, target_temp, gradient=999.9, wait_for_settle=True, margin=1.0, timeout=-1):
        """
        :return: Tuple of (nominal temp, actual temp)
        :rtype: tuple[float]
        """
        self.setTemperatureGradient(gradient)

        tempstring = (f"{target_temp:.1f}").zfill(6)
        self.Write(f"E {tempstring} 0000.0 0000.0 0000.0 0000.0 0101010100000100")
        ret = self.Read()
        if "0" not in ret:
            raise Exception("Error: " + ret)

        sleep(1)
        starttime = arrow.now()
        if wait_for_settle:
            while 1:
                curtemp = self.getTemperature()
                if (target_temp - margin) <= curtemp <= (target_temp + margin):
                    break
                sleep(10.0)
                elapsed = (arrow.now() - starttime).total_seconds()
                if timeout > 0 and elapsed >= timeout:
                    break

    def setTemperatureGradient(self, gradient):
        gradstring = (f"{gradient:.1f}").zfill(6)
        self.Write(f"U {gradstring} {gradstring} 0000.0 0000.0 0000.0 0000.0 0000.0 0000.0 0000.0 0000.0")
        ret = self.Read()
        if "0" not in ret:
            raise Exception("Error: " + ret)


#
# def set_temp(temp):
#     # sets the temperature as temp
#     ser = serial.Serial('/dev/ttyS0', 9600, timeout=1)
#     nominal_temp_string = "$00E " + temp + "\r"
#     ser.write(nominal_temp_string)
#     time.sleep(2)
#
#     '''verifying by reading the present nominal temperature and
#            compare it with the input temperature '''
#     ser.write("$00I\r\n")
#     line = ser.readline()
#     value = string.split(line, ' ')
#     if value[0] != "" and float(value[0]) == float(temp):
#         print
#         "Temperature set to " + value[0] + " successfully"
#     else:
#         print
#         "Error in setting temperature. Please check the setup"

# ser = serial.Serial('/dev/ttyS0', 9600, timeout=1)
# while True:
# 	ser.write("$00I\r\n")
# 	line = ser.readline()
# 	value = string.split(line, ' ')
# 	time.sleep(2)
