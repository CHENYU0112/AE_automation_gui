from __future__ import annotations

import inspect
import logging
import socket
import sys
import threading
import time
from enum import Enum
from multiprocessing import Lock
from pathlib import Path
from typing import TYPE_CHECKING, Any

import arrow
import pandas as pd

from pverify.core.lab.driver_identity import IdentityBasic
from pverify.core.util.decorators import synchronized
from pverify.drivers.TemperatureChamber.vt7021 import limits
from pverify.drivers.TemperatureChamber.vt7021.enums import VoetschEnums

if TYPE_CHECKING:
    from collections.abc import Iterable

DEFAULT_COMMUNICATION_TIMEOUT = 2  # Unit is seconds
LOCK = Lock()


class SimservProtocolError(Exception):
    """Raised when simserv response contained a non-okay error-code (something other than '1')."""


class InstrumentError(Exception):
    """Raised when requested instrument operation failed."""


SimservProtocolErrorMessages = {
    -1: "The receipt string was emtpy.",
    -2: "Missing chamber ID.",
    -3: "Chamber ID is in an invalid range.",
    -4: "Chamber not present.",
    -5: "Unknown command ID.",
    -6: "Too few or incorrect parameters.",
    -7: "No server (for server service functions).",
}


class Parameter:
    def __init__(self, parent: vt7021):
        self._parent = parent

    @property
    def SetPoint(self) -> float:
        """
        The temperature setpoint
        """
        self._parent._log.debug("fetching temperature setpoint")
        setpoint, act_temp = self._parent._get_temperature()
        time.sleep(self._parent._limits.IO_DELAY)
        self._parent._statecache["setpoint"] = setpoint
        return self._parent._statecache["setpoint"]

    @SetPoint.setter
    def SetPoint(self, value: float):
        """
        The temperature setpoint.
        """
        self._parent._log.debug("setting temperature setpoint")
        check_floating_range(self._parent._limits.TEMP_LOW, self._parent._limits.TEMP_HIGH, value)
        self._parent._set_temperature(value)
        time.sleep(self._parent._limits.IO_DELAY)
        self._parent._statecache["setpoint"] = value

    @property
    def Temp(self) -> float:
        """
        Get the dut temperature.
        """
        self._parent._log.debug("fetching actual temperature")
        setpoint, act_temp = self._parent._get_temperature()
        time.sleep(self._parent._limits.IO_DELAY)
        return act_temp


class Templogger:
    def __init__(self, parent: vt7021):
        self._parent = parent
        self._logpath = None

    def config(self, logpath: str | Path, period: float = 5):
        """
        Configures the temperature logger, which is periodically querying the actual and temperature setpoint values
        from the instrument in a background thread.

        This method has to be called when initially starting the logging or whenever the logger was stopped and shall
        be re-started.

        :param logpath: The path of the log file where the data is stored
        :param period: The waiting time between samples. Unit is seconds.
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._thread_templogger.destroy()
            del self._parent._thread_templogger
        self._parent._thread_templogger = ThreadTemperatureLogger(self._parent, logpath, period)
        self._logpath = logpath

    def start(self):
        """
        Start the temperature logging background process.
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._check_initialized()
            if not self._parent._thread_templogger.is_alive():
                try:
                    self._parent._thread_templogger.start()
                except RuntimeError:
                    msg = "You need to invoke Templogger.config() before you can use the start() method."
                    raise Exception(msg) from None
                self._parent._thread_templogger.log.disabled = False

    def pause(self):
        """
        Pauses the logging process (the background process still runs but the logging to file is disabled).
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._check_initialized()
            self._parent._thread_templogger.pause()

    def stop(self):
        """
        Stop the logging process.

        Please consider invoking Templogger.config(...) before starting the logging again.
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._thread_templogger.stop()

    def as_dataframe(self, logpath=None) -> pd.DataFrame:
        """
        Returns the logged temperature data as a Pandas dataframe

        :param logpath: The log file to parse. If None, the previously used logpath is used
        """
        if logpath is None and self._logpath is not None:
            logpath = self._logpath
        if logpath is None and self._logpath is None:
            msg = "No logpath provied."
            raise Exception(msg)
        # workaround for pandas read_csv() which can't deal with windows and utf-8 yet. using a filehandle works.
        with open(logpath) as fp:
            return pd.read_csv(fp, delimiter=";", converters={"Date": pd.to_datetime}, index_col=0)


class SimpatiCmds(str, Enum):
    """
    Command Codes for Simpati Protocol v4.4/v4.5(?)
    """

    # CAUTION: the command codes have to match the Simpati version of the control unit. Documentation regarding the
    # command sets is a major pain in the butt.
    CHAMBER_NAME = "10006"
    SET_SETPOINT = "11001"
    GET_SETPOINT = "11002"
    ACT_TEMPERATURE = "11004"
    HVAC = "14001"


class vt7021:
    """
    This instrument driver works for VÃ¶tsch/Weiss thermal chambers equipped with a SIMPAC control unit and an ethernet
    interface. It's only tested with the 7021 model but should work with other models of the same family which only
    differ with regard to their performance characteristics. It will likely not work with FW versions other than v4.50
    (Simpati Server) because the command set and ids are probably incompatible.
    """

    def __init__(self, logger: logging.Logger | None = None):
        self.__initialized = False
        self._sim: bool = False
        self._chamberaddress = "01"
        self._ip = None
        self._port = None
        self._TYPE: VoetschEnums.TYPES = None

        self._SIMSERV_SEPERATOR = "\xb6"

        if isinstance(logger, logging.Logger):
            self._log = logger
        else:
            self._log = logging.getLogger(self.__class__.__name__)
            if len(self._log.handlers) == 0:  # only add streamhandler if none exists
                self._log.addHandler(logging.StreamHandler(sys.stdout))
            self._log.setLevel(logging.INFO)
        self._thread_templogger = None  # type: ThreadTemperatureLogger

        self._TYPE = VoetschEnums.TYPES.VT7021
        self._limits = limits.LIMITS_VT7021
        self._statecache = {
            "setpoint": 0.0,
        }

        self.__Identity = IdentityBasic(
            fct_idn=lambda: "VT7021", fct_drv_rev=lambda: "unknown", fct_fw_rev=lambda: "unknown"
        )
        self.__parameter = Parameter(parent=self)
        self.__Templogger = Templogger(parent=self)

        # ensures that all socket connections created by the driver use the same blocking-timeout-mode
        socket.setdefaulttimeout(DEFAULT_COMMUNICATION_TIMEOUT)

        self._last_access_time = time.perf_counter()

    def __repr__(self):
        limits, _ = inspect.getsourcelines(self._limits)
        return "Temperature Chamber Limits:\n" + "".join(limits[1:])

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Templogger(self):
        """
        Returns a pointer to the Templogger subclass
        """
        return self.__Templogger

    @property
    def parameter(self):
        """
        Returns a pointer to the parameter subclass
        """
        return self.__parameter

    def _check_initialized(self):
        if not self.__initialized:
            msg = "Driver is not initialized!"
            raise Exception(msg)

    def Initialize(
        self,
        ResourceName: str = "192.168.0.55:2049",
        IdQuery: int = False,
        Reset: int = False,
        OptionString: str = "",
    ):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally validates the instrument model.

        :param ResourceName: Only TCP/IP is implemented. Expects IP address and port, separated by colon.
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :param Reset: Specifies whether to reset the instrument.
        :param OptionString: Initialization options: "chamberaddr=("00"|"01"|"02"|...)"
        """

        if self.__initialized:
            self._log.debug("Already initialized. Skipping.")
            return

        if "simulate=true" in OptionString.lower():
            self._sim = True
            ResourceName = "192.168.0.55:2049"
            self._log.info("Instrument simulation activated!")
        if "chamberaddr" in OptionString.lower():
            key, value = OptionString.split("=")
            self._chamberaddress = value

        if IdQuery:
            msg = "IdQuery is not implemented yet."
            raise NotImplementedError(msg)

        try:
            self._ip, self._port = ResourceName.split(":")
        except ValueError:
            msg = f"Expected resource name in the form: '<ip-address>:<portnumber>'. Got '{ResourceName}' instead."
            raise InstrumentError(msg) from None
        self._port = int(self._port)

        # verify remote connection works by querying a predictable attribute remotely
        expected_chamber_name = "SimPac"
        actual_chamber_name = self._simserv_query_single(SimpatiCmds.CHAMBER_NAME)

        if actual_chamber_name == expected_chamber_name or self._sim:
            self.__initialized = True
            self._log.info(f"Successfully connected to Temperature Chamber (#{self._chamberaddress}) @ {ResourceName}")
        else:
            self._log.error(f"Failed to connect to Temperature Chamber (#{self._chamberaddress}) @ {ResourceName}")
            return

        if Reset:
            msg = "Reset is not supported by this instrument."
            raise NotImplementedError(msg)

        # Initialize statecache
        self._update_statecache()

    def _io_rate_limit(self):
        """This method implements a ratelimiting mechanism to ensure the instrument processes every command."""
        now = time.perf_counter()
        if (self._last_access_time + self._limits.IO_DELAY) > now:
            self._log.debug(f"io rate limit active. minimum delay between requests is: {self._limits.IO_DELAY} s.")
            time.sleep(self._limits.IO_DELAY)

    @synchronized(LOCK)
    def _raw_ascii2_write(self, message: str):
        """Write a string message to the instrument.

        The write_termination is always appended to it.

        :param message: the message to be sent.
        :return: number of bytes written.
        """
        termination = "\r"
        encoding = "utf-8"
        self._io_rate_limit()
        cmd = f"${self._chamberaddress}{message}{termination}".encode(encoding)
        self._log.debug(f"sending:\t'{cmd}'")
        if not self._sim:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.connect((self._ip, self._port))
                sock.sendall(cmd)
        self._last_access_time = time.perf_counter()

    @synchronized(LOCK)
    def _raw_read(self):
        """Read a message from the instrument."""
        recvbuffersize = 4096
        self._io_rate_limit()

        if self._sim:
            resp = b""
        else:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.connect((self._ip, self._port))
                resp = sock.recv(recvbuffersize)
        self._last_access_time = time.perf_counter()
        return resp.decode()

    @synchronized(LOCK)
    def _ascii2_query(self, message: str) -> str:
        """
        Sends a command using the proprietary ASCII-2 protocol and returns the response.

        :param message: the message to send.
        :returns: the answer from the device.
        """

        recvbuffersize = 4096
        termination = "\r"
        self._io_rate_limit()
        cmd = f"${self._chamberaddress}{message}{termination}".encode()
        self._log.debug(f"sending (ASCII-2 protocol):\t'{cmd}'")

        if self._sim:
            resp = b" \r"
        else:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.connect((self._ip, self._port))
                sock.sendall(cmd)
                resp = sock.recv(recvbuffersize)

        self._log.debug(f"receiving (ASCII-2 protocol):\t'{resp.decode()}'")
        self._last_access_time = time.perf_counter()
        return resp.decode()

    def _simserv_query(self, cmd: str, *args) -> list[str | None]:
        """
        Sends a command using the simserv protocol and returns the (multi-value) response.

        :param cmd: simserv command
        :param *args: Arguments to simserv command, if any
        :returns: The (multi-value) response to the query
        """

        argstr = self._simserv_stringify_args(args)
        cmd = f"{cmd}{self._SIMSERV_SEPERATOR}{self._chamberaddress}{self._SIMSERV_SEPERATOR}{argstr}\r".encode(
            "latin_1"
        )
        self._log.debug(f"sending (simserv protocol): '{cmd}'")
        self._io_rate_limit()

        if self._sim:
            resp = f"1{self._SIMSERV_SEPERATOR}42\r\n".encode("latin_1")
        else:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.connect((self._ip, self._port))
                sock.settimeout(5)
                sock.sendall(cmd)
                resp = sock.recv(4096)
        cooked_response = self._simserv_parse_response(resp)
        self._last_access_time = time.perf_counter()
        self._log.debug(f"receiving (simserv protocol): '{cooked_response}'")
        return cooked_response

    def _simserv_query_single(self, cmd: str, *args, ip: str | None = None, port: str | None = None) -> str | None:
        """
        Sends a command using the simserv protocol and returns a single-value response.

        :param cmd: simserv command
        :param *args: Arguments to simserv command, if any
        :param ip: Instruments server IP address
        :param port: Instruments server port number
        :returns: The single-value response to the query
        """

        result, *junk = self._simserv_query(cmd, *args, ip, port)
        self._log.debug(f"query single: '{result}'")
        return result

    def _simserv_stringify_args(self, args: Iterable[Any]):
        """
        Create string from args with simserv separation characters in place.

        :param args: Any number of arguments.
        :return: A single string containing all arguments seperated by simserv seperation character.
        """
        args = [str(arg) for arg in args]
        return self._SIMSERV_SEPERATOR + f"{self._SIMSERV_SEPERATOR}".join(args)

    def _simserv_parse_response(self, resp: bytes) -> list[str | None]:
        """
        Parse raw response of simserv command.

        :param resp: Raw response from the server.
        :return: Medium cooked response payload
        :raises: SimservProtocolError: if malformed request was received by the server.
        """
        decoded_resp = resp.decode(encoding="latin_1").rstrip("\r\n").split(self._SIMSERV_SEPERATOR)
        error_code, *payload = decoded_resp

        try:
            error_msg = SimservProtocolErrorMessages[int(error_code)]
            msg = f"Server complained about invalid request: {error_msg}"
            raise SimservProtocolError(msg)
        except KeyError:
            pass  # the error code is '1' which is means 'all good'

        return payload

    def _update_statecache(self):
        _ = self.parameter.SetPoint
        _ = self.parameter.Temp

    def _get_temperature(self) -> tuple[float, float]:
        """
        Fetch temperatures from the instrument.

        :return: Tuple (setpoint, actual temperature)
        :raises: InstrumentError, if the temperature query failed
        """

        self._check_initialized()

        try:
            setp = self._simserv_query_single(SimpatiCmds.GET_SETPOINT, "1")
            act_temp = self._simserv_query_single(SimpatiCmds.ACT_TEMPERATURE, "1")
        except SimservProtocolError as ex:
            msg = f"Failed to query temperature: {ex}"
            raise InstrumentError(msg) from ex

        return float(setp), float(act_temp)

    def _set_temperature(self, temperature: float):
        """
        Set temperature of instrument.
        :param temperature: Target temperature in degC.
        """

        self._check_initialized()

        try:
            self._simserv_query(SimpatiCmds.SET_SETPOINT, "1", temperature)
        except SimservProtocolError as ex:
            msg = f"Failed to set temperature: {ex}"
            raise InstrumentError(msg) from ex

    def enable(self):
        """Enable hvac unit."""

        self._log.debug("enabling hvac")
        self._check_initialized()
        try:
            self._simserv_query(SimpatiCmds.HVAC, "1", "1")
        except SimservProtocolError as ex:
            msg = f"Failed to enable hvac unit: {ex}"
            raise InstrumentError(msg) from ex

    def disable(self):
        """Disable hvac unit."""

        self._log.debug("disabling hvac")
        self._check_initialized()
        try:
            self._simserv_query(SimpatiCmds.HVAC, "1", "0")
        except SimservProtocolError as ex:
            msg = f"Failed to disable hvac unit: {ex}"
            raise InstrumentError(msg) from ex

    def Close(self):
        self._check_initialized()
        self.__initialized = False

    @property
    def Enums(self):
        return VoetschEnums

    @property
    def Initialized(self):
        return self.__initialized

    def WaitForTemp(
        self,
        timeout_s: float,
        target: float,
        window_k: float = 1,
        soaktime_m: float = 1,
        shutdown_chamber: bool = False,
        disable_exception: bool = False,
    ) -> bool:
        """
        This method is useful if you want a blocking wait until a temperature is reached. Every parameter
        is optional except for timeout_s. Every 100ms the temperature is checked if in range. If not within
        range after timeout an exception is raised.

        :param timeout_s: Timeout in seconds.
        :param target: Target temperature.
        :param window_k: Accepted window around target in Kelvin.
        :param soaktime_m: Time in minutes to wait after target is reached.
        :param shutdown_chamber: If True then heating/cooling unit will be turned off at the end.
        :param disable_exception: If False then exception is raised on timeout, if True then no exception will be raised and False is returned.
        :returns: Returns True if temperature in range before timeout and False otherwise only if exceptions are disabled.
        :raises: TimeoutError, if timeout was exceeded and exceptions not disabled.
        """

        # if target is not None set temperature.
        if target is not None:
            self.parameter.SetPoint = target

        self.enable()

        # check temp periodically
        time_start = time.time()
        if self._sim:
            self._log.info("Simulation mode: Fast forward by a factor of 5")
            timeout_s = timeout_s / 5
        timeout_abs = time_start + timeout_s

        interval = 0.10
        progress = 0.0
        self._log.info(
            f"Waiting for temperature to reach {target} +/-{window_k} C within {timeout_s / 60:.1f} minutes."
        )
        while True:
            # log progress
            cur_temp = self.parameter.Temp
            if self._sim:
                cur_temp = progress * target
            elapsed = time.time() - time_start
            if time.time() > (time_start + (progress * timeout_s)):
                self._log.info(
                    f"\t... current temperature: {cur_temp} C, {elapsed / 60:.1f}/{timeout_s/60:.1f} minutes passed."
                )
                progress += interval

            # check if temp in range
            try:
                check_floating_range(
                    llimit=(self._statecache["setpoint"] - window_k),
                    ulimit=(self._statecache["setpoint"] + window_k),
                    value=cur_temp,
                    clip=False,
                )
                within_range = True
                self._log.info("Temperature is within range.")
            except Exception:
                within_range = False
            if time.time() > timeout_abs or within_range:
                break
            time.sleep(500e-3)

        # when in target range, soak and log progress
        if within_range:
            retval = True
            if soaktime_m is not None:
                self._log.info(f"Soaking for {soaktime_m} minute(s)...")
                time_start = time.time()
                timeout_abs = time_start + soaktime_m * 60.0
                interval = 0.20
                progress = 0.0
                while True:
                    if self._sim:
                        break
                    elapsed = time.time() - time_start
                    if time.time() > (time_start + (progress * soaktime_m * 60.0)):
                        self._log.info(f"\t... soaking {elapsed / 60:.1f}/{soaktime_m:.1f}.")
                        progress += interval
                    if time.time() > timeout_abs:
                        break
                    time.sleep(100e-3)
                self._log.info("Finished soaking. Moving on...")
            else:
                self._log.info("Temperature is within range. Moving on...")

            if shutdown_chamber:
                self._log.info("Shutting down the chamber.")
                self.disable()
        else:
            if disable_exception:
                retval = False
            else:
                msg = "Temperature not within range when timeout occurred."
                raise TimeoutError(msg)
        return retval

    def safe_shutdown(self, timeout_m: float = 120, target: float = 25, shutdown_chamber: bool = True):
        """
        Use this method to safely shut down the thermal chamber at the end or when
        errors occur in your test program. If you want more flexibility use `WaitForTemp()`
        instead.

        :param timeout_m: Timeout. Unit is minutes.
        :param target: Target temperature. Unit is degC.
        :param shutdown_chamber: If True, then heating/cooling unit will be turned off at the end.
        """
        timeout_s = timeout_m * 60
        soaktime_m = 2
        if self._sim:
            self._log.info("Simulation Mode: reduce safe shutdown time to 10 seconds.")
            timeout_s = 50
            soaktime_m = 0
        self.WaitForTemp(
            timeout_s=timeout_s,
            target=target,
            window_k=2,
            soaktime_m=soaktime_m,
            shutdown_chamber=shutdown_chamber,
            disable_exception=False,
        )


def check_floating_range(llimit, ulimit, value, clip=False):
    """
    Check if value is within range including the limits.
    If clip is True the value will be clipped, otherwise an exception is raised.
    """
    # value = round(value, 1)
    if llimit <= value <= ulimit:
        return None
    elif clip:
        return max(llimit, min(ulimit, value))
    else:
        msg = f"Value ({value}) is out of valid input range ({llimit} - {ulimit})."
        raise Exception(msg)


class ThreadTemperatureLogger(threading.Thread):
    def __init__(self, drv: vt7021, logpath: str, period: float = 5.0):
        threading.Thread.__init__(self, daemon=True)
        self.drv = drv
        self.logpath = logpath
        self.period = float(period)
        self._pause = False
        self._exit = False

        self.log = logging.Logger(self.drv.__class__.__name__ + "_" + self.__class__.__name__)
        self.log.setLevel(logging.INFO)
        self.fh = logging.FileHandler(logpath, "w")
        self.fh.setLevel(logging.INFO)
        self.fh.setFormatter(logging.Formatter("%(message)s"))
        self.log.addHandler(self.fh)
        self.log.info("Date;Setpoint;ActualTemperature")
        self.log.disabled = False

    def destroy(self):
        for h in self.log.handlers:
            self.log.removeHandler(h)
        self.log.handlers = []

    def run(self):
        self.log.disabled = False
        now = arrow.now()
        setpoint, act_temp = (-999, -999)
        while not self._exit:
            try:
                if self.drv._sim:
                    self.log.info(f"{arrow.now()};{1.0};{2.0}")
                else:
                    now = arrow.now()
                    setpoint, act_temp = self.drv._get_temperature()
                    self.log.info(f"{now};{setpoint};{act_temp}")
            except Exception as e:
                self.drv._log.error("An exception occured in ThreadTemperatureLogger thread: " + str(e))
                self.drv._log.error(f"now: {now}, setpoint: {setpoint}, act_temp: {act_temp}")
            finally:
                time.sleep(self.period)

    def pause(self):
        self.log.disabled = True

    def stop(self):
        self._exit = True
        self.join(self.period * 1.5)


if __name__ == "__main__":
    import logging

    logging.basicConfig(stream=sys.stdout, level=logging.INFO, format="[%(name)s:%(levelname)-8s] -> %(message)s")
    logger = logging.getLogger("vt7021")
    logger.setLevel(logging.DEBUG)

    thermo = vt7021(logger=logger)
    thermo.Initialize(ResourceName="192.168.0.55:2049", IdQuery=False, Reset=False, OptionString="simulate=False")
    logger.info(thermo)

    # Set temperature
    thermo.parameter.SetPoint = 42
    rb = thermo.parameter.SetPoint
    logger.info(rb)
    assert rb == 42

    # Read temperature
    rb = thermo.parameter.Temp
    logger.info(rb)
    assert thermo._limits.TEMP_LOW <= rb <= thermo._limits.TEMP_HIGH

    # Convenience: Log temperature over time into a dataframe
    thermo.Templogger.config(
        logpath=Path(rf"C:\temp\vt721_temperature_log_{arrow.now().strftime('%Y_%m_%d_%H%M%S')}.csv"), period=5
    )
    thermo.Templogger.start()

    # Convenience: Wait for a certain temperature with optional soaktime
    thermo.WaitForTemp(timeout_s=60 * 5, target=30, soaktime_m=0.2, shutdown_chamber=False)

    # Convenience: plot temperature log
    thermo.Templogger.stop()
    df = thermo.Templogger.as_dataframe()
    print(df)
    df.plot()

    # Convenience: ensure the oven is brought back to room temperature and the hvac is turned off
    thermo.safe_shutdown()
