# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
"""
Module docstring
"""

from __future__ import annotations

import logging
from math import fabs
from time import sleep

import arrow
import serial

from pverify.core.lab.driver_identity import *

STX = 0x2
ETX = 0x3
TEMP = 0x30 | 0x80
DOT = 0x2E | 0x80
SPACE = 0x20 | 0x80
MINUS = 0x2D | 0x80
SET_TEMP = 0xE1
SET_GRAD_P = 0xF5
SET_GRAD_N = 0xE4
SET_DIG_PARAM = 0xF3
READ_TEMP = 0xC1
ON_OFF_SWITCH = 0xB1
DIG_OUT_ON = 0xB1
DIG_OUT_OFF = 0xB0


N_TRIES = 8
address = 0x81

T_LIM_MIN = -80
T_LIM_MAX = 180


SIMULATE = False


class CTST6550:
    """
    bla
    """

    def __init__(self):
        self.drivername = "CTST6550"
        self.interface = None
        self.__Initialized = False
        self._Log = logging.getLogger("driverLog")

    def Initialize(self, ResourceName, IdQuery=0, Reset=0, OptionString=""):
        if not SIMULATE:
            self.interface = serial.Serial(
                port=ResourceName,
                baudrate=19200,
                parity=serial.PARITY_ODD,
                stopbits=serial.STOPBITS_ONE,
                timeout=100,
            )
        self.__Initialized = True
        self.__Identity = IdentityBasic(
            fct_idn=lambda: "CTS T 6550",
            fct_drv_rev=lambda: "unknown",
            fct_fw_rev=lambda: "unknown",
        )

    @property
    def Identity(self):
        return self.__Identity

    def Close(self):
        if self.__Initialized and not SIMULATE:
            self.interface.close()
            self.__Initialized = False

    def _ask(self, command, answerLenght):
        """
        Sends a command (as bytearray) to the chamber and asks for exactly answerLength bits.
        Raises an error if the returned length of the bytearray differs from answerLength.
        """
        self.interface.write(command)
        answ = bytearray(self.interface.read(answerLenght))
        if len(answ) == answerLenght:
            return answ
        else:
            self._Log.error(
                "ValueError: Device answered less (%d) bytes than expected (%d)." % (len(answ), answerLenght)
            )
            raise ValueError("Device answered less (%d) bytes than expected (%d)." % (len(answ), answerLenght))

    def Start(self):
        """
        Switches on the installation.
        """
        if not SIMULATE:
            cmd = bytearray([STX, address, SET_DIG_PARAM, ON_OFF_SWITCH, SPACE, DIG_OUT_ON, ETX])
            insert_CHK(cmd)

            for _tries in range(N_TRIES):
                try:
                    answ = self._ask(cmd, 6)
                    if answ[2] == SET_DIG_PARAM:
                        return
                except ValueError:
                    pass
            msg = "Could not start!"
            raise Exception(msg)

    def Stop(self):
        """
        Switches off the installation.
        """
        if not SIMULATE:
            cmd = bytearray([STX, address, SET_DIG_PARAM, ON_OFF_SWITCH, SPACE, DIG_OUT_OFF, ETX])
            insert_CHK(cmd)

            for _tries in range(N_TRIES):
                try:
                    answ = self._ask(cmd, 6)
                    if answ[2] == SET_DIG_PARAM:
                        return
                except ValueError:
                    pass
            raise e

    def Reset(self):
        """
        Stops the heating/cooling and resets the temperature gradient to maximum 999.9.
        """
        if not SIMULATE:
            self.Stop()
            self.setTemperatureGradient(999.9)

    def getTemperature(self):
        """
        Returns the current temperature in the chamber.
        """
        if not SIMULATE:
            cmd = bytearray([STX, address, READ_TEMP, TEMP, ETX])
            insert_CHK(cmd)

            for _tries in range(N_TRIES):
                try:
                    answ = self._ask(cmd, 18)
                    if answ[5] == MINUS:
                        return -((answ[6] & 0xF) * 10 + (answ[7] & 0xF) + ((answ[9] & 0xF) / 10))
                    else:
                        return (answ[5] & 0xF) * 100 + (answ[6] & 0xF) * 10 + (answ[7] & 0xF) + ((answ[9] & 0xF) / 10)
                except ValueError:
                    pass
            msg = "Could not get temperature"
            raise Exception(msg)
        else:
            return 23.7

    def setTemperature(self, target_temp, gradient=999.9, wait_for_settle=True, margin=1.0, timeout=-1):
        """
        Sets a target temperature and starts heating/cooling.
        If aktivated the function waits for the temperature to be settled within a specific margin.
        :param target_temp: The target temperature.
        :param gradient: The gradient in K/minute the temperature rises/decreases.
        :param wait_for_settle: If True the method waits for be settled within a specific margin
        :param margin: The difference between measured temperate and target temperature that is accepted for the
                       settling to be finished.
        :param timeout: The maximum time in seconds the function waits (if activated) for setting the temperature.
        :return: None
        """
        if not SIMULATE:
            if 0 <= target_temp <= T_LIM_MAX:
                temp_bArray = bytearray((f"{target_temp:03.1f}").zfill(5))
            elif T_LIM_MIN <= target_temp < 0:
                temp_bArray = bytearray((f"{target_temp:02.1f}").zfill(4))
            else:
                self._Log.error("Temperature limits (%d to %d) exceeded." % (T_LIM_MIN, T_LIM_MAX))
                raise ValueError("Temperature limits (%d to %d) exceeded." % (T_LIM_MIN, T_LIM_MAX))

            self.setTemperatureGradient(gradient)

            if target_temp < 0:
                cmd = bytearray(
                    [
                        STX,
                        address,
                        SET_TEMP,
                        TEMP,
                        SPACE,
                        MINUS,
                        temp_bArray[1] % 0x80,
                        temp_bArray[2] % 0x80,
                        DOT,
                        temp_bArray[4] % 0x80,
                        ETX,
                    ]
                )
            else:
                cmd = bytearray(
                    [
                        STX,
                        address,
                        SET_TEMP,
                        TEMP,
                        SPACE,
                        temp_bArray[0] % 0x80,
                        temp_bArray[1] % 0x80,
                        temp_bArray[2] % 0x80,
                        DOT,
                        temp_bArray[4] % 0x80,
                        ETX,
                    ]
                )
            insert_CHK(cmd)

            started = False
            for _tries in range(N_TRIES):
                try:
                    answ = self._ask(cmd, 5)
                    if answ[2] == SET_TEMP:
                        self.Start()
                        started = True
                        break
                except ValueError:
                    pass

            if not started:
                msg = "Could not start"
                raise Exception(msg)

            if not wait_for_settle and started:
                return
            else:
                readTemp = self.getTemperature()
                if timeout < 0:
                    while fabs(readTemp - target_temp) > margin:
                        sleep(10)
                        readTemp = self.getTemperature()
                    return
                else:
                    startTime = arrow.now()
                    while fabs(readTemp - target_temp) > margin and (arrow.now() - startTime).seconds < timeout:
                        sleep(2)
                        readTemp = self.getTemperature()
                    if fabs(readTemp - target_temp) > margin:
                        return
                    else:
                        msg = f"The temperature could not be set within the specified timeout.({timeout} s)"
                        raise Exception(msg)

    def setTemperatureGradient(self, gradient):
        """
        Sets the temperature gradient for heating and cooling in K/minute.
        :param gradient: The temperature gradient in K/minute.
        :type gradient: float
        """
        if not SIMULATE:
            if 0.1 < gradient <= 999.9:
                grad_bArray = bytearray((f"{gradient:03.1f}").zfill(5))
            else:
                msg = "Gradient must be a value between 0.1 and 999.9 K/min"
                raise ValueError(msg)

            cmd = bytearray(
                [
                    STX,
                    address,
                    SET_GRAD_P,
                    TEMP,
                    SPACE,
                    grad_bArray[0] % 0x80,
                    grad_bArray[1] % 0x80,
                    grad_bArray[2] % 0x80,
                    DOT,
                    grad_bArray[4] % 0x80,
                    ETX,
                ]
            )
            insert_CHK(cmd)

            statusP = False
            for _tries in range(N_TRIES):
                try:
                    answ = self._ask(cmd, 5)
                    if answ[2] == SET_GRAD_P:
                        statusP = True
                        break
                    statusP = False
                except ValueError:
                    pass
            if not statusP:
                msg = "Could not set pos. temperature gradient!"
                raise Exception(msg)

            cmd = bytearray(
                [
                    STX,
                    address,
                    SET_GRAD_N,
                    TEMP,
                    SPACE,
                    grad_bArray[0] % 0x80,
                    grad_bArray[1] % 0x80,
                    grad_bArray[2] % 0x80,
                    DOT,
                    grad_bArray[4] % 0x80,
                    ETX,
                ]
            )
            insert_CHK(cmd)

            answ = bytearray()
            for _tries in range(N_TRIES):
                try:
                    answ = self._ask(cmd, 5)
                    if answ[2] == SET_GRAD_N and statusP:
                        return
                except ValueError:
                    pass
            if not statusP:
                msg = "Could not set neg. temperature gradient!"
                raise Exception(msg)


def insert_CHK(byte_array):
    """
    Calculates the XOR result of byte_array[1] to byte_array[-1] and inserts it at byte_array[-1].
    :param byte_array: The byte array that is manipulated.
    """
    byte_array.insert(-1, xor_bytearray(byte_array[1:-1]))


def xor_bytearray(byte_array):
    """
    Returns all elements of byte_array XORed.
    :param byte_array: The byte array wich is used to calculate the XOR.
    :return: XOR result.
    """
    if byte_array is None:
        msg = "Parameter 'byte_array' is None."
        raise Exception(msg)
    elif len(byte_array) == 0:
        msg = "Parameter 'byte_array' is empty."
        raise Exception(msg)
    elif len(byte_array) == 1:
        return byte_array[0]
    elif len(byte_array) >= 2:
        result = byte_array[0]
        for i in range(len(byte_array) - 1):
            result ^= byte_array[i + 1]
        return result
    return None
