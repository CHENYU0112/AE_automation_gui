from __future__ import annotations

import contextlib
import inspect
import logging
import os
import re
import sys
import threading
import time
from multiprocessing import Lock

import arrow
import pandas as pd
from pyvisa import ResourceManager

from pverify.core.lab.driver_identity import Identity_SCPI, IdentityABC
from pverify.core.util.decorators import synchronized

from . import limits
from .enums import TemptronicEnums, key_by_value

DEF_NUM = -999
DEBUG = 0
ESE = 0b00111100
IDN_MATCH_ATS700 = re.compile("TEMPTRONIC, ?ATS-7.*.*")
IDN_MATCH_ATS_545_645 = re.compile("TEMPTRONIC, ?ATS-(545|645).*")
IDN_MATCH_TP04310 = re.compile("TEMPTRONIC, ?TP043.*")
LOCK = Lock()


class CommandError(Exception):
    pass


class ExecutionError(Exception):
    pass


class DeviceDependentError(Exception):
    pass


class QueryError(Exception):
    pass


class Parameter:
    def __init__(self, parent):
        """
        :type parent: temptronic_ats_tp
        """
        self._parent = parent

    @property
    def Mode(self) -> TemptronicEnums.MODE:
        """
        Set the temperature control mode.
        """
        if DEBUG:
            return self._parent._statecache["mode"]
        self._parent._statecache["mode"] = key_by_value(TemptronicEnums.MODE, int(self._parent._query("DUTM?")))
        return self._parent._statecache["mode"]

    @Mode.setter
    def Mode(self, mode: TemptronicEnums.MODE):
        """
        Set the temperature control mode.
        """
        if mode in TemptronicEnums.MODE:
            if mode == TemptronicEnums.MODE.TC_METER and self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:
                msg = "Setting control to TC-Meter is only supported with ATS700 or ATS800 series!"
                raise NotImplementedError(msg)
            self._parent._write(f"DUTM {mode.value:d}")
            self._parent._statecache["mode"] = mode
        else:
            msg = "Unsupported mode!"
            raise ValueError(msg)

    @property
    def Sensor(self) -> TemptronicEnums.SENSOR:
        """
        Set the temperature control mode.
        """
        self._parent._statecache["sensor"] = key_by_value(TemptronicEnums.SENSOR, int(self._parent._query("DSNS?")))
        return self._parent._statecache["sensor"]

    @Sensor.setter
    def Sensor(self, mode: TemptronicEnums.SENSOR):
        """
        Set the temperature control mode.
        """
        self._parent._write("DSNS " + str(mode.value))
        self._parent._statecache["sensor"] = mode

    @property
    def AirTemp(self) -> float:
        """
        The air temperature without offset.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("TMPA?"))

    @property
    def DutTemp(self) -> float:
        """
        The DUT temperature without offset.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("TMPD?"))

    @property
    def SetPoint(self) -> float:
        """
        The temperature setpoint
        """
        if DEBUG:
            return self._parent._statecache["setpoint"]
        self._parent._statecache["setpoint"] = float(self._parent._query("SETP?"))
        return self._parent._statecache["setpoint"]

    @SetPoint.setter
    def SetPoint(self, value: float):
        """
        The temperature setpoint
        """
        check_floating_range(self._parent._limits.TEMP_LOW, self._parent._limits.TEMP_HIGH, value)
        self._parent._write("SETP " + f"{value:.1f}")
        self._parent._statecache["setpoint"] = value

    @property
    def Temp(self) -> float:
        """
        Get the dut temperature without offset. It returns the temp corresponding to the active mode eg. dut, air, etc.
        """
        if DEBUG:
            return DEF_NUM
        return float(self._parent._query("TEMP?"))

    @property
    def Window(self) -> float:
        """
        The temperature window the Thermostream should try to stay in and use as acceptance criteria.

        Example: given value is 1.0 results in a window of setpoint - 1.0 and setpoint + 1.0 creating
        an effective range of 2.0 (째C) around the setpoint.
        """
        if DEBUG:
            return self._parent._statecache["window"]
        self._parent._statecache["window"] = float(self._parent._query("WNDW?"))
        return self._parent._statecache["window"]

    @Window.setter
    def Window(self, value: float):
        """
        The temperature window the Thermostream should try to stay in and use as acceptance criteria.

        Example: given value is 1.0 results in a window of setpoint - 1.0 and setpoint + 1.0 creating
        an effective range of 2.0 (째C) around the setpoint.
        """
        check_floating_range(self._parent._limits.WINDOW_LOW, self._parent._limits.WINDOW_HIGH, value)
        self._parent._write(f"WNDW {value:.1f}")
        self._parent._statecache["window"] = value

    @property
    def RampRate(self) -> float:
        """
        Ramp rate of the device
        """
        if DEBUG:
            return self._parent._statecache["ramp_rate"]
        # Workaround for firmware bug when querying the ramprate on the TP04310.
        # All Rampvalues below 100 will be reported as one tenth of the actual value on the instruments display.
        response = float(self._parent._query("RAMP?"))
        if self._parent._TYPE == TemptronicEnums.TYPES.TP04310 and response < 10:
            response *= 10
        self._parent._statecache["ramp_rate"] = response
        return self._parent._statecache["ramp_rate"]

    @RampRate.setter
    def RampRate(self, value: float | int):
        """
        Ramp rate of the device
        """
        check_floating_range(self._parent._limits.RATE_LOW, self._parent._limits.RATE_HIGH, value)
        self._parent._write(f"RAMP {value:.1f}" if value <= 100 else f"RAMP {value:.0f}")
        self._parent._statecache["ramp_rate"] = value

    @property
    def FlowRate(self) -> float:
        """
        Flow rate of the device in l/s.
        """
        if DEBUG:
            return self._parent._statecache["flow_rate"]
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:
            msg = "Querying the flowrate is only supported with ATS700 or ATS800 series!"
            raise NotImplementedError(msg)
        else:
            self._parent._statecache["flow_rate"] = limits.scfm_to_lps(float(self._parent._query("FLSE?")))
            return self._parent._statecache["flow_rate"]

    @FlowRate.setter
    def FlowRate(self, value: float | int):
        """
        Flow rate of the device in l/s.
        """
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:  # Property setter only supported by ATS700/800
            msg = "Setting the flow rate is only supported with ATS700 or ATS800 series!"
            raise NotImplementedError(msg)
            # ToDo: Check if ATS 545 supports setting the flow rate. The datasheet says so but the remote manual lists no comand for it
        else:
            scfm = limits.lps_to_scfm(value)
            check_floating_range(self._parent._limits.FLOW_LOW, self._parent._limits.FLOW_HIGH, value)
            self._parent._write(f"FLSE {scfm:.0f}")
            self._parent._statecache["flow_rate"] = value

    @property
    def FlowState(self) -> bool:
        """
        The flow valve of the device. Head needs to be in the lower position for this to have an effect.
        """
        if DEBUG:
            return self._parent._statecache["flow_state"]
        self._parent._statecache["flow_state"] = bool(int(self._parent._query("FLOW?")))
        return self._parent._statecache["flow_state"]

    @FlowState.setter
    def FlowState(self, value: bool):
        """
        The flow valve of the device. Head needs to be in the lower position for this to have an effect.
        """
        value = bool(value)
        if value:
            if self.HeadPosition == TemptronicEnums.HEAD_POS.UP:
                msg = "Head needs to be lowered first before flow can be set to True."
                raise Exception(msg)
            else:
                self._parent._write("FLOW 1")
        else:
            self._parent._write("FLOW 0")
        self._parent._statecache["flow_state"] = value

    @property
    def CompressorState(self) -> bool:
        """
        Set the compressor state of the device. Turning the compressor on takes ~1 minute, turning off about ~1s.

        If the flow state is ON when enabling the compressor, the flow is disabled during compressor startup.
        """
        if DEBUG:
            return self._parent._statecache["compressor_state"]
        self._parent._statecache["compressor_state"] = bool(int(self._parent._query("COOL?")))
        return self._parent._statecache["compressor_state"]

    @CompressorState.setter
    def CompressorState(self, state: bool):
        """
        Set the compressor state of the device. Turning the compressor on takes ~1 minute, turning off about ~1s.

        If the flow state is ON when enabling the compressor, the flow is disabled during compressor startup.
        """
        state = bool(state)

        if state != self.CompressorState:
            if state:
                # apparently you can't turn on the compressor while the flow is on.
                if self.FlowState:
                    self.FlowState = False
                    self._parent._write("COOL 1")
                    self.FlowState = True
                else:
                    self._parent._write("COOL 1")
                # the instrument needs a minute to start the compressor
                if not DEBUG:
                    time.sleep(61)
            else:
                self._parent._write("COOL 0")
                time.sleep(1)

        # update state variable
        self._parent._statecache["compressor_state"] = state

    @property
    def CompressorTimerRemaining(self) -> int:
        """
        The remaining time in minutes the compressor is switched off by timer
        """
        if DEBUG:
            return self._parent._statecache["compressor_timer"]
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:
            msg = "Remaining compressor timer is only supported with ATS700 or ATS800 series!"
            raise NotImplementedError(msg)
        else:
            response = self._parent._query("GTIM?").strip()
            self._parent._statecache["compressor_timer"] = int(response.split("(")[-1].strip(")"))
            return self._parent._statecache["compressor_timer"]

    @property
    def CompressorTimer(self) -> int:
        """
        Timer in minutes to turn off the compressor.

        A value of 0 will turn the timer off. Valid values 15 - 12960.
        """
        if DEBUG:
            return max(0, self._parent._statecache["compressor_timer"] - 1)
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:
            msg = "Compressor timer is only supported with ATS700 or ATS800 series!"
            raise NotImplementedError(msg)
        else:
            response = self._parent._query("GTIM?").strip()
            self._parent._statecache["compressor_timer"] = int(response.split("(")[0])
            return self._parent._statecache["compressor_timer"]

    @CompressorTimer.setter
    def CompressorTimer(self, value: int):
        """
        Timer in minutes to turn off the compressor.

        A value of 0 will turn the timer off. Valid values 15 - 12960.
        """
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:
            msg = "Compressor timer is only supported with ATS700 or ATS800 series!"
            raise NotImplementedError(msg)
        else:
            value = int(value)
            check_floating_range(0, 12960, value)

            if value > 0:
                self._parent._write(f"GTIM {value:d}")
            else:
                self._parent._write("GTIM 0")
            self._parent._statecache["compressor_timer"] = value

    @property
    def HeadLock(self) -> bool:
        """
        Sets the head lock to prevent accidental movement.

        If True head will be locked, if False head is unlocked.
        """
        if DEBUG:
            return self._parent._statecache["head_lock"]
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:
            self._parent._statecache["head_lock"] = False
        else:
            self._parent._statecache["head_lock"] = bool(int(self._parent._query("HDLK?")))
        return self._parent._statecache["head_lock"]

    @HeadLock.setter
    def HeadLock(self, value: bool):
        """
        Sets the head lock to prevent accidental movement.

        If True head will be locked, if False head is unlocked.
        """
        if self._parent._TYPE != TemptronicEnums.TYPES.ATS_700_800:  # Property only supported by ATS700/800
            msg = "Locking the head is only supported with ATS700 or ATS800 series!"
            raise NotImplementedError(msg)
        else:
            value = bool(value)
            if value is True:
                self._parent._write("HDLK 1")
            elif value is False:
                self._parent._write("HDLK 0")
            self._parent._statecache["head_lock"] = value

    @property
    def HeadPosition(self) -> TemptronicEnums.HEAD_POS:
        """
        Controls the head position (up/down)
        """
        if DEBUG:
            return self._parent._statecache["head_pos"]
        headpos = int(self._parent._query("HEAD?"))
        self._parent._statecache["head_pos"] = key_by_value(TemptronicEnums.HEAD_POS, headpos)
        return self._parent._statecache["head_pos"]

    @HeadPosition.setter
    def HeadPosition(self, value: TemptronicEnums.HEAD_POS):
        """
        Controls the head position (up/down)
        """
        if self.HeadLock:
            msg = "Head is currently locked. You need to unlock it before moving."
            raise Exception(msg)

        if value == TemptronicEnums.HEAD_POS.UP:
            self._parent._write("HEAD 0")
        elif value == TemptronicEnums.HEAD_POS.DOWN:
            self._parent._write("HEAD 1")
            # this delay is essential, otherwise set_flow(False) will be without effect.
            time.sleep(2.5)
            self.FlowState = False
        else:
            raise Exception("Invalid position argument: " + str(value))
        self._parent._statecache["head_pos"] = value


class Templogger:
    def __init__(self, parent):
        """
        :type parent: temptronic_ats_tp
        """
        self._parent = parent
        self._logpath = None

    def config(self, logpath: str, period: float):
        """
        Configures the temperature logger, which is periodically querying the air and DUT temperature values from the device in a background thread.

        This method has to be called when initially starting the logging or whenever the logger was stopped and shall be re-started.

        :param logpath: The path of the log file where the data is stored
        :param period: The waiting time between samples
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._thread_templogger.destroy()
            del self._parent._thread_templogger
        self._parent._thread_templogger = ThreadTemperatureLogger(self._parent, logpath, period)
        self._logpath = logpath

    def start(self):
        """
        Start the temperature logging background process.
        """
        if isinstance(self._parent._thread_templogger, ThreadTemperatureLogger):
            self._parent._check_initialized()
            if not self._parent._thread_templogger.is_alive():
                try:
                    self._parent._thread_templogger.start()
                except RuntimeError:
                    msg = "You need to invoke Templogger.config() before you can use the start() method."
                    raise Exception(msg) from None
                self._parent._thread_templogger.log.disabled = False

    def pause(self):
        """
        Pauses the logging process (the background process still runs but the logging to file is disabled).
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._check_initialized()
            self._parent._thread_templogger.pause()

    def stop(self):
        """
        Stop the logging process.

        Please consider invoking Templogger.config(...) before starting the logging again.
        """
        if (
            isinstance(self._parent._thread_templogger, ThreadTemperatureLogger)
            and self._parent._thread_templogger.is_alive()
        ):
            self._parent._thread_templogger.stop()

    def as_dataframe(self, logpath=None) -> pd.DataFrame:
        """
        Returns the logged temperature data as a Pandas dataframe

        :param logpath: The log file to parse. If None, the previously used logpath is used
        """
        if logpath is None:
            if self._logpath is not None:
                logpath = self._logpath
            else:
                msg = "No logpath provied."
                raise Exception(msg)
        else:
            if not os.path.exists(logpath):
                msg = "Provided logpath does not exist!"
                raise Exception(msg)

        with open(
            logpath
        ) as fh:  # read_csv cannot handle paths with non-ascii characters --> workaround by passing file handle
            # (https://github.com/pandas-dev/pandas/issues/15086)
            return pd.read_csv(fh, delimiter=";", converters={"Date": pd.to_datetime}, index_col=0)


class temptronic_ats_tp(IdentityABC):
    def __init__(self, logger: logging.Logger | None = None):
        self.__initialized = False
        self._inst = None
        """:type : pyvisa.resources.gpib.GPIBInstrument"""
        self._TYPE = None
        """:type : TemptronicEnums.TYPES"""
        if isinstance(logger, logging.Logger):
            self._log = logger
        else:
            self._log = logging.getLogger(self.__class__.__name__)
            if len(self._log.handlers) == 0:  # only add streamhandler if none exists
                self._log.addHandler(logging.StreamHandler(sys.stdout))
            self._log.setLevel(logging.INFO)
        self._limits = limits.LIMITS_DEFAULT
        self._thread_templogger = None  # type: ThreadTemperatureLogger

        self._statecache = {
            "mode": TemptronicEnums.MODE.AIR_CTRL,
            "setpoint": 0.0,
            "window": 0.0,
            "ramp_rate": 0.0,
            "flow_rate": 0.0,
            "flow_state": False,
            "compressor_state": False,
            "compressor_timer": 0.0,
            "head_pos": TemptronicEnums.HEAD_POS.UP,
            "head_lock": False,
            "sensor": TemptronicEnums.SENSOR.NONE,
        }

        self.__Identity = Identity_SCPI(parent=self, rsrc_attr_name="_inst")
        self.__parameter = Parameter(parent=self)
        self.__Templogger = Templogger(parent=self)

    def __repr__(self):
        limits, _ = inspect.getsourcelines(self._limits)
        return "Thermostream Limits:\n" + "".join(limits[1:])

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Templogger(self):
        """
        Returns a pointer to the Templogger subclass
        """
        return self.__Templogger

    @property
    def parameter(self):
        """
        Returns a pointer to the parameter subclass
        """
        return self.__parameter

    def _check_initialized(self):
        if not self.__initialized:
            msg = "Driver is not initialized!"
            raise Exception(msg)

    def Initialize(self, ResourceName, IdQuery=True, Reset=True, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
            of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: Initialization options: "simulate=(true|false)"
        :type OptionString: str
        """
        global DEBUG  # noqa: PLW0603
        if "simulate=true" in OptionString.lower():
            DEBUG = True
            ResourceName = "GPIB0::1::INSTR"
            self._log.info("Instrument simulation activated!")

        if self.__initialized:
            return

        self._rm = ResourceManager("@sim" if DEBUG else "")
        self._inst = self._rm.open_resource(ResourceName)
        """:type : pyvisa.resources.gpib.GPIBInstrument"""
        self._inst.open()

        if IdQuery:
            idn = self._query("*IDN?")
            if DEBUG or IDN_MATCH_ATS700.match(idn) is not None:
                self._TYPE = TemptronicEnums.TYPES.ATS_700_800
                self._limits = limits.LIMITS_ATS710
            elif IDN_MATCH_ATS_545_645.match(idn) is not None:
                self._TYPE = TemptronicEnums.TYPES.ATS_545_645
                self._limits = limits.LIMITS_ATS_545_645
            elif IDN_MATCH_TP04310.match(idn) is not None:
                self._TYPE = TemptronicEnums.TYPES.TP04310
                self._limits = limits.LIMITS_TP04310
            else:
                msg = f"Unknown/Unsupported thermostream type '{idn}'!"
                raise Exception(msg)
            self._log.info(f"Successfully connected to thermostream {idn} @ {ResourceName}")
        else:
            self._TYPE = TemptronicEnums.TYPES.ATS_700_800
            self._limits = limits.LIMITS_DEFAULT
            self._log.info(f"Successfully connected to thermostream @ {ResourceName}")

        self._inst.write_termination = "\r"
        self._inst.read_termination = "\r"

        if Reset and not DEBUG:
            self._write("*RST")
            time.sleep(5)

        # Configure Event Status Register
        # bit 5 - command error (cme)
        # bit 4 - execution error (exe)
        # bit 3 - device dependent error (dde)
        # bit 2 - query error (qye)
        self._write("*CLS")
        self._write("*ESE %d" % ESE)

        # Set the temperature limits to min/max
        self._write(f"LLIM {self._limits.TEMP_LOW:.1f}")
        self._write(f"ULIM {self._limits.TEMP_HIGH:.1f}")

        self.__initialized = True

        # Initialize statecache
        self.__update_statecache()

    @synchronized(LOCK)
    def _write(self, message, termination=None, encoding=None):
        """Write a string message to the device.

        The write_termination is always appended to it.

        :param message: the message to be sent.
        :type message: unicode (Py2) or str (Py3)
        :return: number of bytes written.
        :rtype: int
        """
        return self._inst.write(message, termination, encoding)

    @synchronized(LOCK)
    def _query(self, message, delay=None):
        """A combination of write(message) and read()

        :param message: the message to send.
        :type message: str
        :param delay: delay in seconds between write and read operations.
                      if None, defaults to self.query_delay
        :returns: the answer from the device.
        :rtype: str
        """
        return self._inst.query(message, delay)

    def __update_statecache(self):
        _ = self.parameter.Mode
        _ = self.parameter.SetPoint
        _ = self.parameter.Window
        _ = self.parameter.RampRate
        _ = self.parameter.FlowState
        _ = self.parameter.CompressorState
        _ = self.parameter.HeadPosition
        with contextlib.suppress(NotImplementedError):
            _ = self.parameter.HeadLock
        with contextlib.suppress(NotImplementedError):
            _ = self.parameter.CompressorTimer
        with contextlib.suppress(NotImplementedError):
            _ = self.parameter.FlowRate

    def Close(self):
        self._check_initialized()
        self._write("%GL")
        self._inst.close()
        self.__initialized = False

    def CheckError(self):
        self._check_initialized()
        if DEBUG:
            return
        esr = int(self._query("*ESR?"))
        self._write("*CLS")
        if esr & ESE:
            if esr & 0b00100000:
                msg = ""
                raise CommandError(msg)
            elif esr & 0b00010000:
                msg = ""
                raise ExecutionError(msg)
            elif esr & 0b00001000:
                # dde
                dde = int(self._query("EROR?"))
                if dde:
                    self._write("CLER")
                    if dde & 2 ^ 0:
                        msg = "overheat"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 1:
                        msg = "air open loop"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 2:
                        msg = "set point out of range"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 3:
                        msg = "low flow"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 4:
                        msg = "low input air pressure"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 5:
                        msg = "no purge flow (ats710)/air sensor open (ats545, ats645, tp04310)"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 6:
                        msg = "open purge temperature sensor (ats710)"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 7:
                        msg = "internal error"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 8:
                        msg = "DUT open loop"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 9:
                        msg = "flow sensor hardware error"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 10:
                        msg = "purge heat failed (ats710), no line sense (ats545, ats645, tp04310)"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 11:
                        msg = "NVRAM fault"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 12:
                        msg = "BVRAM fault"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 13:
                        msg = "improper software version"
                        raise DeviceDependentError(msg)
                    elif dde & 2 ^ 14:
                        msg = "no DUT sensor selected"
                        raise DeviceDependentError(msg)

            elif esr & 0b00000100:
                msg = ""
                raise QueryError(msg)

    @property
    def Enums(self):
        return TemptronicEnums

    @property
    def Initialized(self):
        return self.__initialized

    def WaitForTemp(
        self,
        timeout_s,
        target: float,
        window_k: float | None = None,
        flowrate: float | None = None,
        soaktime_m: int | None = None,
        disable_exception: bool = False,
    ) -> bool:
        """
        This method is useful if you want a blocking wait until a temperature is reached. Every parameter
        is optional except for timeout_s. Every 100ms the temperature is checked if in range. If not within
        range after timeout an exception is raised.

        :param timeout_s: Timeout in seconds.
        :param target: Target temperature.
        :param window_k: Accepted window around target in Kelvin.
        :param flowrate: Flow rate of the device.
        :param soaktime_m: Time in minutes to wait after target is reached.
        :param disable_exception: If False then exception is raised on timeout, if True then no exception will be raised and False is returned.
        :returns: Returns True if temperature in range before timeout and False otherwise only if exceptions are disabled.
        """

        # if target is not None set temperature.
        if target is not None:
            self.parameter.SetPoint = target

        # analog to target...
        if window_k is not None:
            self.parameter.Window = window_k

        # analog to target...
        if flowrate is not None:
            try:
                self.parameter.FlowRate = flowrate
            except NotImplementedError as e:
                self._log.warning(e, exc_info=False)

        # initiate compressor and flow
        self.parameter.CompressorState = True
        self.parameter.FlowState = True

        # check temp periodically
        time_start = time.time()
        timeout_abs = time_start + timeout_s
        interval = 0.20
        progress = 0.0
        while True:
            # log progress
            cur_temp = self.parameter.Temp
            if time.time() > (time_start + (progress * timeout_s)):
                self._log.info(
                    "{:3d}% of wait time has passed. Cur: {:0.1f}째C\tTarget: {:0.1f}째C.".format(
                        int(progress * 100), cur_temp, self._statecache["setpoint"]
                    )
                )
                progress += interval

            # check if temp in range
            try:
                check_floating_range(
                    (self._statecache["setpoint"] - self._statecache["window"]),
                    (self._statecache["setpoint"] + self._statecache["window"]),
                    cur_temp,
                )
                within_range = True
            except Exception:
                within_range = False or DEBUG
            if time.time() > timeout_abs or within_range:
                break
            time.sleep(100e-3)

        # when in target range, soak and log progress
        if within_range:
            retval = True
            if soaktime_m is not None:
                self._log.info(f"Temperature is within range. Soaking for {soaktime_m} minute(s)...")
                time_start = time.time()
                timeout_abs = time_start + soaktime_m * 60.0
                interval = 0.20
                progress = 0.0
                while True:
                    if DEBUG:
                        break
                    if time.time() > (time_start + (progress * soaktime_m * 60.0)):
                        self._log.info(f"{int(progress * 100):3d}% of soaktime has passed.")
                        progress += interval
                    if time.time() > timeout_abs:
                        break
                    time.sleep(100e-3)
                self._log.info("Finished soaking. Moving on...")
            else:
                self._log.info("Temperature is within range. Moving on...")
        else:
            if disable_exception:
                retval = False
            else:
                msg = "Temperature not within range when timeout occurred."
                raise Exception(msg)
        return retval

    def configure(
        self,
        mode: TemptronicEnums.MODE,
        temp: float,
        window_k: float = 1.0,
        flowrate: float = 5.0,
        ramprate: float = 9999.0,
    ):
        """
        Convenience method to configure all essential aspects of the device.
        """
        self.parameter.Mode = mode
        self.parameter.SetPoint = temp
        self.parameter.Window = window_k
        self.parameter.FlowRate = flowrate
        self.parameter.RampRate = ramprate


def check_floating_range(llimit, ulimit, value, clip=False):
    """
    Check if value is within range including the limits.
    If clip is True the value will be clipped, otherwise an exception is raised.
    """
    # value = round(value, 1)
    if llimit <= value <= ulimit:
        return None
    elif clip:
        return max(llimit, min(ulimit, value))
    else:
        msg = f"Value ({value}) is out of valid input range ({llimit} - {ulimit})."
        raise Exception(msg)


class ThreadTemperatureLogger(threading.Thread):
    def __init__(self, drv: temptronic_ats_tp, logpath: str, period: float = 1.0):
        threading.Thread.__init__(self)
        self.drv = drv
        self.logpath = logpath
        self.period = float(period)
        self._pause = False
        self._exit = False

        self.log = logging.Logger(self.drv.__class__.__name__ + "_" + self.__class__.__name__)
        self.log.setLevel(logging.INFO)
        self.fh = logging.FileHandler(logpath, "w")
        self.fh.setLevel(logging.INFO)
        self.fh.setFormatter(logging.Formatter("%(message)s"))
        self.log.addHandler(self.fh)
        self.log.info("Date;AirTemp;DutTemp")
        self.log.disabled = False

    def destroy(self):
        for h in self.log.handlers:
            self.log.removeHandler(h)
        self.log.handlers = []

    def run(self):
        self.log.disabled = False
        while not self._exit:
            try:
                if DEBUG:
                    self.log.info(f"{arrow.now()};{1.0};{2.0}")
                else:
                    self.log.info(f"{arrow.now()};{self.drv.parameter.AirTemp:.2f};{self.drv.parameter.DutTemp:.2f}")
            except Exception as e:
                self.drv._log.error("An exception occurred in ThreadTemperatureLogger thread: " + str(e))
            finally:
                time.sleep(self.period)

    def pause(self):
        self.log.disabled = True

    def stop(self):
        self._exit = True
        self.join(self.period * 1.5)
