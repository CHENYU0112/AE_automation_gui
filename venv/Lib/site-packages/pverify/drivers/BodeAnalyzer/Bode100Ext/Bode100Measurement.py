from __future__ import annotations

from . import Bode100Calibration, Bode100Enums, Bode100FrequencySettings, Bode100Results


class Bode100Measurement:
    def __init__(self, BodeDoc, MeasurementObj):
        self.Enums = Bode100Enums
        self._BodeDoc = BodeDoc
        self._MeasurementObj = MeasurementObj

        self.Results = Bode100Results.Bode100Results(self._BodeDoc, self._MeasurementObj)
        self.SingleFrequencySettings = Bode100FrequencySettings.Bode100SingleFrequencySettings(
            self._BodeDoc, self._MeasurementObj
        )
        self.FrequencySweepSettings = Bode100FrequencySettings.Bode100FrequencySweepSettings(
            self._BodeDoc, self._MeasurementObj
        )
        self.DeviceSettings = None
        self.__UserCalibration = None
        """:type : Bode100Calibration.Bode100Calibration"""
        self.__ProbeCalibration = None
        """:type : Bode100Calibration.Bode100Calibration"""

    @property
    def UserCalibration(self):
        if self.__UserCalibration is None:
            self.__UserCalibration = Bode100Calibration.Bode100Calibration(
                self._BodeDoc, self._MeasurementObj.UserCalibration
            )
        return self.__UserCalibration

    @property
    def ProbeCalibration(self):
        if self.__ProbeCalibration is None:
            self.__ProbeCalibration = Bode100Calibration.Bode100Calibration(
                self._BodeDoc, self._MeasurementObj.ProbeCalibration
            )
        return self.__ProbeCalibration

    @property
    def Name(self):
        return str(self._MeasurementObj.Name)

    @property
    def IsReadyExecute(self):
        """
        Checks if the measurement engine is started.
        Returns true if the measurement engine is in the warmup state otherwise false.
        For tracking the warmup state of the measurement engine this property can be used.
        If the measurement engine runs into synchronization problems the cool down will be initiated automatically.
        Anyway the execute returns false if it detects an undefined state.

        :rtype: bool
        """
        return bool(self._MeasurementObj.IsReadyExecute)

    @property
    def OverloadLevelCH1(self):
        """
        Returns the overload value for channel 1.
        A value greater than 1.0 means that an overload occurred during the measurement.
        It is the maximum value detected during the measurement.

        :rtype: float
        """
        return float(self._MeasurementObj.OverloadLevelCH1)

    @property
    def OverloadLevelCH2(self):
        """
        Returns the overload value for channel 2.
        A value greater than 1.0 means that an overload occurred during the measurement.
        It is the maximum value detected during the measurement.

        :rtype: float
        """
        return float(self._MeasurementObj.OverloadLevelCH2)

    def Execute(self, timeout=0):
        """
        Performs the measurement for the current setup.
        Returns true if the execution of the measurement was successful otherwise false.
        During measurement the source will be automatically switched on while after the measurement
        has been completed the source will be switched off automatically.

        :param timeout: User specified timeout in milliseconds after which the execution will be aborted.
        :rtype: bool
        """
        if timeout <= 0:
            return bool(self._MeasurementObj.Execute())
        else:
            return bool(self._MeasurementObj.Execute2(timeout))

    def CoolDownExecute(self):
        """
        Cool down the measurement engine after execution has been performed.
        Returns true if the cooling down of the measurement engine was successful otherwise false.
        This method cools down the measurement engine after all executins have been performed.
        After cooling down the measurement engine the Execute Method has the same behaviour as already known.
        There also exists a counterpart WarmUpExecute Method which connects the measurement engine to the measurement.
        The warming up and cooling down is always related directly to measurements so one always have to take care that
        when switching between different measurements always the current warmed up measurement
        has to be cooled down before. The same is true when a calibration needs to be performed.
        After cooling down the engine the source will be switched off automatically.

        :rtype: bool
        """
        return bool(self._MeasurementObj.CoolDownExecute())

    def WarmUpExecute(self):
        """
        Cool down the measurement engine after execution has been performed.
        Returns true if the warming up of the measurement engine was successful otherwise false.
        This method gives us the possibility to startup the measurement engine before performing an execution.
        After the warming up phase the Execute Method can be performed as already known.
        The effect of the warming up is that the execution time of a measurement decreases.
        There also exists a counterpart CoolDownExecute Method which disconnects the measurement engine
        afterwards from the measurement. After the cooling down has been performed the Execute
        Method falls back to the same behaviour as already known.
        The warming up and cooling down is always related directly to measurements so one always have to take care that
        when switching between different measurements always the current warmed up measurement has to be cooled down before.
        The same is true when a calibration needs to be performed.
        During the execution in the warmup phase the source will be switched on automatically.

        :rtype: bool
        """
        return bool(self._MeasurementObj.WarmUpExecute())

    def LoadCalibration(self, filename):
        """
        This method gives the user the possibility to load an existing
        calibration configuration for the related measurement.
        Returns true if the file was loaded successfully, otherwise false.
        Each measurement is responsible for its own calibration values. The user of this method is also responsible
        that he loads the measurement dependent calibration file.

        The calibration file contains all calibration related data for the

            - User Calibration and
            - Probe Calibration

        but NO user dependent settings will be saved.

        When loading the calibration file it will be checked

            - if the file exists and has the correct file extension ".mcal"
            - if the number of frequencies in the user calibration correspond to the
              number of frequencies defined in the test settings.
            - If the file contains valid calibration data (i.e. the calibration is available) then the enabled
              properties (GainPhaseEnabled Property and/or ImpedanceEnabled Property dependent on the gain- and/or
              impedance-calibration) of the calibration object will be set to true automatically.

        Hints:

            - If a probe- and user-calibration is enabled at the same time the user calibration will be taken because
              it leads to more accurate measurement results.
            - The calibration of a measurement can be saved by perfoming the SaveCalibration Method

        :param filename: The calibration file to be loaded. The full path of the file is expected.
        :rtype: bool
        """
        from os.path import exists

        if not exists(filename):
            msg = f"'{filename}' does not exist!"
            raise Exception(msg)
        return bool(self._MeasurementObj.LoadCalibration(filename))

    def SaveCalibration(self, filename):
        """
        This method gives the user the possibility to save an existing
        calibration configuration for the related measurement.
        Returns true if the file was saved successfully, otherwise false.

        Each measurement is responsible for its own calibration values.
        The calibration file contains all callibration related data for the

        - User Calibration and
        - Probe Calibration

        but NO user dependent settings will be saved.
        The correct file extenstion for calibration files will be ".mcal".

        :param filename: The calibration file to be saved. The full path of the file is expected.
        :rtype: bool
        """
        return bool(self._MeasurementObj.SaveCalibration(filename))
