# ruff: noqa
"""
This test is for the Keithley 2450 SMU.

Prerequisites:
* When using PyCharm to execute the test:
  File -> Settings -> Tools -> Python Integrated Tools -> Default test runner: py.test
* Put a 1k resistor between the FORCE HI and FORCE LO terminals on the frontpanel.
* Adjust the resource name according to your device setting in the `connect_disconnect()`s `drv.Initialize()` function.
"""

from __future__ import annotations

import sys
from os.path import *

import pytest

rootdir = dirname(__file__)
sys.path.insert(0, rootdir)
# sys.path.insert(1, r"C:\Inicio_dev\flow\simctrl")

from pverify import np
from pverify.drivers.SMU.ke2450.ke2450 import ke2450

UnitV = "Volt DC"
UnitC = "Amp DC"
UnitR = "Ohm"
UnitP = "Watt DC"

U = 5.0
R = 1000.0
I = U / R
U_max = U * 1.05
U_min = U * 0.95
R_max = R * 1.05
R_min = R * 0.95
I_max = U_max / R_min
I_min = U_min / R_max
P = U * I
P_max = U_max * I_max
P_min = U_min * I_min


@pytest.fixture(scope="class")
def connect_disconnect(request):
    drv = ke2450()
    drv.Initialize(
        "USB0::0x05E6::0x2450::04314436::0::INSTR",
        True,
        True,
        OptionString="simulate=false",
    )
    ch = drv.GetChannel(1)

    # inject class variables
    request.cls.drv = drv
    request.cls.ch = ch
    yield  # Call the test method

    drv.Close()


# Parameters
PERFORMANCE = ("performance", [3])  # [0, 1, 2, 3, 4, 5, 6])
PARAMS_TRIGGER = [
    "triggertype,source,measure",
    [
        ("simple", "voltage", "voltage"),
        ("duration", "voltage", "voltage"),
    ],
]
PARAMS_SWEEP = [
    "sweeptype",
    [
        ("lin"),
        ("step"),
        ("log"),
        ("list"),
    ],
]


@pytest.mark.usefixtures("connect_disconnect")
class Test_ke2450:
    # For code-completion only
    drv = None
    """:type : ke2450"""
    ch = None
    """:type : ke2450_Channel"""

    def test_misc(self):
        self.drv.System.Utility.Reset()
        self.drv.System.SelectRearTerminal()
        self.drv.System.SelectFrontTerminal()
        self.drv.System.SetCurrentTime()
        self.drv.System.Beep(1000, 0.05)
        self.drv.System.ClearEventLog()

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMV(self, performance):
        self.ch.SourceMeterSetup("volt", "volt", performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)
        self.ch.Source.Voltage.SetCurrentLimit(0.01)
        self.ch.Source.SetOutputEnabled(True)
        self.ch.Measure.AutoZeroOnce()
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert U_min < read < U_max
        assert unit == UnitV

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMI(self, performance):
        self.ch.SourceMeterSetup(Source="voltage", Measure="current", Performance=performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)
        self.ch.Source.Voltage.SetCurrentLimit(0.01)
        self.ch.Measure.Current.ConfigureMeasurement(Range=I_max * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert I_min < read < I_max
        assert unit == UnitC

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMR(self, performance):
        self.ch.SourceMeterSetup(Source="voltage", Measure="resistance", Performance=performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)
        self.ch.Source.Voltage.SetCurrentLimit(0.01)
        self.ch.Measure.Current.ConfigureMeasurement(Range=I_max * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert R_min < read < R_max
        assert unit == UnitR

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMP(self, performance):
        self.ch.SourceMeterSetup(Source="voltage", Measure="power", Performance=performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)
        self.ch.Source.Voltage.SetCurrentLimit(0.01)
        self.ch.Measure.Current.ConfigureMeasurement(Range=I_max * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert P_min < read < P_max
        assert unit == UnitP

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMV(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="voltage", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=True)
        self.ch.Source.Current.SetVoltageLimit(U * 2)
        self.ch.Measure.Voltage.ConfigureMeasurement(Range=U * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert U_min < read < U_max
        assert unit == UnitV

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMI(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="current", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=True)
        self.ch.Source.Current.SetVoltageLimit(U_max)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert I_min < read < I_max
        assert unit == UnitC

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMR(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="resistance", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=True)
        self.ch.Source.Current.SetVoltageLimit(U * 2)
        self.ch.Measure.Voltage.ConfigureMeasurement(Range=U * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert R_min < read < R_max
        assert unit == UnitR

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMP(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="power", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=True)
        self.ch.Source.Current.SetVoltageLimit(U * 2)
        self.ch.Measure.Voltage.ConfigureMeasurement(Range=U * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert P_min < read < P_max
        assert unit == UnitP

    def test_direct_IO(self):
        self.drv.DirectIO.Write("*IDN?")
        idn1 = self.drv.DirectIO.Read()
        idn2 = self.drv.DirectIO.Query("*IDN?")

        assert idn1 == idn2
        assert idn1.upper().startswith("KEITHLEY INSTRUMENTS,MODEL 24")

    @pytest.mark.parametrize(*PARAMS_TRIGGER)
    def test_trigger(self, triggertype, source, measure):
        self.ch.SourceMeterSetup(Source=source, Measure=measure, Performance=3)

        if triggertype == "simple":
            self.drv.Trigger.ConfigureSimpleLoopTrigger(Count=10, Delay=0.05)
        else:
            self.drv.Trigger.ConfigureDurationLoopTrigger(Duration=0.5, Delay=0.05)

        self.ch.Source.SetOutputEnabled(True)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        self.ch.Source.SetOutputEnabled(False)

        sour, sourunit, read, unit = self.ch.Measure.Trace.GetData(
            BufferElements="SOUR, SOURUNIT, READ, UNIT", Transposed=True
        )

        if "volt" in source:
            assert all(np.array(sour) > U_min)
            assert all(np.array(sour) < U_max)
            assert all(np.array(sourunit) == UnitV)
        elif "curr" in source:
            assert all(np.array(sour) > I_min)
            assert all(np.array(sour) < I_max)
            assert all(np.array(sourunit) == UnitC)

        if "volt" in measure:
            assert all(np.array(read) > U_min)
            assert all(np.array(read) < U_max)
            assert all(np.array(sourunit) == UnitV)
        elif "curr" in measure:
            assert all(np.array(read) > I_min)
            assert all(np.array(read) < I_max)
            assert all(np.array(sourunit) == UnitC)
        elif "res" in measure:
            assert all(np.array(read) > R_min)
            assert all(np.array(read) < R_max)
            assert all(np.array(sourunit) == UnitR)
        elif "pow" in measure:
            assert all(np.array(read) > P_min)
            assert all(np.array(read) < P_max)
            assert all(np.array(sourunit) == UnitP)

    @pytest.mark.parametrize(*PARAMS_SWEEP)
    def test_sweep(self, sweeptype):
        self.ch.SourceMeterSetup(Source="voltage", Measure="voltage", Performance=3)

        if sweeptype == "lin":
            self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=10, Delay=0.05)
        elif sweeptype == "step":
            self.ch.Source.Voltage.ConfigureLinearSweepStep(Start=0, Stop=5, Step=0.5, Delay=0.05)
        elif sweeptype == "log":
            self.ch.Source.Voltage.ConfigureLogarithmicSweep(Start=0.01, Stop=5, Points=10, Delay=0.05)
        elif sweeptype == "list":
            self.ch.Source.Voltage.ConfigureListSweep(Values=[0, 1, 2, 3, 4, 5], Ranges=None, Delay=0.1)

        self.ch.Source.SetOutputEnabled(True)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        self.ch.Source.SetOutputEnabled(False)

        sour, sourunit, read, unit = self.ch.Measure.Trace.GetData(
            BufferElements="SOUR, SOURUNIT, READ, UNIT", Transposed=True
        )

        assert all(np.array(sourunit) == UnitV)
        assert all(np.array(sourunit) == UnitV)

        if sweeptype == "lin":
            assert all(
                np.array(read) > np.array([0, 0.5555045, 1.111, 1.666, 2.222, 2.778, 3.333, 3.889, 4.444, 5.0]) - 0.05
            )
            assert all(
                np.array(read) < np.array([0, 0.5555045, 1.111, 1.666, 2.222, 2.778, 3.333, 3.889, 4.444, 5.0]) + 0.05
            )
        elif sweeptype == "step":
            assert all(np.array(read) > np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]) - 0.05)
            assert all(np.array(read) < np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]) + 0.05)
        elif sweeptype == "log":
            assert all(
                np.array(read)
                > np.array(
                    [
                        0.0101,
                        0.02008,
                        0.0400,
                        0.0796,
                        0.1585,
                        0.3159,
                        0.6300,
                        1.256,
                        2.50675,
                        5.0,
                    ]
                )
                - 0.05
            )
            assert all(
                np.array(read)
                < np.array(
                    [
                        0.0101,
                        0.02008,
                        0.0400,
                        0.0796,
                        0.1585,
                        0.3159,
                        0.6300,
                        1.256,
                        2.50675,
                        5.0,
                    ]
                )
                + 0.05
            )
        elif sweeptype == "list":
            assert all(np.array(read) > np.array([0, 1, 2, 3, 4, 5]) - 0.05)
            assert all(np.array(read) < np.array([0, 1, 2, 3, 4, 5]) + 0.05)

    def test_trace_measurements(self):
        self.ch.SourceMeterSetup(Source="voltage", Measure="voltage", Performance=3)

        self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=10, Delay=0.05)

        self.ch.Source.SetOutputEnabled(True)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        self.ch.Source.SetOutputEnabled(False)

        assert 2.48 < self.ch.Measure.Trace.GetAverageReading() < 2.52
        assert 4.98 < self.ch.Measure.Trace.GetPeak2PeakReading() < 5.02
        assert 4.98 < self.ch.Measure.Trace.GetMaximumReading() < 5.02
        assert -0.02 < self.ch.Measure.Trace.GetMinimumReading() < 0.02
        assert 1.66 < self.ch.Measure.Trace.GetSDevReading() < 1.70

    def test_buffer(self):
        self.ch.SourceMeterSetup("volt", "volt", 3)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)
        self.ch.Source.Voltage.SetCurrentLimit(I_max)
        self.ch.Source.SetOutputEnabled(True)

        buff = "testbuffer1"
        self.drv.System.BufferCreate(buff, 10000)
        self.drv.System.BufferClear(buff)
        assert self.drv.System.BufferGetActualSize(buff) == 0
        self.ch.Measure.Read(BufferName=buff)
        assert self.drv.System.BufferGetActualSize(buff) == 1

        self.ch.Measure.Read(BufferName=buff)
        assert self.drv.System.BufferGetActualSize(buff) == 2

        self.ch.Measure.Read(BufferName=buff)
        assert self.drv.System.BufferGetActualSize(buff) == 3

        self.drv.System.BufferClear(buff)
        assert self.drv.System.BufferGetActualSize(buff) == 0

        self.drv.System.BufferModify(buff, BufferSize=10, BufferFillMode="cont")
        self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=11, Delay=0.02, Count=1, BufferName=buff)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)

        (read,) = self.ch.Measure.Trace.GetData(BufferElements="READ", Transposed=True, BufferName=buff)
        assert self.drv.System.BufferGetActualSize(buff) == 10
        assert 4.98 < read[0] < 5.02
        assert 0.48 < read[1] < 0.52
        assert 4.48 < read[-1] < 4.52

        self.drv.System.BufferModify(buff, BufferSize=15, BufferFillMode="once")
        self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=10, Delay=0.02, Count=2, BufferName=buff)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        assert self.drv.System.BufferGetActualSize(buff) == 0  # If BufferSize < nr. of points no sweep is done

        self.drv.System.BufferModify(buff, BufferSize=20, BufferFillMode="once")
        self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=10, Delay=0.02, Count=2, BufferName=buff)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        assert self.drv.System.BufferGetActualSize(buff) == 20

        try:
            self.ch.Measure.Read(BufferName=buff)
        except Exception:
            self.drv.System.ClearEventLog()
        else:
            msg = "Could perform Read operation despite buffer is full!"
            raise Exception(msg)

        self.drv.System.BufferDelete(buff)
        try:
            self.ch.Measure.Read(BufferName=buff)
        except Exception:
            self.drv.System.ClearEventLog()
        else:
            msg = "Could perform Read operation despite buffer should be deleted!"
            raise Exception(msg)

        self.ch.Source.SetOutputEnabled(False)

    def test_meas_count(self):
        self.ch.SourceMeterSetup("volt", "volt", 3)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)

        self.drv.System.BufferClear()
        self.ch.Source.SetOutputEnabled(True)

        self.ch.Measure.ConfigureMeasurementCount(count=5)
        read = self.ch.Measure.Read("READ")
        assert self.drv.System.BufferGetActualSize() == 5

        self.ch.Measure.ConfigureMeasurementCount(count=1)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        assert self.drv.System.BufferGetActualSize() == 6

        assert [sour, sourunit, read, unit] == self.ch.Measure.Fetch("SOUR, SOURUNIT, READ, UNIT")
        assert self.drv.System.BufferGetActualSize() == 6

        self.drv.System.BufferClear()
        self.ch.Source.SetOutputEnabled(False)

    def test_config_lists(self):
        self.ch.SourceMeterSetup("volt", "volt", 3)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=True)

        sc, sname = self.ch.Source.ConfigLists, "src_cfg"
        mc, mname = self.ch.Measure.ConfigLists, "meas_cfg"

        for pnt, name in [(sc, sname), (mc, mname)]:
            pnt.Create(name)
            assert pnt.GetSize(name) == 0
            pnt.Store(name)
            pnt.Store(name)
            pnt.Store(name)
            assert pnt.GetSize(name) == 3
            pnt.StoreIndex(name, 1)
            assert pnt.GetSize(name) == 3
            pnt.DeleteIndex(name, 1)
            assert pnt.GetSize(name) == 2
            pnt.DeleteIndex(name, 1)
            assert pnt.GetSize(name) == 1
            pnt.RecallIndex(name, 1)
            assert pnt.GetSize(name) == 1
            pnt.Create(name)
            assert pnt.GetSize(name) == 0
            pnt.Delete(name)
            try:
                pnt.GetSize(name)
            except Exception:
                self.drv.System.ClearEventLog()
            else:
                msg = "Could query list size despite config list should be deleted!"
                raise Exception(msg)
