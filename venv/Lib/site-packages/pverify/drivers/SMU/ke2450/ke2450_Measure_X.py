from __future__ import annotations

from .ke2450_dllwrap import *


class ke2450_Measure_X:
    def __init__(self, parent, function):
        self._parent = parent
        """:type : pverify.drivers.SMU.ke2450.ke2450_Measure.ke2450_Measure"""
        self._name = self._parent._name
        self._function = function

    @property
    def _vi(self):
        """
        The instrument IO session
        """
        return self._parent._vi

    @property
    def _dllwrap(self):
        """
        The Python dll wrapper module
        """
        return self._parent._dllwrap

    def ConfigureMeasurement(
        self,
        Range=None,
        AutoZeroState=None,
        EnableOffsetCompensation=None,
        EnableRemoteSense=None,
        NPLC=None,
        Resolution=None,
    ):
        """
        Configures the SMU measurement for the current selected function

        :param Range: the positive full-scale value of the measurement range for measurements of the selected function
        :type Range: int|float
        :param AutoZeroState: Enables/Disables AutoZero state
        :type AutoZeroState: bool
        :param EnableOffsetCompensation: Enables or disables offset compensation for measurement function
        :type EnableOffsetCompensation: bool
        :param EnableRemoteSense: Determines 2-wire (local) or 4-wire (remote) sensing is used
        :type EnableRemoteSense: bool
        :param NPLC: the amount of time(based on the number of power line cycles) that the input signal is measured
        :type NPLC: int|float
        :param Resolution: the number of digits that are displayed for measurements on the front panel.
        :type Resolution: int|float
        """
        if Range is not None:
            self._dllwrap.SetRange(self._vi, self._function, float(Range))
        if AutoZeroState is not None:
            self._dllwrap.SetAutoZeroState(self._vi, self._function, int(not bool(AutoZeroState)))
        if EnableOffsetCompensation is not None:
            self._dllwrap.SetEnableOffsetCompensation(self._vi, self._function, bool(EnableOffsetCompensation))
        if EnableRemoteSense is not None:
            self._dllwrap.SetEnableRemoteSense(self._vi, self._function, bool(EnableRemoteSense))
        if NPLC is not None:
            self._dllwrap.SetFunctionnplc(self._vi, self._function, float(NPLC))
        if Resolution is not None:
            self._dllwrap.SetResolution(self._vi, self._function, int(Resolution))

    def ConfigureAutoRange(self, Enabled, LowLimit=None, VoltageUpperLimit=None, ResistanceUpperLimit=None):
        """
        Configure measurement auto-range settings

        :param Enabled: Enable/disable auto-range
        :type Enabled: bool
        :param LowLimit: the lower limit for measurements of the selected function when the range is selected automatically.
                         It prevents the instrument from selecting a range that is below this limit.
        :type LowLimit: int|float
        :param VoltageUpperLimit: upper limit for Voltage measurement function when auto range is selected
        :type VoltageUpperLimit: int|float
        :param ResistanceUpperLimit: upper limit for Resistance measurement function when auto range is selected.
        :type ResistanceUpperLimit: int|float
        """
        self._dllwrap.SetAutoRange(self._vi, self._function, bool(Enabled))
        if LowLimit is not None:
            self._dllwrap.SetLowerLimit(self._vi, self._function, float(LowLimit))
        if VoltageUpperLimit is not None:
            self._dllwrap.SetAttributeViReal64(self._vi, "", KE2450_ATTR_VOLTAGE_UPPER_LIMIT, float(VoltageUpperLimit))
        if ResistanceUpperLimit is not None:
            self._dllwrap.SetAttributeViReal64(
                self._vi,
                "",
                KE2450_ATTR_RESISTANCE_UPPER_LIMIT,
                float(ResistanceUpperLimit),
            )

    def ConfigureAveragingFilter(self, Enabled, Count=None, Type=None):
        """
        Configures measurement averaging

        :param Enabled: Enables or disables the averaging filter for measurements of the selected function
        :type Enabled: bool
        :param Count: the number of measurements that are averaged when filtering is enabled for the function measurements
        :type Count: int|float
        :param Type: the type of averaging filter that is used for measurements for the selected function when the measurement filter is enabled.

                     Valid values: "moving", "repeating" or short "mov", "rep"
        :type Type: str
        """
        self._dllwrap.SetAveragingFilterState(self._vi, self._function, bool(Enabled))
        if Enabled:
            if Count is not None:
                self._dllwrap.SetAveragingFilterCount(self._vi, self._function, int(Count))
            if Type is not None:
                Type = str(Type).lower()
                if "rep" in Type:
                    self._dllwrap.SetAveragingFilterType(
                        self._vi,
                        self._function,
                        KE2450_VAL_MEASUR_CONFIG_AVERAGING_FILTER_TYPE_REPEAT,
                    )
                elif "mov" in Type:
                    self._dllwrap.SetAveragingFilterType(
                        self._vi,
                        self._function,
                        KE2450_VAL_MEASUR_CONFIG_AVERAGING_FILTER_TYPE_MOVING,
                    )
                else:
                    msg = "Invalid value for parameter 'Type'. Valid: 'repeating', 'moving'."
                    raise ValueError(msg)

    def ConfigureRelativeOffset(self, Enabled, Offset=None):
        """
        Configures the relative offset settings for the measurement.

        :param Enabled: Enables or disables the null relative offset value.
        :type Enabled: bool
        :param Offset: the relative offset value for the measurement
        :type Offset: float|int
        """
        self._dllwrap.SetRelativeOffsetState(self._vi, self._function, bool(Enabled))
        if Enabled:
            self._dllwrap.SetRelativeOffset(self._vi, self._function, float(Offset))

    def Acquire(self):
        """
        Acquires an internal measurement to store as the relative offset value
        """
        self._dllwrap.Acquire(self._vi, self._function)


class ke2450_Measure_V(ke2450_Measure_X):
    def __init__(self, parent):
        ke2450_Measure_X.__init__(self, parent, KE2450_VAL_FUNCTION_VOLTAGE)

    def ConfigureVoltageMeasureUnits(self, unit):
        """
        Sets the Voltage Measure Units

        :param unit: Valid values: "volts", "ohms", "watts" or short "v", "o", "w"
        :type unit: str
        """
        unit = str(unit).lower()
        if "v" in unit:
            self._dllwrap.SetAttributeViInt32(
                self._vi,
                "",
                KE2450_ATTR_VOLTAGE_MEASURE_UNITS,
                KE2450_VAL_VOLTAGE_MEASURE_UNITS_VOLTS,
            )
        elif "o" in unit:
            self._dllwrap.SetAttributeViInt32(
                self._vi,
                "",
                KE2450_ATTR_VOLTAGE_MEASURE_UNITS,
                KE2450_VAL_VOLTAGE_MEASURE_UNITS_OHMS,
            )
        elif "w" in unit:
            self._dllwrap.SetAttributeViInt32(
                self._vi,
                "",
                KE2450_ATTR_VOLTAGE_MEASURE_UNITS,
                KE2450_VAL_VOLTAGE_MEASURE_UNITS_WATTS,
            )
        else:
            msg = "Invalid value for parameter 'unit'. Valid: 'volts', 'ohms', 'watts' or short 'v', 'o', 'w'."
            raise ValueError(msg)


class ke2450_Measure_C(ke2450_Measure_X):
    def __init__(self, parent):
        ke2450_Measure_X.__init__(self, parent, KE2450_VAL_FUNCTION_CURRENT)

    def ConfigureCurrentMeasureUnits(self, unit):
        """
        Sets the Current Measure Units

        :param unit: Valid values: "amps", "ohms", "watts" or short "a", "o", "w"
        :type unit: str
        """
        unit = str(unit).lower()
        if "w" in unit:
            self._dllwrap.SetAttributeViInt32(
                self._vi,
                "",
                KE2450_ATTR_CURRENT_MEASURE_UNITS,
                KE2450_VAL_CURRENT_MEASURE_UNITS_WATTS,
            )
        elif "a" in unit:
            self._dllwrap.SetAttributeViInt32(
                self._vi,
                "",
                KE2450_ATTR_CURRENT_MEASURE_UNITS,
                KE2450_VAL_CURRENT_MEASURE_UNITS_AMPS,
            )
        elif "o" in unit:
            self._dllwrap.SetAttributeViInt32(
                self._vi,
                "",
                KE2450_ATTR_CURRENT_MEASURE_UNITS,
                KE2450_VAL_CURRENT_MEASURE_UNITS_OHMS,
            )
        else:
            msg = "Invalid value for parameter 'unit'. Valid: 'amps', 'ohms', 'watts' or short 'a', 'o', 'w'."
            raise ValueError(msg)
