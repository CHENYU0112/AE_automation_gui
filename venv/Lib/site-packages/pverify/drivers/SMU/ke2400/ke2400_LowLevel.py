from __future__ import annotations

from time import sleep

import numpy as np
from pyvisa.constants import VI_GPIB_REN_ADDRESS_GTL
from pyvisa.resources import GPIBInstrument, GPIBInterface

from pverify.core.lab.ivi.helper import InstrumentError

from .ke2400_const import *


def function2string(function):
    if function == KE24XX_SOURCE_VOLTAGE_FUNCTION:
        return "VOLT"
    elif function == KE24XX_SOURCE_CURRENT_FUNCTION:
        return "CURR"
    else:
        raise ValueError


def bool2onoff(value):
    return ["OFF", "ON"][bool(value)]


class ke2400_LowLevel:
    def __init__(self, parent):
        self._parent = parent
        """:type : pverify.drivers.SMU.ke2400.ke2400.ke2400"""

    @property
    def _inst(self):
        """
        The instrument visa resource
        """
        return self._parent._inst

    def Ke24xx_GTL(self):
        if self._parent._simulation_mode:
            return
        if not isinstance(self._inst, (GPIBInstrument, GPIBInterface)):
            # This functionality only seems to work reliably when using a GPIB interface.
            # When using a serial interface ":SYSTem:LOCal" did not have the desired effect.
            return

        sleep(
            0.01
        )  # Need this sleep otherwise the previous command is interrupted somehow ... awesome device firmware!
        self._inst.control_ren(VI_GPIB_REN_ADDRESS_GTL)
        sleep(
            0.01
        )  # Need this sleep otherwise the previous command is interrupted somehow ... awesome device firmware!

    def Ke24xx_error_query(self):
        if not self._parent._simulation_mode:
            errors = []
            while True:
                sleep(0.05)
                ret = self._inst.query(":SYST:ERR?")
                status, msg = ret.split(",")
                status = int(status)
                msg = msg.strip()
                if status != 0:
                    errors.append((status, msg))
                else:
                    break

            if len(errors):
                raise InstrumentError(errors[0][0], "\n".join(["%d,%s" % (s, m) for s, m in errors]))
        else:
            self._parent._log.debug("Can't query errors in DEBUG/simulation mode.")

    # SOURCE

    def Ke24xx_ConfigureSourceMode(self, function, mode):
        if function == KE24XX_SOURCE_VOLTAGE_FUNCTION:
            f = "VOLT"
        elif function == KE24XX_SOURCE_CURRENT_FUNCTION:
            f = "CURR"
        else:
            raise ValueError
        if mode == KE24XX_SOURCE_FIXED_MODE:
            m = "FIX"
        elif mode == KE24XX_SOURCE_SWEEP_MODE:
            m = "SWE"
        elif mode == KE24XX_SOURCE_LIST_MODE:
            m = "LIST"
        else:
            raise ValueError

        self._inst.write(f":SOUR:FUNC:MODE {f};")
        sleep(0.1)
        self._inst.write(f":SOUR:{f}:MODE {m}")

    def Ke24xx_SetFixedMode(self):
        self._inst.write(":SOUR:VOLT:MODE FIX")
        self._inst.write(":SOUR:CURR:MODE FIX")

    def Ke24xx_ConfigureSourceDelay(self, Auto, delay):
        if Auto:
            self._inst.write(":SOUR:DEL:AUTO ON;")
        else:
            self._inst.write(f":SOUR:DEL:AUTO OFF; :SOUR:DEL {delay}")

    def Ke24xx_ConfigureSourceCompliance(self, function, level):
        self._inst.write(f":SENS:{function}:PROT:LEV {level:f}")
        self._inst.write(f":SENS:{function}:RANG {level:f}")

    def Ke24xx_ConfigureVSourceProtection(self, level):
        self._inst.write(f":SOUR:VOLT:PROT:LEV {level:f}")

    def Ke24xx_ConfigureSourceLevel(self, function, level, update):
        if update == KE24XX_SOURCE_LEVEL_IMMEDIATE:
            self._inst.write(f":SOUR:{function2string(function)} {level:f}")
        else:
            self._inst.write(f":SOUR:{function2string(function)}:TRIG {level:f}")

    def Ke24xx_ConfigureOutputOffMode(self, mode):
        if mode == KE24XX_OFF_MODE_NORMAL:
            sm = "NORM"
        elif mode == KE24XX_OFF_MODE_HIMP:
            sm = "HIMP"
        elif mode == KE24XX_OFF_MODE_ZERO:
            sm = "ZERO"
        elif mode == KE24XX_OFF_MODE_GUARD:
            sm = "GUAR"
        else:
            raise ValueError

        self._inst.write(f":OUTP:SMOD {sm}")

    def Ke24xx_ConfigureSourceSweep(self, sourceFunction, spacing, direction, ranging, start, stop, numberPoints):
        sp = "LOG" if spacing == KE24XX_SWEEP_SPACING_LOG else "LIN"
        if ranging == KE24XX_SWEEP_RANGING_BEST:
            ra = "BEST"
        elif ranging == KE24XX_SWEEP_RANGING_FIXED:
            ra = "FIX"
        else:
            ra = "AUTO"

        self._inst.write(
            f":SOUR:SWE:SPAC {sp}; DIR UP; POIN {numberPoints:d}; RANG {ra}; :SOUR:{function2string(sourceFunction)}:STAR {start:f}; STOP {stop:f};"
        )

    def Ke24xx_ConfigureSourceList(self, sourceFunction, values):
        if not (1 <= len(values) <= 100):
            msg = "Length of values must be 1-100"
            raise ValueError(msg)
        self._inst.write(":SOUR:LIST:{} {};".format(function2string(sourceFunction), ",".join(map(str, values))))

    def Ke24xx_EnableSourceOutput(self, enabled):
        self._inst.write(f":OUTP:STAT {bool2onoff(enabled)}")

    # SENSE

    def Ke24xx_ConfigureDCVSense(self, range, nplc):
        self._inst.write(f":SENS:CURR:DC:RANG {range:f}; :SENS:VOLT:DC:NPLC {nplc:f}")

    def Ke24xx_ConfigureDCISense(self, range, nplc):
        if range == KE24XX_AUTO_RANGE:
            self._inst.write(":SENS:CURR:DC:RANG:AUTO ON")
        else:
            self._inst.write(f":SENS:CURR:DC:RANG {range:f}")
        sleep(0.01)
        self._inst.write(f":SENS:CURR:DC:NPLC {nplc:f}")

    def Ke24xx_ConfigureRESSense(self, range, nplc, mode, compensation):
        m = "MAN" if mode == KE24XX_MANUAL_OHMS else "AUTO"

        self._inst.write(
            f":SENS:CURR:DC:RANG {range:f}; :SENS:CURR:DC:NPLC {nplc:f}; :SENS:RES:OCOM {bool2onoff(compensation)}; :SENS:RES:MODE {m}"
        )

    def Ke24xx_ResSenseOffsetCompensation(self, enabled):
        self._inst.write(f":SENS:RES:OCOM {bool2onoff(enabled)}")

    def Ke24xx_SelectSenseFunc(self, DCV, DCI, RES):
        # numEnabled = int(DCV) + int(DCI) + int(RES)
        # if numEnabled == 0:
        #     raise ValueError("You have to select at least one sense function!")
        # elif numEnabled == 1:
        #     self.Conccurent = False
        # else:
        #     if not self.Conccurent:
        #         self._parent._log.warning("Concurrent not enabled! Enabling now...")
        #     self.Conccurent = True
        self.Conccurent = True

        self._inst.write(f":SENS:FUNC:{bool2onoff(DCV)} 'VOLT:DC'")
        sleep(0.01)
        self._inst.write(f":SENS:FUNC:{bool2onoff(DCI)} 'CURR:DC'")
        sleep(0.01)
        self._inst.write(f":SENS:FUNC:{bool2onoff(RES)} 'RES'")

    def Ke24xx_EnableAutoZero(self, enabled):
        if enabled:
            self._inst.write(":SENS:RES:MODE MAN")
        self._inst.write(f":SYST:AZER:STAT {bool2onoff(enabled)}")

    def Ke24xx_ConfigureFilterWeight(self, weigth):
        self._inst.write(f":SENS:AVER:COUN {min(100, weigth):d}")

    def Ke24xx_ConfigureFilterType(self, type):
        if type == KE24XX_REPEAT_FILTER:
            self._inst.write(":SENS:AVER:TCON REP")
        elif type == KE24XX_MOVING_FILTER:
            self._inst.write(":SENS:AVER:TCON MOV")
        else:
            pass

    def Ke24xx_EnableFilter(self, enabled):
        self._inst.write(f":SENS:AVER:STAT {bool2onoff(enabled)}")

    @property
    def Conccurent(self):
        return bool(int(self._inst.query(":SENS:FUNC:CONC?")))

    @Conccurent.setter
    def Conccurent(self, value):
        self._inst.write(f":SENS:FUNC:CONC {bool2onoff(value)}")

    # TRIGGER

    def Ke24xx_ConfigureArmLayer(self, count, triggerSource, timer, outputOn):
        c = "INF" if count == 0 else str(count)

        if triggerSource == KE24XX_TRIG_ON_IMMEDIATE:
            ts = "IMM"
        elif triggerSource == KE24XX_TRIG_ON_TIMER:
            ts = f"TIM; TIM {timer}"
        elif triggerSource == KE24XX_TRIG_ON_FRONT_PANEL:
            ts = "MAN"
        elif triggerSource == KE24XX_TRIG_ON_GET:
            ts = "BUS"
        elif triggerSource == KE24XX_TRIG_ON_SOT_LOW:
            ts = "NST"
        elif triggerSource == KE24XX_TRIG_ON_SOT_HIGH:
            ts = "PST"
        elif triggerSource == KE24XX_TRIG_ON_SOT:
            ts = "BST"
        else:
            raise ValueError

        if outputOn == 1:
            o = "TENT"
        elif outputOn == 2:
            o = "TEX"
        elif outputOn == 3:
            o = "TENT,TEX"
        else:
            o = "NONE"

        self._inst.write(f":ARM:COUN {c}; :ARM:SOUR {ts}; :ARM:OUTP {o};")

    def Ke24xx_ConfigureTriggerLayer(self, count, triggerSource, delay):
        self._inst.write(f":TRIG:COUN {int(count):d};:TRIG:DEL {delay}")
        sleep(0.01)

        if triggerSource == KE24XX_TRIG_ON_IMMEDIATE:
            self._inst.write(":TRIG:SOUR IMM")
        else:
            raise ValueError

    def Ke24xx_Abort(self):
        self._inst.write(":TRIG:CLE")
        sleep(0.01)
        self._inst.write(":ABOR")

    def Ke24xx_Initiate(self):
        self._inst.write(":TRIG:CLE;:INIT;*TRG")
        sleep(0.05)

    # MEASURE

    def GetNumOfReadings(self):
        arm = int(self._inst.query(":ARM:COUN?"))
        sleep(0.01)
        trig = int(self._inst.query(":TRIG:COUN?"))
        return arm * trig

    def GetNumOfReadingsInBuf(self):
        return int(self._inst.query(":TRAC:POIN:ACT?"))

    def Ke24xx_PrepareRead(self, elements, fromBuf):
        if elements == 1:
            msg = ":FORM:ELEM VOLT"
        elif elements == 2:
            msg = ":FORM:ELEM CURR"
        elif elements == 3:
            msg = ":FORM:ELEM VOLT,CURR"
        elif elements == 4:
            msg = ":FORM:ELEM RES"
        elif elements == 5:
            msg = ":FORM:ELEM VOLT,RES"
        elif elements == 6:
            msg = ":FORM:ELEM CURR,RES"
        elif elements == 7:
            msg = ":FORM:ELEM VOLT,CURR,RES"
        elif elements == 8:
            msg = ":FORM:ELEM TIME"
        elif elements == 9:
            msg = ":FORM:ELEM VOLT,TIME"
        elif elements == 10:
            msg = ":FORM:ELEM CURR,TIME"
        elif elements == 11:
            msg = ":FORM:ELEM VOLT,CURR,TIME"
        elif elements == 12:
            msg = ":FORM:ELEM RES,TIME"
        elif elements == 13:
            msg = ":FORM:ELEM VOLT,RES,TIME"
        elif elements == 14:
            msg = ":FORM:ELEM CURR,RES,TIME"
        elif elements == 15:
            msg = ":FORM:ELEM VOLT,CURR,RES,TIME"
        else:
            raise ValueError

        self._inst.write(msg)
        if not fromBuf:
            return self.GetNumOfReadings()
        else:
            return self.GetNumOfReadingsInBuf()

    def Ke24xx_Fetch(self, elements="", timeout=None, measure_fct=KE24XX_READ_VOLTAGE):
        tmo = self._inst.timeout
        if timeout is not None:
            self._inst.timeout = int(timeout)
        sleep(0.01)
        data = self._inst.query_ascii_values(":FETCH?")
        if timeout is not None:
            self._inst.timeout = tmo
        return self._ExtractData(elements, data, measure_fct)

    def Ke24xx_Read(self, elements="", timeout=None, measure_fct=KE24XX_READ_VOLTAGE):
        tmo = self._inst.timeout
        if timeout is not None:
            self._inst.timeout = int(timeout)
        sleep(0.01)
        data = self._inst.query_ascii_values(":READ?")
        if timeout is not None:
            self._inst.timeout = tmo
        return self._ExtractData(elements, data, measure_fct)

    def _ExtractData(self, elements, data, measure_fct, raw=False):
        if not elements:
            elements = "SOUR, READ"
        elements = [str.strip(x) for x in str(elements).lower().split(",")]
        if measure_fct is None:
            msg = "You have to call the 'SourceMeterSetup' function first before making any measurements!"
            raise Exception(msg)
        sour_fct = self._inst.query(":SOUR:FUNC:MODE?").lower()
        data = np.reshape(data, (4, -1), "F")

        if "volt" in sour_fct:
            sour_data = data[0]
            sour_units = np.array(["Volt DC"] * len(sour_data))
        elif "curr" in sour_fct:
            sour_data = data[1]
            sour_units = np.array(["Amp DC"] * len(sour_data))
        else:
            msg = "Unknown source function queried from :SOUR:FUNC:MODE?"
            raise Exception(msg)

        if measure_fct == KE24XX_READ_VOLTAGE:
            meas_data = data[0]
            meas_units = np.array(["Volt DC"] * len(meas_data))
        elif measure_fct == KE24XX_READ_CURRENT:
            meas_data = data[1]
            meas_units = np.array(["Amp DC"] * len(meas_data))
        elif measure_fct == KE24XX_READ_RESISTANCE:
            meas_data = data[2]
            meas_units = np.array(["Ohm"] * len(meas_data))
        else:
            msg = "Unknown source function queried from :SOUR:FUNC:MODE?"
            raise Exception(msg)

        time_data = data[3]
        time_data -= time_data[0]

        output = []
        for e in elements:
            if "rel" in e:
                output.append(time_data)
            elif "sour" in e:
                if "unit" in e:
                    output.append(sour_units)
                else:
                    output.append(sour_data)
            elif "unit" in e:
                output.append(meas_units)
            elif "read" in e:
                output.append(meas_data)

        if raw:
            return np.vstack(output)
        else:
            readings = np.vstack(output).reshape((-1,), order="F")
            ret = []
            for r in readings:
                try:
                    ret.append(float(r))
                except Exception:
                    ret.append(r)
            return ret

    # TRACE

    def Ke24xx_EnableBuffer(self, enable):
        if bool(enable):
            self._inst.write(":TRAC:FEED:CONT NEXT")
        else:
            self._inst.write(":TRAC:FEED:CONT NEV")

    def Ke24xx_ClearBuffer(self):
        self._inst.write(":TRAC:CLE")

    def Ke24xx_ConfigureBuffer(self, bufferSize, timeStampFormat):
        self._inst.write(f":TRAC:POIN {max(0, min(int(bufferSize), 2500))}")
        if timeStampFormat == KE24XX_BUF_TSTMODE_DELTA:
            self._inst.write(":TRAC:TST:FORM DELT")
        else:
            self._inst.write(":TRAC:TST:FORM ABS")

    # SYSTEM

    def Ke24xx_SelectTerminals(self, terminals):
        if terminals == KE24XX_USE_FRONT_TERMINALS:
            self._inst.write(":SYST:FRSW FRON")
        else:
            self._inst.write(":SYST:FRSW REAR")

    def Ke24xx_EnableRemoteSensing(self, enable):
        self._inst.write(f":SYST:RSEN {bool2onoff(enable)}")

    def Ke24xx_EnableBeeper(self, enable):
        self._inst.write(f":SYST:BEEP:STAT {bool2onoff(enable)}")

    def Ke24xx_ConfigureDisplayResolution(self, res):
        self._inst.write(f":DISP:DIG {res}")

    def Ke24xx_SaveSetup(self, number):
        self._inst.write(f"*SAV {number}")

    def Ke24xx_RecallSetup(self, number):
        self._inst.write(f"*RCL {number}")

    def Ke24xx_ReadRegister(self, Register):
        if Register == KE24XX_REG_SRE:
            regName = "*SRE?"
        elif Register == KE24XX_REG_ESE:
            regName = "*ESE?"
        elif Register == KE24XX_REG_QUES_ENAB:
            regName = ":STAT:QUES:ENAB?"
        elif Register == KE24XX_REG_MEAS_ENAB:
            regName = ":STAT:MEAS:ENAB?"
        elif Register == KE24XX_REG_OPER_ENAB:
            regName = ":STAT:OPER:ENAB?"
        elif Register == KE24XX_REG_STB:
            regName = "*STB?"
        elif Register == KE24XX_REG_ESE_EVENT:
            regName = "*ESR?"
        elif Register == KE24XX_REG_QUES_COND:
            regName = ":STAT:QUES:COND?"
        elif Register == KE24XX_REG_MEAS_COND:
            regName = ":STAT:MEAS:COND?"
        elif Register == KE24XX_REG_OPER_COND:
            regName = ":STAT:OPER:COND?"
        elif Register == KE24XX_REG_QUES_EVENT:
            regName = ":STAT:QUES?"
        elif Register == KE24XX_REG_MEAS_EVENT:
            regName = ":STAT:MEAS?"
        elif Register == KE24XX_REG_OPER_EVENT:
            regName = ":STAT:OPER?"
        else:
            msg = "Unknown register!"
            raise ValueError(msg)
        return int(self._inst.query(regName))

    def Ke24xx_WriteRegister(self, Register, value):
        if Register == KE24XX_REG_SRE:
            regName = "*SRE "
        elif Register == KE24XX_REG_ESE:
            regName = "*ESE "
        elif Register == KE24XX_REG_QUES_ENAB:
            regName = ":STAT:QUES:ENAB "
        elif Register == KE24XX_REG_MEAS_ENAB:
            regName = ":STAT:MEAS:ENAB "
        elif Register == KE24XX_REG_OPER_ENAB:
            regName = ":STAT:OPER:ENAB "
        else:
            msg = "Unknown register!"
            raise ValueError(msg)
        self._inst.write(f"{regName} {int(value):d}")

    def Ke24xx_ConfigureSRQEvents(self, condition):
        if condition == KE24XX_NO_SRQ:
            self.Ke24xx_ClearEnableRegisters()
            return

        measReg = self.Ke24xx_ReadRegister(KE24XX_REG_MEAS_ENAB)
        operReg = self.Ke24xx_ReadRegister(KE24XX_REG_OPER_ENAB)
        stdEvReg = self.Ke24xx_ReadRegister(KE24XX_REG_ESE)
        sreReg = self.Ke24xx_ReadRegister(KE24XX_REG_SRE)
        quesReg = self.Ke24xx_ReadRegister(KE24XX_REG_QUES_ENAB)

        if condition & KE24XX_SRQ_ON_ERROR_AVAILABLE:
            sreReg |= 0x04
        if condition & KE24XX_SRQ_ON_MESSAGE_AVAILABLE:
            sreReg |= 0x10
        if condition & KE24XX_SRQ_ON_OPERATION_COMPLETE:
            sreReg |= 0x20
            stdEvReg |= 0x0001
        if condition & KE24XX_SRQ_ON_QUERY_ERROR:
            sreReg |= 0x20
            stdEvReg |= 0x0004
        if condition & KE24XX_SRQ_ON_DEVICE_ERROR:
            sreReg |= 0x20
            stdEvReg |= 0x0008
        if condition & KE24XX_SRQ_ON_EXECUTION_ERROR:
            sreReg |= 0x20
            stdEvReg |= 0x0010
        if condition & KE24XX_SRQ_ON_COMMAND_ERROR:
            sreReg |= 0x20
            stdEvReg |= 0x0020
        if condition & KE24XX_SRQ_ON_USER_REQUEST:
            sreReg |= 0x20
            stdEvReg |= 0x0040
        if condition & KE24XX_SRQ_ON_POWER_ON:
            sreReg |= 0x20
            stdEvReg |= 0x0080
        if condition & KE24XX_SRQ_ON_CALIBRATION_SUMMARY:
            sreReg |= 0x04
            quesReg |= 0x00000100
        if condition & KE24XX_SRQ_ON_COMMAND_WARNING:
            sreReg |= 0x04
            quesReg |= 0x00004000
        if condition & KE24XX_SRQ_ON_CALIBRATING:
            sreReg |= 0x80
            operReg |= 0x00000001
        if condition & KE24XX_SRQ_ON_SWEEPING:
            sreReg |= 0x80
            operReg |= 0x00000008
        if condition & KE24XX_SRQ_ON_WAITING_TRIGGER:
            sreReg |= 0x80
            operReg |= 0x00000020
        if condition & KE24XX_SRQ_ON_WAITING_ARM:
            sreReg |= 0x80
            operReg |= 0x00000040
        if condition & KE24XX_SRQ_ON_IDLE:
            sreReg |= 0x80
            operReg |= 0x00000400
        if condition & KE24XX_SRQ_ON_LIMIT1_FAIL:
            sreReg |= 0x01
            measReg |= 0x00000001
        if condition & KE24XX_SRQ_ON_LOWLIMIT2_FAIL:
            sreReg |= 0x01
            measReg |= 0x00000002
        if condition & KE24XX_SRQ_ON_HIGHLIMIT2_FAIL:
            sreReg |= 0x01
            measReg |= 0x00000004
        if condition & KE24XX_SRQ_ON_LOWLIMIT3_FAIL:
            sreReg |= 0x01
            measReg |= 0x00000008
        if condition & KE24XX_SRQ_ON_HIGHLIMIT3_FAIL:
            sreReg |= 0x01
            measReg |= 0x00000010
        if condition & KE24XX_SRQ_ON_LIMITS_PASS:
            sreReg |= 0x01
            measReg |= 0x00000020
        if condition & KE24XX_SRQ_ON_READING_AVAILABLE:
            sreReg |= 0x01
            measReg |= 0x00000040
        if condition & KE24XX_SRQ_ON_READING_OVERFLOW:
            sreReg |= 0x01
            measReg |= 0x00000080
        if condition & KE24XX_SRQ_ON_BUFFER_AVAILABLE:
            sreReg |= 0x01
            measReg |= 0x00000100
        if condition & KE24XX_SRQ_ON_BUFFER_FULL:
            sreReg |= 0x01
            measReg |= 0x00000200
        if condition & KE24XX_SRQ_ON_CONTACT_CHECK:
            sreReg |= 0x01
            measReg |= 0x00000400
        if condition & KE24XX_SRQ_ON_INTERLOCK_ASSERTED:
            sreReg |= 0x01
            measReg |= 0x00000800
        if condition & KE24XX_SRQ_ON_OVER_TEMPERATURE:
            sreReg |= 0x01
            measReg |= 0x00001000
        if condition & KE24XX_SRQ_ON_OVER_VOLTAGE_PROTECTION:
            sreReg |= 0x01
            measReg |= 0x00002000
        if condition & KE24XX_SRQ_ON_COMPLIANCE:
            sreReg |= 0x01
            measReg |= 0x00004000

        self.Ke24xx_WriteRegister(KE24XX_REG_SRE, sreReg)
        self.Ke24xx_WriteRegister(KE24XX_REG_ESE, stdEvReg)
        self.Ke24xx_WriteRegister(KE24XX_REG_QUES_ENAB, quesReg)
        self.Ke24xx_WriteRegister(KE24XX_REG_MEAS_ENAB, measReg)
        self.Ke24xx_WriteRegister(KE24XX_REG_OPER_ENAB, operReg)

    def Ke24xx_ClearEnableRegisters(self):
        self._inst.write("*ESE 0; *SRE 0; :STAT:MEAS:ENAB 0; :STAT:QUES:ENAB 0; :STAT:OPER:ENAB 0")

    def Ke24xx_ClearEventRegisters(self):
        self._inst.write("*CLS")

    def Ke24xx_EnableOPC(self):
        self._inst.write("*OPC")

    def Ke24xx_GetOPC(self):
        status = self.Ke24xx_ReadRegister(KE24XX_REG_ESE_EVENT) & 0b01
        return bool(status)

    def Ke24xx_GetIdleEvent(self):
        status = self.Ke24xx_ReadRegister(KE24XX_REG_OPER_EVENT) & 0b10000000000
        return bool(status)

    def Ke24xx_GetIdleCondition(self):
        status = self.Ke24xx_ReadRegister(KE24XX_REG_OPER_COND) & 0b10000000000
        return bool(status)
