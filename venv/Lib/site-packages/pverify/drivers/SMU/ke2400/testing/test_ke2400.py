# ruff: noqa
"""
This test is for the Keithley 2400 SMU.

Prerequisites:
* When using PyCharm to execute the test:
  File -> Settings -> Tools -> Python Integrated Tools -> Default test runner: py.test
* Put a 1k resistor between the FORCE HI and FORCE LO terminals on the frontpanel.
* Adjust the resource name according to your device setting in the `connect_disconnect()`s `drv.Initialize()` function.
"""

from __future__ import annotations

import sys
from os.path import *

import pytest

rootdir = dirname(__file__)
sys.path.insert(0, rootdir)
# sys.path.insert(1, r"C:\Inicio_dev\flow\simctrl")

from pverify import np
from pverify.drivers.SMU.ke2400.ke2400 import ke2400

UnitV = "Volt DC"
UnitC = "Amp DC"
UnitR = "Ohm"

U = 5.0
R = 1000.0
I = U / R
U_max = U * 1.05
U_min = U * 0.95
R_max = R * 1.05
R_min = R * 0.95
I_max = U_max / R_min
I_min = U_min / R_max


@pytest.fixture(scope="class")
def connect_disconnect(request):
    drv = ke2400()
    drv.Initialize("GPIB0::24::INSTR", True, True, OptionString="simulate=false")
    ch = drv.GetChannel(1)

    # inject class variables
    request.cls.drv = drv
    request.cls.ch = ch
    yield  # Call the test method

    drv.Close()


# Parameters
PERFORMANCE = ("performance", [3])  # [0, 1, 2, 3, 4, 5, 6])
PARAMS_TRIGGER = [
    "triggertype,source,measure",
    [
        ("simple", "voltage", "voltage"),
        ("duration", "voltage", "voltage"),
    ],
]
PARAMS_SWEEP = [
    "sweeptype",
    [
        ("lin"),
        ("step"),
        ("log"),
        ("list"),
    ],
]


@pytest.mark.usefixtures("connect_disconnect")
class Test_ke2400:
    # For code-completion only
    drv = None
    """:type : ke2400"""
    ch = None
    """:type : ke2400_Channel"""

    def test_misc(self):
        self.drv.System.SelectRearTerminal()
        self.drv.System.SelectFrontTerminal()
        # self.drv.System.Beep(1000, 0.05)
        self.drv.System.ClearEventLog()

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMV(self, performance):
        self.ch.SourceMeterSetup("volt", "volt", performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=None)
        self.ch.Source.Voltage.SetCurrentLimit(0.01)
        self.ch.Source.SetOutputEnabled(True)
        self.ch.Measure.AutoZeroOnce()
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert U_min < read < U_max
        assert unit == UnitV

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMI(self, performance):
        self.ch.SourceMeterSetup(Source="voltage", Measure="current", Performance=performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=None)
        self.ch.Source.Voltage.SetCurrentLimit(I_max * 2)
        self.ch.Measure.Current.ConfigureMeasurement(Range=I_max * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert I_min < read < I_max
        assert unit == UnitC

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SVMR(self, performance):
        self.ch.SourceMeterSetup(Source="voltage", Measure="resistance", Performance=performance)
        self.ch.Source.Voltage.ConfigureSource(Amplitude=U, Range=U * 2, ReadBackState=None)
        self.ch.Source.Voltage.SetCurrentLimit(I_max * 2)
        self.ch.Measure.Current.ConfigureMeasurement(Range=I_max * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert U_min < sour < U_max
        assert sourunit == UnitV
        assert R_min < read < R_max
        assert unit == UnitR

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMV(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="voltage", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=None)
        self.ch.Source.Current.SetVoltageLimit(U * 2)
        self.ch.Measure.Voltage.ConfigureMeasurement(Range=U * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert U_min < read < U_max
        assert unit == UnitV

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMI(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="current", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=None)
        self.ch.Source.Current.SetVoltageLimit(U_max)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert I_min < read < I_max
        assert unit == UnitC

    @pytest.mark.parametrize(*PERFORMANCE)
    def test_SIMR(self, performance):
        self.ch.SourceMeterSetup(Source="current", Measure="resistance", Performance=performance)
        self.ch.Source.Current.ConfigureSource(Amplitude=I, Range=I * 2, ReadBackState=None)
        self.ch.Source.Current.SetVoltageLimit(U * 2)
        self.ch.Measure.Voltage.ConfigureMeasurement(Range=U * 2)
        self.ch.Source.SetOutputEnabled(True)
        sour, sourunit, read, unit = self.ch.Measure.Read("SOUR, SOURUNIT, READ, UNIT")
        self.ch.Source.SetOutputEnabled(False)

        assert I_min < sour < I_max
        assert sourunit == UnitC
        assert R_min < read < R_max
        assert unit == UnitR

    def test_direct_IO(self):
        self.drv.DirectIO.Write("*IDN?")
        idn1 = self.drv.DirectIO.Read().strip()
        idn2 = self.drv.DirectIO.Query("*IDN?").strip()

        assert idn1 == idn2
        assert idn1.upper().startswith("KEITHLEY INSTRUMENTS INC.,MODEL 2400")

    @pytest.mark.parametrize(*PARAMS_TRIGGER)
    def test_trigger(self, triggertype, source, measure):
        self.ch.SourceMeterSetup(Source=source, Measure=measure, Performance=3)
        self.ch.Source.Voltage.SetCurrentLimit(I_max)

        if triggertype == "simple":
            self.drv.Trigger.ConfigureSimpleLoopTrigger(Count=10, Delay=0.05)
        else:
            self.drv.Trigger.ConfigureDurationLoopTrigger(Duration=0.5, Delay=0.05)

        self.ch.Source.SetOutputEnabled(True)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        self.ch.Source.SetOutputEnabled(False)

        sour, sourunit, read, unit = self.ch.Measure.Trace.GetData(
            BufferElements="SOUR, SOURUNIT, READ, UNIT", Transposed=True
        )

        if "volt" in source:
            assert all(np.array(sour) > U_min)
            assert all(np.array(sour) < U_max)
            assert all(np.array(sourunit) == UnitV)
        elif "curr" in source:
            assert all(np.array(sour) > I_min)
            assert all(np.array(sour) < I_max)
            assert all(np.array(sourunit) == UnitC)

        if "volt" in measure:
            assert all(np.array(read) > U_min)
            assert all(np.array(read) < U_max)
            assert all(np.array(sourunit) == UnitV)
        elif "curr" in measure:
            assert all(np.array(read) > I_min)
            assert all(np.array(read) < I_max)
            assert all(np.array(sourunit) == UnitC)
        elif "res" in measure:
            assert all(np.array(read) > R_min)
            assert all(np.array(read) < R_max)
            assert all(np.array(sourunit) == UnitR)

    @pytest.mark.parametrize(*PARAMS_SWEEP)
    def test_sweep(self, sweeptype):
        self.ch.SourceMeterSetup(Source="voltage", Measure="voltage", Performance=3)
        self.ch.Source.Voltage.SetCurrentLimit(I_max)

        if sweeptype == "lin":
            self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=10, Delay=0.05)
        elif sweeptype == "step":
            self.ch.Source.Voltage.ConfigureLinearSweepStep(Start=0, Stop=5, Step=0.5, Delay=0.05)
        elif sweeptype == "log":
            self.ch.Source.Voltage.ConfigureLogarithmicSweep(Start=0.01, Stop=5, Points=10, Delay=0.05)
        elif sweeptype == "list":
            self.ch.Source.Voltage.ConfigureListSweep(Values=[0, 1, 2, 3, 4, 5], Ranges=None, Delay=0.1)

        self.ch.Source.SetOutputEnabled(True)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        self.ch.Source.SetOutputEnabled(False)

        sour, sourunit, read, unit = self.ch.Measure.Trace.GetData(
            BufferElements="SOUR, SOURUNIT, READ, UNIT", Transposed=True
        )

        assert all(np.array(sourunit) == UnitV)
        assert all(np.array(sourunit) == UnitV)

        if sweeptype == "lin":
            assert all(
                np.array(read) > np.array([0, 0.5555045, 1.111, 1.666, 2.222, 2.778, 3.333, 3.889, 4.444, 5.0]) - 0.05
            )
            assert all(
                np.array(read) < np.array([0, 0.5555045, 1.111, 1.666, 2.222, 2.778, 3.333, 3.889, 4.444, 5.0]) + 0.05
            )
        elif sweeptype == "step":
            assert all(np.array(read) > np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]) - 0.05)
            assert all(np.array(read) < np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]) + 0.05)
        elif sweeptype == "log":
            assert all(
                np.array(read)
                > np.array(
                    [
                        0.0101,
                        0.02008,
                        0.0400,
                        0.0796,
                        0.1585,
                        0.3159,
                        0.6300,
                        1.256,
                        2.50675,
                        5.0,
                    ]
                )
                - 0.05
            )
            assert all(
                np.array(read)
                < np.array(
                    [
                        0.0101,
                        0.02008,
                        0.0400,
                        0.0796,
                        0.1585,
                        0.3159,
                        0.6300,
                        1.256,
                        2.50675,
                        5.0,
                    ]
                )
                + 0.05
            )
        elif sweeptype == "list":
            assert all(np.array(read) > np.array([0, 1, 2, 3, 4, 5]) - 0.05)
            assert all(np.array(read) < np.array([0, 1, 2, 3, 4, 5]) + 0.05)

    def test_trace_measurements(self):
        self.ch.SourceMeterSetup(Source="voltage", Measure="voltage", Performance=3)
        self.ch.Source.Voltage.SetCurrentLimit(I_max)

        self.ch.Source.Voltage.ConfigureLinearSweep(Start=0, Stop=5, Points=10, Delay=0.05)

        self.ch.Source.SetOutputEnabled(True)
        self.drv.Trigger.Initiate()
        self.drv.Trigger.Wait4Idle(10)
        self.ch.Source.SetOutputEnabled(False)

        assert 2.48 < self.ch.Measure.Trace.GetAverageReading() < 2.52
        assert 4.98 < self.ch.Measure.Trace.GetPeak2PeakReading() < 5.02
        assert 4.98 < self.ch.Measure.Trace.GetMaximumReading() < 5.02
        assert -0.02 < self.ch.Measure.Trace.GetMinimumReading() < 0.02
        assert 1.50 < self.ch.Measure.Trace.GetSDevReading() < 1.70
