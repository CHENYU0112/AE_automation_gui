from __future__ import annotations

from pverify.core.lab.ivi.helper import InstrumentError

from .ke2400_const import *


class ke2400_Measure_X:
    def __init__(self, parent, function):
        self._parent = parent
        """:type : pverify.drivers.SMU.ke2400.ke2400_Measure.ke2400_Measure"""
        self._name = self._parent._name
        self._function = function

    @property
    def _root(self):
        return self._parent._parent._parent

    @property
    def _inst(self):
        """
        The instrument visa resource
        """
        return self._root._inst

    def ConfigureMeasurement(
        self,
        Range=None,
        AutoZeroState=None,
        EnableOffsetCompensation=None,
        EnableRemoteSense=None,
        NPLC=None,
        Resolution=None,
    ):
        """
        Configures the SMU measurement for the current selected function

        :param Range: the positive full-scale value of the measurement range for measurements of the selected function
        :type Range: int|float
        :param AutoZeroState: Enables/Disables AutoZero state
        :type AutoZeroState: bool
        :param EnableOffsetCompensation: Enables or disables offset compensation for **resistance** measurement function
        :type EnableOffsetCompensation: bool
        :param EnableRemoteSense: Determines 2-wire (local) or 4-wire (remote) sensing is used
        :type EnableRemoteSense: bool
        :param NPLC: the amount of time(based on the number of power line cycles) that the input signal is measured
        :type NPLC: int|float
        :param Resolution: the number of digits that are displayed for measurements on the front panel.
        :type Resolution: int|float
        """
        if Range is not None:
            source = self._inst.query(":SOUR:FUNC:MODE?")
            if self._function.upper() in source.upper():
                msg = "Instrument doesn't allow to change the measure range to something other than the source range in readback mode. Either leave the measure range as it is (equal to source range), or configure the smu to not (also) measure the source you configured. You can do this with ke2400.LowLevel.Ke24xx_SelectSenseFunc()."
                raise Exception(msg)
            else:
                self._inst.write(f":SENS:{self._function}:DC:RANG {Range:f}")
        if AutoZeroState is not None:
            self._root.LowLevel.Ke24xx_EnableAutoZero(AutoZeroState)
            try:
                self._root.CheckError()
            except InstrumentError as ie:
                self._root._log.debug(
                    f"Suppressed errors:\n\tDescription: {ie.description}, Status: {ie.status}",
                    exc_info=False,
                )
        if EnableOffsetCompensation is not None:  # and self._parent._parent._measure_fct == KE24XX_READ_RESISTANCE:
            self._root.LowLevel.Ke24xx_ResSenseOffsetCompensation(EnableOffsetCompensation)
        if EnableRemoteSense is not None:
            self._root.LowLevel.Ke24xx_EnableRemoteSensing(EnableRemoteSense)
        if NPLC is not None:
            self._inst.write(f":SENS:{self._function}:DC:NPLC {NPLC:f}" "")
        if Resolution is not None:
            self._root.LowLevel.Ke24xx_ConfigureDisplayResolution(Resolution)
        self._root.CheckError()

    def ConfigureAutoRange(self, Enabled, LowLimit=None, VoltageUpperLimit=None, ResistanceUpperLimit=None):
        """
        Configure measurement auto-range settings

        :param Enabled: Enable/disable auto-range
        :type Enabled: bool
        :param LowLimit: not used - kept for compliance with ke2450
        :param VoltageUpperLimit: not used - kept for compliance with ke2450
        :param ResistanceUpperLimit: not used - kept for compliance with ke2450
        """
        source = self._inst.query(":SOUR:FUNC:MODE?")
        if self._function.upper() in source.upper():
            msg = "Instrument doesn't allow to change the measure range to something other than the source range in readback mode. Either leave the measure range as it is (equal to source range), or configure the smu to not (also) measure the source you configured. You can do this with ke2400.LowLevel.Ke24xx_SelectSenseFunc()."
            raise Exception(msg)

        if bool(Enabled):
            self._inst.write(f":SENS:{self._function}:DC:RANG:AUTO ON")
        else:
            self._inst.write(f":SENS:{self._function}:DC:RANG:AUTO OFF")
        self._root.CheckError()
        if LowLimit is not None:
            raise NotImplementedError
        if VoltageUpperLimit is not None:
            raise NotImplementedError
        if ResistanceUpperLimit is not None:
            raise NotImplementedError

    def ConfigureAveragingFilter(self, Enabled, Count=None, Type=None):
        """
        Configures measurement averaging

        :param Enabled: Enables or disables the averaging filter for measurements of the selected function
        :type Enabled: bool
        :param Count: the number of measurements that are averaged when filtering is enabled for the function measurements
        :type Count: int|float
        :param Type: the type of averaging filter that is used for measurements for the selected function when the measurement filter is enabled.

                     Valid values: "moving", "repeating" or short "mov", "rep"
        :type Type: str
        """

        self._root.LowLevel.Ke24xx_EnableFilter(bool(Enabled))
        if Enabled:
            if Count is not None:
                self._root.LowLevel.Ke24xx_ConfigureFilterWeight(int(Count))
            if Type is not None:
                Type = str(Type).lower()
                if "rep" in Type:
                    self._root.LowLevel.Ke24xx_ConfigureFilterType(KE24XX_REPEAT_FILTER)
                elif "mov" in Type:
                    self._root.LowLevel.Ke24xx_ConfigureFilterType(KE24XX_MOVING_FILTER)
                else:
                    msg = "Invalid value for parameter 'Type'. Valid: 'repeating', 'moving'."
                    raise ValueError(msg)
        self._root.CheckError()

    def ConfigureRelativeOffset(self, Enabled, Offset=None):
        """
        Configures the relative offset settings for the measurement.

        :param Enabled: Enables or disables the null relative offset value.
        :type Enabled: bool
        :param Offset: the relative offset value for the measurement
        :type Offset: float|int
        """
        raise NotImplementedError

    def Acquire(self):
        """
        Acquires an internal measurement to store as the relative offset value
        """
        raise NotImplementedError


class ke2400_Measure_V(ke2400_Measure_X):
    def __init__(self, parent):
        ke2400_Measure_X.__init__(self, parent, "VOLT")

    def ConfigureVoltageMeasureUnits(self, unit):
        """
        not used - kept for compliance with ke2450
        """
        raise NotImplementedError


class ke2400_Measure_C(ke2400_Measure_X):
    def __init__(self, parent):
        ke2400_Measure_X.__init__(self, parent, "CURR")

    def ConfigureCurrentMeasureUnits(self, unit):
        """
        not used - kept for compliance with ke2450
        """
        raise NotImplementedError
