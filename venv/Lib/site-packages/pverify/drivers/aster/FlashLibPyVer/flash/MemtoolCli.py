# Copyright (C) Infineon Technologies (2019)
#
# All rights reserved.
#
# This document contains proprietary information belonging to Infineon
# Technologies. Passing on and copying of this document, and communication
# of its contents is not permitted without prior written authorization.

""" This module provides the flash capabilities"""
from __future__ import annotations

import os
import re
import subprocess
import sys

from . import FlashBase, FlashLibError


class MemtoolCli(FlashBase):
    """Flashing the target."""

    ROBOT_LIBRARY_SCOPE = "TEST SUITE"
    memtool_cfg = {}

    def __init__(self, cfg_dict=None):
        """Constructor for memtoolcli driver"""
        # Call the parent constructor for forward compatibility
        super().__init__()
        if cfg_dict:
            self.memtool_cfg.update(cfg_dict)

    def init_flash_lib(self, flash_cfg=None):
        """Initialize Flash Lib"""
        if flash_cfg:
            self.memtool_cfg.update(flash_cfg)
        self.memtool_cfg["MEMTOOL_PATH"] = self.memtool_cfg["Driver"]["MemtoolCli"]

    def command_flash(self, command=None, bin_file=None, sections=None, log_level=None):
        """Command flash"""
        memtool_path = self.memtool_cfg["MEMTOOL_PATH"]
        cfg_file = self.memtool_cfg["MEMTOOL_CFG"]
        # TODO: This is inter library config
        log_dir = os.getcwd()

        if bin_file:
            if not bin_file.endswith(".hex"):
                raise FlashLibError("FlashLib: Memtool supports only hex files. File: %s" % (bin_file))
            hex_file = bin_file

        if not log_level:
            log_level = "100"

        # Basic command
        cmd = [memtool_path, command, "-c", cfg_file, "-l", log_level]
        if command == "PROGRAM" or command == "VERIFY":
            # Add hex file on position 2
            cmd.insert(2, hex_file)
            if sections:  # Add sections on position 3
                cmd.insert(3, sections)
            # Add the log at the end
            cmd.extend(["-v", log_dir + "/verify.log"])
        elif command == "ERASE":
            if sections:  # Add sections on position 3
                cmd.insert(2, sections)
        else:
            raise FlashLibError("FlashLib: %s is not a valid command for flash!!" % command)

        try:
            ret_err = self.execute(cmd=cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except FileNotFoundError:
            raise FlashLibError("Memtool program path is invalid. Path= %s" % (memtool_path))

        ret_err_comm = ret_err.communicate()[0]

        if ret_err.returncode == 1 and command != "VERIFY":
            match = re.search(b"Demo limit exceeded", ret_err_comm)
            if match:
                msg = "License Error occurred!"
                raise FlashLibError(msg)
        elif ret_err.returncode == 1 and command == "VERIFY":
            if re.search(rb"Error:\s+\d+\s+differences\s+found", ret_err_comm):
                ret_err.returncode = 2
            else:
                match = re.search(b"Error:\\s+.+\n", ret_err_comm)
                match_str = None
                if match:
                    match_str = match.group()
                msg = "FlashLib: Error occurred: %s"
                raise FlashLibError(msg, match_str)

        return ret_err

    def program_flash(self, bin_file=None, sections=None, log_level=None):
        """ Program Flash
        Args
        | bin_file
        |   Complete path to binary file which should be flashed on DUT

        | sections
        |   Zero based index of a sector to be programmed when executing\
            the PROGRAM command. When omitted all sectors are programed.

        | log_level
        |   Set the log level for diagnostic output. Range: 0 ... 100
        |   0 ... no log output
        |   10 ... Log errors, main steps and function progress
        |   50 ... Log additional steps for diagnostic
        |   100 ... Log almost all internal function calls for debugging
        |   This argument is optional. When omitted the value is taken that\
            was lastly used
        """
        # Verify before Program
        verify_ret = self.verify_flash(bin_file=bin_file, sections=sections, log_level=log_level)

        if verify_ret.returncode == 2:
            return self.command_flash(
                command="PROGRAM",
                bin_file=bin_file,
                sections=sections,
                log_level=log_level,
            )
        elif verify_ret.returncode == 0:
            return verify_ret
        return None

    def erase_flash(self, sections=None, log_level=None):
        """ Erase Flash
        Args
        | sections
        |   Zero based index of a sector to be programmed when executing\
            the ERASE command. When omitted all sectors are erased.

        | log_level
        |   Set the log level for diagnostic output. Range: 0 ... 100
        |   0 ... no log output
        |   10 ... Log errors, main steps and function progress
        |   50 ... Log additional steps for diagnostic
        |   100 ... Log almost all internal function calls for debugging
        |   This argument is optional. When omitted the value is taken that\
            was lastly used
        """
        return self.command_flash(command="ERASE", sections=sections, log_level=log_level)

    def verify_flash(self, bin_file=None, sections=None, log_level=None):
        """ Verify Flash
        Args
        | bin_file
        |   Complete path to bianry file which should be verified on DUT

        | sections
        |   Zero based index of a sector to be verified when executing\
            the VERIFY command. When omitted all sectors are verified.

        | log_level
        |   Set the log level for diagnostic output. Range: 0 ... 100
        |   0 ... no log output
        |   10 ... Log errors, main steps and function progress
        |   50 ... Log additional steps for diagnostic
        |   100 ... Log almost all internal function calls for debugging
        |   This argument is optional. When omitted the value is taken that\
            was lastly used
        """
        return self.command_flash(command="VERIFY", bin_file=bin_file, sections=sections, log_level=log_level)

    def execute(self, cmd=None, stdout=None, stderr=None):
        """Extending subprocess Popen"""
        return subprocess.Popen(args=cmd, stdout=stdout, stderr=stderr)


if __name__ == "__main__":
    class_obj = MemtoolCli()
    method_name = sys.argv[1]
    method_args = sys.argv[2:]

    try:
        method = getattr(class_obj, method_name)
        method(*method_args)
    except AttributeError:
        raise FlashLibError('Not a valid attribute: "%s"' % method_name)
