from __future__ import annotations

import importlib
import sys

try:
    import AseCfg
except ImportError:
    AseCfg = None

import contextlib

from .flash import FlashBase, FlashLibError


class FlashLib(FlashBase):
    """
    FlashLib provides a way to interact with the Flash tool in order to
    perform some basic actions like flash the binary image on hardware
    device. It also provides other functionalities like 'Reset Device' and
    'Erase Flash'. In order to use Flash Lib standalone, user can call
    init_flash_lib with proper configuration.

    FlashLib will use FLASH_TOOL to perform all flash operations.
    Currently, FlashLib provides support of MemtoolCli and MemtoolExe as
    Flash tool.

    **MemtoolCli:**
        - Memtool Command line interface is good to use as it provides a
          better control over the device under test.
        - Provision to verify flash before programming.
        - Better error handling provided without delay.
        - Generates a flash log in results folder.
        - Avaialble only with UDE memtool and hence needs a UDE license.

    **MemtoolExe:**
        - Memtool GUI support is provided for UDE and Infineon Memtool. Hence
          no need of UDE license all the time.
        - When working with memtool exe, a timeout of 180 sec is provided.
        - Error handling is not done with Memtool Exe.

    If you get a FlashLibError when working with Memtool then look for following things:
        - USB Connection issues between DUT and PC.
        - DUT is powered on with correct power supply.
        - MEMTOOL_CFG file is available in path specified.
        - UDE Dongle is connected if using UDE Memtool.
    """

    _flash_lib_cfg = {}
    _flash_connections = {}

    def __init__(self, flash_cfg=None, **kwargs):
        """Constructor."""
        # Call the parent constructor for forward compatibility
        super().__init__()

        if flash_cfg or kwargs:
            self.init_flash_lib(flash_cfg=flash_cfg, **kwargs)

    def init_flash_lib(self, connection=0, flash_cfg=None, **kwargs):
        """
        Initialize FlashLib: It will initialize the driver bconfiguration by the values provided.

        :param connection: The connection id.
        :type connection: int
        :param flash_cfg: The Configuration dictonary.
        :type flash_cfg: dict
        """
        # Load the configuration
        self._update_cfg(flash_cfg, **kwargs)
        self._map_channels()
        # self.initialized = True
        _id = str(connection)
        self._flash_connections[_id]["Driver"]["@obj"].init_flash_lib(flash_cfg=self._flash_connections[_id], **kwargs)

    def program_flash(self, connection=0, bin_file=None, **kwargs):
        """Program Flash: It will dump the hex file in the microcontroller using Memtool.

        :param connection: The connection id.
        :type connection: int
        :param bin_file: The Hex files to be flashed.
        :type bin_file: list
        """
        _id = str(connection)
        self._flash_connections[_id]["Driver"]["@obj"].program_flash(bin_file=bin_file, **kwargs)

    def erase_flash(self, connection=0, **kwargs):
        """Erase Flash: It will clean up the memory of the microcontroller.

        :param connection: The connection id.
        :type connection: int
        """
        _id = str(connection)
        self._flash_connections[_id]["Driver"]["@obj"].erase_flash(**kwargs)

    def verify_flash(self, connection=0, bin_file=None, **kwargs):
        """Verify Flash: It will verify the program which we flashed is correctly dumped in the microcontroller.

        :param connection: The connection id.
        :type connection: int
        :param bin_file: The Hex files to be flashed.
        :type bin_file: list
        """
        _id = str(connection)
        self._flash_connections[_id]["Driver"]["@obj"].verify_flash(bin_file=bin_file, **kwargs)

    def _update_cfg(self, flash_cfg=None, **kwargs):
        """Updates the current configuration using the configuration
        dictionary object "flash_cfg". If some pairs name=value the
        kwargs are available then they will also update
        the configuration
        """
        _ase_flash = None
        _cfg = None
        # Load the configuration
        with contextlib.suppress(AttributeError, KeyError):
            _ase_flash = AseCfg.get_ase_cfg("FlashLib")
        if flash_cfg and _ase_flash or flash_cfg:
            _cfg = flash_cfg
        elif _ase_flash:
            _cfg = _ase_flash
        else:
            msg = "No valid configuration found."
            raise FlashLibError(msg)

        self._flash_lib_cfg.update(_cfg)

        if kwargs:
            self._flash_lib_cfg.update(**kwargs)

    def _map_channels(self):
        """Get the channels from the configuration object and map its ID to
        a dictionary key. The returned channels configuration can be either
        one channel dictionary or a list of channels dictionaries
        """
        _cfg = self._flash_lib_cfg["Connection"]
        if isinstance(_cfg, dict):  # only one dictionary returned
            self._map_channel(_cfg)
        elif isinstance(_cfg, list):  # list of dictionaries returned
            for _ch in _cfg:
                self._map_channel(_ch)

    def _map_channel(self, chcfg=None):
        """Maps the channel configuration "chcfg" to the corresponding
        channel id in the "self._flash_connections" object.
        Furthermore this function creates an object to the class
        represented by the "Driver" configuration value and stores it to the
        '@obj' key.
        """
        _id = chcfg["@id"]
        self._flash_connections[_id] = chcfg
        _drv_name = chcfg["Driver"]["@name"]
        self._flash_connections[_id]["Driver"]["@obj"] = self._import_driver(_drv_name)

    def _import_driver(self, driver=None):
        """Dynamicall import the driver represented by "driver"

        Args:
        driver , package: it is a string representing the module (file) name
                    where the driver functionality is implemented. It can
                    contain the package name: "package.module" or just "module"
                    If only the module is utilized and it is not importable
                    (e.g. inside a package) then this function will try to
                    prefix the module with the package
                    DRIVER_PACKAGE_NAME='flash'

        Returns: allocated object
        Raises: FlashLibError
        """
        _module_name = driver
        _module = None
        _driver = driver
        _obj = None

        DRIVER_PACKAGE_NAME = FlashLib.__module__.rsplit(".", 1)[0] + ".flash"

        # Try to import the module as it is
        try:
            _module = importlib.import_module(name=_driver, package=DRIVER_PACKAGE_NAME)
        except ImportError:
            # If there is an error then add the package prefix and try again
            # to import the module
            try:
                _driver = f"{DRIVER_PACKAGE_NAME}.{_driver}"
                _module = importlib.import_module(name=_driver)
            except ImportError:
                raise FlashLibError("Driver=[%s] cannot be imported. Please check its availability" % (_driver))
        # If the module name contains the package then split it and use only
        # the name
        if "." in _module_name:
            _module_name = _module_name.split(".")[1]
        # Parse all the attributes of the module and check if the main class
        # has the same name as the module and instantiate it
        for _i in dir(_module):
            if _i.lower() == _module_name.lower():
                _obj = getattr(_module, _i)(self._flash_connections)
                break

        if not _obj:
            raise FlashLibError("No valid driver found in %s" % (_module))
        return _obj


if __name__ == "__main__":
    class_obj = FlashLib()
    method_name = sys.argv[1]
    method_args = sys.argv[2:]

    try:
        method = getattr(class_obj, method_name)
        method(*method_args)
    except AttributeError:
        raise AttributeError('Not a valid attribute: "%s"' % method_name)
