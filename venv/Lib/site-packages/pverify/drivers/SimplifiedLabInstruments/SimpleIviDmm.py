from __future__ import annotations

import copy
from typing import Any

from pverify.drivers.SimplifiedLabInstruments._simple_instr.simple_dmm import SimpleIviDmm_ABC

dmms_not_supporting_multipoint = ["Ag34405", "ke2000", "ke2100"]


class SimpleIviDmm(SimpleIviDmm_ABC):
    def __init__(self, driver, alias: str | None = None):
        super().__init__(driver, alias)

        self._liveview = False
        self._liveview_idle_configuration = {
            "count": int(1e9),
            "samplecount": 1,
            "interval": 0.2,
            "trigger": self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerInterval,
        }

        self._liveview_read_configuration = {
            "count": 1,
            "samplecount": 1,
            "interval": 0.2,
            "trigger": self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerImmediate,
        }
        # initializing the backup with sensible content
        self._multipoint_backup = copy.copy(self._liveview_read_configuration)

    @property
    def Initialized(self):
        return self.lld.Initialized

    @property
    def drivername(self):
        return self.lld.drivername

    @property
    def liveview(self):
        return self._liveview

    def Initialize(self, ResourceName, IdQuery, Reset, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
            of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: The user can use the OptionsString parameter to specify the initial values of
            certain IVI inherent attributes for the session. The format of an assignment in
            the OptionsString parameter is "Name=Value", where Name is one of: RangeCheck,
            QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck, or
            DriverSetup. Value is either true or false except for DriverSetup. If the
            Options String parameter contains an assignment for the Driver Setup attribute,
            the Initialize function assumes that everything following "DriverSetup=" is part
            of the assignment.
        :type OptionString: str
        """
        self.lld._check_ivi_compliance()

        self.lld.Initialize(ResourceName, IdQuery, Reset, OptionString)

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Close()

    def DmmSetup(self, Function=None, Range=None, Resolution=None, AutoZero=None):
        """
        Common setup function for the DMM.

        :param Function: The measurement function. This property determines the units for Range and Resolution and
                         the values returned by the Read, Read Multiple Point, Fetch, and Fetch Multiple Point methods.
        :type Function: choice(DCVolts,ACVolts,DCCurrent,ACCurrent,2WireRes,4WireRes,Freq,Period)
        :param Range: The measurement range, coerced by the driver to the appropriate range for the instrument.
                      Positive values set the absolute value of the maximum measurement expected.
                      Negative values set Auto Range mode. Units are determined by Function.
        :type Range: float
        :param Resolution: The measurement resolution in absolute units. Units are determined by Function.
        :type Resolution: float
        :param AutoZero: The auto-zero mode. When the auto-zero mode is enabled, the DMM internally disconnects the
                         input signal and takes a Zero Reading. The DMM then subtracts the Zero Reading from the
                         measurement.
        :type AutoZero: choice(On,Off,Once)
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if isinstance(Function, str):
            _Function = str(Function).lower()
            if _Function.startswith("dcv"):
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunctionDCVolts
            elif "acv" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunctionACVolts
            elif "dcc" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunctionDCCurrent
            elif "acc" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunctionACCurrent
            elif "2" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunction2WireRes
            elif "4" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunction4WireRes
            elif "freq" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunctionFreq
            elif "per" in _Function:
                self.lld.Function = self.lld.Enums.IviDmmFunctionEnum.IviDmmFunctionPeriod
            else:
                msg = f"Unknown measure function '{Function}'"
                raise ValueError(msg)

        if Range is not None:
            self.lld.Range = Range
        if Resolution is not None:
            self.lld.Resolution = Resolution

        if isinstance(AutoZero, str):
            _AutoZero = str(AutoZero).lower()
            if "once" in _AutoZero:
                self.lld.Advanced.AutoZero = self.lld.Enums.IviDmmAutoZeroEnum.IviDmmAutoZeroOnce
            elif "off" in _AutoZero:
                self.lld.Advanced.AutoZero = self.lld.Enums.IviDmmAutoZeroEnum.IviDmmAutoZeroOff
            elif "on" in _AutoZero:
                self.lld.Advanced.AutoZero = self.lld.Enums.IviDmmAutoZeroEnum.IviDmmAutoZeroOn
            else:
                self.lld.Advanced.AutoZero = self.lld.Enums.IviDmmAutoZeroEnum.IviDmmAutoZeroOnce

    def Configure_AC_Measurement(self, FrequencyMin=None, FrequencyMax=None):
        """
        Setup function for AC measurements.

        :param FrequencyMin: The minimum frequency component of the input signal for AC measurements.
                             The value of this property affects instrument behavior only when the Function
                             property is set to an AC voltage or AC current measurement.
        :type FrequencyMin: float
        :param FrequencyMax: The maximum frequency component of the input signal for AC measurements.
                             The value of this property affects instrument behavior only when the Function
                             property is set to an AC voltage or AC current measurement.
        :type FrequencyMax: float
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if FrequencyMin is not None:
            self.lld.AC.FrequencyMin = FrequencyMin
        if FrequencyMax is not None:
            self.lld.AC.FrequencyMax = FrequencyMax

    def Configure_Freq_Measurement(self, VoltageRange=None):
        """
        Setup function for Frequency measurements.

        :param VoltageRange: The expected maximum voltage level of the input signal for frequency and period
                             measurements.
                             Positive values set the manual range. Negative values set Auto Range mode.
                             The units are specified in Volts RMS.
        :type VoltageRange: float
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if VoltageRange is not None:
            self.lld.Frequency.VoltageRange = VoltageRange

    def Configure_Trigger(self, Source=None, Slope=None, Delay=None):
        """
        Setup function for DMM trigger.

        :param Source: The trigger source.
        :type Source: choice(Immediate,External,SW,TTL0,TTL1,TTL2,TTL3,TTL4,TTL5,TTL6,TTL7,ECL0,ECL1)
        :param Slope: The polarity of the external trigger slope, which determines whether the DMM triggers on
                      either the rising or the falling edge of the external trigger source.
        :type Slope: choice(Positive,Negative)
        :param Delay: The interval between the time when the DMM receives the trigger and the time when it takes a
                      measurement. Positive values set the trigger delay in seconds. Negative values set auto delay
                      mode.
        :type Delay: float
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if isinstance(Slope, str):
            try:
                if "neg" in Slope.lower():
                    self.lld.Trigger.Slope = self.lld.Enums.IviDmmTriggerSlopeEnum.IviDmmTriggerSlopeNegative
                else:
                    self.lld.Trigger.Slope = self.lld.Enums.IviDmmTriggerSlopeEnum.IviDmmTriggerSlopePositive
            except Exception:
                pass
        if Delay is not None:
            self.lld.Trigger.Delay = Delay

        if isinstance(Source, str):
            _Source = str(Source).lower()
            if "imm" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceImmediate
            elif "ext" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceExternal
            elif "sw" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceSwTrigFunc
            elif "ttl0" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL0
            elif "ttl1" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL1
            elif "ttl2" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL2
            elif "ttl3" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL3
            elif "ttl4" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL4
            elif "ttl5" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL5
            elif "ttl6" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL6
            elif "ttl7" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceTTL7
            elif "ecl0" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceECL0
            elif "ecl1" in _Source:
                self.lld.Trigger.Source = self.lld.Enums.IviDmmTriggerSourceEnum.IviDmmTriggerSourceECL1

    def Configure_Multipoint(self, Count=None, SampleCount=None, SampleInterval=None, SampleTrigger=None):
        """
        Setup function for multipoint measurement.

        :param Count: The number of triggers the DMM accepts before it returns to the idle state.
        :type Count: int
        :param SampleCount: The number of measurements the DMM takes each time it receives a trigger.
        :type SampleCount: int
        :param SampleInterval: The interval between samples in seconds. Applies only when Sample Count is greater than 1
                               and Sample Trigger is Interval.
        :type SampleInterval: float
        :param SampleTrigger: The sample trigger source. If the value of the Sample Count is greater than 1,
                              the DMM enters the Wait-For-Sample-Trigger state after taking a single measurement.
                              When a sample trigger occurs, the DMM takes the next measurement.
        :type SampleTrigger: choice(Immediate,External,Interval,SW,TTL0,TTL1,TTL2,TTL3,TTL4,TTL5,TTL6,TTL7,ECL0,ECL1)
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if self.drivername in dmms_not_supporting_multipoint:
            msg = "This driver does not support the IviDmmMultipoint feature."
            raise NotImplementedError(msg)

        if Count is not None:
            self.lld.Trigger.MultiPoint.Count = Count
        if SampleCount is not None:
            self.lld.Trigger.MultiPoint.SampleCount = SampleCount
        if SampleInterval is not None:
            self.lld.Trigger.MultiPoint.SampleInterval = SampleInterval

        if isinstance(SampleTrigger, str):
            _SampleTrigger = str(SampleTrigger).lower()
            if "imm" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerImmediate
                )
            elif "ext" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerExternal
                )
            elif "int" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerInterval
                )
            elif "sw" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerSwTrigFunc
                )
            elif "ttl0" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL0
                )
            elif "ttl1" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL1
                )
            elif "ttl2" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL2
                )
            elif "ttl3" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL3
                )
            elif "ttl4" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL4
                )
            elif "ttl5" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL5
                )
            elif "ttl6" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL6
                )
            elif "ttl7" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerTTL7
                )
            elif "ecl0" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerECL0
                )
            elif "ecl1" in _SampleTrigger:
                self.lld.Trigger.MultiPoint.SampleTrigger = (
                    self.lld.Enums.IviDmmSampleTriggerEnum.IviDmmSampleTriggerECL1
                )
            else:
                msg = f"Unknown SampleTrigger '{SampleTrigger}'"
                raise ValueError(msg)

    def Initiate(self):
        """
        Initiates the DMM acquisition.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Measurement.Initiate()

    def Abort(self):
        """
        Aborts the DMM acquisition.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Measurement.Abort()

    def Send_Software_Trigger(self):
        """
        Sends a software trigger, which causes the DMM to take a measurement.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Measurement.SendSoftwareTrigger()

    def LiveViewEnable(self, interval: float = 0.2, duration: int | None = None):
        """
        Enables a live view on the DMMs front panel. Use this if you want to see live readings in between remote
        read/fetch operations.

        DISCLAIMER: Impacts multipoint fetch because this feature uses multipoint mode with a suitable configuration to
        achieve live view. Fetch will return the readings of the live view and not of your custom multipoint
        configuration. Multipoint reads on the other hand still work if you configure it before enabling live view.
        Only use this if you need it as it will impose a certain overhead when doing read/fetch operations while in live
        mode.

        :param interval: The interval in which the front panel of the DMM is updated. Unit is seconds.
        :param duration: If provided, limits the duration of the live view. Unit is seconds.
        """

        if self.drivername in dmms_not_supporting_multipoint:
            msg = "LiveView mode requires the Multipoint feature which is not supported by this DMM."
            raise NotImplementedError(msg)

        self.Abort()
        # backup multipoint settings
        self._multipoint_backup = {
            "count": self.lld.Trigger.MultiPoint.Count,
            "samplecount": self.lld.Trigger.MultiPoint.SampleCount,
            "interval": self.lld.Trigger.MultiPoint.SampleInterval,
            "trigger": self.lld.Trigger.MultiPoint.SampleTrigger,
        }
        # using multipoint to achieve live view: configure_multi with sample count 1 and count calculated based on
        # duration and interval, sample trigger "interval"
        self._liveview_idle_configuration["interval"] = interval
        if duration:
            self._liveview_idle_configuration["count"] = int(duration / interval)

        self._apply_multipoint_settings(self._liveview_idle_configuration)

        # start sampling
        self.Initiate()
        # set liveview flag
        self._liveview = True

    def LiveViewDisable(self):
        """
        Disables the live view on the DMMs front panel.
        """
        self.Abort()
        self._apply_multipoint_settings(self._multipoint_backup)
        self._liveview = False

    def _apply_multipoint_settings(self, settings: dict[str, Any]):
        """
        Takes the multipoint settings from a dict and applies them to the
        low level driver IVI attributes.

        :param settings: A dict containing the essential multipoint parameters.
        """
        self.lld.Trigger.MultiPoint.Count = settings["count"]
        self.lld.Trigger.MultiPoint.SampleCount = settings["samplecount"]
        self.lld.Trigger.MultiPoint.SampleInterval = settings["interval"]
        self.lld.Trigger.MultiPoint.SampleTrigger = settings["trigger"]

    def Fetch_Multi(self, TimeoutMs: int = 2000) -> list[float]:
        """
        Fetches multiple data points (count depends on multipoint setup).
        The Initiate method has to be called before fetching data points.

        :param TimeoutMs: The maximum time allowed for the measurement to complete in milliseconds.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if not self._liveview:
            return list(self.lld.Measurement.FetchMultiPoint(TimeoutMs)[0])

        self.Abort()
        reading = list(self.lld.Measurement.FetchMultiPoint(TimeoutMs)[0])
        self.Initiate()
        return reading

    def Fetch_Single(self, TimeoutMs: int = 1000) -> float:
        """
        Fetches a single data point.
        The Initiate method has to be called before fetching the data point.

        :param TimeoutMs: The maximum time allowed for the measurement to complete in milliseconds.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if not self._liveview:
            return float(self.lld.Measurement.Fetch(TimeoutMs))

        self.Abort()
        reading = float(self.lld.Measurement.Fetch(TimeoutMs))
        self.Initiate()
        return reading

    def Read_Multi(self, TimeoutMs: int = 2000) -> list[float]:
        """
        Initiates a measurement and fetches multiple data points (count depends on multipoint setup).

        :param TimeoutMs: The maximum time allowed for the measurement to complete in milliseconds.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if not self._liveview:
            return list(self.lld.Measurement.ReadMultiPoint(TimeoutMs)[0])

        self.Abort()
        self._apply_multipoint_settings(self._multipoint_backup)
        reading = list(self.lld.Measurement.ReadMultiPoint(TimeoutMs)[0])
        self._apply_multipoint_settings(self._liveview_idle_configuration)
        self.Initiate()

        return reading

    def Read_Single(self, TimeoutMs: int = 1000) -> float:
        """
        Initiates a measurement and fetches a single data point.

        :param TimeoutMs: The maximum time allowed for the measurement to complete in milliseconds.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if not self._liveview:
            return float(self.lld.Measurement.Read(TimeoutMs))

        self.Abort()
        self._apply_multipoint_settings(self._liveview_read_configuration)
        reading = float(self.lld.Measurement.Read(TimeoutMs))
        self._apply_multipoint_settings(self._liveview_idle_configuration)
        self.Initiate()

        return reading

    def GetChannel(self, Index):
        msg = "This device type has only one channel!"
        raise NotImplementedError(msg)


if __name__ == "__main__":
    from pverify.drivers.Dmm.ke2000.IIviDmm import IIviDmm

    a = SimpleIviDmm(IIviDmm())
    # a.Initialize("", 1, 1, "simulate=true")
    a.Initialize("GPIB0::16::INSTR", 1, 1, "")
    a.DmmSetup("dcv", 10, 0.001, "off")
    a.Configure_Trigger("imm", "pos", 0)
    a.Configure_Multipoint(1, 10, 0.2, "int")
    a.Initiate()

    a.Close()
