from __future__ import annotations

import contextlib
from time import sleep
from typing import TYPE_CHECKING

import numpy as np

from pverify.drivers.SimplifiedLabInstruments._simple_instr.simple_fgen import (
    SimpleIviFgen_ABC,
    SimpleIviFgenChannel_ABC,
)
from pverify.postproc.waveform import Waveform

if TYPE_CHECKING:
    import pverify


class SimpleIviFgen(SimpleIviFgen_ABC):
    @property
    def Initialized(self):
        return self.lld.Initialized

    @property
    def drivername(self):
        return self.lld.drivername

    def Initialize(self, ResourceName, IdQuery, Reset, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
            of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: The user can use the OptionsString parameter to specify the initial values of
            certain IVI inherent attributes for the session. The format of an assignment in
            the OptionsString parameter is "Name=Value", where Name is one of: RangeCheck,
            QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck, or
            DriverSetup. Value is either true or false except for DriverSetup. If the
            Options String parameter contains an assignment for the Driver Setup attribute,
            the Initialize function assumes that everything following "DriverSetup=" is part
            of the assignment.
        :type OptionString: str
        """
        self.lld._check_ivi_compliance()

        self.lld.Initialize(ResourceName, IdQuery, Reset, OptionString)

        # Clear arb waveform data
        with contextlib.suppress(Exception):
            self.lld.Arbitrary.ClearMemory()

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Close()

    def FgenSetup(self, InternalTriggerRate=None, ReferenceClockSource=None):
        """
        Common Fgen setup.

        :param InternalTriggerRate: The rate at which the function generator's internal trigger source produces a
                                    trigger, in triggers per second.
        :type InternalTriggerRate: float
        :param ReferenceClockSource: The source of the reference clock. The function generator derives frequencies
                                     and sample rates that it uses to generate waveforms from the reference clock.
        :type ReferenceClockSource: choice(Internal,External)
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if InternalTriggerRate is not None:
            self.lld.Trigger.InternalRate = InternalTriggerRate

        if ReferenceClockSource is not None:
            if "int" in ReferenceClockSource.lower():
                self.lld.Output.ReferenceClockSource = (
                    self.lld.Enums.IviFgenReferenceClockSourceEnum.IviFgenReferenceClockSourceInternal
                )
            elif "ex" in ReferenceClockSource.lower():
                self.lld.Output.ReferenceClockSource = (
                    self.lld.Enums.IviFgenReferenceClockSourceEnum.IviFgenReferenceClockSourceExternal
                )
            else:
                self._log.warning(f"Unknown ReferenceClockSource '{ReferenceClockSource}'. Using 'Internal' instead.")
                self.lld.Output.ReferenceClockSource = (
                    self.lld.Enums.IviFgenReferenceClockSourceEnum.IviFgenReferenceClockSourceInternal
                )

    def InitiateGeneration(self):
        """
        If the function generator is in the Configuration State, this function moves the
        function generator to the Output Generation State. If the function generator is
        already in the Output Generation State, this function does nothing.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.InitiateGeneration()

    def SendSoftwareTrigger(self):
        """
        Sends a software trigger, which will cause the function generator to generate output
        if the operation mode is Burst and the trigger source is "Software".
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Trigger.SendSoftwareTrigger()

    def AbortGeneration(self):
        """
        If the function generator is in the Output Generation State, this function moves
        the function generator to the Configuration State. If the function generator is
        already in the Configuration State, the function does nothing and returns
        Success.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.AbortGeneration()

    def GetChannel(self, Index):
        """
        Returns a channel object. The different channels can be set up indepentently from each other

        :param Index: The index of the channel
        :type Index: int
        :return: _SimpleFgenChannel instance
        :rtype: _SimpleFgenChannel
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        ccount = self.lld.Output.Count
        if Index > ccount:
            raise Exception("Only %d channels available on this instrument!" % ccount)
        return SimpleIviFgenChannel(self, channelindex=Index)


class SimpleIviFgenChannel(SimpleIviFgenChannel_ABC):
    """
    A Class providing all functionality of a fgen channel
    """

    def __init__(self, parent, channelindex):
        super().__init__(parent, channelindex)
        self._ch_name = self.lld.Output.Name(self._ch_index)
        self.__arbwf_handle = None

    def ChannelSetup(self, Impedance=None, OperationMode=None, BurstCount=None, TriggerSource=None):
        """
        Common setup for the Fgen channel

        :param Impedance: The impedance of the output channel. The units are Ohms. 0 means INFINITE.
        :type Impedance: float
        :param OperationMode: The mode that determines how the function generator produces output on a channel.

            - Continuous: When in the Output Generation State, the function generator produces output continuously.
            - Burst: When in the Output Generation State, the function generator produces a burst of waveform cycles
                     based on a trigger condition. A burst consists of a discrete number of waveform cycles.

        :type OperationMode: choice(Continuous,Burst)
        :param BurstCount: The number of waveform cycles that the function generator produces after it receives a
                           trigger.
        :type BurstCount: int
        :param TriggerSource: The trigger source.
        :type TriggerSource: choice(Internal,External,SW,TTL0,TTL1,TTL2,TTL3,TTL4,TTL5,TTL6,TTL7,ECL0,ECL1)
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if Impedance is not None:
            self.lld.Output.set_Impedance(self._ch_name, Impedance)
        if OperationMode is not None:
            if "con" in OperationMode.lower():
                self.lld.Output.set_OperationMode(
                    self._ch_name,
                    self.lld.Enums.IviFgenOperationModeEnum.IviFgenOperationModeContinuous,
                )
            elif "bur" in OperationMode.lower():
                self.lld.Output.set_OperationMode(
                    self._ch_name,
                    self.lld.Enums.IviFgenOperationModeEnum.IviFgenOperationModeBurst,
                )
                if BurstCount is not None:
                    self.lld.Trigger.set_BurstCount(self._ch_name, BurstCount)
            else:
                self._log.warning(f"Unknown OperationMode '{OperationMode}'. Using OperationMode 'Coninuous' instead.")
                self.lld.Output.set_OperationMode(
                    self._ch_name,
                    self.lld.Enums.IviFgenOperationModeEnum.IviFgenOperationModeContinuous,
                )
        if TriggerSource is not None:
            _TriggerSource = TriggerSource.lower()
            if "in" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceInternal,
                )
            elif "ext" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceExternal,
                )
            elif "sw" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceSoftware,
                )
            elif "ttl0" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL0,
                )
            elif "ttl1" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL1,
                )
            elif "ttl2" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL2,
                )
            elif "ttl3" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL3,
                )
            elif "ttl4" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL4,
                )
            elif "ttl5" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL5,
                )
            elif "ttl6" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL6,
                )
            elif "ttl7" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceTTL7,
                )
            elif "ecl0" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceECL0,
                )
            elif "ecl1" in _TriggerSource:
                self.lld.Trigger.set_Source(
                    self._ch_name,
                    self.lld.Enums.IviFgenTriggerSourceEnum.IviFgenTriggerSourceECL1,
                )

        if self.lld.drivername == "Ag3352x":
            # Disable interpolation between arbitrary waveform points
            self.lld.dllwrap.SetAttributeViInt32(self._ch_name, 1150168, 2)

    def Enable(self):
        """
        Enables the channel.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self._ch_name = self.lld.Output.Name(self._ch_index)
        self.lld.Output.set_Enabled(self._ch_name, True)

    def Disable(self):
        """
        Disables the channel.
        """
        if self.lld.drivername == "hp33120a":
            # This model does not support disabling the channel WTF!
            self.Configure_DC(0)
            return
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.Output.set_Enabled(self._ch_name, False)

    def __OutputStandardWaveform(self, Waveform, Amplitude, DCOffset, Frequency, StartPhase, DutyCycleHigh):
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if self.lld.Output.OutputMode != self.lld.Enums.IviFgenOutputModeEnum.IviFgenOutputModeFunction:
            self.lld.Output.OutputMode = self.lld.Enums.IviFgenOutputModeEnum.IviFgenOutputModeFunction
        self.lld.StandardWaveform.Configure(self._ch_name, Waveform, Amplitude, DCOffset, Frequency, StartPhase)
        if Waveform == self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformSquare:
            self.lld.StandardWaveform.set_DutyCycleHigh(self._ch_name, DutyCycleHigh)

    def Configure_Sine(self, Amplitude: float, Frequency: float = 10e3, StartPhase: float = 0, DCOffset: float = 0):
        """
        Configures a sine wave output.

        :param Amplitude: The amplitude of the standard waveform output by the function generator. The units are volts.
        :param Frequency: The frequency of the standard waveform output by the function generator. The units are Hertz.
        :param StartPhase: The frequency of the standard waveform output by the function generator. The units are Hertz.
        :param DCOffset: The DC offset of the standard waveform output by the function generator. The units are volts.
        """
        self.__OutputStandardWaveform(
            Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformSine,
            Amplitude=Amplitude,
            DCOffset=DCOffset,
            Frequency=Frequency,
            StartPhase=StartPhase,
            DutyCycleHigh=0,
        )

    def Configure_Square(
        self, Amplitude: float, DutyCycleHigh: float = 25, Frequency: float = 10e3, DCOffset: float = 0
    ):
        """
        Configures a square wave output.

        :param DutyCycleHigh: The duty cycle for a square waveform. The value is expressed as a percentage.
        :param Amplitude: The amplitude of the standard waveform output by the function generator. The units are volts.
        :param Frequency: The frequency of the standard waveform output by the function generator. The units are Hertz.
        :param DCOffset: The DC offset of the standard waveform output by the function generator. The units are volts.
        """
        self.__OutputStandardWaveform(
            Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformSquare,
            Amplitude=Amplitude,
            DCOffset=DCOffset,
            Frequency=Frequency,
            StartPhase=0,
            DutyCycleHigh=DutyCycleHigh,
        )

    def Configure_DC(self, DCOffset: float):
        """
        Configures a DC wave output.

        :param DCOffset: The DC offset of the standard waveform output by the function generator. The units are volts.
        """
        if self.lld.drivername == "ww257x":
            self.__OutputStandardWaveform(
                Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformDC,
                Amplitude=16e-3,
                DCOffset=DCOffset,
                Frequency=0,
                StartPhase=0,
                DutyCycleHigh=0,
            )
        else:
            self.__OutputStandardWaveform(
                Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformDC,
                Amplitude=0,
                DCOffset=DCOffset,
                Frequency=0,
                StartPhase=0,
                DutyCycleHigh=0,
            )

    def Configure_Triangle(self, Amplitude: float, Frequency: float = 10e3, DCOffset: float = 0):
        """
        Configures a triangle wave output.

        :param Amplitude: The amplitude of the standard waveform output by the function generator. The units are volts.
        :param Frequency: The frequency of the standard waveform output by the function generator. The units are Hertz.
        :param DCOffset: The DC offset of the standard waveform output by the function generator. The units are volts.
        """
        if self.lld.drivername == "tkafg3k":
            self.__OutputStandardWaveform(
                Waveform=1001,
                Amplitude=Amplitude,
                DCOffset=DCOffset,
                Frequency=Frequency,
                StartPhase=0,
                DutyCycleHigh=0,
            )
        else:
            self.__OutputStandardWaveform(
                Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformTriangle,
                Amplitude=Amplitude,
                DCOffset=DCOffset,
                Frequency=Frequency,
                StartPhase=0,
                DutyCycleHigh=0,
            )

    def Configure_RampUp(self, Amplitude: float, Frequency: float = 10e3, DCOffset: float = 0):
        """
        Configures a positive ramp waveform output.

        :param Amplitude: The amplitude of the standard waveform output by the function generator. The units are volts.
        :param Frequency: The frequency of the standard waveform output by the function generator. The units are Hertz.
        :param DCOffset: The DC offset of the standard waveform output by the function generator. The units are volts.
        """
        self.__OutputStandardWaveform(
            Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformRampUp,
            Amplitude=Amplitude,
            DCOffset=DCOffset,
            Frequency=Frequency,
            StartPhase=0,
            DutyCycleHigh=0,
        )

    def Configure_RampDown(self, Amplitude: float, Frequency: float = 10e3, DCOffset: float = 0):
        """
        Configures a positive ramp waveform output.

        :param Amplitude: The amplitude of the standard waveform output by the function generator. The units are volts.
        :param Frequency: The frequency of the standard waveform output by the function generator. The units are Hertz.
        :param DCOffset: The DC offset of the standard waveform output by the function generator. The units are volts.
        """
        self.__OutputStandardWaveform(
            Waveform=self.lld.Enums.IviFgenWaveformEnum.IviFgenWaveformRampDown,
            Amplitude=Amplitude,
            DCOffset=DCOffset,
            Frequency=Frequency,
            StartPhase=0,
            DutyCycleHigh=0,
        )

    def Configure_Arbitrary(self, Data: list | np.ndarray, Gain: float, Offset: float = 0, SampleRate: float = 10e3):
        """
        Configures an arbitrary waveform output.

        :param Data: Specifies the array of data to use for the new arbitrary waveform.
                     The array's elements must be normalized between -1.00 and +1.00.
        :param Gain: The gain of the arbitrary waveform the function generator produces. This value is unitless.
        :param Offset: The offset of the arbitrary waveform the function generator produces. The units are volts.
        :param SampleRate: The sample rate of the arbitrary waveforms the function generator produces. The units are
                           samples per second.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        sizemax = self.lld.Arbitrary.Waveform.SizeMax
        sizemin = self.lld.Arbitrary.Waveform.SizeMin
        quantum = int(self.lld.Arbitrary.Waveform.Quantum)

        if type(Data) not in [list, np.ndarray]:
            msg = "Type of argument 'data' must be a list or numpy array"
            raise Exception(msg)

        self._ch_name = self.lld.Output.Name(self._ch_index)

        _was_enabled = self.lld.Output.get_Enabled(self._ch_name)
        self._parent.AbortGeneration()
        if self.lld.drivername != "hp33120a":
            # Does not support disabling the channel so DC output is used.
            # DC output cannot be set in case burst mode is enabled.
            self.Disable()
        sleep(0.1)

        # tkafg3k: When setting function mode (regardless if in function mode already) all channels are reset to sine!
        # self.lld.Output.OutputMode = self.lld.Enums.IviFgenOutputModeEnum.IviFgenOutputModeFunction

        tkafg3k_old_wf_handle = None
        if self.lld.drivername == "Ag3352x":
            pass  # Don't delete because handle is ignored and entire volatile mem is deleted from both channels .(
            # Clear has to be done manually
        elif self.lld.drivername == "tkafg3k":
            # Do not clear now, because deleting handle and creating a new one results in the same handle number.
            # tkafg3k only applies new data if the handle is changing, so we have to create a new handle first before
            # deleting the old one -.-
            tkafg3k_old_wf_handle = self.__arbwf_handle
        else:
            if self.__arbwf_handle is not None:
                self.lld.Arbitrary.Waveform.Clear(self.__arbwf_handle)
        if self.lld.Output.OutputMode != self.lld.Enums.IviFgenOutputModeEnum.IviFgenOutputModeArbitrary:
            self.lld.Output.OutputMode = self.lld.Enums.IviFgenOutputModeEnum.IviFgenOutputModeArbitrary

        fixedData = Waveform(Data).cast_float()
        if min(fixedData) < -1.0 or max(fixedData) > 1.0:
            fixedData.scale_to_amplitude(1.0)

        if len(fixedData) < sizemin:
            fixedData.up_sample_interp(nr_points=sizemin)
        elif len(fixedData) > sizemax:
            fixedData = fixedData.down_sample(sizemax)
        elif sizemin <= len(fixedData) <= sizemax and len(fixedData) % quantum != 0:
            newlen = int(len(fixedData) / quantum) * quantum
            fixedData = fixedData.down_sample(newlen)

        self.__arbwf_handle = self.lld.Arbitrary.Waveform.Create(fixedData.data)

        # Configure the waveform BEFORE changing the samplerate, since some instruments are converting between sample
        # rate and frequency which requires
        self.lld.Arbitrary.Waveform.Configure(
            ChannelName=self._ch_name,
            Handle=self.__arbwf_handle,
            Gain=Gain,
            Offset=Offset,
        )

        if self.lld.drivername == "tkafg3k":
            # Now we can delete the old wf handle
            if tkafg3k_old_wf_handle is not None:
                self.lld.Arbitrary.Waveform.Clear(tkafg3k_old_wf_handle)
            # Setting the samplerate on tkafg3k driver is not supported, instead the arb. frequency has to be set
            self.lld.Arbitrary.Waveform.set_Frequency(self._ch_name, SampleRate / len(fixedData.data))
        else:
            self.lld.Arbitrary.SampleRate = SampleRate

        self._parent.InitiateGeneration()
        if _was_enabled:
            self.lld.Output.set_Enabled(self._ch_name, True)

    def Configure_ArbitraryFromWaveform(self, WaveformObj: pverify.Waveform, SampleRate: float | None = None):
        """
        Configures an arbitrary waveform output.

        :param WaveformObj: The waveform to be configured as output
        :param SampleRate: The sample rate of the arbitrary waveforms the function generator produces. The units are
                           samples per second. If specified the waveform object is sampled to the specified rate.
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        if not isinstance(WaveformObj, Waveform):
            msg = "WaveformObj has to be of type 'Waveform'"
            raise TypeError(msg)

        wave = WaveformObj.copy()
        if SampleRate is not None:
            wave.change_samplerate(SampleRate)
        mean = (wave.Measurements_Base.max() + wave.Measurements_Base.min()) / 2.0
        wave -= mean
        max1 = abs(wave).Measurements_Base.max()
        wave.scale_to_absmax(1.0)
        max2 = abs(wave).Measurements_Base.max()
        gain = max1 / max2
        self.Configure_Arbitrary(Data=wave.data, Gain=gain, Offset=mean, SampleRate=wave.samplerate)

    def Enable_AM(self, Depth: float, Frequency: float = 10e3, ModulationWaveform: str = "Sine"):
        """
        Enables amplitude modulation on the configured output waveform.

        :param Depth: The extent of modulation the function generator applies to the carrier waveform. The unit is
                      percentage.
        :param Frequency: The frequency of the internal modulating waveform source. The units are Hertz.
        :param ModulationWaveform: The waveform of the internal modulating waveform source.
                                   choice(Sine,Square,Triangle,RampUp,RampDown)
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.AM.set_Enabled(self._ch_name, True)
        self.lld.AM.set_Source(self._ch_name, self.lld.Enums.IviFgenAMSourceEnum.IviFgenAMSourceInternal)
        self.lld.AM.InternalDepth = Depth
        self.lld.AM.InternalFrequency = Frequency
        modwave = ModulationWaveform.lower()
        if "sine" in modwave:
            self.lld.AM.InternalWaveform = self.lld.Enums.IviFgenAMInternalWaveformEnum.IviFgenAMInternalWaveformSine
        elif "square" in modwave:
            self.lld.AM.InternalWaveform = self.lld.Enums.IviFgenAMInternalWaveformEnum.IviFgenAMInternalWaveformSquare
        elif "tri" in modwave:
            self.lld.AM.InternalWaveform = (
                self.lld.Enums.IviFgenAMInternalWaveformEnum.IviFgenAMInternalWaveformTriangle
            )
        elif "up" in modwave:
            self.lld.AM.InternalWaveform = self.lld.Enums.IviFgenAMInternalWaveformEnum.IviFgenAMInternalWaveformRampUp
        elif "down" in modwave:
            self.lld.AM.InternalWaveform = (
                self.lld.Enums.IviFgenAMInternalWaveformEnum.IviFgenAMInternalWaveformRampDown
            )

    def Disable_AM(self):
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.AM.set_Enabled(self._ch_name, False)

    def Enable_FM(self, Deviation: float = 100, Frequency: float = 10e3, ModulationWaveform: str = "Sine"):
        """
        Enables frequency modulation on the configured output waveform.

        :param Deviation: The maximum frequency deviation the function generator applies to the carrier waveform.
        :param Frequency: The frequency of the internal modulating waveform source. The units are Hertz.
        :param ModulationWaveform: The waveform of the internal modulating waveform source.
                                   choice(Sine,Square,Triangle,RampUp,RampDown)
        """
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.FM.set_Enabled(self._ch_name, True)
        self.lld.FM.set_Source(self._ch_name, self.lld.Enums.IviFgenFMSourceEnum.IviFgenFMSourceInternal)
        self.lld.FM.InternalDeviation = Deviation
        self.lld.FM.InternalFrequency = Frequency
        modwave = ModulationWaveform.lower()
        if "sine" in modwave:
            self.lld.FM.InternalWaveform = self.lld.Enums.IviFgenFMInternalWaveformEnum.IviFgenFMInternalWaveformSine
        elif "square" in modwave:
            self.lld.FM.InternalWaveform = self.lld.Enums.IviFgenFMInternalWaveformEnum.IviFgenFMInternalWaveformSquare
        elif "tri" in modwave:
            self.lld.FM.InternalWaveform = (
                self.lld.Enums.IviFgenFMInternalWaveformEnum.IviFgenFMInternalWaveformTriangle
            )
        elif "up" in modwave:
            self.lld.FM.InternalWaveform = self.lld.Enums.IviFgenFMInternalWaveformEnum.IviFgenFMInternalWaveformRampUp
        elif "down" in modwave:
            self.lld.FM.InternalWaveform = (
                self.lld.Enums.IviFgenFMInternalWaveformEnum.IviFgenFMInternalWaveformRampDown
            )

    def Disable_FM(self):
        self.lld._check_ivi_compliance()
        self.lld._check_initialized()

        self.lld.FM.set_Enabled(self._ch_name, False)


if __name__ == "__main__":
    pass
