#!/usr/bin/python
# ===========================================================================
# Name:        com_dpifgen2_api_basic_dp25.py
#
# Purpose:     Basic API for dpIFGen2 communication for dp2.5 chips
#
# Author:      Aslam Faizan Muhammad (IFAG PMM SYS SWT SWI)
#                                       <Faizan.Aslam@infineon.com>
# Created:     03.06.2015
#
# Python Version: v2.7.2
#
# Dependency: lib_dpifgen2_commands_list, com_dpifgen2_api_executer_basic,
#             config_dpifgen2_api
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#

""" This Documentation describes the .dp Interface Gen 2(dpIfGen2) board's
    basic API to communicate with the dp2.5 (dp2b b13) chip. The API is
    meant to serve as an abstraction layer between the PC and the
    dp2.5 (dp2b b13) chip hiding the unnecessary details in the low level
    communication between the Interface board and the chip itself.
    The API has been partitioned into the following major command categories::

        1. Connection Commands
        2. Read Commands
        3. Write Commands
        4. Burn Commands
        5. Check Commands
        6. Other Commands
"""
from __future__ import annotations

import re

from dpIfGen2lib.dpIfGen2API.com_dpifgen2_api_executer_basic import DpIfGen2APIExecuterBasic
from dpIfGen2lib.dpIfGen2API.lib_dpifgen2_commands_list import DpIfGen2Commands
from dpIfGen2lib.support.config_dpifgen2_api import HIDConfigAPI, PrintConfigAPI


class ShowDocumentation:
    @staticmethod
    def show(obj):
        print(obj.__doc__)


class DpIfGen2APIBasicDp25:
    """The Detailed API is as follows:

    Connection Commands:
        1. :func:`connection_establish`
        2. :func:`baudrate_set`
        3. :func:`sync_set`
        4. :func:`chip_identify`
        5. :func:`interface_fw_id_read`
        6. :func:`voltage_level_set`
        7. :func:`voltage_cycle_execute`
        8. :func:`dp25_chip_connect`
        9. :func:`dp25_chip_disconnect`

    Read Commands:
        1. :func:`memory_read`
        2. :func:`memory_block_read`
        3. :func:`dmem_read`
        4. :func:`aparam_read`
        5. :func:`aparam_block_read`

    Write Commands:
        1. :func:`memory_write`
        2. :func:`memory_block_write`
        3. :func:`ahex_file_write`
        4. :func:`dmem_write`
        5. :func:`aparam_write`
        6. :func:`aparam_block_write`
        7. :func:`aparam_ahex_file_write`

    Burn Commands:
        1. :func:`memory_burn`
        2. :func:`memory_block_burn`
        3. :func:`ahex_file_burn`
        4. :func:`aparam_burn`
        5. :func:`aparam_block_burn`
        6. :func:`aparam_ahex_file_burn`
        7. :func:`fw_patch_burn`
        8. :func:`fw_patch_block_burn`
        9. :func:`fw_patch_ahex_file_burn`

    Check Commands:
        1. :func:`memory_block_check_blank`
        2. :func:`memory_crc_get`
        3. :func:`otp_crc_get`
        4. :func:`aparam_crc_get`

    Other Commands:
        1. :func:`jump_execute`
        2. :func:`call_execute`
        3. :func:`info_get`
        4. :func:`info_get_single`
        5. :func:`application_start`
        6. :func:`application_stop`
        7. :func:`auto_start_set`
        8. :func:`auto_start_get`
        9. :func:`boot_status_get`
        10. :func:`aparam_api_lock`
        11. :func:`aparam_apply`
        12. :func:`fw_patch_apply`
        13. :func:`dp25_chip_lock`
        14. :func:`dp25_chip_unlock`
        15. :func:`protocol_id_get`

    """

    #: dpIfGen2 dp2.5 API Version 2.0.5
    VERSION = "2.0.5"

    # Note: Following constants determine for which versions of the dpIfGen2 FW this API is build for.
    #       There is no check in this module, because it has no knowledge about the dpIfGen2 FW version.
    #       The check is done outside by a separate script.
    MIN_DPIFGEN2_FW_VERSION = "2.0.8"
    MAX_DPIFGEN2_FW_VERSION = "3.0.0"

    @staticmethod
    def list_of_functions():
        return [
            "connection_establish()",
            "baudrate_set()",
            "sync_set()",
            "chip_identify()",
            "interface_fw_id_read()",
            "voltage_level_set()",
            "voltage_cycle_execute()",
            "dp25_chip_connect()",
            "dp25_chip_disconnect()",
            "memory_read()",
            "memory_block_read()",
            "dmem_read()",
            "aparam_read()",
            "aparam_block_read()",
            "memory_write()",
            "memory_block_write()",
            "ahex_file_write()",
            "dmem_write()",
            "aparam_write()",
            "aparam_block_write()",
            "aparam_ahex_file_write()",
            "memory_burn()",
            "memory_block_burn()",
            "ahex_file_burn()",
            "aparam_burn()",
            "aparam_block_burn()",
            "aparam_ahex_file_burn()",
            "fw_patch_burn()",
            "fw_patch_block_burn()",
            "fw_patch_ahex_file_burn()",
            "memory_block_check_blank()",
            "memory_crc_get()",
            "otp_crc_get()",
            "aparam_crc_get()",
            "jump_execute()",
            "call_execute()",
            "info_get()",
            "info_get_single()",
            "application_start()",
            "application_stop()",
            "auto_start_set()",
            "auto_start_get()",
            "boot_status_get()",
            "aparam_api_lock()",
            "aparam_apply()",
            "fw_patch_apply()",
            "dp25_chip_lock()",
            "dp25_chip_unlock()",
            "protocol_id_get()",
        ]

    @staticmethod
    def dict_of_api_functions():
        return {
            "C1_1:Establish Connection": {
                "Name": "Establish Connection",
                "Usage": "DpIfGen2APIBasicDp25.connection_establish(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.connection_establish.__doc__,
                "Class": "Connection",
            },
            "C1_2:Set Baudrate": {
                "Name": "Set Baudrate",
                "Usage": 'DpIfGen2APIBasicDp25.baudrate_set("57600", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.baudrate_set.__doc__,
                "Class": "Connection",
            },
            "C1_3:Set Sync": {
                "Name": "Set Sync",
                "Usage": "DpIfGen2APIBasicDp25.sync_set(3, verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.sync_set.__doc__,
                "Class": "Connection",
            },
            "C1_4:Identify chip": {
                "Name": "Identify chip",
                "Usage": "chip_id = DpIfGen2APIBasicDp25.chip_identify(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.chip_identify.__doc__,
                "Class": "Connection",
            },
            "C1_5:Read dpIfGen2 FW ID": {
                "Name": "Read dpIfGen2 FW ID",
                "Usage": "fw_id = DpIfGen2APIBasicDp25.interface_fw_id_read(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.interface_fw_id_read.__doc__,
                "Class": "Connection",
            },
            "C1_6:Set Voltage Level": {
                "Name": "Set Voltage Level",
                "Usage": "DpIfGen2APIBasicDp25.voltage_level_set(24.5 ,verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.voltage_level_set.__doc__,
                "Class": "Connection",
            },
            "C1_7:Execute Voltage Cycle": {
                "Name": "Execute Voltage Cycle",
                "Usage": "DpIfGen2APIBasicDp25.voltage_cycle_execute(24, 7.5 ,verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.voltage_cycle_execute.__doc__,
                "Class": "Connection",
            },
            "C1_8:Connect Dp2.5 chip": {
                "Name": "Connect Dp2.5 chip",
                "Usage": "DpIfGen2APIBasicDp25.dp25_chip_connect(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.dp25_chip_connect.__doc__,
                "Class": "Connection",
            },
            "C1_9:Disconnect Dp2.5 chip": {
                "Name": "Disconnect Dp2.5 chip",
                "Usage": "DpIfGen2APIBasicDp25.dp25_chip_disconnect(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.dp25_chip_disconnect.__doc__,
                "Class": "Connection",
            },
            "C2_1:Read Memory": {
                "Name": "Read Memory",
                "Usage": 'output_word = DpIfGen2APIBasicDp25.memory_read("8080", "hex", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.memory_read.__doc__,
                "Class": "Read",
            },
            "C2_2:Read Memory Block": {
                "Name": "Read Memory Block",
                "Usage": 'output_data = DpIfGen2APIBasicDp25.memory_block_read("8080", "0010", "hex", '
                "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.memory_block_read.__doc__,
                "Class": "Read",
            },
            "C2_3:Read DMEM": {
                "Name": "Read DMEM",
                "Usage": 'output_word = DpIfGen2APIBasicDp25.dmem_read("0002", "hex", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.dmem_read.__doc__,
                "Class": "Read",
            },
            "C2_4:Read APARAM": {
                "Name": "Read APARAM",
                "Usage": 'output_word = DpIfGen2APIBasicDp25.aparam_read("002A", "hex", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.aparam_read.__doc__,
                "Class": "Read",
            },
            "C2_5:Read APARAM Block": {
                "Name": "Read APARAM Block",
                "Usage": 'output_data = DpIfGen2APIBasicDp25.aparam_block_read("0020", "0010", "hex", '
                "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.aparam_block_read.__doc__,
                "Class": "Read",
            },
            "C3_1:Write Memory": {
                "Name": "Write Memory",
                "Usage": 'DpIfGen2APIBasicDp25.memory_write("8000", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.memory_write.__doc__,
                "Class": "Write",
            },
            "C3_2:Write Memory Block": {
                "Name": "Write Memory Block",
                "Usage": 'DpIfGen2APIBasicDp25.memory_block_write("8080", '
                '["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.memory_block_write.__doc__,
                "Class": "Write",
            },
            "C3_3:Write Ahex File": {
                "Name": "Write Ahex File",
                "Usage": 'DpIfGen2APIBasicDp25.ahex_file_write(r"filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.ahex_file_write.__doc__,
                "Class": "Write",
            },
            "C3_4:Write DMEM": {
                "Name": "Write DMEM",
                "Usage": 'DpIfGen2APIBasicDp25.dmem_write("0012", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.dmem_write.__doc__,
                "Class": "Write",
            },
            "C3_5:Write APARAM": {
                "Name": "Write APARAM",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_write("002A", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_write.__doc__,
                "Class": "Write",
            },
            "C3_6:Write APARAM Block": {
                "Name": "Write APARAM Block",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_block_write("0020", '
                '["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_block_write.__doc__,
                "Class": "Write",
            },
            "C3_7:Write APARAM ahex file": {
                "Name": "Write APARAM ahex file",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_ahex_file_write("filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_ahex_file_write.__doc__,
                "Class": "Write",
            },
            "C4_1:Burn Memory": {
                "Name": "Burn Memory",
                "Usage": 'DpIfGen2APIBasicDp25.memory_burn("8000", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.memory_burn.__doc__,
                "Class": "Burn",
            },
            "C4_2:Burn Memory Block": {
                "Name": "Burn Memory Block",
                "Usage": 'DpIfGen2APIBasicDp25.memory_block_burn("8080", '
                '["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.memory_block_burn.__doc__,
                "Class": "Burn",
            },
            "C4_3:Burn Ahex File": {
                "Name": "Burn Ahex File",
                "Usage": 'DpIfGen2APIBasicDp25.ahex_file_burn(r"filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.ahex_file_burn.__doc__,
                "Class": "Burn",
            },
            "C4_4:Burn APARAM": {
                "Name": "Burn APARAM",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_burn("0020", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_burn.__doc__,
                "Class": "Burn",
            },
            "C4_5:Burn APARAM Block": {
                "Name": "Burn APARAM Block",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_block_burn("002A", '
                '["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_block_burn.__doc__,
                "Class": "Burn",
            },
            "C4_6:Burn APARAM ahex File": {
                "Name": "Burn APARAM ahex File",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_ahex_file_burn(r"filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_ahex_file_burn.__doc__,
                "Class": "Burn",
            },
            "C4_7:Burn FW Patch": {
                "Name": "Burn FW Patch",
                "Usage": 'DpIfGen2APIBasicDp25.fw_patch_burn("8120", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.fw_patch_burn.__doc__,
                "Class": "Burn",
            },
            "C4_8:Burn FW Patch Block": {
                "Name": "Burn FW Patch Block",
                "Usage": 'DpIfGen2APIBasicDp25.fw_patch_block_burn("812A", '
                '["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.fw_patch_block_burn.__doc__,
                "Class": "Burn",
            },
            "C4_9:Burn FW Patch ahex File": {
                "Name": "Burn FW Patch ahex File",
                "Usage": 'DpIfGen2APIBasicDp25.fw_patch_ahex_file_burn(r"filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.fw_patch_ahex_file_burn.__doc__,
                "Class": "Burn",
            },
            "C5_1:Blank Check": {
                "Name": "Blank Check",
                "Usage": 'is_memory_blank = DpIfGen2APIBasicDp25.memory_block_check_blank("8080", "0010", '
                "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.memory_block_check_blank.__doc__,
                "Class": "Check",
            },
            "C5_2:Calculate Memory CRC": {
                "Name": "Get CRC Memory Block",
                "Usage": 'crc = DpIfGen2APIBasicDp25.memory_crc_get("8000", "0010", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.memory_crc_get.__doc__,
                "Class": "Check",
            },
            "C5_3:Calculate OTP CRC": {
                "Name": "Get CRC OTP Block",
                "Usage": 'crc = DpIfGen2APIBasicDp25.otp_crc_get("C800", "0010", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.otp_crc_get.__doc__,
                "Class": "Check",
            },
            "C5_4:Calculate APARAM CRC": {
                "Name": "Get CRC APARAM Block",
                "Usage": 'crc = DpIfGen2APIBasicDp25.aparam_crc_get("002C", "0010", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_crc_get.__doc__,
                "Class": "Check",
            },
            "C6_1:Execute Jump": {
                "Name": "Execute Jump",
                "Usage": 'DpIfGen2APIBasicDp25.jump_execute("8000", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.jump_execute.__doc__,
                "Class": "Others",
            },
            "C6_2:Execute Call": {
                "Name": "Execute Call",
                "Usage": 'DpIfGen2APIBasicDp25.call_execute("8000", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.call_execute.__doc__,
                "Class": "Others",
            },
            "C6_3:Get Information": {
                "Name": "Get Information",
                "Usage": "info = DpIfGen2APIBasicDp25.info_get(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.info_get.__doc__,
                "Class": "Others",
            },
            "C6_3_1:Get Information": {
                "Name": "Get Single Information",
                "Usage": "info = DpIfGen2APIBasicDp25.info_get_single(info_code, num_words, verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.info_get_single.__doc__,
                "Class": "Others",
            },
            "C6_4:Start Application": {
                "Name": "Start Application",
                "Usage": "DpIfGen2APIBasicDp25.application_start(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.application_start.__doc__,
                "Class": "Others",
            },
            "C6_5:Stop Application": {
                "Name": "Stop Application",
                "Usage": "DpIfGen2APIBasicDp25.application_stop(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.application_stop.__doc__,
                "Class": "Others",
            },
            "C6_6:Set Autostart": {
                "Name": "Set Autostart",
                "Usage": "DpIfGen2APIBasicDp25.auto_start_set(mode, verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.auto_start_set.__doc__,
                "Class": "Others",
            },
            "C6_7:Get Autostart": {
                "Name": "Get Autostart",
                "Usage": "mode = DpIfGen2APIBasicDp25.auto_start_get(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.auto_start_get.__doc__,
                "Class": "Others",
            },
            "C6_8:Get Boot status": {
                "Name": "Get Boot status",
                "Usage": "status = DpIfGen2APIBasicDp25.boot_status_get(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.boot_status_get.__doc__,
                "Class": "Others",
            },
            "C6_9: Lock APARAM API": {
                "Name": "Lock APARAM API",
                "Usage": 'DpIfGen2APIBasicDp25.aparam_api_lock("read", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.aparam_api_lock.__doc__,
                "Class": "Others",
            },
            "C6_A:Apply APARAM": {
                "Name": "Apply APARAM",
                "Usage": "DpIfGen2APIBasicDp25.aparam_apply(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.aparam_apply.__doc__,
                "Class": "Others",
            },
            "C6_B:APPLY FW Patch": {
                "Name": "Apply FW Patch",
                "Usage": "DpIfGen2APIBasicDp25.fw_patch_apply(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicDp25.fw_patch_apply.__doc__,
                "Class": "Others",
            },
            "C6_C:Lock Dp2.5 chip": {
                "Name": "Lock Dp2.5 chip",
                "Usage": 'DpIfGen2APIBasicDp25.dp25_chip_lock("DEEDBEAF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.dp25_chip_lock.__doc__,
                "Class": "Others",
            },
            "C6_D:Unlock Dp2.5 chip": {
                "Name": "Unlock Dp2.5 chip",
                "Usage": 'DpIfGen2APIBasicDp25.dp25_chip_unlock("DEEDBEAF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.dp25_chip_unlock.__doc__,
                "Class": "Others",
            },
            "C6_E:Read Protocol ID": {
                "Name": "Read Protocol ID",
                "Usage": 'DpIfGen2APIBasicDp25.protocol_id_get("hex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicDp25.protocol_id_get.__doc__,
                "Class": "Others",
            },
        }

    @staticmethod
    def connection_establish(verbose=False, debug=False, parent=None):
        """Establishes connection with the dp2.5 (dp2b b13) chip.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.


        Connection Establish is a combinational command that performs the
        following operations::

            1. Set Baudrate: Default Value (57600)
            2. Set Voltage Cycle: Default Value (Voltage 1: 24V; Voltage 2: 7.5V)
            3. Set Sync: Default Value (3 Sync tries)

        .. note::

           This module will be the only command you need to start communication
           with the chip if you do not have any special requirements.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.connection_establish()
        >>> DpIfGen2APIBasicDp25.connection_establish(verbose=True)

        @@Class: Connection
        """
        DpIfGen2APIBasicDp25.baudrate_set("57600", verbose, debug)
        DpIfGen2APIBasicDp25.voltage_cycle_execute(23, 7.5, verbose, debug)
        DpIfGen2APIBasicDp25.sync_set(3, verbose, debug)

    @staticmethod
    def baudrate_set(baudrate, verbose=False, debug=False, parent=None):
        """Sets the communication baudrate.

        :param baudrate: The selected baudrate for communication with dp2.5 (dp2b b13)
        :type baudrate: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.

        .. note::

           57600 is the standard baudrate for communication with the chip.
           Other supported baudrates include::

            * 9600
            * 19200
            * 38400
            * 57600
            * 82000
            * 105000

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip. Otherwise a
            synchronization command is necessary after selecting the baudrate.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.baudrate_set("57600")
        >>> DpIfGen2APIBasicDp25.baudrate_set("57600", verbose=True)

        @@Class: Connection
        """
        # allowed baudrates
        allowed_baudrates = {
            "9600": "0000",
            "19200": "0100",
            "38400": "0200",
            "57600": "0300",
            "82000": "0400",
            "105000": "0500",
        }
        if baudrate in allowed_baudrates:
            baudrate_value = allowed_baudrates.get(baudrate)
            exec_seq = {}
            exec_seq["Name"] = "Set Baudrate"
            exec_seq[0] = {
                "Step": "Set Baudrate",
                "Command": DpIfGen2Commands.CONFIGURE_UART_COMMAND,
                "Parameters": "".join(["0100", baudrate_value]),
                "Response": DpIfGen2Commands.ACK,
                "Timeout": 1,
            }
            DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

        else:
            raise Exception(
                "".join(
                    [
                        "The selected baudrate is not ",
                        "supported. ",
                        "Please enter a baudrate from the ",
                        "following values: ",
                        str(allowed_baudrates.keys()),
                    ]
                )
            )

    @staticmethod
    def sync_set(num_tries=3, verbose=False, debug=False, parent=None):
        """Synchronizes the baudrate with the dp2.5 (dp2b b13) chip.

        :param num_tries: Number of tries to perform the synchronization
        :type num_tries: int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.

        This command is used to establish a common communication baudrate with
        the dp2.5 (dp2b b13) chip. Number of synchronization attempts can be configured.
        Default value is 3. Maximum value is 100.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.sync_set(3)
        >>> DpIfGen2APIBasicDp25.sync_set(3, verbose=True)

        @@Class: Connection
        """
        num_tries = f"{num_tries:04X}"
        num_tries_endian = DpIfGen2APIBasicDp25.convert_endian(num_tries)
        parameter = num_tries_endian

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Synchronize"
        exec_seq[0] = {
            "Step": "Set Sync",
            "Command": DpIfGen2Commands.SYNC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def chip_identify(verbose=False, debug=False, parent=None):
        """Identifies the chip type.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: chip_id string: e.g. dp25, dp2a, dp2b, ..
        :rtype: str

        This command is used to identify the chip type.

        .. warning::

            This command requires the function :func:`connection_establish` to be called first.

        Example Usage:

        >>> chip_id = DpIfGen2APIBasicDp25.chip_identify()
        >>> chip_id = DpIfGen2APIBasicDp25.chip_identify(verbose=True)

        @@Class: Connection
        """
        # define the sequence
        # DpIfGen2APIBasicDp25.connection_establish(verbose, debug, parent)
        exec_seq = {}
        exec_seq["Name"] = "Read Chip ID"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.CHIP_IDENTIFY_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        status = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        chip_id = None
        if status:
            if status & 0x0002:
                chip_id = "dp25"
            elif status & 0x0001:
                if status & 0x0008:
                    chip_id = "dp2a"
                elif status & 0x0020:
                    chip_id = "dp2b"
                else:
                    chip_id = "dp2"
            else:
                raise Exception(
                    "".join(
                        [
                            "Chip type could not be identified. Please verify that you have an "
                            "unlocked and known chip."
                        ]
                    )
                )
        else:
            # status word is empty => No valid chip type found
            raise Exception(
                "".join(["Chip type could not be identified. Please verify that you have an unlocked and known chip."])
            )
        return chip_id

    @staticmethod
    def interface_fw_id_read(verbose=False, debug=False, parent=None):
        """Reads the FW ID of the dpIFGen2 board.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: fw_id: Interface FW version ID.
        :type fw_id: str

        This command is used to read back the dpIFGen2 board FW id.

        Example Usage:

        >>> fw_id = DpIfGen2APIBasicDp25.interface_fw_id_read()
        >>> fw_id = DpIfGen2APIBasicDp25.interface_fw_id_read(verbose=True)

        @@Class: Connection
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read FW ID"
        exec_seq[0] = {
            "Step": "Read FW ID",
            "CommandData": DpIfGen2Commands.READ_DPIFGEN2_FW_ID_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        return DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def voltage_level_set(v_level, verbose=False, debug=False, parent=None):
        """Sets the voltage level of interface board to a constant level.

        :param v_level: Constant voltage level for the dpIFGen2 Board.
        :type v_level: float
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to supply a constant voltage level to the dpIFGen2
        interface board. Setting the voltage level to zero can be regarded as
        a special case of clearing the voltage.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.
            A too high voltage can destroy the device.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.voltage_level_set(23.5)
        >>> DpIfGen2APIBasicDp25.voltage_level_set(23.5 ,verbose=True)

        @@Class: Connection
        """
        voltage = f"{v_level:.1f}"
        voltage_dec = int(float(voltage) * 10)
        voltage_hex = f"{voltage_dec:04X}"
        voltage_endian = DpIfGen2APIBasicDp25.convert_endian(voltage_hex)
        parameter = voltage_endian

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Set Voltage Level"
        exec_seq[0] = {
            "Step": "Set Voltage Level",
            "Command": DpIfGen2Commands.SET_CUSTOM_VOLTAGE_LEVEL_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def voltage_cycle_execute(v_level1, v_level2, verbose=False, debug=False, parent=None):
        """Executes a voltage cycle consisting of a peak voltage and a constant
        voltage level. Peak voltage level is provided by v_level1 and the
        constant voltage level is provided by v_level2.

        :param v_level1: Peak voltage level for the voltage cycle.
        :type v_level1: float
        :param v_level2: Constant voltage level for the voltage cycle.
        :type v_level2: float
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to supply a constant voltage level to the dpIFGen2
        interface board. Setting the voltage level to zero can be regarded as
        a special case of clearing the voltage.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.
            A too high voltage can destroy the device.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.voltage_cycle_execute(23, 7.5)
        >>> DpIfGen2APIBasicDp25.voltage_cycle_execute(23, 7.5 ,verbose=True)

        @@Class: Connection
        """
        voltage1 = f"{v_level1:.1f}"
        voltage1_dec = int(float(voltage1) * 10)
        voltage1_hex = f"{voltage1_dec:04X}"
        voltage1_endian = DpIfGen2APIBasicDp25.convert_endian(voltage1_hex)

        voltage2 = f"{v_level2:.1f}"
        voltage2_dec = int(float(voltage2) * 10)
        voltage2_hex = f"{voltage2_dec:04X}"
        voltage2_endian = DpIfGen2APIBasicDp25.convert_endian(voltage2_hex)

        parameter = "".join([voltage1_endian, voltage2_endian])
        # DPTOOLS-83: A voltage cycle can take more than one second on dpIfGen2 FW 2.2.16 and later.
        # Before the fix the timeout used to be 1 second.
        # Final decision is that a timeout of 4 seconds is sufficient.
        timeout_in_seconds = 4

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Execute Voltage Cycle"
        exec_seq[0] = {
            "Step": "Execute Voltage Cycle",
            "Command": DpIfGen2Commands.EXECUTE_CUSTOM_VOLTAGE_CYCLE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": timeout_in_seconds,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def dp25_chip_connect(verbose=False, debug=False, parent=None):
        """Establishes connection with the dp2.5 (dp2b b13) chip.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.


        Connect dp2.5 (dp2b b13) chip, closes the VCC switch and enables the UART.

        .. note::

           This command does not need to be called on startup. This is the default state
           of the chip. The command is only relevant if :func:`dp25_chip_disconnect` is called earlier.

        .. note::

           If the dp2.5 (dp2b b13) chip was not supplied by another source in the meantime, a
           :func:`voltage_cycle_execute` has to be sent to restart the chip.


        Example Usage:

        >>> DpIfGen2APIBasicDp25.dp25_chip_connect()
        >>> DpIfGen2APIBasicDp25.dp25_chip_connect(verbose=True)

        @@Class: Connection
        """

        parameter = "0000"
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Connect dp2.5 chip"
        exec_seq[0] = {
            "Step": "Connect dp2.5 chip",
            "Command": DpIfGen2Commands.CONNECT_DP25_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def dp25_chip_disconnect(verbose=False, debug=False, parent=None):
        """Disconnects connection with the dp2.5 (dp2b b13) chip.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.


        Disconnect dp2.5 (dp2b b13) chip, opens the VCC switch and tristates the UART. After
        executing this command, the dp2.5 (dp2b b13) is completely disconnected from the
        .dpIfGen2 board. There is no current flowing through the pins (<1uA)

        Example Usage:

        >>> DpIfGen2APIBasicDp25.dp25_chip_disconnect()
        >>> DpIfGen2APIBasicDp25.dp25_chip_disconnect(verbose=True)

        @@Class: Connection
        """

        parameter = "0100"
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Disconnect dp2.5 chip"
        exec_seq[0] = {
            "Step": "Disconnect dp2.5 chip",
            "Command": DpIfGen2Commands.CONNECT_DP25_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    ##########################################################################
    ########################### Read Commands ################################
    ##########################################################################
    @staticmethod
    def memory_read(address, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param out_format: The format of the word read from the memory location
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to read one word from the specified memory address.

        .. note::

            The read word is returned in hexdecimal format by default.
            Supported return formats are:

                * **dec**: Decimal format
                * **hex**: Hexadecimal format

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> output_word = DpIfGen2APIBasicDp25.memory_read("8080")
        >>> output_word = DpIfGen2APIBasicDp25.memory_read("8080", "dec", verbose=True)

        @@Class: Read
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        valid_fmt = ["hex", "dec"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read Word"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.READ_VALUES_COMMAND,
            "Parameters": "".join([address_endian, "0100"]),
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        word = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        if out_format == "dec":
            return word
        elif out_format == "hex":
            return f"{word:04X}"
        return None

    @staticmethod
    def memory_block_read(address, length, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a memory block.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param out_format: The format of the read data from the memory block
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to reads the memory block from the chip starting
        at the specified address. Length specifies the number of words to be
        read.

        .. note::

           The read word is returned in hexdecimal format by default.
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format
              * **dict**: Python Dictionary
              * **ahex**: AHEX file format

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        >>> output_data = DpIfGen2APIBasicDp25.memory_block_read("8080", "0010")
        >>> output_data = DpIfGen2APIBasicDp25.memory_block_read("8080", "0010", "hex", verbose=True)

        @@Class: Read
        """

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        valid_fmt = ["hex", "dec", "dict", "ahex"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        address_dec = int(address, 16)
        length_dec = int(length, 16)

        # define the sequence

        exec_seq = {}
        exec_seq["Name"] = "Read Memory Block"
        """
        seq = Executer()
        seq.add_step("Read Momory Block")
        seq.add_property("Process", True)
        seq.add_property(seq.P_PROCESS_COMMMAND, DpIfGen2Commands.READ_VALUES_COMMAND)
        """
        exec_seq[0] = {
            "Step": "Read Memory Block",
            "Process": True,
            "Address": address_dec,
            "Length": length_dec,
            "ProcessCommand": DpIfGen2Commands.READ_VALUES_COMMAND,
            "Parameters": "",
            "Response": "ACK",
            "Timeout": 2,
        }

        mem_block = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

        if out_format == "dec":
            return [int(mem_block[item], 16) for item in sorted(mem_block.keys())]
        elif out_format == "hex":
            return [mem_block[item] for item in sorted(mem_block.keys())]
        elif out_format == "dict":
            return mem_block
        elif out_format == "ahex":
            return [f"{item}:{mem_block[item]}" for item in sorted(mem_block.keys())]
        return None

    @staticmethod
    def dmem_read(address, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a DMEM register.

        :param address: 4 hexadecimal digit DMEM register address
        :type address: str
        :param out_format: The format of the word read from the DMEM register address
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to read one word from the DMEM register specified.

        .. note::

            The read word is returned in hexdecimal format by default.
            Supported return formats are:

                * **dec**: Decimal format
                * **hex**: Hexadecimal format

        .. warning::

            This command only works with unlocked chips.

        .. note::

            Valid DMEM Register for this operation are:
                * 0000 DMEM_SUBS_CDR
                * 0001 DMEM_SUBS_FTR
                * 0002 DMEM_SUBS_IFR
                * 0003 DMEM_SUBS_SREQ0
                * 0004 DMEM_SUBS_SREQ12
                * 0005 DMEM_SUBS_INTCTR
                * 0006 DMEM_SUBS_PIDR
                * 0007 DMEM_SUBS_PODR
                * 0008 DMEM_SUBS_STATUS

        Example Usage:

        >>> output_word = DpIfGen2APIBasicDp25.dmem_read("0002")
        >>> output_word = DpIfGen2APIBasicDp25.dmem_read("0002", "dec", verbose=True)

        @@Class: Read
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        valid_fmt = ["hex", "dec"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        parameter = address_endian
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read Word"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.DMEM_READ_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        word = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        if out_format == "dec":
            return word
        elif out_format == "hex":
            return f"{word:04X}"
        return None

    @staticmethod
    def aparam_read(address, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a APARAM memory location.

        :param address: 4 hexadecimal digit APARAM memory address
        :type address: str
        :param out_format: The format of the word read from the APARAM memory location
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to read one word from the specified APARAM memory address.

        .. note::

            The read word is returned in hexdecimal format by default.
            Supported return formats are:

                * **dec**: Decimal format
                * **hex**: Hexadecimal format

        .. warning::

            This command only works with chips which have APARAM Read API unlocked.

        Example Usage:

        >>> output_word = DpIfGen2APIBasicDp25.aparam_read("002A")
        >>> output_word = DpIfGen2APIBasicDp25.aparam_read("002A", "dec", verbose=True)

        @@Class: Read
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        valid_fmt = ["hex", "dec"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read Word"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.APARAM_READ_COMMAND,
            "Parameters": "".join([address_endian, "0100"]),
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        word = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        if out_format == "dec":
            return word
        elif out_format == "hex":
            return f"{word:04X}"
        return None

    @staticmethod
    def aparam_block_read(address, length, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a APARAM memory block.

        :param address: 4 hexadecimal digit APARAM memory address
        :type address: str
        :param length: 4 hexadecimal digit APARAM memory block length/ APARAM memory block length in int
        :type length: str, int
        :param out_format: The format of the read data from the APARAM memory block
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to reads the APARAM memory block from the chip starting
        at the specified offset. Length specifies the number of words to be
        read.

        .. note::

           The read word is returned in hexdecimal format by default.
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format
              * **dict**: Python Dictionary
              * **ahex**: AHEX file format

        .. warning::

            This command only works with chips which have APARAM Read API unlocked.

        Example Usage:

        >>> output_data = DpIfGen2APIBasicDp25.aparam_block_read("002A", "0010")
        >>> output_data = DpIfGen2APIBasicDp25.aparam_block_read("002A", "0010", "hex", verbose=True)

        @@Class: Read
        """

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        valid_fmt = ["hex", "dec", "dict", "ahex"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        address_dec = int(address, 16)
        length_dec = int(length, 16)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read Memory Block"
        exec_seq[0] = {
            "Step": "Read Memory Block",
            "Process": True,
            "Address": address_dec,
            "Length": length_dec,
            "ProcessCommand": DpIfGen2Commands.APARAM_READ_COMMAND,
            "Parameters": "",
            "Response": "ACK",
            "Timeout": 2,
        }

        mem_block = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

        if out_format == "dec":
            return [int(mem_block[item], 16) for item in sorted(mem_block.keys())]
        elif out_format == "hex":
            return [mem_block[item] for item in sorted(mem_block.keys())]
        elif out_format == "dict":
            return mem_block
        elif out_format == "ahex":
            return [f"{item}:{mem_block[item]}" for item in sorted(mem_block.keys())]
        return None

    ##########################################################################
    ########################### Write Commands ###############################
    ##########################################################################
    @staticmethod
    def memory_write(address, value, verbose=False, debug=False, parent=None):
        """Write a word value to the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write one word to the specified memory location.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.memory_write("8000", "BEEF")
        >>> DpIfGen2APIBasicDp25.memory_write("8000", "BEEF", verbose=True)

        @@Class: Write
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)
        value_chk = re.match(r"([0-9a-fA-F]{4})", value)
        if not value_chk:
            msg = "Value is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        value_endian = DpIfGen2APIBasicDp25.convert_endian(value)

        parameter = "".join([address_endian, value_endian])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Memory"
        exec_seq[0] = {
            "Step": "Write Memory",
            "Command": DpIfGen2Commands.WRITE_ONE_VALUE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def memory_block_write(address, data, verbose=False, debug=False, parent=None):
        """Writes a data block to memory.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param data: data block to be written to memory
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write a data block in the memory block starting
        at the specified address. This function also checks for CRC to verify
        the successful block write.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.memory_block_write("8080", ["0010", "0089", "0123"])
        >>> DpIfGen2APIBasicDp25.memory_block_write("8080", ["0010", "0089", "0123"], verbose=True)

        @@Class: Write
        """
        # validate address is in correct format
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if not data:
            msg = "Data must be provided as a list of Hexadecimal digits or decimal."
            raise Exception(msg)
        # validate data is in correct format
        for index, value in enumerate(data):
            if isinstance(value, int):
                data[index] = f"{value:04X}"
            else:
                value_chk = re.match(r"([0-9a-fA-F]{4})", value)
                if not value_chk:
                    raise Exception(
                        'Value "%s" is not in correct format. '
                        "Please enter a decimal value or a "
                        "4 Hexadecimal digit Value in the"
                        "format ([0-9a-fA-F]{4})"
                        'example: 15 or "000F' % value
                    )

        address_dec = int(address, 16)
        address_hex = f"{address_dec:06X}"

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Memory Block"
        exec_seq[0] = {
            "Step": "Data Block Prepare",
            "Process": True,
            "Address": address_hex,
            "Data": data,
        }
        exec_seq[1] = {
            "Step": "Select Buffer16K",
            "Command": DpIfGen2Commands.BUF16K_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[4] = {
            "Step": "Write RAM Command",
            "Command": DpIfGen2Commands.WRITE_RAM_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def ahex_file_write(filename, verbose=False, debug=False, parent=None):
        """Writes an ahex file to a memory block.

        :param filename: Memory values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write a memory block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function writes the values starting from the start address to the
            end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                008000:BEEF
                008001:BAAF
                008004:DEED

            In this case addresses 0x8002, 0x8003 are written with 0x0000

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.ahex_file_write(r"filename.ahex")
        >>> DpIfGen2APIBasicDp25.ahex_file_write(r"filename.ahex", verbose=True)

        @@Class: Write
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Ahex File"
        exec_seq[0] = {
            "Step": "Data extraction from ahex file",
            "Process": True,
            "Filename": filename,
        }
        exec_seq[1] = {
            "Step": "Select Buffer16K",
            "Command": DpIfGen2Commands.BUF16K_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[4] = {
            "Step": "Write RAM Command",
            "Command": DpIfGen2Commands.WRITE_RAM_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def dmem_write(address, value, verbose=False, debug=False, parent=None):
        """Write a word value to the specified DMEM register

        :param address: 4 hexadecimal digit DMEM register address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write one word to the specified DMEM register location.

        .. note::

            This command only works with unlocked chips.

            Valid DMEM Register for this operation are:

                * 0000 DMEM_SUBS_CDR
                * 0001 DMEM_SUBS_FTR
                * 0003 DMEM_SUBS_SREQ0
                * 0004 DMEM_SUBS_SREQ12
                * 0005 DMEM_SUBS_INTCTR
                * 0007 DMEM_SUBS_PODR

        Example Usage:

        >>> DpIfGen2APIBasicDp25.dmem_write("0001", "BEEF")
        >>> DpIfGen2APIBasicDp25.dmem_write("0001", "BEEF", verbose=True)

        @@Class: Write
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)
        value_chk = re.match(r"([0-9a-fA-F]{4})", value)
        if not value_chk:
            msg = "Value is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        value_endian = DpIfGen2APIBasicDp25.convert_endian(value)

        parameter = "".join([address_endian, value_endian])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write DMEM Register"
        exec_seq[0] = {
            "Step": "Write DMEM Register",
            "Command": DpIfGen2Commands.DMEM_WRITE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_write(address, value, verbose=False, debug=False, parent=None):
        """Write a word value to the specified APARAM location.

        :param address: 4 hexadecimal digit APARAM address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write one word to the specified APARAM location.

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_write("002A", "BEEF")
        >>> DpIfGen2APIBasicDp25.aparam_write("002A", "BEEF", verbose=True)

        @@Class: Write
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)
        value_chk = re.match(r"([0-9a-fA-F]{4})", value)
        if not value_chk:
            msg = "Value is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        value_endian = DpIfGen2APIBasicDp25.convert_endian(value)

        parameter = "".join([address_endian, value_endian])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Memory"
        exec_seq[0] = {
            "Step": "Write Memory",
            "Command": DpIfGen2Commands.APARAM_WRITE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_block_write(address, data, verbose=False, debug=False, parent=None):
        """Writes a data block to APARAM.

        :param address: 4 hexadecimal digit APARAM address
        :type address: str
        :param data: data block to be written to APARAM
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write a data block in the APARAM block starting
        at the specified offset. This function also checks for CRC to verify
        the successful block write.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.memory_block_write("002A", ["0010", "0089", "0123"])
        >>> DpIfGen2APIBasicDp25.memory_block_write("002A", ["0010", "0089", "0123"], verbose=True)

        @@Class: Write
        """
        # validate address is in correct format
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if not data:
            msg = "Data must be provided as a list of Hexadecimal digits or decimal."
            raise Exception(msg)
        # validate data is in correct format
        for index, value in enumerate(data):
            if isinstance(value, int):
                data[index] = f"{value:04X}"
            else:
                value_chk = re.match(r"([0-9a-fA-F]{4})", value)
                if not value_chk:
                    raise Exception(
                        'Value "%s" is not in correct format. '
                        "Please enter a decimal value or a "
                        "4 Hexadecimal digit Value in the"
                        "format ([0-9a-fA-F]{4})"
                        'example: 15 or "000F' % value
                    )

        address_dec = int(address, 16)
        address_hex = f"{address_dec:06X}"

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Memory Block"
        exec_seq[0] = {
            "Step": "Data Block Prepare",
            "Process": True,
            "Address": address_hex,
            "Data": data,
        }
        exec_seq[1] = {
            "Step": "Select Parameter Buffer",
            "Command": DpIfGen2Commands.BUF_PARAMETER_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[4] = {
            "Step": "Write RAM Command",
            "Command": DpIfGen2Commands.APARAM_BLOCK_WRITE_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_ahex_file_write(filename, verbose=False, debug=False, parent=None):
        """Writes an aparam ahex file to a memory block.

        :param filename: APARAM values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write a APARAM block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function writes the values starting from the start address to the
            end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                000000:BEEF
                000001:BAAF
                000004:DEED

            In this case addresses 0x0002, 0x0003 are written with 0x0000

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_ahex_file_write(r"filename.ahex")
        >>> DpIfGen2APIBasicDp25.aparam_ahex_file_write(r"filename.ahex", verbose=True)

        @@Class: Write
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write APARAM ahex File"
        exec_seq[0] = {
            "Step": "Data extraction from ahex file",
            "Process": True,
            "Filename": filename,
        }
        exec_seq[1] = {
            "Step": "Select Parameter Buffer",
            "Command": DpIfGen2Commands.BUF_PARAMETER_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[4] = {
            "Step": "Write APARAM Block Write Command",
            "Command": DpIfGen2Commands.APARAM_BLOCK_WRITE_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    ##########################################################################
    ########################### Burn Commands ################################
    ##########################################################################

    @staticmethod
    def memory_burn(address, value, verbose=False, debug=False, parent=None):
        """Burn a word value to the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn one word to the specified memory location.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.memory_burn("8000", "BEEF")
        >>> DpIfGen2APIBasicDp25.memory_burn("8000", "BEEF", verbose=True)

        @@Class: Burn
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)
        value_chk = re.match(r"([0-9a-fA-F]{4})", value)
        if not value_chk:
            msg = "Value is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        value_endian = DpIfGen2APIBasicDp25.convert_endian(value)

        parameter = "".join([address_endian, value_endian])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn Memory"
        exec_seq[0] = {
            "Step": "Burn Single Memory",
            "Command": DpIfGen2Commands.BURN_ONE_VALUE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def memory_block_burn(address, data, verbose=False, debug=False, parent=None):
        """Burns a data block to memory.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param data: data block to be written to memory
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a data block in the memory block starting
        at the specified address. This function also checks for CRC to verify
        the successful block burn.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.memory_block_burn("8080", ["0010", "0089", "0123"])
        >>> DpIfGen2APIBasicDp25.memory_block_burn("8080", ["0010", "0089", "0123"], verbose=True)

        @@Class: Burn
        """
        DpIfGen2APIBasicDp25.memory_block_write(address, data, verbose, debug, parent)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn Memory Block"
        exec_seq[0] = {
            "Step": "Write OTP Command",
            "Command": DpIfGen2Commands.WRITE_OTP_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def ahex_file_burn(filename, verbose=False, debug=False, parent=None):
        """Burns an ahex file to a memory block.

        :param filename: Memory values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a memory block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function burns the values starting from the start address to
            the end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                00C000:BEEF
                00C001:BAAF
                00C004:DEED

            In this case addresses 0xC002, 0xC003 are written with 0x0000

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.ahex_file_burn(r"filename.ahex")
        >>> DpIfGen2APIBasicDp25.ahex_file_burn(r"filename.ahex", verbose=True)

        @@Class: Burn
        """

        DpIfGen2APIBasicDp25.ahex_file_write(filename, verbose, debug, parent)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn Memory Block"
        exec_seq[0] = {
            "Step": "Write OTP Command",
            "Command": DpIfGen2Commands.WRITE_OTP_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_burn(address, value, verbose=False, debug=False, parent=None):
        """Burn a word value to the specified APARAM location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn one word to the specified APARAM location.

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_burn("002A", "BEEF")
        >>> DpIfGen2APIBasicDp25.aparam_burn("002A", "BEEF", verbose=True)

        @@Class: Burn
        """
        DpIfGen2APIBasicDp25.aparam_write(address, value, verbose, debug, parent)

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)

        parameter = address_endian

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn APARAM Patch"
        exec_seq[0] = {
            "Step": "Burn APARAM Patch",
            "Command": DpIfGen2Commands.BURN_APARAM_PATCH_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_block_burn(address, data, verbose=False, debug=False, parent=None):
        """Burns a data block to APARAM.

        :param address: 4 hexadecimal digit APARAM address
        :type address: str
        :param data: data block to be written to APARAM
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a data block in the memory block starting
        at the specified address. This function also checks for CRC to verify
        the successful block burn.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_block_burn("0012", ["0010", "0089", "0123"])
        >>> DpIfGen2APIBasicDp25.aparam_block_burn("0012", ["0010", "0089", "0123"], verbose=True)

        @@Class: Burn
        """
        DpIfGen2APIBasicDp25.aparam_block_write(address, data, verbose, debug, parent)

        executer_basic = DpIfGen2APIExecuterBasic()
        executer_basic.fake_data_extraction_block(address, data)
        info = executer_basic._process_ahex_file.get_file_info()

        crc_data = info.get("CRC")
        length_data = f"{len(data):04X}"

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        length_endian = DpIfGen2APIBasicDp25.convert_endian(length_data)
        crc_endian = DpIfGen2APIBasicDp25.convert_endian(crc_data)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn APARAM Block"
        exec_seq[0] = {
            "Step": "Burn APARAM Command",
            "Command": DpIfGen2Commands.APARAM_BLOCK_BURN_COMMAND,
            "Parameters": "".join([address_endian, length_endian, crc_endian]),
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_ahex_file_burn(filename, verbose=False, debug=False, parent=None):
        """Burns an ahex file to a APARAM block.

        :param filename: APARAM values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a APARAM block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function burns the values starting from the start address to
            the end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                00C000:BEEF
                00C001:BAAF
                00C004:DEED

            In this case addresses 0xC002, 0xC003 are written with 0x0000

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_ahex_file_burn(r"filename.ahex")
        >>> DpIfGen2APIBasicDp25.aparam_ahex_file_burn(r"filename.ahex", verbose=True)

        @@Class: Burn
        """

        DpIfGen2APIBasicDp25.aparam_ahex_file_write(filename, verbose, debug, parent)

        executer_basic = DpIfGen2APIExecuterBasic()
        executer_basic._filename = filename

        # need this step for reusing the existing function in the executer
        dummy_seq = {}
        dummy_seq["Name"] = "Dummy Sequence"
        dummy_seq[0] = {"Step": "Dummy Step"}

        executer_basic.create_sequence(dummy_seq)

        executer_basic.extract_data_file()
        info = executer_basic._process_ahex_file.get_file_info()

        address_ahex_file = info.get("Start Address")
        address_file = f"{int(address_ahex_file, 16):04X}"
        crc_file = info.get("CRC")
        length_file = info.get("Length")

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address_file)
        length_endian = DpIfGen2APIBasicDp25.convert_endian(length_file)
        crc_endian = DpIfGen2APIBasicDp25.convert_endian(crc_file)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn APARAM Block"
        exec_seq[0] = {
            "Step": "Burn APARAM Block Command",
            "Command": DpIfGen2Commands.APARAM_BLOCK_BURN_COMMAND,
            "Parameters": "".join([address_endian, length_endian, crc_endian]),
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def fw_patch_burn(address, value, verbose=False, debug=False, parent=None):
        """Patches a word value to the burnt FW.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to patch one word to the already burnt FW.

        .. warning::

            This command only works with chips with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.fw_patch_burn("812A", "BEEF")
        >>> DpIfGen2APIBasicDp25.fw_patch_burn("812A", "BEEF", verbose=True)

        @@Class: Burn
        """
        DpIfGen2APIBasicDp25.memory_write(address, value, verbose, debug, parent)

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)

        parameter = address_endian

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn FW Patch"
        exec_seq[0] = {
            "Step": "Burn FW Patch",
            "Command": DpIfGen2Commands.FW_PATCH_BURN_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def fw_patch_block_burn(address, data, verbose=False, debug=False, parent=None):
        """Patches a FW block to burnt FW.

        :param address: 4 hexadecimal digit FW address
        :type address: str
        :param data: data block to be patched to FW
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to patch a data block in the memory block starting
        at the specified address. This function also checks for CRC to verify
        the successful block burn.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.fw_patch_block_burn("8112", ["0010", "0089", "0123"])
        >>> DpIfGen2APIBasicDp25.fw_patch_block_burn("8112", ["0010", "0089", "0123"], verbose=True)

        @@Class: Burn
        """
        DpIfGen2APIBasicDp25.memory_block_write(address, data, verbose, debug, parent)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn FW Patch Block"
        exec_seq[0] = {
            "Step": "Burn FW Patch Block Command",
            "Command": DpIfGen2Commands.FW_PATCH_BLOCK_BURN_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def fw_patch_ahex_file_burn(filename, verbose=False, debug=False, parent=None):
        """Patches an ahex file to a FW.

        :param filename: Patch values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a FW Patch block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function burns the values starting from the start address to
            the end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                00C000:BEEF
                00C001:BAAF
                00C004:DEED

            In this case addresses 0xC002, 0xC003 are written with 0x0000

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_ahex_file_burn(r"filename.ahex")
        >>> DpIfGen2APIBasicDp25.aparam_ahex_file_burn(r"filename.ahex", verbose=True)

        @@Class: Burn
        """

        DpIfGen2APIBasicDp25.ahex_file_write(filename, verbose, debug, parent)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn FW Patch Block"
        exec_seq[0] = {
            "Step": "Burn FW Patch Block Command",
            "Command": DpIfGen2Commands.FW_PATCH_BLOCK_BURN_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    ##########################################################################
    ########################### Check Commands ###############################
    ##########################################################################

    @staticmethod
    def memory_block_check_blank(address, length, verbose=False, debug=False, parent=None):
        """Verifies if the memory block is blank.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: bool

        This command is used to verify the memory block is blank (filled with
        zeros).

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> is_memory_blank = DpIfGen2APIBasicDp25.memory_block_check_blank("8080", "0010")
        >>> is_memory_blank = DpIfGen2APIBasicDp25.memory_block_check_blank("8080", "0010", verbose=True)

        @@Class: Check
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        length_endian = DpIfGen2APIBasicDp25.convert_endian(length)

        parameter = "".join([address_endian, length_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Blank Check Memory"
        exec_seq[0] = {
            "Step": "Blank Check",
            "Command": DpIfGen2Commands.BLANK_CHECK,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        try:
            DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
            return True
        except Exception as e:
            if "NAK3F00" in str(e):
                return False
            else:
                raise Exception(str(e))

    @staticmethod
    def memory_crc_get(address, length, verbose=False, debug=False, parent=None):
        """Calculates the CRC of a memory block

        :param address: 4 hexadecimal digit starting memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to calculate the CRC over memory block.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> memory_crc = DpIfGen2APIBasicDp25.memory_crc_get("8080", "0010")
        >>> memory_crc = DpIfGen2APIBasicDp25.memory_crc_get("8080", "0010", verbose=True)

        @@Class: Check
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        length_endian = DpIfGen2APIBasicDp25.convert_endian(length)

        parameter = "".join([address_endian, length_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Calculate CRC Memory block"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.MEMORY_GET_CRC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        crc = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

        return f"{crc:04X}"

    @staticmethod
    def otp_crc_get(address, length, verbose=False, debug=False, parent=None):
        """Calculates the CRC of an OTP block

        :param address: 4 hexadecimal digit starting OTP address
        :type address: str
        :param length: 4 hexadecimal digit OTP block length/ OTP block length in int
        :type length: str, int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to calculate the CRC over OTP block.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> memory_crc = DpIfGen2APIBasicDp25.otp_crc_get("8080", "0010")
        >>> memory_crc = DpIfGen2APIBasicDp25.otp_crc_get("8080", "0010", verbose=True)

        @@Class: Check
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        length_endian = DpIfGen2APIBasicDp25.convert_endian(length)

        parameter = "".join([address_endian, length_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Calculate CRC OTP block"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.OTP_GET_CRC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        crc = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

        return f"{crc:04X}"

    @staticmethod
    def aparam_crc_get(address, length, verbose=False, debug=False, parent=None):
        """Calculates the CRC of an APARAM block

        :param address: 4 hexadecimal digit starting APARAM address
        :type address: str
        :param length: 4 hexadecimal digit APARAM block length/ APARAM block length in int
        :type length: str, int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: bool

        This command is used to calculate the CRC over APARAM block.

        .. warning::

            This command only works with chips which have APARAM Read API unlocked.

        Example Usage:

        >>> memory_crc = DpIfGen2APIBasicDp25.aparam_crc_get("8080", "0010")
        >>> memory_crc = DpIfGen2APIBasicDp25.aparam_crc_get("8080", "0010", verbose=True)

        @@Class: Check
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)
        length_endian = DpIfGen2APIBasicDp25.convert_endian(length)

        parameter = "".join([address_endian, length_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Calculate CRC APARAM block"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.APARAM_GET_CRC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        crc = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

        return f"{crc:04X}"

    ##########################################################################
    ########################### Other Commands ###############################
    ##########################################################################
    @staticmethod
    def jump_execute(address, verbose=False, debug=False, parent=None):
        """Executes a jump at the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command Triggers a LJUMP of the nanoDSP core to the given code
        address. The Stack is reset to it initial position before the jump.

        .. warning::

            This command only works with unlocked chips.

        .. warning::

            This command requires knowledge of the Firmware programmed on the
            chip. A resynchronization might be necessary with the chip after
            performing the jump command.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.jump_execute("8000")
        >>> DpIfGen2APIBasicDp25.jump_execute("8000", verbose=True)

        @@Class: Others
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)

        parameter = "".join([address_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Execute Jump"
        exec_seq[0] = {
            "Step": "Jump",
            "Command": DpIfGen2Commands.JUMP_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def call_execute(address, verbose=False, debug=False, parent=None):
        """Calls a routine at the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command Triggers a LCALL of the nanoDSP core of the given code
        address. The jump-back address is pushed on the stack, so
        a RET call will return to the protocol handler.

        .. warning::

            This command only works with unlocked chips.

        .. warning::

            This command requires knowledge of the Firmware programmed on the
            chip. A resynchronization might be necessary with the chip after
            performing the call command.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.call_execute("8000")
        >>> DpIfGen2APIBasicDp25.call_execute("8000", verbose=True)

        @@Class: Others
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = DpIfGen2APIBasicDp25.convert_endian(address)

        parameter = "".join([address_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Execute Call"
        exec_seq[0] = {
            "Step": "Call",
            "Command": DpIfGen2Commands.CALL_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def info_get(verbose=False, debug=False, parent=None):
        """gets information about the chip

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: available information as a Python dictionary

        This command is used to read back the following information from
        the chip:

            * Device ID
            * Firmware ID
            * Customer ID
            * Patch ID
            * APARAM ID
            * ROM ID

        Example Usage:

        >>> info = DpIfGen2APIBasicDp25.info_get()
        >>> info = DpIfGen2APIBasicDp25.info_get(verbose=True)

        @@Class: Others
        """
        # reads the memory location 0x0001 of the chip to determine the
        # chip type
        info = {}
        info["Device ID"] = DpIfGen2APIBasicDp25.info_get_single("0000", 2, verbose, debug, parent)
        info["Firmware ID"] = DpIfGen2APIBasicDp25.info_get_single("0100", 4, verbose, debug, parent)
        info["Customer ID"] = DpIfGen2APIBasicDp25.info_get_single("0200", 2, verbose, debug, parent)
        info["Patch ID"] = DpIfGen2APIBasicDp25.info_get_single("0300", 1, verbose, debug, parent)
        info["APARAM ID"] = DpIfGen2APIBasicDp25.info_get_single("1000", 1, verbose, debug, parent)
        info["ROM ID"] = DpIfGen2APIBasicDp25.info_get_single("1100", 1, verbose, debug, parent)

        if debug:
            print(info)
        return info

        # if verbose:
        #     DpIfGen2APIBasicDp25.display_msg(''.join(["ROM_VERSION_IDENTIFIED: ",
        #                                           str(info["ROM_VERSION_IDENTIFIED"]["Status"])]))
        #
        # if debug:
        #     for key in sorted(rom_version.keys()):
        #         DpIfGen2APIBasicDp25.display_msg(''.join([key, ":", rom_version[key]]))
        #
        # if verbose:
        #     msg = ''.join([exec_seq.get("Name"), " successfully executed ", ])
        #     DpIfGen2APIBasicDp25.display_msg(msg)
        # return info

    @staticmethod
    def info_get_single(info_code, num_words, verbose=False, debug=False, parent=None):
        """gets single information about the chip

        :param info_code: ID of information to request.
        :type info_code: str
        :param num_words: Number of expected words for the answer. One word contains two bytes.
        :type num_words: int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: available information as a Python dictionary

        This command is used to read back a single information from the chip.

        Example Usage to read the ROM ID:

        >>> info = DpIfGen2APIBasicDp25.info_get_single("1100", )
        >>> info = DpIfGen2APIBasicDp25.info_get_single("1100", 1, verbose=True)

        @@Class: Others
        """

        exec_seq = {}
        exec_seq["Name"] = "Get Info"
        exec_seq[0] = {
            "Step": "Get Info Seq",
            "CommandData": DpIfGen2Commands.GET_INFO_COMMAND,
            "Parameters": info_code,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        info = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        return [info[word] for word in range(num_words)]

    @staticmethod
    def application_start(verbose=False, debug=False, parent=None):
        """Launch the Application Firmware. The start address is specified in the boot descriptor of the OTP.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to start the application firmware (in case auto-start is disabled).

        Example Usage:

        >>> DpIfGen2APIBasicDp25.application_start()
        >>> DpIfGen2APIBasicDp25.application_start(verbose=True)

        @@Class: Others
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Application Start"
        exec_seq[0] = {
            "Step": "Application Start",
            "Command": DpIfGen2Commands.APPLICATION_START_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def application_stop(verbose=False, debug=False, parent=None):
        """Stops the Application Firmware (calls an implementation specific callback).

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to stop the application firmware.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.application_stop()
        >>> DpIfGen2APIBasicDp25.application_stop(verbose=True)

        @@Class: Others
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Application Stop"
        exec_seq[0] = {
            "Step": "Application Stop",
            "Command": DpIfGen2Commands.APPLICATION_STOP_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def auto_start_set(mode, verbose=False, debug=False, parent=None):
        """To enable or disable Application FW auto start.

        :param mode: 4 hexadecimal digit memory address
        :type mode: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command can be used to enable or disable the App FW Auto start. The information
        is stored Byte-Redundant i.e. the upper byte and the lower byte of the 16 Bit word are
        bitwise OR'd ang read to get a single byte. This byte is inspected.

        ARG0 = New Autostart Value

        An odd amount of bits in this byte enables Autostart, an even amount or
        no bits at all disable Autostart.

        E.g.: 0b00000001 00000001 would read as 0b0000 0001 after applying
        byte redundancy internally and would thus lead to an enabled autostart

        Example Usage:

        >>> DpIfGen2APIBasicDp25.auto_start_set("0101")
        >>> DpIfGen2APIBasicDp25.auto_start_set("0101", verbose=True)

        @@Class: Others
        """
        mode_chk = re.match(r"([0-9a-fA-F]{4})", mode)
        if not mode_chk:
            msg = "Mode is not in correct format. Please enter a 4 Hexadecimal digit Mode"
            raise Exception(msg)

        mode_endian = DpIfGen2APIBasicDp25.convert_endian(mode)

        parameter = "".join([mode_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Set Autostart"
        exec_seq[0] = {
            "Step": "Set Autostart",
            "Command": DpIfGen2Commands.AUTOSTART_SET_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def auto_start_get(out_format="hex", verbose=False, debug=False, parent=None):
        """To read back the Application FW auto start value.

        :param out_format: The format of the word read from the memory location
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command reads the current value of the redundant Autostart Enable byte.

        Example Usage:

        >>> mode = DpIfGen2APIBasicDp25.auto_start_get()
        >>> mode = DpIfGen2APIBasicDp25.auto_start_get("hex", verbose=True)

        @@Class: Others
        """
        valid_fmt = ["hex", "dec"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Get Autostart"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.AUTOSTART_GET_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Parameters": "",
            "Timeout": 1,
        }
        word = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        if out_format == "dec":
            return word
        elif out_format == "hex":
            return f"{word:04X}"
        return None

    @staticmethod
    def boot_status_get(verbose=False, debug=False, parent=None):
        """To read back the Boot status.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: status (str)

        This command returns the status of the executed boot process.

        Example Usage:

        >>> status = DpIfGen2APIBasicDp25.boot_status_get()
        >>> status = DpIfGen2APIBasicDp25.boot_status_get(verbose=True)

        @@Class: Others
        """

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Get Boot status"
        exec_seq[0] = {
            "Step": "Get boot status",
            "Command": DpIfGen2Commands.BOOT_STATUS_GET_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        try:
            DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
            return True
        except Exception as e:
            if "NAK" in str(e):
                status = str(e).split("NAK")
                status = status[1][0:4]
                return DpIfGen2APIBasicDp25.convert_endian(status)
            else:
                raise Exception(str(e))
        return False

    @staticmethod
    def aparam_api_lock(mode, verbose=False, debug=False, parent=None):
        """To enable or disable features of APARAM API.

        :param mode: lock mode for the APARAM API
        :type mode: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        Can be used to permanently lock certain features of the APARAM API.
        The features are only locked, if the controller is locked as well.
        The following modes are supported:

            * read
            * write

        .. warning::

            This command is not reversible.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_api_lock("read")
        >>> DpIfGen2APIBasicDp25.aparam_api_lock("read", verbose=True)

        @@Class: Others
        """
        valid_mode = ["read", "write"]
        if mode not in valid_mode:
            raise Exception(
                "".join(
                    [
                        "Lock mode is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_mode),
                    ]
                )
            )
        elif mode == "read":
            parameter = "0100"
        elif mode == "write":
            parameter = "0200"

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Lock APARAM API"
        exec_seq[0] = {
            "Step": "Lock APARAM API",
            "Command": DpIfGen2Commands.APARAM_API_LOCK_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def aparam_apply(verbose=False, debug=False, parent=None):
        """Applies the set of APARAM Values from OTP to Memory.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to apply the set of APARAM Values from OTP to Memory.

        .. warning::

            This command only works with chips which have APARAM Write API unlocked.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.aparam_apply()
        >>> DpIfGen2APIBasicDp25.aparam_apply(verbose=True)

        @@Class: Others
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Aparam Apply"
        exec_seq[0] = {
            "Step": "Aparam Apply",
            "Command": DpIfGen2Commands.APARAM_APPLY_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def fw_patch_apply(verbose=False, debug=False, parent=None):
        """Applies the set of FW Patch Values to the burnt FW.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to apply the FW Patch.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.fw_patch_apply()
        >>> DpIfGen2APIBasicDp25.fw_patch_apply(verbose=True)

        @@Class: Others
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "FW Patch Apply"
        exec_seq[0] = {
            "Step": "FW Patch Apply",
            "Command": DpIfGen2Commands.FW_PATCH_APPLY_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def dp25_chip_lock(password, verbose=False, debug=False, parent=None):
        """Write a password to lock the chip for IP protection.

        :param password: 8 hexadecimal digit password
        :type password: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write the 32 bit password (2 words) to lock
        the chip for IP Protection.

        .. warning::

           The password must not be 0 and the MSB must be set to 1.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.dp25_chip_lock("DEEDBEAF")
        >>> DpIfGen2APIBasicDp25.dp25_chip_lock("DEEDBEAF", verbose=True)

        @@Class: Others
        """
        password_chk = re.match(r"([0-9a-fA-F]{8})", password)
        if not password_chk:
            msg = "Password is not in correct format. Please enter a 8 Hexadecimal digit password"
            raise Exception(msg)

        password_high = password[0:4]
        password_low = password[4:8]

        parameter1 = DpIfGen2APIBasicDp25.convert_endian(password_high)
        parameter2 = DpIfGen2APIBasicDp25.convert_endian(password_low)

        parameter = "".join([parameter2, parameter1])
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Lock Chip"
        exec_seq[0] = {
            "Step": "Write Password Register",
            "Command": DpIfGen2Commands.LOCK_CHIP_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    @staticmethod
    def dp25_chip_unlock(password, verbose=False, debug=False, parent=None):
        """Write a password to unlock the locked chip for IP protection.

        :param password: 8 hexadecimal digit password
        :type password: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write the 32 bit password (2 words) to unlock
        the chip locked for IP Protection.

        Example Usage:

        >>> DpIfGen2APIBasicDp25.dp25_chip_unlock("DEEDBEAF")
        >>> DpIfGen2APIBasicDp25.dp25_chip_unlock("DEEDBEAF", verbose=True)

        @@Class: Others
        """
        password_chk = re.match(r"([0-9a-fA-F]{8})", password)
        if not password_chk:
            msg = "Password is not in correct format. Please enter a 8 Hexadecimal digit password"
            raise Exception(msg)

        password_high = password[0:4]
        password_low = password[4:8]

        parameter1 = DpIfGen2APIBasicDp25.convert_endian(password_high)
        parameter2 = DpIfGen2APIBasicDp25.convert_endian(password_low)

        parameter = "".join([parameter2, parameter1])
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Unlock Chip"
        exec_seq[0] = {
            "Step": "Write Password Register",
            "Command": DpIfGen2Commands.UNLOCK_CHIP_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)

    #########################################################################
    ############    Helper Functions ########################################
    #########################################################################
    @staticmethod
    def convert_endian(endian_prev):
        return "".join(format(b, "02X") for b in bytearray.fromhex(endian_prev)[::-1])

    @staticmethod
    def display_msg(msg, parent=None):
        if not parent:
            print("".join(["[I]: ", msg]))

    @staticmethod
    def exec_config_seq(exec_seq, verbose=False, debug=False, parent=None):
        try:
            if verbose:
                msg = "".join(["Executing Sequence ", exec_seq.get("Name")])
                DpIfGen2APIBasicDp25.display_msg(msg, parent)
            # initialize the executer class
            dpifgen2_api_executer_basic = DpIfGen2APIExecuterBasic()
            dpifgen2_api_executer_basic._verbose = debug
            dpifgen2_api_executer_basic._debug = False
            dpifgen2_api_executer_basic.open_check_hid_device()
            dpifgen2_api_executer_basic.set_receive_handle()

            # create/define the sequence
            dpifgen2_api_executer_basic.create_sequence(exec_seq)

            # execute the sequence
            dpifgen2_api_executer_basic.execute_sequence()
        except Exception as e:
            # decode error string
            decoded = DpIfGen2APIBasicDp25.decode_error_code(str(e))
            if decoded:
                raise Exception(decoded)
            else:
                raise Exception(str(e))
        finally:
            # close the hid connections
            dpifgen2_api_executer_basic.close_hid_device()
        # check if the execution was successful
        if dpifgen2_api_executer_basic._success:
            if verbose:
                msg = "".join([exec_seq.get("Name"), " successfully executed"])
                DpIfGen2APIBasicDp25.display_msg(msg, parent)
            return dpifgen2_api_executer_basic._data_exchange
        return None

    @staticmethod
    def decode_error_code(error_str):
        error_decoded = None
        if "NAK" in error_str:
            error_string = error_str.split("NAK")
            error_code = error_string[1][0:4]
            # print("Error Code Received: ", error_code)

            result = re.search("[0-9a-fA-F]{4}", error_code)
            if result:
                code_string_low = result.group()[0:2]
                code_string_high = result.group()[2:4]
                if code_string_high == "04":
                    # These messages are coming from the dpIFGen2 board only.
                    if code_string_low in DpIfGen2Commands.NACK_LIST_DPIFGEN2_2_X:
                        dpifgen2_err = DpIfGen2Commands.NACK_LIST_DPIFGEN2_2_X.get(code_string_low)
                        err_name = dpifgen2_err.get("Name")
                        err_desc = dpifgen2_err.get("Description")
                        err_action = dpifgen2_err.get("Action")

                        error_decoded = "".join(
                            [
                                error_str,
                                "\n\n",
                                "Error Details: ",
                                "\n",
                                "ERROR NAME: ",
                                err_name,
                                "\n",
                                "ERROR DESCRIPTION: ",
                                err_desc,
                                "\n",
                                "ERROR ACTION: ",
                                err_action,
                            ]
                        )
                    else:
                        error_string = "Unknown Error Code. This indicates that the NAK list is not up to date."
                        error_decoded = "".join([error_str, "Error Details: ", "\n", error_string])
                elif code_string_high == "00":
                    # These messages are coming from the device directly.
                    nibble_high = code_string_low[0]
                    if nibble_high in ["7", "B", "F"]:
                        # replace the lower nibble with 'X'
                        code_string_low = "".join([code_string_low[0], "X"])
                    if code_string_low in DpIfGen2Commands.NACK_LIST_DP2:
                        dpifgen2_err = DpIfGen2Commands.NACK_LIST_DP2.get(code_string_low)
                        err_name = dpifgen2_err.get("Name")
                        err_desc = dpifgen2_err.get("Description")
                        err_action = dpifgen2_err.get("Action")

                        error_decoded = "".join(
                            [
                                error_str,
                                "\n\n",
                                "Error Details: ",
                                "\n",
                                "ERROR NAME: ",
                                err_name,
                                "\n",
                                "ERROR DESCRIPTION: ",
                                err_desc,
                                "\n",
                                "ERROR ACTION: ",
                                err_action,
                            ]
                        )
                    else:
                        error_string = "Unknown Error Code. This indicates that the NAK list is not up to date."
                        error_decoded = "".join([error_str, "Error Details: ", "\n", error_string])
        return error_decoded

    @staticmethod
    def protocol_id_get(out_format="hex", verbose=False, debug=False, parent=None):
        """To read back the protocol ID.

        :param out_format: The format of the word returned
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: protocol ID word

        This command reads the value of the protocol ID.

        Example Usage:

        >>> mode = DpIfGen2APIBasicDp25.protocol_id_get()
        >>> mode = DpIfGen2APIBasicDp25.protocol_id_get("hex", verbose=True)

        @@Class: Others
        """
        valid_fmt = ["hex", "dec"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Get Protocol ID"
        exec_seq[0] = {
            "Step": "Read Protocol ID",
            "CommandDataImmediate": DpIfGen2Commands.GET_PROTOCOL_VERSION_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Parameters": "",
            "Timeout": 1,
        }
        word = DpIfGen2APIBasicDp25.exec_config_seq(exec_seq, verbose, debug, parent)
        if out_format == "dec":
            return word
        elif out_format == "hex":
            return f"{word:04X}"
        return None


def main():
    print("This script is not executable. It contains library functions only.")
    print("Version", DpIfGen2APIBasicDp25.VERSION)

    print_config_api = PrintConfigAPI.instance()
    print_config_api._enable_wire_dumping()

    hid_config_api = HIDConfigAPI.instance()
    hid_config_api._set_vendor_id(0x058B)
    hid_config_api._set_product_id(0x0220)

    # DpIfGen2APIBasicDp25.baudrate_set('57600', True, False)
    DpIfGen2APIBasicDp25.connection_establish(True, False)
    # DpIfGen2APIBasicDp25.sync_set(10, True, False)

    # DpIfGen2APIBasicDp25.voltage_level_set(27.5, True, False)
    # DpIfGen2APIBasicDp25.voltage_cycle_execute(27.5, 8.5, True, False)
    # DpIfGen2APIBasicDp25.chip_id_set("dp2a", True, False)
    info = DpIfGen2APIBasicDp25.info_get(verbose=True, debug=False)
    print(info)
    DpIfGen2APIBasicDp25.memory_block_write("8000", ["0000", "0001", "0002", 3, 4, "0005"], True, False)
    read_back = DpIfGen2APIBasicDp25.memory_block_read("8000", 6, "hex", True, False)
    print(read_back)
    print(DpIfGen2APIBasicDp25.memory_block_check_blank("8000", "0010", True, False))
    func_dict = DpIfGen2APIBasicDp25.dict_of_api_functions()
    print(func_dict)


##    DpIfGen2APIBasicDp25.interface_fw_id_read(True, False)
##    DpIfGen2APIBasicDp25.memory_write("9C00","BEEF", True, False)
##    DpIfGen2APIBasicDp25.memory_block_write("dump.ahex", True, False)
##    DpIfGen2APIBasicDp25.password_write("548DE563", True, False)
##    print(DpIfGen2APIBasicDp25.memory_read("9C00", "hex", True, False))
##    DpIfGen2APIBasicDp25.memory_burn("C347", "BAAF", True, False)
##    DpIfGen2APIBasicDp25.memory_block_burn("dump.otp.ahex", True, False)
##    print(DpIfGen2APIBasicDp25.memory_read("C348", "hex", True, False))
##    print(DpIfGen2APIBasicDp25.memory_read("C349", "hex", True, False))
##    DpIfGen2APIBasicDp25.crc_verify("C348", "0002", "2737", True)
##    DpIfGen2APIBasicDp25.memory_block_check_blank("c34D","0002", True)
##    DpIfGen2APIBasicDp25.jump_execute("8000", True)
##    DpIfGen2APIBasicDp25.call_execute("8000", True)
##    print(DpIfGen2APIBasicDp25.memory_block_read("9C00", "1000", "hex", True, False))
##    print(DpIfGen2APIBasicDp25.memory_read("C347", "hex", True, False))

if __name__ == "__main__":
    main()

# --- End of File ------------------------------------------------
