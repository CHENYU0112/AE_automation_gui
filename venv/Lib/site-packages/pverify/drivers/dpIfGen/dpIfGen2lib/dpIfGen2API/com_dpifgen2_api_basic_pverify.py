#!/usr/bin/python
# ===========================================================================
# Name:        com_dpifgen2_api_basic_pverify.py
#
# Purpose:     Basic API for dpIFGen2 communication adapted for pVerify
#
# Author:      Aslam Faizan Muhammad (IFAG PMM SYS SWT SWI)
#                                       <Faizan.Aslam@infineon.com>
#
# Adapted for pVerify: Johannes Loibl
#
# Created:     28.10.2014
#
# Python Version: v2.7.9
#
# Dependency: lib_dpifgen2_commands_list, com_dpifgen2_api_executer_basic
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#

""" This Documentation describes the .dp Interface Gen 2(dpIfGen2) board's
    basic API to communicate with the dp2a/dp2b b11 chip. The API is meant to serve as an
    abstraction layer between the PC and the dp2a/dp2b b11 chip hiding the unnecessary
    details in the low level communication between the Interface
    board and the chip itself. The API is derived from the com_dpifgen2_api_basic but
    adapted for pVerify project to satisfy the real time constraints.
    The API has been partitioned into the following
    major command categories::

        1. Connection Commands
        2. Read Commands
        3. Write Commands
        4. Burn Commands
        5. Check Commands
        6. Other Commands
"""
from __future__ import annotations

import re

from dpIfGen2lib.dpIfGen2API.com_dpifgen2_api_executer_basic import DpIfGen2APIExecuterBasic
from dpIfGen2lib.dpIfGen2API.lib_dpifgen2_commands_list import DpIfGen2Commands


class DpIfGen2APIBasicpVerify:
    """The Detailed API is as follows:

    Connection Commands:
        1. :func:`connection_establish`
        2. :func:`baudrate_set`
        3. :func:`sync_set`
        4. :func:`interface_fw_id_read`
        5. :func:`voltage_level_set`
        6. :func:`voltage_cycle_execute`
        7. :func:`auto_chip_id_set`
        8. :func:`chip_id_set`
        9. :func:`chip_identify`

    Read Commands:
        1. :func:`memory_read`
        2. :func:`memory_block_read`

    Write Commands:
        1. :func:`memory_write`
        2. :func:`memory_block_write`
        3. :func:`ahex_file_write`
        4. :func:`password_write`

    Burn Commands:
        1. :func:`memory_burn`
        2. :func:`memory_block_burn`
        3. :func:`ahex_file_burn`

    Check Commands:
        1. :func:`crc_verify`
        2. :func:`memory_block_check_blank`

    Other Commands:
        1. :func:`jump_execute`
        2. :func:`call_execute`
        3. :func:`crc_calculate`
        4. :func:`info_get`

    """

    #: dpIfGen2 pVerify API Version v1.1.11
    VERSION = "1.1.11"

    MIN_DPIFGEN2_FW_VERSION = "1.8.0"
    MAX_DPIFGEN2_FW_VERSION = "2.0.0"

    def __init__(self, debug=False, verbose=False):
        self.executer = None
        """:type : DpIfGen2APIExecuterBasic"""
        self.args = {"debug": debug, "verbose": verbose}

    @staticmethod
    def list_of_functions():
        return [
            "connection_establish()",
            "baudrate_set()",
            "sync_set()",
            "interface_fw_id_read()",
            "voltage_level_set()",
            "voltage_cycle_execute()",
            "auto_chip_id_set()",
            "chip_id_set()",
            "chip_identify()",
            "memory_read()",
            "memory_block_read()",
            "memory_write()",
            "memory_block_write()",
            "ahex_file_write()",
            "password_write()",
            "memory_burn()",
            "memory_block_burn()",
            "ahex_file_burn()",
            "crc_verify()",
            "memory_block_check_blank()",
            "jump_execute()",
            "call_execute()",
            "info_get()",
            "crc_calculate()",
        ]

    @staticmethod
    def dict_of_api_functions():
        return {
            "C1_1:Establish Connection": {
                "Name": "Establish Connection",
                "Usage": "dp.connection_establish(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.connection_establish.__doc__,
                "Class": "Connection",
            },
            "C1_2:Set Baudrate": {
                "Name": "Set Baudrate",
                "Usage": 'dp.baudrate_set("57600", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.baudrate_set.__doc__,
                "Class": "Connection",
            },
            "C1_3:Set Sync": {
                "Name": "Set Sync",
                "Usage": "dp.sync_set(3, verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.sync_set.__doc__,
                "Class": "Connection",
            },
            "C1_4:Read FW ID": {
                "Name": "Read FW ID",
                "Usage": "fw_id = dp.interface_fw_id_read(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.interface_fw_id_read.__doc__,
                "Class": "Connection",
            },
            "C1_5:Set Voltage Level": {
                "Name": "Set Voltage Level",
                "Usage": "dp.voltage_level_set(24.5 ,verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.voltage_level_set.__doc__,
                "Class": "Connection",
            },
            "C1_6:Voltage Cycle": {
                "Name": "Voltage Cycle",
                "Usage": "dp.voltage_cycle_execute(24, 7.5 ,verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.voltage_cycle_execute.__doc__,
                "Class": "Connection",
            },
            "C1_7:Select Chip ID": {
                "Name": "Select Chip ID",
                "Usage": 'dp.chip_id_set("dp2b", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.chip_id_set.__doc__,
                "Class": "Connection",
            },
            "C1_8:Set Auto Chip ID": {
                "Name": "Set Auto Chip ID",
                "Usage": "dp.auto_chip_id_set(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.auto_chip_id_set.__doc__,
                "Class": "Connection",
            },
            "C1_9:Identify Chip": {
                "Name": "Identify Chip",
                "Usage": "dp.chip_identify(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.chip_identify.__doc__,
                "Class": "Connection",
            },
            "C2_1:Read Memory": {
                "Name": "Read Memory",
                "Usage": 'output_word = dp.memory_read("8080", "dec", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.memory_read.__doc__,
                "Class": "Read",
            },
            "C2_2:Read Memory Block": {
                "Name": "Read Memory Block",
                "Usage": 'output_data = dp.memory_block_read("8080", "0010", "hex", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.memory_block_read.__doc__,
                "Class": "Read",
            },
            "C3_1:Write Memory": {
                "Name": "Write Memory",
                "Usage": 'dp.memory_write("8000", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.memory_write.__doc__,
                "Class": "Write",
            },
            "C3_2:Write Memory Block": {
                "Name": "Write Memory Block",
                "Usage": 'dp.memory_block_write("8080", ["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.memory_block_write.__doc__,
                "Class": "Write",
            },
            "C3_3:Write Ahex File": {
                "Name": "Write Ahex File",
                "Usage": 'dp.ahex_file_write(r"filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.ahex_file_write.__doc__,
                "Class": "Write",
            },
            "C3_4:Write Password": {
                "Name": "Write Password",
                "Usage": 'dp.password_write("DEEDBEAF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.password_write.__doc__,
                "Class": "Write",
            },
            "C4_1:Burn Memory": {
                "Name": "Burn Memory",
                "Usage": 'dp.memory_burn("8000", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.memory_burn.__doc__,
                "Class": "Burn",
            },
            "C4_2:Burn Memory Block": {
                "Name": "Burn Memory Block",
                "Usage": 'dp.memory_block_burn("8080", ["0010", "0089", "0123"], verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.memory_block_burn.__doc__,
                "Class": "Burn",
            },
            "C4_3:Burn Ahex File": {
                "Name": "Burn Ahex File",
                "Usage": 'dp.ahex_file_burn(r"filename.ahex", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.ahex_file_burn.__doc__,
                "Class": "Burn",
            },
            "C5_1:Verify CRC": {
                "Name": "Verify CRC",
                "Usage": 'verified = dp.crc_verify("8000", "0010", "BEEF", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.crc_verify.__doc__,
                "Class": "Check",
            },
            "C5_2:Blank Check": {
                "Name": "Blank Check",
                "Usage": 'memory_blank = dp.memory_block_check_blank("8080", "0010", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.memory_block_check_blank.__doc__,
                "Class": "Check",
            },
            "C6_1:Execute Jump": {
                "Name": "Execute Jump",
                "Usage": 'dp.jump_execute("8000", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.jump_execute.__doc__,
                "Class": "Others",
            },
            "C6_2:Execute Call": {
                "Name": "Execute Call",
                "Usage": 'dp.call_execute("8000", verbose=True, debug=False)',
                "Description": DpIfGen2APIBasicpVerify.call_execute.__doc__,
                "Class": "Others",
            },
            "C6_3:Calculate CRC": {
                "Name": "Calculate CRC",
                "Usage": 'crc = dp.crc_calculate("8080", "0010", "hex", ' "verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.crc_calculate.__doc__,
                "Class": "Others",
            },
            "C6_4:Get Information": {
                "Name": "Get Information",
                "Usage": "info = dp.info_get(verbose=True, debug=False)",
                "Description": DpIfGen2APIBasicpVerify.info_get.__doc__,
                "Class": "Others",
            },
        }

    def open(self):
        self.executer = DpIfGen2APIExecuterBasic()
        self.executer._verbose = self.args["verbose"]
        self.executer._debug = self.args["debug"]
        self.executer.open_check_hid_device()
        self.executer.set_receive_handle()

    def is_opened(self):
        # todo add functionality
        return self.executer._device.is_opened()

    def check_reopen(self):
        if self.executer is None or not self.executer._device.is_opened():
            self.open()

    def close(self):
        self.executer.close_hid_device()

    def connection_establish(self, verbose=False, debug=False, parent=None):
        """Establishes connection with the dp2a/dp2b b11 chip.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.


        Connection Establish is a combinational command that performs the
        following operations::

            1. Set Baudrate: Default Value (57600)
            2. Set Voltage Cycle: Default Value (Voltage 1: 24V; Voltage 2: 7.5V)
            3. Set Sync: Default Value (3 Sync tries)
            4. Set AutoChip ID: Requires the chip to be unlocked

        .. note::

           This module will be the only command you need to start communication
           with the chip if you do not have any special requirements.

        Example Usage:

        >>> dp.connection_establish()
        >>> dp.connection_establish(verbose=True)

        """
        self.check_reopen()

        self.baudrate_set("57600", verbose, debug)
        self.voltage_cycle_execute(24, 7.5, verbose, debug)
        self.sync_set(3, verbose, debug)
        self.auto_chip_id_set(verbose, debug)

    def baudrate_set(self, baudrate, verbose=False, debug=False, parent=None):
        """Sets the communication baudrate.

        :param baudrate: The selected baudrate for communication with dp2a/dp2b b11 chip
        :type baudrate: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.

        .. note::

           57600 is the standard baudrate for communication with the chip.
           Other supported baudrates include::

            * 9600
            * 19200
            * 38400
            * 57600
            * 82000
            * 105000

        .. warning::

            A synchronization command is necessary after selecting the baudrate.

        Example Usage:

        >>> dp.baudrate_set("57600")
        >>> dp.baudrate_set("57600", verbose=True)

        """
        # allowed baudrates
        allowed_baudrates = {
            "9600": "0000",
            "19200": "0100",
            "38400": "0200",
            "57600": "0300",
            "82000": "0400",
            "105000": "0500",
        }
        if baudrate in allowed_baudrates:
            baudrate_value = allowed_baudrates.get(baudrate)
            exec_seq = {}
            exec_seq["Name"] = "Set Baudrate"
            exec_seq[0] = {
                "Step": "Set Baudrate",
                "Command": DpIfGen2Commands.CONFIGURE_UART_COMMAND,
                "Parameters": "".join(["0100", baudrate_value]),
                "Response": DpIfGen2Commands.ACK,
                "Timeout": 1,
            }
            self.exec_config_seq(exec_seq, verbose, debug, parent)

        else:
            raise Exception(
                "".join(
                    [
                        "The selected baudrate is not ",
                        "supported. ",
                        "Please enter a baudrate from the ",
                        "following values: ",
                        str(allowed_baudrates.keys()),
                    ]
                )
            )

    def sync_set(self, num_tries=3, verbose=False, debug=False, parent=None):
        """Synchronizes the baudrate with the dp2a/dp2b b11 chip.

        :param num_tries: Number of tries to perform the synchronization
        :type num_tries: int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns:  none.

        This command is used to establish a common communication baudrate with
        the dp2a/dp2b b11 chip. Number of synchronization attempts can be configured.
        Default value is 3. Maximum value is 100.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.

        Example Usage:

        >>> dp.sync_set(3)
        >>> dp.sync_set(3, verbose=True)
        """
        num_tries = f"{num_tries:04X}"
        num_tries_endian = self.convert_endian(num_tries)
        parameter = num_tries_endian

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Synchronize"
        exec_seq[0] = {
            "Step": "Set Sync",
            "Command": DpIfGen2Commands.SYNC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def interface_fw_id_read(self, verbose=False, debug=False, parent=None):
        """Reads the FW ID of the dpIFGen2 board.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: fw_id: Interface FW version ID.
        :type fw_id: str

        This command is used to read back the interface FW id.

        Example Usage:

        >>> fw_id = dp.interface_fw_id_read()
        >>> fw_id = dp.interface_fw_id_read(verbose=True)
        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read FW ID"
        exec_seq[0] = {
            "Step": "Read FW ID",
            "CommandData": DpIfGen2Commands.READ_DPIFGEN2_FW_ID_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        return self.exec_config_seq(exec_seq, verbose, debug, parent)

    def voltage_level_set(self, v_level, verbose=False, debug=False, parent=None):
        """Sets the voltage level of interface board to a constant level.

        :param v_level: Constant voltage level for the dpIFGen2 Board.
        :type v_level: float
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to supply a constant voltage level to the dpIFGen2
        interface board. Setting the voltage level to zero can be regarded as
        a special case of clearing the voltage.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.

        Example Usage:

        >>> dp.voltage_level_set(24.5)
        >>> dp.voltage_level_set(24.5 ,verbose=True)
        """
        voltage = f"{v_level:.1f}"
        voltage_dec = int(float(voltage) * 10)
        voltage_hex = f"{voltage_dec:04X}"
        voltage_endian = self.convert_endian(voltage_hex)
        parameter = voltage_endian

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Set Voltage Level"
        exec_seq[0] = {
            "Step": "Set Voltage Level",
            "Command": DpIfGen2Commands.SET_CUSTOM_VOLTAGE_LEVEL_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def voltage_cycle_execute(self, v_level1, v_level2, verbose=False, debug=False, parent=None):
        """Executes a voltage cycle consisting of a peak voltage and a constant
        voltage level. Peak voltage level is provided by v_level1 and the
        constant voltage level is provided by v_level2.

        :param v_level1: Peak voltage level for the voltage cycle.
        :type v_level1: float
        :param v_level2: Constant voltage level for the voltage cycle.
        :type v_level2: float
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to supply a constant voltage level to the dpIFGen2
        interface board. Setting the voltage level to zero can be regarded as
        a special case of clearing the voltage.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.

        Example Usage:

        >>> dp.voltage_cycle_execute(24, 7.5)
        >>> dp.voltage_cycle_execute(24, 7.5 ,verbose=True)
        """
        voltage1 = f"{v_level1:.1f}"
        voltage1_dec = int(float(voltage1) * 10)
        voltage1_hex = f"{voltage1_dec:04X}"
        voltage1_endian = self.convert_endian(voltage1_hex)

        voltage2 = f"{v_level2:.1f}"
        voltage2_dec = int(float(voltage2) * 10)
        voltage2_hex = f"{voltage2_dec:04X}"
        voltage2_endian = self.convert_endian(voltage2_hex)

        parameter = "".join([voltage1_endian, voltage2_endian])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Execute Voltage Cycle"
        exec_seq[0] = {
            "Step": "Execute Voltage Cycle",
            "Command": DpIfGen2Commands.EXECUTE_CUSTOM_VOLTAGE_CYCLE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def auto_chip_id_set(self, verbose=False, debug=False, parent=None):
        """Automatically configures the dpIFGen2 board to identify the correct
        chip ID.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to automatically configure the chip ID for the
        communication protocol. This step is necessary to be performed since
        the communication protocol is different for the platforms dp2a and dp2b.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.

        .. warning:: This only works on the unlocked devices.

        Example Usage:

        >>> dp.auto_chip_id_set()
        >>> dp.auto_chip_id_set(verbose=True)
        """
        parameter = ""
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Auto Chip Select"
        exec_seq[0] = {
            "Step": "Auto Chip Select",
            "Command": DpIfGen2Commands.AUTO_CHIP_SET_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def chip_id_set(self, chip_id, verbose=False, debug=False, parent=None):
        """Configures the dpIFGen2 board to assume the interaction is performed
        with the given chip_id.

        :param chip_id: Chip Id representing the platform dp2a or dp2b
        :type chip_id: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to manually configure the chip ID for the
        communication protocol. A use case might be to interact with the
        locked devices.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            or :func:`auto_chip_id_set` command for establishing communication
            with the chip.

        Example Usage:

        >>> dp.chip_id_set("dp2b")
        >>> dp.chip_id_set("dp2b", verbose=True)
        """

        chip_id = chip_id.lower()
        valid_id = ["dp2a", "dp2b"]
        if chip_id not in valid_id:
            raise Exception(
                "".join(
                    [
                        "ID is not valid. ",
                        "Please specify a valid ID ",
                        "from the following: ",
                        str(valid_id),
                    ]
                )
            )

        parameter = ""
        if chip_id == "dp2a":
            parameter = "0100"
        elif chip_id == "dp2b":
            parameter = "0200"
        else:
            msg = "Sanity check: This code should not be reached."
            raise Exception(msg)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Set Chip ID"
        exec_seq[0] = {
            "Step": "Set Chip ID",
            "Command": DpIfGen2Commands.SET_CHIP_ID_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def chip_identify(self, verbose=False, debug=False, parent=None):
        """Identifies the chip type.

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: chip_id: Interface FW version ID.
        :type chip_id: str

        This command is used to identify the chip type.

        .. warning::

            This command requires the function :func:`connection_establish` to be called first.

        Example Usage:

        >>> chip_id = dp.chip_identify()
        >>> chip_id = dp.chip_identify(verbose=True)
        """
        # define the sequence
        # dp.connection_establish(verbose, debug, parent)
        exec_seq = {}
        exec_seq["Name"] = "Read Chip ID"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.CHIP_IDENTIFY_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        status = self.exec_config_seq(exec_seq, verbose, debug, parent)
        chip_id = None
        if status:
            if status & 0x0002:
                chip_id = "dp25"
            elif status & 0x0001:
                if status & 0x0008:
                    chip_id = "dp2a"
                elif status & 0x0020:
                    chip_id = "dp2b"
                else:
                    chip_id = "dp2"
            else:
                raise Exception(
                    "".join(
                        [
                            "Chip type could not be identified. Please verify that you have an "
                            "unlocked and known chip."
                        ]
                    )
                )
        else:
            # status word is empty => No valid chip type found
            raise Exception(
                "".join(["Chip type could not be identified. Please verify that you have an unlocked and known chip."])
            )
        return chip_id

    ##########################################################################
    ########################### Read Commands ################################
    ##########################################################################
    def memory_read(self, address, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param out_format: The format of the word read from the memory location
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to read one word from the specified memory address.

        .. note::

            The read word is returned in hexdecimal format by default.
            Supported return formats are:

                * **dec**: Decimal format
                * **hex**: Hexadecimal format

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> output_word = dp.memory_read("8080")
        >>> output_word = dp.memory_read("8080", "dec", verbose=True)
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = self.convert_endian(address)
        valid_fmt = ["hex", "dec"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read Word"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.READ_VALUES_COMMAND,
            "Parameters": "".join([address_endian, "0100"]),
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        word = self.exec_config_seq(exec_seq, verbose, debug, parent)
        if out_format == "dec":
            return word
        elif out_format == "hex":
            return f"{word:04X}"
        return None

    def memory_block_read(self, address, length, out_format="hex", verbose=False, debug=False, parent=None):
        """Reads a memory block.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param out_format: The format of the read data from the memory block
        :type out_format: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to reads the memory block from the chip starting
        at the specified address. Length specifies the number of words to be
        read.

        .. note::

           The read word is returned in hexdecimal format by default.
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format
              * **dict**: Python Dictionary

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        >>> output_data = dp.memory_block_read("8080", "0010")
        >>> output_data = dp.memory_block_read("8080", "0010", "hex", verbose=True)
        """

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        valid_fmt = ["hex", "dec", "dict"]
        if out_format not in valid_fmt:
            raise Exception(
                "".join(
                    [
                        "Format is not valid. ",
                        "Please specify a valid format ",
                        "from the following: ",
                        str(valid_fmt),
                    ]
                )
            )

        address_dec = int(address, 16)
        length_dec = int(length, 16)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Read Memory Block"
        exec_seq[0] = {
            "Step": "Read Memory Block",
            "Process": True,
            "Address": address_dec,
            "Length": length_dec,
            "ProcessCommand": DpIfGen2Commands.READ_VALUES_COMMAND,
            "Parameters": "",
            "Response": "ACK",
            "Timeout": 2,
        }

        mem_block = self.exec_config_seq(exec_seq, verbose, debug, parent)

        if out_format == "dec":
            return [int(mem_block[item], 16) for item in sorted(mem_block.keys())]
        elif out_format == "hex":
            return [mem_block[item] for item in sorted(mem_block.keys())]
        elif out_format == "dict":
            return mem_block
        return None

    ##########################################################################
    ########################### Write Commands ###############################
    ##########################################################################
    def memory_write(self, address, value, verbose=False, debug=False, parent=None):
        """Write a word value to the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write one word to the specified memory location.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> dp.memory_write("8000", "BEEF")
        >>> dp.memory_write("8000", "BEEF", verbose=True)

        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)
        value_chk = re.match(r"([0-9a-fA-F]{4})", value)
        if not value_chk:
            msg = "Value is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_endian = self.convert_endian(address)
        value_endian = self.convert_endian(value)

        parameter = "".join([address_endian, value_endian])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Memory"
        exec_seq[0] = {
            "Step": "Write Memory",
            "Command": DpIfGen2Commands.WRITE_ONE_VALUE_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def memory_block_write(self, address, data, verbose=False, debug=False, parent=None):
        """Writes a data block to memory.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param data: data block to be written to memory
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write a data block in the memory block starting
        at the specified address. This function also checks for CRC to verify
        the successful block write.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        >>> dp.memory_block_write("8080", ["0010", "0089", "0123"])
        >>> dp.memory_block_write("8080", ["0010", "0089", "0123"], verbose=True)
        """
        # validate address is in correct format
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if not data:
            msg = "Data must be provided as a list of Hexadecimal digits or decimal."
            raise Exception(msg)
        # validate data is in correct format
        for index, value in enumerate(data):
            if isinstance(value, int):
                data[index] = f"{value:04X}"
            else:
                value_chk = re.match(r"([0-9a-fA-F]{4})", value)
                if not value_chk:
                    raise Exception(
                        'Value "%s" is not in correct format. '
                        "Please enter a decimal value or a "
                        "4 Hexadecimal digit Value in the"
                        "format ([0-9a-fA-F]{4})"
                        'example: 15 or "000F' % value
                    )

        address_dec = int(address, 16)
        address_hex = f"{address_dec:06X}"

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Memory Block"
        exec_seq[0] = {
            "Step": "Data Block Prepare",
            "Process": True,
            "Address": address_hex,
            "Data": data,
        }
        exec_seq[1] = {
            "Step": "Select Buffer16K",
            "Command": DpIfGen2Commands.BUF16K_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Auto Select Chip",
            "Command": DpIfGen2Commands.AUTO_CHIP_SET_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[4] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[5] = {
            "Step": "Write RAM Command",
            "Command": DpIfGen2Commands.WRITE_RAM_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def ahex_file_write(self, filename, verbose=False, debug=False, parent=None):
        """Writes an ahex file to a memory block.

        :param filename: Memory values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write a memory block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function writes the values starting from the start address to the
            end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                008000:BEEF
                008001:BAAF
                008004:DEED

            In this case addresses 0x8002, 0x8003 are written with 0x0000

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> dp.ahex_file_write(r"filename.ahex")
        >>> dp.ahex_file_write(r"filename.ahex", verbose=True)

        """
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Ahex File"
        exec_seq[0] = {
            "Step": "Data extraction from ahex file",
            "Process": True,
            "Filename": filename,
        }
        exec_seq[1] = {
            "Step": "Select Buffer16K",
            "Command": DpIfGen2Commands.BUF16K_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Auto Select Chip",
            "Command": DpIfGen2Commands.AUTO_CHIP_SET_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[4] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[5] = {
            "Step": "Write RAM Command",
            "Command": DpIfGen2Commands.WRITE_RAM_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def password_write(self, password, verbose=False, debug=False, parent=None):
        """Write a password to unlock the chip.

        :param password: 8 hexadecimal digit password
        :type password: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to write the 32 bit password (2 words) to unlock
        the chip.

        Example Usage:

        >>> dp.password_write("DEEDBEAF")
        >>> dp.password_write("DEEDBEAF", verbose=True)
        """
        password_chk = re.match(r"([0-9a-fA-F]{8})", password)
        if not password_chk:
            msg = "Password is not in correct format. Please enter a 8 Hexadecimal digit password"
            raise Exception(msg)

        password_high = password[0:4]
        password_low = password[4:8]

        parameter1 = self.convert_endian(password_high)
        parameter2 = self.convert_endian(password_low)
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Write Password"
        exec_seq[0] = {
            "Step": "Write Password Register 1",
            "Command": DpIfGen2Commands.WRITE_PASSWORD_REG1,
            "Parameters": parameter1,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[1] = {
            "Step": "Write Password Register 2",
            "Command": DpIfGen2Commands.WRITE_PASSWORD_REG2,
            "Parameters": parameter2,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    ##########################################################################
    ########################### Burn Commands ################################
    ##########################################################################

    def memory_burn(self, address, value, verbose=False, debug=False, parent=None):
        """Burn a word value to the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param value: 4 hexadecimal digit value
        :type value: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn one word to the specified memory location.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> dp.memory_burn("8000", "BEEF")
        >>> dp.memory_burn("8000", "BEEF", verbose=True)
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)
        value_chk = re.match(r"([0-9a-fA-F]{4})", value)
        if not value_chk:
            msg = "Value is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_dec = int(address, 16)
        address_hex = f"{address_dec:06X}"

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn Memory"
        exec_seq[0] = {
            "Step": "Burn Single Memory Prepare",
            "Process": True,
            "Address": address_hex,
            "Value": value,
        }
        exec_seq[1] = {
            "Step": "Select Buffer16K",
            "Command": DpIfGen2Commands.BUF16K_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[2] = {
            "Step": "Auto Select Chip",
            "Command": DpIfGen2Commands.AUTO_CHIP_SET_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[3] = {
            "Step": "Write Buffer Command",
            "Command": DpIfGen2Commands.WRITE_PIC_BUFFER_COMMAND,
            "Parameters": "",
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        exec_seq[4] = {"Step": "Sending Data in 64 byte chunks", "Process": True}
        exec_seq[5] = {
            "Step": "Write RAM Command",
            "Command": DpIfGen2Commands.WRITE_RAM_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 5,
        }
        exec_seq[6] = {
            "Step": "Write OTP Command",
            "Command": DpIfGen2Commands.WRITE_OTP_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 5,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def memory_block_burn(self, address, data, verbose=False, debug=False, parent=None):
        """Burns a data block to memory.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param data: data block to be written to memory
        :type data: list(str), list(int)
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a data block in the memory block starting
        at the specified address. This function also checks for CRC to verify
        the successful block burn.

        .. note::

           Data must be a Python list. The elements in the list must have of the following
           supported format:
           Supported return formats are:

              * **dec**: Decimal format
              * **hex**: Hexadecimal format

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        memory_block_burn("8080", ["0010", "0089", "0123"])
        memory_block_burn("8080", ["0010", "0089", "0123"], verbose=True)
        """
        self.memory_block_write(address, data, verbose, debug, parent)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn Memory Block"
        exec_seq[0] = {
            "Step": "Write OTP Command",
            "Command": DpIfGen2Commands.WRITE_OTP_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def ahex_file_burn(self, filename, verbose=False, debug=False, parent=None):
        """Burns an ahex file to a memory block.

        :param filename: Memory values in an ahex file
        :type filename: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to burn a memory block from an ahex file.
        This function also checks for CRC to verify the successful block write.

        .. note::

            The function burns the values starting from the start address to
            the end address with the values specified in the ahex file.

            .. warning:: Unspecified values in the range are written to 0.

            The file must have the following format:

            ([0-9a-fA-F]{6}:[0-9a-fA-F]{4})

            example::

                00C000:BEEF
                00C001:BAAF
                00C004:DEED

            In this case addresses 0xC002, 0xC003 are written with 0x0000

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> dp.ahex_file_burn(r"filename.ahex")
        >>> dp.ahex_file_burn(r"filename.ahex", verbose=True)
        """

        self.ahex_file_write(filename, verbose, debug, parent)

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Burn Memory Block"
        exec_seq[0] = {
            "Step": "Write OTP Command",
            "Command": DpIfGen2Commands.WRITE_OTP_COMMAND,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 20,
        }

        self.exec_config_seq(exec_seq, verbose, debug, parent)

    ##########################################################################
    ########################### Check Commands ###############################
    ##########################################################################

    def crc_verify(self, address, length, crc, verbose=False, debug=False, parent=None):
        """Verifies the CRC value calculated for a memory block.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param crc: 4 hexadecimal digit reference CRC to verify
        :type crc: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: bool

        This command is used to verify the CRC calculated over a specified
        memory location. The start address and length of the memory block is
        provided with the command.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> verified = crc_verify("8000", "0010", "BEEF")
        >>> verified = crc_verify("8000", "0010", "BEEF", verbose=True)
        """

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)
        crc_chk = re.match(r"([0-9a-fA-F]{4})", crc)
        if not crc_chk:
            msg = "CRC is not in correct format. Please enter a 4 Hexadecimal digit Value"
            raise Exception(msg)

        address_endian = self.convert_endian(address)
        length_endian = self.convert_endian(length)
        crc_endian = self.convert_endian(crc)

        parameter = "".join([address_endian, length_endian, crc_endian, "0000"])

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Compare CRC"
        exec_seq[0] = {
            "Step": "Compare CRC",
            "Command": DpIfGen2Commands.VERIFY_CRC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        try:
            self.exec_config_seq(exec_seq, verbose, debug, parent)
            return True
        except Exception as e:
            if "NAK3100" in str(e):
                return False
            else:
                raise Exception(str(e))

    def memory_block_check_blank(self, address, length, verbose=False, debug=False, parent=None):
        """Verifies if the memory block is blank.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: bool

        This command is used to verify the memory block is blank (filled with
        zeros).

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> memory_blank = dp.memory_block_check_blank("8080", "0010")
        >>> memory_blank = dp.memory_block_check_blank("8080", "0010", verbose=True)
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        address_endian = self.convert_endian(address)
        length_endian = self.convert_endian(length)

        parameter = "".join([address_endian, length_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Blank Check Memory"
        exec_seq[0] = {
            "Step": "Blank Check",
            "Command": DpIfGen2Commands.BLANK_CHECK,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        try:
            self.exec_config_seq(exec_seq, verbose, debug, parent)
            return True
        except Exception as e:
            if "NAK3F00" in str(e):
                return False
            else:
                raise Exception(str(e))

    ##########################################################################
    ########################### Other Commands ###############################
    ##########################################################################
    def jump_execute(self, address, verbose=False, debug=False, parent=None):
        """Executes a jump at the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to execute a jump at the specified memory location.

        .. warning::

            This command only works with unlocked chips.

        .. warning::

            This command requires knowledge of the Firmware programmed on the
            chip. A resynchronization might be necessary with the chip after
            performing the jump command.

        Example Usage:

        >>> dp.jump_execute("8000")
        >>> dp.jump_execute("8000", verbose=True)
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = self.convert_endian(address)

        parameter = "".join([address_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Execute Jump"
        exec_seq[0] = {
            "Step": "Jump",
            "Command": DpIfGen2Commands.JUMP_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def call_execute(self, address, verbose=False, debug=False, parent=None):
        """Calls a routine at the specified memory location.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: none

        This command is used to execute a call at the specified memory location.

        .. warning::

            This command only works with unlocked chips.

        .. warning::

            This command requires knowledge of the Firmware programmed on the
            chip. A resynchronization might be necessary with the chip after
            performing the call command.

        Example Usage:

        >>> dp.call_execute("8000")
        >>> dp.call_execute("8000", verbose=True)
        """
        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        address_endian = self.convert_endian(address)

        parameter = "".join([address_endian]).upper()
        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Execute Call"
        exec_seq[0] = {
            "Step": "Call",
            "Command": DpIfGen2Commands.CALL_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 1,
        }
        self.exec_config_seq(exec_seq, verbose, debug, parent)

    def info_get(self, verbose=False, debug=False, parent=None):
        """gets information about the chip

        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: available information as a Python dictionary

        This command is used to read back the ROM version from
        the chip.

        .. warning::

            This command only works with unlocked chips.

        Example Usage:

        >>> info = dp.if_info_get()
        >>> info = dp.if_info_get(verbose=True)
        """
        # reads the memory location 0x0001 of the chip to determine the
        # chip type
        info = {}
        exec_seq = {}
        exec_seq["Name"] = "Get Info"
        if verbose:
            msg = "".join(["Executing Sequence ", exec_seq.get("Name")])
            self.display_msg(msg)
        ROM_VERSION_DICT = {
            0xB01: "DP2B A11",
            0xB02: "DP2B B11",
            0x101: "DP2A-A11",
            0x102: "DP2A-B11",
            0x103: "DP2A-B12",
        }

        ROM_VERSION_LOC = "0001"
        ROM_VERSION_LEN = 1
        rom_version = self.memory_block_read(ROM_VERSION_LOC, ROM_VERSION_LEN, "dict", debug, False)
        info["ROM_VERSION_IDENTIFIED"] = {}
        info["ROM_VERSION_IDENTIFIED"]["Value"] = rom_version
        rom_version_dec = [int(val_hex, 16) for val_hex in rom_version.values()]
        if rom_version_dec[0] in ROM_VERSION_DICT:
            info["ROM_VERSION_IDENTIFIED"]["Status"] = True
        else:
            info["ROM_VERSION_IDENTIFIED"]["Status"] = False
            if debug:
                self.display_msg(
                    "".join(
                        [
                            "This chip has an unknown ROM version!! \n",
                            "Make sure you have the correct ",
                            "chip in place.",
                        ]
                    )
                )
        if verbose:
            self.display_msg(
                "".join(
                    [
                        "ROM_VERSION_IDENTIFIED: ",
                        str(info["ROM_VERSION_IDENTIFIED"]["Status"]),
                    ]
                )
            )

        if debug:
            for key in sorted(rom_version.keys()):
                self.display_msg("".join([key, ":", rom_version[key]]))

        if verbose:
            msg = "".join(
                [
                    exec_seq.get("Name"),
                    " successfully executed ",
                ]
            )
            self.display_msg(msg)
        return info

    def crc_calculate(self, address, length, verbose=False, debug=False, parent=None):
        """Calculates the CRC of a data block of given length starting from the start address.

        :param address: 4 hexadecimal digit memory address
        :type address: str
        :param length: 4 hexadecimal digit memory block length/ memory block length in int
        :type length: str, int
        :param verbose: Prints execution information.
        :type verbose: bool
        :param debug: Prints additional debug information.
        :type debug: bool
        :param parent: Reference to the calling object.
        :type parent: object reference
        :returns: word

        This command is used to calculate the CRC from the chip starting
        at the specified address. Length specifies the number of words to be
        read.

        .. note::

           The read word is returned in hexdecimal format.

        .. warning::

           This command only works with unlocked chips.

        Example Usage:

        >>> crc = dp.crc_calculate("8080", "0010")
        >>> crc = dp.crc_calculate("8080", "0010", "hex", verbose=True)
        """

        address_chk = re.match(r"([0-9a-fA-F]{4})", address)
        if not address_chk:
            msg = "Address is not in correct format. Please enter a 4 Hexadecimal digit Address"
            raise Exception(msg)

        if isinstance(length, int):
            length = f"{length:04X}"
        else:
            length_chk = re.match(r"([0-9a-fA-F]{4})", length)
            if not length_chk:
                msg = 'Length is not in correct format. Please enter a decimal value or a 4 Hexadecimal digit Value in theformat ([0-9a-fA-F]{4})example: 15 or "000F'
                raise Exception(msg)

        address_endian = self.convert_endian(address)
        length_endian = self.convert_endian(length)

        parameter = "".join([address_endian, length_endian]).upper()

        # define the sequence
        exec_seq = {}
        exec_seq["Name"] = "Calculate CRC"
        exec_seq[0] = {
            "Step": "Read Single Word",
            "CommandData": DpIfGen2Commands.CALCULATE_CRC_COMMAND,
            "Parameters": parameter,
            "Response": DpIfGen2Commands.ACK,
            "Timeout": 2,
        }

        crc = self.exec_config_seq(exec_seq, verbose, debug, parent)

        return f"{crc:04X}"

    #########################################################################
    ############    Helper Functions ########################################
    #########################################################################
    def convert_endian(self, endian_prev):
        return "".join(format(b, "02X") for b in bytearray.fromhex(endian_prev)[::-1])

    def display_msg(self, msg, parent=None):
        if not parent:
            print("".join(["[I]: ", msg]))

    def exec_config_seq(self, exec_seq, verbose=False, debug=False, parent=None):
        try:
            if verbose:
                msg = "".join(["Executing Sequence ", exec_seq.get("Name")])
                self.display_msg(msg, parent)
            # initialize the executer class

            self.check_reopen()
            self.executer._execution_step = 0
            self.executer._filename = None
            self.executer._data_exchange = None

            # create/define the sequence
            self.executer.create_sequence(exec_seq)

            # execute the sequence
            self.executer.execute_sequence()
        except Exception as e:
            # decode error string
            decoded = self.decode_error_code(str(e))
            if decoded:
                raise Exception(decoded)
            else:
                raise Exception(str(e))
        # close the hid connections
        # check if the execution was successful
        if self.executer._success:
            if verbose:
                msg = "".join([exec_seq.get("Name"), " successfully executed"])
                self.display_msg(msg, parent)
            return self.executer._data_exchange
        return None

    def decode_error_code(self, error_str):
        error_decoded = None
        if "NAK" in error_str:
            error_string = error_str.split("NAK")
            error_code = error_string[1][0:4]
            # print("Error Code Received: ", error_code)

            result = re.search("[0-9a-fA-F]{4}", error_code)
            if result:
                code_string_low = result.group()[0:2]
                code_string_high = result.group()[2:4]
                if code_string_high == "00":
                    # These messages are coming from the dpIFGen2 board only.
                    if code_string_low in DpIfGen2Commands.NACK_LIST_DPIFGEN2_1_X:
                        dpifgen2_err = DpIfGen2Commands.NACK_LIST_DPIFGEN2_1_X.get(code_string_low)
                        err_name = dpifgen2_err.get("Name")
                        err_desc = dpifgen2_err.get("Description")
                        err_action = dpifgen2_err.get("Action")

                        error_decoded = "".join(
                            [
                                error_str,
                                "\n\n",
                                "Error Details: ",
                                "\n",
                                "ERROR NAME: ",
                                err_name,
                                "\n",
                                "ERROR DESCRIPTION: ",
                                err_desc,
                                "\n",
                                "ERROR ACTION: ",
                                err_action,
                            ]
                        )
                    else:
                        error_string = "Unknown Error Code. This indicates that the NAK list is not up to date."
                        error_decoded = "".join([error_str, "Error Details: ", "\n", error_string])
        return error_decoded


def main():
    test()


def test():
    from datetime import datetime as dt

    dp = DpIfGen2APIBasicpVerify()
    dp.connection_establish()
    for _i in range(10):
        t1 = dt.now()
        for _i in range(1000):
            dp.memory_read("8000")
        t2 = dt.now() - t1
        print(t2)
    dp.close()


if __name__ == "__main__":
    main()

# --- End of File ------------------------------------------------
