#!/usr/bin/python
# ===========================================================================
# Name:        com_dpifgen2_lld.py
#
# Purpose:     Low Level Driver for dpIfGen2 board
#
# Author:      Aslam Faizan Muhammad (IFAG PMM SYS SWT SWI)
#                                       <Faizan.Aslam@infineon.com>
#              Loibl Johannes (IFAG PMM ACDC D TFV FV / EE)
#                                       <Johannes.Loibl-EE@infineon.com>
#
# Created:     31.05.2015
#
# Python Version: v2.7.2
#
# Dependency: com_hid_communication, config_dpifgen2_api,
#             multiprocessing, datetime
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#

"""Low level drivers for dpIfGen2 board

This class implements the low level drivers for the dpIfGen2 board.
The class implements the two modes:

    1. Command => Responded with an ACK/NAK

        This mode allows the user to send a command in a buffer over HID and in turns
        waits for a response from the other side within a specified timeout.
        If a response is received, it is compared against the expected response.
        The operation is considered successful if the expected response was
        received with in the timeout otherwise it is regarded as a fail and
        an exception is raised.

        The script can be used from the command line using the same arguments
        as :mod:`com_hid_communication`

        .. warning::

            It is assumed that the response span only one data buffer. If the
            response span more than one buffer, it can not be regarded as a
            command but as a request.

    2. Request => Responded with an ACK/NAK followed by a single data buffer

        This mode allows the user to send a request in a buffer over HID and in turns
        waits for a response from the other side within a specified timeout.
        The response in this case comprise of an Acknowledgement and a data buffer.
        If a response is received, it is compared against the expected response.
        The operation is considered successful if the expected response(acknowledgement
        followed by the data buffer) was received with in the timeout otherwise it is
        regarded as a fail and an exception is raised.

        The script can be used from the command line using the same arguments
        as :mod:`com_hid_communication`

        .. warning::

            It is assumed that the response spans two data buffers.
            The first buffer contains the acknowledgement and the second buffer
            contains the requested data. If the requested data span more than
            one buffer, the data has to be requested in two separate commands.

"""
from __future__ import annotations

import os
from datetime import datetime
from multiprocessing import Queue
from multiprocessing.queues import Empty

if "TEST_ENV_DP_TOOLS_2016-04-15" in os.environ and os.environ["TEST_ENV_DP_TOOLS_2016-04-15"] == "true":
    from dpIfGen2lib.test.dp25.support.fake_com_hid_communication import HIDCommunication
else:
    from dpIfGen2lib.dpIfGen2API.com_hid_communication import HIDCommunication

from dpIfGen2lib.dpIfGen2API.misc import decode
from dpIfGen2lib.support.config_dpifgen2_api import PrintConfigAPI
from dpIfGen2lib.support.logger import logger


class DpIfGen2LLD(HIDCommunication):
    """
    Low Level Driver for dpIfGen2 board
    """

    #: dpIfGen2 LLD Version v1.0.7
    VERSION = "1.0.7"

    def __init__(self, parent=None):
        super().__init__()
        self._q = Queue()
        self._debug = False
        self._success = False
        self._error_msg = None
        # raw response data (1st buffer) of last command_query or request_query
        self._raw_data = None
        self._wire_dump = False
        wire_dump = PrintConfigAPI.instance().is_wire_dumping_enabled()
        if wire_dump:
            self._wire_dump = True

    def get_raw_data(self):
        # get raw response data (1st buffer) of last command_query or request_query
        return self._raw_data[1:]  # first byte is garbage (an additional zero-byte)

    def receive_handler(self, data_buffer):
        self.display_debug_msg("Received a new buffer")
        self._q.put({"data": data_buffer, "timestamp": datetime.now(), "somestuff": None})

    def command_query(self, cmd, resp, timeout):
        """
        Function returns true or false.
                True: expected response have been found in received data
        """
        self._success = False
        # Send Command
        if len(cmd):
            self.display_wire_msg("".join(["Sending Command: ", cmd.strip()]))
            self.send_string(cmd)
        # Wait for an entry in the queue. If there is a response from the device within
        # the specified timeout, the corresponding data buffer is saved in the queue.
        q_entry = None
        try:
            self.display_debug_msg("Waiting for the answer to be received")
            q_entry = self._q.get(True, timeout)
            self.display_debug_msg("".join(["Answer received", str(q_entry)]))
        except Empty as e:
            self.display_debug_msg("".join(["An exception is raised", str(e)]))
            self._error_msg = "API: Command Timeout"
        finally:
            self.display_debug_msg("Processing the received buffer")
            if q_entry is not None:
                self.display_debug_msg("Checking the response")
                # store the raw data
                self._raw_data = q_entry.get("data")
                response = self.check_response(self._raw_data, resp) if len(resp) else True
                if response:
                    self._success = True
                self.display_debug_msg("".join(["Command Sequence Execution Status: ", str(response)]))
                return response
            return None

    def request_query(self, cmd, resp, timeout):
        self._success = False
        response = self.command_query(cmd, resp, timeout)
        received_data = False
        if not response:
            return None
        if response:
            q_entry = None
            try:
                self.display_debug_msg("Waiting for the answer to be received")
                q_entry = self._q.get(True, timeout)
                self.display_debug_msg("".join(["Answer received", str(q_entry)]))
            except Empty as e:
                self.display_debug_msg("".join(["An exception is raised", str(e)]))
                self._error_msg = "API: Request Timeout"
            finally:
                self.display_debug_msg("Processing the received buffer")
                if q_entry is not None:
                    self.display_debug_msg("Retrieving the data")
                    received_data = self.format_data(q_entry.get("data"))
                    if received_data is not None:
                        self._success = True
                    self.display_debug_msg("".join(["Request Sequence Execution Status: ", str(response)]))
                    return received_data
                return None
        else:
            self.display_debug_msg("Request Failed")
        return received_data

    def check_response(self, data, resp):
        data = data[1:]
        response_str = decode(bytearray(data))
        response_str = response_str.replace("\x00", "").strip()
        self.display_wire_msg("".join(["Response received: ", response_str]))

        if response_str.upper().startswith(resp):
            self.display_debug_msg("Successful: Command Acknowledged")
            return True
        else:
            self.display_debug_msg("Fail: Command Not Acknowledged")
            self._error_msg = "".join(["Expected response not received. \nReceived: ", response_str])
            return False

    def format_data(self, data):
        data = data[1:]
        data_hex = [f"{item:02X}" for item in data]
        self.display_wire_msg("".join(["Data Received: ", str(data_hex)]))
        return data

    def close_queue(self):
        if self._q._thread and self._q._thread.is_alive:
            self._q.close()
            self._q.join_thread()

    def close_hid_device(self):
        self.close_queue()
        if self._device and self._device.is_opened():
            self._device.close()

    def set_receive_handle(self):
        self._device.set_raw_data_handler(self.receive_handler)

    def send_string(self, transmit_string):
        convert_buffer = list(map(ord, transmit_string))
        fill_buffer = [0] * (self.BUFFER_SIZE - len(convert_buffer))
        transmit_buffer = []
        transmit_buffer.append(0)
        transmit_buffer.extend(convert_buffer)
        transmit_buffer.extend(fill_buffer)
        self.display_debug_msg(str(transmit_buffer))
        self.send_data_buffer(transmit_buffer)

    def display_debug_msg(self, msg):
        if self._debug:
            logger.info("".join(["[D]: ", msg]))

    def display_wire_msg(self, msg):
        if self._wire_dump:
            logger.info(msg)

    def open_check_hid_device(self):
        self.open_hid_device()
        if not self._device_open:
            exception_str = "".join(
                [
                    "An error occurred opening the HID device.\n"
                    "The requested device with the following "
                    "specifications could not be found \n\n"
                    "Vendor ID: 0x",
                    f"{self._vendor_id:04X}",
                    "\n",
                    "Product ID: 0x",
                    f"{self._product_id:02X}",
                    "\n\n",
                    "Please make sure the dpIfGen2 board is connected.",
                ]
            )
            raise Exception(exception_str)


def main():
    print_config_api = PrintConfigAPI.instance()
    print_config_api._enable_wire_dumping()

    # create an instance of the class
    hid_communication = DpIfGen2LLD()
    # parse the arguments
    hid_communication.parse_arguments()
    # execute rest of the script flow in multiple functions.
    # open device
    hid_communication.open_hid_device()
    hid_communication.set_receive_handle()
    hid_communication.command_query("CMD28\r", "ACK", 2)
    hid_communication.command_query("CMD19F0004B00\r", "ACK", 2)
    hid_communication.command_query("CMD010300\r", "ACK", 2)
    hid_communication.command_query("CMD2E\r", "ACK", 2)
    hid_communication.request_query("CMD0200800400\r", "ACK", 2)
    hid_communication.close_hid_device()


if __name__ == "__main__":
    main()

# --- End of File ------------------------------------------------
