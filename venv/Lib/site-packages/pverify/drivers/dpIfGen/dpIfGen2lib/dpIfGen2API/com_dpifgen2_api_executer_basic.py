#!/usr/bin/python
# ===========================================================================
# Name:        com_dpifgen2_api_executer_basic.py
#
# Purpose:     Execution of defined sequences for dpifgen2 basic api
#
# Author:      Aslam Faizan Muhammad (IFAG PMM SYS SWT SWI)
#                                       <Faizan.Aslam@infineon.com>
# Created:     29.10.2014
#
# Python Version: v2.7.2
#
# Dependency: flow_process_ahex_file.py, com_dpifgen2_lld.py,
#             config_dpifgen2_api
#             argparse, math
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
from __future__ import annotations

import argparse
import math

from dpIfGen2lib.dpIfGen2API.com_dpifgen2_lld import DpIfGen2LLD
from dpIfGen2lib.support.config_dpifgen2_api import HIDConfigAPI
from dpIfGen2lib.support.flow_process_ahex_file import ProcessAhexFile


class DpIfGen2APIExecuterBasic(DpIfGen2LLD):
    """
    This class is a generic sequence executor for the sequences that are defined in
    the dpIfGen2 basic API. The sequences defined in the API correspond to different
    dpIFGen2 commands in the API, like read memory block, burn memory block, etc.

    The executer is implemented in a generic way, therefore all the sequence in the
    API are structured similarly. This makes adding new commands to the API much easier.
    Only a new command has to be added to API, the executing functionality remains
    unchanged. This corresponds to our strategy of faster time to market. A strong
    basis is provided already that is implemented in a generic way to cater for a
    possible extension of already existing commands in mind.

    This class serves as the bridge that connects the HID communication and maps it
    to the dpIfGen2 API. This class is the crux of how API functions are mapped to
    the low level HID communication. From concept this class, should be the only
    gateway to the low level functions of the HID. All the API commands have to
    go through this gateway to reach the HID. No direct access is allowed. This
    preserves our modular development approach. The obvious benefit for such an
    approach is scalability. In case of a new Hardware or mode of communication,
    the only thing that needs to be adapted is the low level drivers and the
    gateway to the drivers. The tooling remains intact.

    This class is an extension of HIDCommunicationExtended class which enables the
    user to pass simple commands or requests (comprising an acknowledgement and a
    single data buffer) from the user over HID.
    """

    #: dpIfGen2 Executer Basic Version v1.0.5
    VERSION = "1.0.6"

    def __init__(self, parent=None):
        """
        Initialization of the class. Call the __init__ for the super class
        """
        super().__init__()
        self._parent = parent
        # Default set to Product specific settings of HID device
        # Infineon Vendor ID (hex): 058B
        # Product ID (hex):
        # Product running FW: 	0220
        # Bootloader: 		0221
        self._vendor_id = 0x058B
        self._product_id = 0x0220

        vid = HIDConfigAPI.instance().get_vendor_id()
        if vid:
            self._vendor_id = vid

        pid = HIDConfigAPI.instance().get_product_id()
        if pid:
            self._product_id = pid

        self._execution_step = 0
        self._filename = None
        self._data_exchange = None

    def parse_arguments(self):
        parser = argparse.ArgumentParser(description=self.__doc__)

        group_basic = parser.add_argument_group("Options")

        group_basic.add_argument("-vid", "--vendor_id", help="Vendor Id", type=int, required=False)
        group_basic.add_argument("-pid", "--product_id", help="Product Id", type=int, required=False)
        group_basic.add_argument(
            "-v",
            "--verbose",
            help="provide additional printout",
            action="store_true",
            required=False,
        )
        group_basic.add_argument(
            "-d",
            "--debug",
            help="provide debug information",
            action="store_true",
            required=False,
        )
        group_basic.add_argument("-f", "--filename", help="File Name", required=False)
        group_basic.add_argument("-V", "--version", help="Print Version", action="store_true", required=False)

        args = parser.parse_args()

        # assign argument values to class variables ##

        if args.vendor_id:
            self._vendor_id = args.vendor_id
        if args.product_id:
            self._product_id = args.product_id
        if args.verbose:
            self._verbose = args.verbose
        if args.debug:
            self._debug = args.debug
        if args.filename:
            self._filename = args.filename

        # special handler for version information
        if args.version:
            # show the version and exit
            print("Version: ", self.VERSION)
            exit()

        # show values ##
        if self._verbose:
            print("Vendor ID : 0x{}".format(f"{self._vendor_id:04X}"))
            print("Product ID: 0x{}".format(f"{self._product_id:04X}"))
            print("verbose mode: %s" % self._verbose)

    def create_sequence(self, sequence):
        """
        :type sequence: dict

        """
        self._exec_seq = sequence

        if self._debug:
            print(self._exec_seq)

    def _continue_execution(self, status):
        step = self._exec_seq.get(self._execution_step)
        if status:
            update_msg = "".join(["Step: ", step.get("Step"), " Successfully executed!"])
            if self._verbose:
                self.display_msg(update_msg)
                if self._parent:
                    self._parent.statusbar.showMessage(update_msg)
            self._execution_step += 1
        else:
            update_msg = "".join(["An error occurred while executing the Step: ", step.get("Step")])
            self._sequence_status = False
            if self._verbose:
                self.display_msg(update_msg)
                if self._parent:
                    self._parent.statusbar.showMessage(update_msg)
            raise Exception(
                "".join(
                    [
                        "Sequence Execution Failed!! \n",
                        update_msg,
                        "\n\n",
                        str(self._error_msg),
                    ]
                )
            )

    def execute_sequence(self):
        """
        Executes the get info sequence
        """
        if self._exec_seq:
            for key in sorted(map(str, self._exec_seq.keys())):
                if key == "Name":
                    continue
                cur_step = self._exec_seq.get(int(key))
                if self._verbose:
                    msg = "".join(["Executing Step: ", cur_step.get("Step")])
                    self.display_msg(msg)
                if "Command" in cur_step:
                    # Note: A command is a single message to the device. It either expects ACK or NACK as response.
                    send_str = "".join([cur_step.get("Command"), cur_step.get("Parameters", "")])  # ,
                    #                    '\r'])
                    expected_str = cur_step.get("Response")
                    # Note: Timeout is in seconds
                    timeout = cur_step.get("Timeout")

                    self._continue_execution(self.command_query(send_str, expected_str, timeout))

                elif "CommandData" in cur_step:
                    # Note: CommandData actually is a request message to the device. It expects ACK and further data
                    #       or NACK respectively
                    send_str = "".join([cur_step.get("CommandData"), cur_step.get("Parameters"), "\r"])
                    expected_str = cur_step.get("Response")
                    # Note: Timeout is in seconds
                    timeout = cur_step.get("Timeout")
                    response_data = self.request_query(send_str, expected_str, timeout)
                    self._continue_execution(response_data is not None)
                    self._process_data(response_data)
                elif "CommandDataImmediate" in cur_step:
                    # Note: CommandData actually is a request message to the device. It expects ACK and further data
                    #       or NACK respectively. Data is included in same message (immediate) with the ACK.
                    send_str = "".join(
                        [
                            cur_step.get("CommandDataImmediate"),
                            cur_step.get("Parameters"),
                            "\r",
                        ]
                    )
                    expected_str = cur_step.get("Response")
                    # Note: Timeout is in seconds
                    timeout = cur_step.get("Timeout")
                    is_response_ok = self.command_query(send_str, expected_str, timeout)
                    if is_response_ok:
                        self._execution_step += 1
                        if len(self.get_raw_data()) >= 7:
                            self._process_data(self.get_raw_data()[3:7])
                elif "Process" in cur_step:
                    self.execute_process(cur_step)

                elif "CondCommandData" in cur_step:
                    cond = cur_step.get("Condition")
                    if cond:
                        send_str = "".join(
                            [
                                cur_step.get("CondCommandData"),
                                cur_step.get("Parameters"),
                                "\r",
                            ]
                        )
                        expected_str = cur_step.get("Response")
                        # Note: Timeout is in seconds
                        timeout = cur_step.get("Timeout")

                        response_data = self.request_query(send_str, expected_str, timeout)
                        self._continue_execution(response_data is not None)
                        self._process_data(response_data)
                    else:
                        pass

                else:
                    pass

    ##            if self.success:
    ##                if self.verbose:
    ##                    print("Sequence successfully executed")

    def execute_process(self, cur_step):
        step = cur_step.get("Step")
        if step == "Data extraction from ahex file":
            ##                elif key == 0:
            # extract information from file
            self._filename = cur_step.get("Filename", None)
            self.extract_data_file()
            # prepare the write buffer command
            buf_command = self.prepare_write_buffer_command()
            for item in self._exec_seq:
                if item == "Name":
                    continue
                if self._exec_seq[item]["Step"] == "Write Buffer Command":
                    step_idx = item
            self._exec_seq[step_idx]["Parameters"] = buf_command
        elif step == "Sending Data in 64 byte chunks":
            ##                elif key == 6:
            # sending data in 64 byte chunks
            try:
                self.send_buffer_data()
                self._continue_execution(True)
            except Exception as e:
                print("An exception occurred")
                print(str(e))

        elif step == "Burn Single Memory Prepare":
            single_address = cur_step.get("Address")
            single_value = cur_step.get("Value")
            self.fake_data_extraction(single_address, single_value)
            # prepare the write buffer command
            buf_command = self.prepare_write_buffer_command()
            for item in self._exec_seq:
                if item == "Name":
                    continue
                if self._exec_seq[item]["Step"] == "Write Buffer Command":
                    step_idx = item
            self._exec_seq[step_idx]["Parameters"] = buf_command

        elif step == "Read Memory Block":
            self._dump_mem = {}
            self._blocksize = 0x0020
            start_address = cur_step.get("Address")
            length = cur_step.get("Length")
            self._address_range = (start_address, start_address + length - 1)
            self.partition_address_range()
            self.start_dump_memory_loop()

        elif step == "Data Block Prepare":
            start_address = cur_step.get("Address")
            block_data = cur_step.get("Data")
            self.fake_data_extraction_block(start_address, block_data)
            # prepare the write buffer command
            buf_command = self.prepare_write_buffer_command()
            for item in self._exec_seq:
                if item == "Name":
                    continue
                if self._exec_seq[item]["Step"] == "Write Buffer Command":
                    step_idx = item
            self._exec_seq[step_idx]["Parameters"] = buf_command

    def partition_address_range(self):
        self._address_range_part = []
        # partition the address range in to list of tuples.
        # Each tuple contains start address of memory and length in bytes
        (start, stop) = self._address_range
        num_partitions = int(math.ceil((stop - start + 1) / float(self._blocksize)))
        for part in range(num_partitions):
            start_add = start + part * self._blocksize
            length = self._blocksize * 2 if start + (part + 1) * self._blocksize <= stop else (stop - start_add + 1) * 2
            address_tuple = (start_add, length)
            self._address_range_part.append(address_tuple)

    def start_dump_memory_loop(self):
        num_blocks = len(self._address_range_part)
        for block_idx in range(num_blocks):
            self._block_num = block_idx
            start_add = self._address_range_part[block_idx][0]
            block_length = self._address_range_part[block_idx][1]
            if self._verbose:
                info_str = "".join(
                    [
                        "Reading Memory: ",
                        "0x",
                        f"{start_add:04X}",
                        " - ",
                        "0x",
                        f"{start_add + int(block_length / 2) - 1:04X}",
                    ]
                )
                self.display_msg(info_str)
            cur_step = self._exec_seq.get(self._execution_step)

            expected_str = cur_step.get("Response")
            # Note: Timeout is in seconds
            timeout = cur_step.get("Timeout")
            start_add_le = self.convert_endian(f"{start_add:04X}")
            block_length_le = self.convert_endian(f"{int(block_length / 2):04X}")
            cur_step["Parameters"] = "".join([start_add_le, block_length_le])
            send_str = "".join([cur_step.get("ProcessCommand"), cur_step.get("Parameters"), "\r"])

            response_data = self.request_query(send_str, expected_str, timeout)
            self._continue_execution(response_data is not None)
            self._process_data(response_data)

            self._execution_step -= 1

    def convert_endian(self, endian_prev):
        return "".join(format(b, "02X") for b in bytearray.fromhex(endian_prev)[::-1])

    def _process_data(self, data):
        step = self._exec_seq[self._execution_step - 1].get("Step")

        if step == "Read FW ID":
            self._data_exchange = "".join(chr(i) for i in data)

        if step == "Read Protocol ID":
            low_byte = int("".join([chr(data[0]), chr(data[1])]), 16)
            high_byte = int("".join([chr(data[2]), chr(data[3])]), 16)
            self._data_exchange = high_byte * 256 + low_byte

        if step == "Read Single Word":
            self._data_exchange = data[1] * 256 + data[0]

        if step == "Read Memory Block":
            start_add = self._address_range_part[self._block_num][0]
            block_length = self._address_range_part[self._block_num][1]
            for mem in range(int(block_length / 2)):
                memory_add = f"{start_add + mem:06X}"
                mem_val = data[2 * mem + 1] * 256 + data[2 * mem]
                memory_val = f"{mem_val:04X}"
                self._dump_mem[memory_add] = memory_val
            self._data_exchange = self._dump_mem

        if step == "Get Info Seq":
            buffer_length = self.BUFFER_SIZE
            get_info_response = {}
            for words in range(int(buffer_length / 2)):
                word_val = data[2 * words + 1] * 256 + data[2 * words]
                word_value = f"{word_val:04X}"
                get_info_response[words] = word_value
            self._data_exchange = get_info_response

    def display_msg(self, msg):
        print("".join(["[D]: ", msg]))

    def prepare_write_buffer_command(self):
        start_address = self._process_ahex_file.get_start_address()
        self._transmit_buffer = self._process_ahex_file.get_buffer()
        if self._transmit_buffer:
            length_bytes = self._process_ahex_file.get_length(self._transmit_buffer)
            # calculate crc
            crc_bytes = self._process_ahex_file.get_crc(self._transmit_buffer)
            # send command
            send_string = "".join([start_address, length_bytes, crc_bytes])
            if self._debug:
                msg = "".join(["Sending Command :", send_string])
                self.display_msg(msg)
            return send_string
        return None

    def extract_data_file(self):
        # Extract data from hex file
        self._process_ahex_file = ProcessAhexFile()
        self._process_ahex_file.filename = self._filename
        extracted = self._process_ahex_file.extract_data()
        if extracted:
            self._data_extracted = self._process_ahex_file.data_extracted
            self._continue_execution(True)
        else:
            msg = "An exception occurred while extracting data from the ahex file"
            raise Exception(msg)

    def fake_data_extraction(self, address, value):
        self._process_ahex_file = ProcessAhexFile()
        self._process_ahex_file.data_extracted[address.upper()] = value

    def fake_data_extraction_block(self, address, data):
        self._process_ahex_file = ProcessAhexFile()
        address_dec = int(address, 16)
        for item in data:
            self._process_ahex_file.data_extracted[f"{address_dec:06X}".upper()] = item
            address_dec += 1

    # added by Gerhard (buff must contain binary words)
    def send_word_buffer(self, buff):
        # turn words into little endian ordered bytes
        tx_buffer = []
        for word in range(len(buff)):
            tx_buffer.append(buff[word] & 0xFF)
            tx_buffer.append(buff[word] >> 8)
        # assign transmit buffer
        self._transmit_buffer = tx_buffer
        # transmit (automatically splits into packets of 64 bytes as required by the HID)
        try:
            self.send_buffer_data()
        except Exception as e:
            print("An exception occurred")
            print(str(e))

    def send_buffer_data(self):
        hid_packet_size = self.BUFFER_SIZE
        length_buffer = len(self._transmit_buffer)
        packets_to_send = int(math.ceil(length_buffer / float(hid_packet_size)))
        if self._debug:
            msg = "".join(["Packets_to_send: ", str(packets_to_send)])
            self.display_msg(msg)
            self.display_msg("Preparing packets. ")
            msg = "".join(["Total of ", str(packets_to_send), "packets will be sent"])
            self.display_msg(msg)

        for packet in range(packets_to_send):
            tx_buffer = []
            tx_buffer.append(0)
            if packet != packets_to_send - 1:
                tx_buffer.extend(
                    self._transmit_buffer[packet * hid_packet_size : packet * hid_packet_size + hid_packet_size]
                )
            else:
                tx_buffer.extend(self._transmit_buffer[packet * hid_packet_size : length_buffer])
                fill_buffer = [0] * (hid_packet_size - len(tx_buffer) + 1)
                tx_buffer.extend(fill_buffer)
            if self._debug:
                msg = "".join(["Sending packet[", str(packet), "]: of length ", str(len(tx_buffer))])
                self.display_msg(msg)
                print(tx_buffer)
            self.send_data_buffer(tx_buffer)

        if self._verbose:
            print("Data transmission complete")


def main():
    dpifgen2_api_executer_basic = DpIfGen2APIExecuterBasic()
    dpifgen2_api_executer_basic.parse_arguments()
    dpifgen2_api_executer_basic.open_check_hid_device()
    # dpifgen2_api_executer_basic.initialize_threads()
    dpifgen2_api_executer_basic.set_receive_handle()

    # create/define the sequence
    dpifgen2_api_executer_basic.create_sequence(None)
    # execute the sequence
    dpifgen2_api_executer_basic.execute_sequence()
    dpifgen2_api_executer_basic.close_hid_device()


if __name__ == "__main__":
    main()

# --- End of File ------------------------------------------------
