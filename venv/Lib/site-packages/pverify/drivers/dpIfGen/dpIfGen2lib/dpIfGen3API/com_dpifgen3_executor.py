from __future__ import annotations

from dpIfGen2lib.dpIfGen3API.com_dpifgen3_lld import DpIfGen3LLD
from dpIfGen2lib.support.config_dpifgen2_api import PrintConfigAPI


class Telegram:
    def __init__(self, max_size):
        self.data = [0] * max_size
        self.write_offset = 0
        self.has_command = False
        self.has_data = False

    def is_combo(self):
        return self.has_data and self.has_command

    def is_cmd(self):
        return self.data[0:3] == [ord("C"), ord("M"), ord("D")]

    def is_dat0(self):
        return self.data[0:4] == [ord("D"), ord("A"), ord("T"), 0]

    def get_max_size(self):
        return len(self.data)

    def get_telegram(self):
        return self.data

    def add_command(self, command):
        """
        :type command: str
        """
        self._add_string(command)
        self.has_command = True

    def add_data(self, data):
        """
        :type data: list
        """
        if self.write_offset != 0:
            self._add_bytes([0])
        self._add_string("DAT")
        self._add_bytes([len(data)])
        self._add_bytes(data)
        self.has_data = True

    def _add_string(self, the_string):
        string_as_bytes = list(map(ord, the_string))
        self._add_bytes(string_as_bytes)

    def _add_bytes(self, data_list):
        if self.write_offset + len(data_list) > len(self.data):
            msg = "Data cannot be appended to telegram"
            raise Exception(msg)

        for item in data_list:
            self.data[self.write_offset] = item
            self.write_offset += 1


class CommandBasic:
    DEFAULT_TRUE_RESPONSE = "ACK"
    DEFAULT_DATA_RESPONSE = "DAT"
    DEFAULT_FALSE_RESPONSE = "NAK"
    COMMAND_LENGTH = 5  # number of letters a command should be 'CMDxx'

    def __init__(self, lld=None):
        if isinstance(lld, DpIfGen3LLD):
            self.lld, self._static = lld, False
        else:
            self.lld, self._static = DpIfGen3LLD(), True
        self.command_string = ""
        self.command_id_int = 0
        self.timeout_s = 2
        self.parameters_int_list = []
        self.support_combo = PrintConfigAPI.instance().is_combo_enabled()

    def combo_disable(self):
        self.support_combo = False

    def combo_enable(self):
        self.support_combo = True

    def set_command_string(self, command_string_with_id):
        if len(command_string_with_id) != self.COMMAND_LENGTH:
            msg = "Error: Command length wrong"
            raise Exception(msg)
        if not command_string_with_id.startswith("CMD"):
            msg = "Error: Command does not start with CMD"
            raise Exception(msg)
        value = "".join(
            [
                command_string_with_id[self.COMMAND_LENGTH - 2],
                command_string_with_id[self.COMMAND_LENGTH - 1],
            ]
        )
        try:
            self.command_id_int = int(value, 16)
        except Exception:
            msg = "Error: conversion of command ID not successful"
            raise Exception(msg)
        self.command_string = command_string_with_id

    def get_command_string(self):
        return self.command_string

    def set_timeout(self, timeout_s):
        self.timeout_s = timeout_s

    def add_32bit_parameter(self, parameter):
        self.add_16bit_parameter(parameter & 0x0000FFFF)
        self.add_16bit_parameter((parameter & 0xFFFF0000) >> 16)

    def add_16bit_parameter(self, parameter_value_int):
        """
        Take care that you add the parameter in the right order
        Parameters
        ----------
        parameter_value_int

        Returns
        -------
        No
        """
        if self.command_string != "":
            self.parameters_int_list.append(parameter_value_int)
            # self.command_string = self.command_string + '{:04X}'.format(parameter_value_int)
            big_endian = f"{parameter_value_int:04X}"
            self.command_string += self.convert_endian(big_endian)
        else:
            msg = "Please set command string first!"
            raise Exception(msg)

    def add_8bit_parameter(self, parameter_value_byte):
        """
        Take care that you add the parameter in the right order
        Parameters
        ----------
        parameter_value_byte

        Returns
        -------
        No
        """
        if self.command_string != "":
            self.parameters_int_list.append(parameter_value_byte)
            byte_value = f"{parameter_value_byte:02X}"
            self.command_string += byte_value
        else:
            msg = "Please set command string first!"
            raise Exception(msg)

    def add_parameter_as_string(self, parameter_as_string):
        if self.command_string == "":
            self.command_string = self.command_string + parameter_as_string
        else:
            msg = "Please set command string first!"
            raise Exception(msg)

    def convert_endian(self, endian_prev):
        return "".join(format(b, "02X") for b in bytearray.fromhex(endian_prev)[::-1])

    def check_command_string(self):
        if len(self.parameters_int_list) == 0:
            self.command_string += "0" * (CommandBasic.COMMAND_LENGTH - len(self.command_string))

    def calculate_crc(self, data):
        # todo remove this function because it is not used
        # it could be used for transparent communication, but there is no demand yet
        crc = 0xFFFF
        msb = crc >> 8
        lsb = crc & 255
        for c in data:
            x = c ^ msb
            x ^= x >> 4
            msb = (lsb ^ (x >> 3) ^ (x << 4)) & 255
            lsb = (x ^ (x << 5)) & 255
        return (msb << 8) + lsb

    def convert_data_to_string(self, data):
        respond_string = ""
        for i in data:
            if i == 0:
                break
            else:
                respond_string += str(chr(i))
        return respond_string

    def calculate_check_sum(self, param):
        check_sum = 0
        for i in range(0, len(param), 2):
            element = self.convert_data_to_string(param[0 + i : 2 + i])
            element = 0 if element == "" else int(element, 16)
            check_sum ^= element

        return check_sum == 0


class CmdSingle(CommandBasic):
    def __init__(self, lld=None):
        CommandBasic.__init__(self, lld)
        self.requested_data = None
        self.respond_string = ""

    def get_data(self):
        return self.requested_data

    def execute(self, check_queue=False):
        self.check_command_string()
        successful = False

        if self._static:
            self.lld.open_check_hid_device()
            self.lld.set_receive_handle()

        if self.lld.command_query(self.command_string, CommandBasic.DEFAULT_TRUE_RESPONSE, self.timeout_s):
            successful = True
            self.requested_data = self.lld.get_raw_data(check_queue)
        else:
            # we are here if we received an unexpected answer or timeout
            if not self.lld.is_timeout():
                # get the unexpected response (e.g. NAK)
                self.requested_data = self.lld.get_raw_data()

        if self._static:
            self.lld.close_hid_device()

        if self.lld.is_timeout():
            raise Exception("Timeout: no ACK received after sending %s" % self.command_string)

        return successful

    def get_data_as_string(self):
        self.respond_string = self.convert_data_to_string(self.requested_data)
        # Remove leading ACK string.
        if self.respond_string.startswith(CommandBasic.DEFAULT_TRUE_RESPONSE):
            self.respond_string = self.respond_string[len(CommandBasic.DEFAULT_TRUE_RESPONSE) :]
        return self.respond_string


class CmdDataRead(CommandBasic):
    def __init__(self, lld=None):
        CommandBasic.__init__(self, lld)
        self.requested_data = None

    def get_data(self):
        return self.requested_data

    def execute(self):
        self.check_command_string()
        successful = False

        if self._static:
            self.lld.open_check_hid_device()
            self.lld.set_receive_handle()

        if self.lld.command_query(self.command_string, CommandBasic.DEFAULT_TRUE_RESPONSE, self.timeout_s):
            successful = self._receive_data()
        else:
            # we are here if we received an unexpected answer or timeout
            if not self.lld.is_timeout():
                # get the unexpected response (e.g. NAK)
                self.requested_data = self.lld.get_raw_data()

        if self._static:
            self.lld.close_hid_device()

        if self.lld.is_timeout():
            raise Exception("Timeout: no ACK received after sending data command. %s" % self.command_string)

        return successful

    def _receive_data(self):
        success = False
        self.requested_data = []

        # check if we received a combo-telegram
        data = self.lld.get_raw_data()
        if len(data) > 7 and data[0:7] == [
            ord("A"),
            ord("C"),
            ord("K"),
            0,
            ord("D"),
            ord("A"),
            ord("T"),
        ]:
            length = data[7]
            self.requested_data.extend(data[8 : 8 + length])
            return True

        while True:
            if self.lld.command_query("NXT", CommandBasic.DEFAULT_DATA_RESPONSE, 1):
                data = self.lld.get_raw_data()
                length = data[3]
                if length:
                    self.requested_data.extend(data[4 : 4 + length])
                else:
                    success = True
                    break
            else:
                # we are here if we received an unexpected answer or timeout
                if not self.lld.is_timeout():
                    # get the unexpected response (e.g. NAK)
                    self.requested_data = self.lld.get_raw_data()
                    break
                else:
                    if self._static:
                        self.lld.close_hid_device()
                    msg = "Timeout: no DAT received after sending NXT."
                    raise Exception(msg)

        return success

    def get_answered_data_as_string(self):
        # data is a list of 8-bit integers
        # Conversion: [0, 1, 2, 3, 255] -> '00010203FF'
        respond_string = ""
        for i in self.requested_data:
            respond_string += f"{i:02X}"
        return respond_string


class CmdDataWrite(CommandBasic):
    TELEGRAM_DATA_LENGTH = DpIfGen3LLD.BUFFER_SIZE - 4  # 4 because of DATn

    def __init__(self, lld=None):
        CommandBasic.__init__(self, lld)
        self.data = []
        self.data_telegrams = []
        self.unexpected_answer = None

    def get_answer(self):
        return self.unexpected_answer

    def execute(self):
        self.check_command_string()
        success = False

        if self._static:
            self.lld.open_check_hid_device()
            self.lld.set_receive_handle()

        is_combo = self.create_telegrams()
        if not is_combo:
            if self.lld.command_query(self.command_string, CommandBasic.DEFAULT_TRUE_RESPONSE, self.timeout_s):
                success = self._transmit_telegrams()
            else:
                # we are here if we received an unexpected answer or timeout
                if not self.lld.is_timeout():
                    self.unexpected_answer = self.lld.get_raw_data()
        else:
            # here we send a (single) combo telegram
            success = self._transmit_telegrams()

        if self._static:
            self.lld.close_hid_device()

        if self.lld.is_timeout():
            raise Exception("Timeout: no ACK received after sending %s" % self.command_string)

        return success

    def _transmit_telegrams(self):
        success = True
        for telegram in self.data_telegrams:
            timeout = 1
            if telegram.is_dat0():
                # When sending the last DAT command, the interface box starts to transmit the data
                # to the device. A maximum of 32kByte can be transferred i.e. it takes a while.
                # Therefore we increase the timeout here.
                timeout = 10
            if not self.lld.send_data(telegram.get_telegram(), timeout):
                success = False
                if self.lld.is_timeout():
                    if self._static:
                        self.lld.close_hid_device()
                    msg = "Timeout: no ACK received after sending DAT"
                    raise Exception(msg)
                else:
                    self.unexpected_answer = self.lld.get_raw_data()
                    break

        return success

    def create_telegrams(self):
        self.data_telegrams = []

        # build a working copy with the data
        data_copy = []
        data_copy.extend(self.data)

        if self.support_combo:
            # print("use combo")
            if len(self.data) + 5 < len(self.command_string):
                # create combo telegram
                telegram = Telegram(DpIfGen3LLD.BUFFER_SIZE)
                telegram.add_command(self.command_string)
                telegram.add_data(self.data)
                self.data_telegrams.append(telegram)
                return True

        telegram = Telegram(DpIfGen3LLD.BUFFER_SIZE)

        while len(data_copy) >= self.TELEGRAM_DATA_LENGTH:
            data_chunk = data_copy[0 : CmdDataWrite.TELEGRAM_DATA_LENGTH]
            telegram.add_data(data_chunk)
            del data_copy[0 : self.TELEGRAM_DATA_LENGTH]
            self.data_telegrams.append(telegram)
            telegram = Telegram(DpIfGen3LLD.BUFFER_SIZE)

        # last data telegram can be shorter
        if len(data_copy):
            telegram.add_data(data_copy)
            self.data_telegrams.append(telegram)

        # add DAT0 telegram for termination
        telegram = Telegram(DpIfGen3LLD.BUFFER_SIZE)
        telegram.add_data([])
        self.data_telegrams.append(telegram)

        return False

    def add_data(self, data):
        self.data.extend(data)

    def get_data(self):
        return self.data

    def get_data_telegram(self, index):
        """
        :rtype: Telegram
        """
        return self.data_telegrams[index]
