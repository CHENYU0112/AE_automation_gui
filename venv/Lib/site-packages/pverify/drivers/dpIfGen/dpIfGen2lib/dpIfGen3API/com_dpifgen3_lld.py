#!/usr/bin/python
# ===========================================================================
# Name:        com_dpifgen3_lld.py
#
# Purpose:     Low Level Driver for dpIfGen2 board
#
# Author:      Fuchs Philipp (IFAG HR FW VT MUC )
#                                       <Philipp.Fuchs@infineon.com>
#
# Created:     22.11.2016
#
# Python Version: v2.7.2
#
# Dependency: com_hid_communication, config_dpifgen2_api,
#             multiprocessing, datetime
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#

"""Low level drivers for dpIfGen2 board

This class implements the low level drivers for the dpIfGen2 board.
The class implements the two modes:

    1. Command => Responded with an ACK/NAK

        This mode allows the user to send a command in a buffer over HID and in turns
        waits for a response from the other side within a specified timeout.
        If a response is received, it is compared against the expected response.
        The operation is considered successful if the expected response was
        received with in the timeout otherwise it is regarded as a fail and
        an exception is raised.

        The script can be used from the command line using the same arguments
        as :mod:`com_hid_communication`

        .. warning::

            It is assumed that the response span only one data buffer. If the
            response span more than one buffer, it can not be regarded as a
            command but as a request.

    2. Request => Responded with an ACK/NAK followed by a single data buffer

        This mode allows the user to send a request in a buffer over HID and in turns
        waits for a response from the other side within a specified timeout.
        The response in this case comprise of an Acknowledgement and a data buffer.
        If a response is received, it is compared against the expected response.
        The operation is considered successful if the expected response(acknowledgement
        followed by the data buffer) was received with in the timeout otherwise it is
        regarded as a fail and an exception is raised.

        The script can be used from the command line using the same arguments
        as :mod:`com_hid_communication`

        .. warning::

            It is assumed that the response spans two data buffers.
            The first buffer contains the acknowledgement and the second buffer
            contains the requested data. If the requested data span more than
            one buffer, the data has to be requested in two separate commands.

"""
from __future__ import annotations

import os
from datetime import datetime
from multiprocessing import Queue
from multiprocessing.queues import Empty

if "TEST_ENV_DP_TOOLS_2016-04-15" in os.environ and os.environ["TEST_ENV_DP_TOOLS_2016-04-15"] == "true":
    from dpIfGen2lib.test.dp3.support.fake_com_hid_communication import HIDCommunication
else:
    from dpIfGen2lib.dpIfGen3API.com_hid_communication import HIDCommunication

from dpIfGen2lib.dpIfGen3API.misc import decode
from dpIfGen2lib.support.config_dpifgen2_api import PrintConfigAPI
from dpIfGen2lib.support.logger import logger


class DpIfGen3LLD(HIDCommunication):
    """
    Low Level Driver for dpIfGen2 board
    """

    #: dpIfGen2 LLD Version v1.0.6
    VERSION = "3.0.1"

    def __init__(self, parent=None):
        super().__init__()
        self.parent = parent
        # the receiving queue (i.e. received USB telegrams are inserted to the queue)
        self._q = Queue()
        self._debug = False
        self._error_msg = ""
        # raw response data (1st buffer) of last command_query or request_query
        self._raw_data = None
        self.timeout_occurred = False

    @property
    def _wire_dump(self):
        return PrintConfigAPI.instance().is_wire_dumping_enabled()

    def is_timeout(self):
        return self.timeout_occurred

    def get_error_msg(self):
        return self._error_msg

    def get_raw_data(self, check_queue=False):
        """
        Returns the raw data byte list from the last received telegram.
        If check_queue is True, it checks if there is another telegram containing the data.
        This is relevant for older protocols (DP2A, DP2B)
        :type check_queue: bool
        :rtype: list
        """
        if check_queue:
            try:
                # Is is sufficient to wait only 100ms for a telegram, since older boxes will send two telegrams one
                # after the other very quickly (ACK telegram followed by data telegram)
                q_entry = self._q.get(True, 0.1)
                self._raw_data = q_entry.get("data")
            except Empty:
                pass

        if self._raw_data is None:
            return []

        if len(self._raw_data) == 1:
            return []

        # get raw response data (1st buffer) of last command_query or request_query
        return self._raw_data[1:]  # first byte is the report ID - we can discard)

    def receive_handler(self, data_buffer):
        # This function is called from the HID library every time a new USB telegram has been received
        # from the interface box. Actually it is called as a thread.
        # data_buffer contains the USB telegram received (up to 64 byes) as a byte list
        self.display_debug_msg("Received a new buffer")
        self._q.put({"data": data_buffer, "timestamp": datetime.now(), "somestuff": None})

    def send_data(self, data, timeout):
        if len(data) > self.BUFFER_SIZE:
            logger.error(f"Telegram cannot be sent because it is too big (size: {len(data)}).")

        # Send Command
        self.display_wire_msg("Sending Data (%d bytes)" % len(data))
        # first element is the report ID
        data_buffer = [0]
        data_buffer.extend(data)
        self.send_data_buffer(data_buffer)
        self.display_debug_msg("Sent (%d): %s" % (len(data), data))
        self.timeout_occurred = False

        # Wait for an entry in the queue. If there is a response from the device within
        # the specified timeout, the corresponding data buffer is saved in the queue.
        q_entry = None
        try:
            self.display_debug_msg("Waiting for the data to be received")
            q_entry = self._q.get(True, timeout)
            self.display_debug_msg("".join(["[Q]: An entry is made in the queue", str(q_entry)]))
        except Empty as e:
            self.display_debug_msg("".join(["An exception is raised", str(e)]))
            self._error_msg = "API: Command Timeout"
            self.timeout_occurred = True
        finally:
            self.display_debug_msg("Processing the received buffer")
            if q_entry is not None:
                self.display_debug_msg("Checking the response")
                # store the raw data
                self._raw_data = q_entry.get("data")
                if len(self._raw_data) >= 1:
                    response = self.check_response("ACK")
                else:
                    # todo why do we return True, if response is too short?
                    response = True
                self.display_debug_msg("".join(["Command Sequence Execution Status: ", str(response)]))
                return response
            return None

    def command_query(self, cmd, response_expected, timeout):
        """
        The function sends a given command (cmd) to the interface and
        waits for an expected answer (response_expected) from it.
        The timeout specifies the maximum waiting time for an answer.

        Function returns true or false.
                True: expected response have been found in received data

        Parameters
        ----------
        timeout
        response_expected
        cmd
        :type response_expected: str
        :type timeout: float
        :type cmd: str
        """
        if len(cmd) == 0:
            return True

        self.timeout_occurred = False
        # Send Command
        self.display_wire_msg("".join(["Sending String Command: ", cmd.strip()]))
        self.send_string(cmd)
        # Wait for an entry in the queue. If there is a response from the device within
        # the specified timeout, the corresponding data buffer is saved in the queue.
        q_entry = None
        try:
            self.display_debug_msg("Waiting for the data to be received")
            q_entry = self._q.get(True, timeout)
            self.display_debug_msg(("[Q]: ", "An entry is made in the queue", q_entry))
        except Empty as e:
            self.display_debug_msg("".join(["An exception is raised", str(e)]))
            self._error_msg = "API: Command Timeout"
            self.timeout_occurred = True
        finally:
            # we reach this block in all cases w/o exception
            self.display_debug_msg("Processing the received buffer")
            # todo find out in which case q_entry remains None
            if q_entry is not None:
                self.display_debug_msg("Checking the response")
                # store the raw data
                self._raw_data = q_entry.get("data")
                response = self.check_response(response_expected)
                self.display_debug_msg("".join(["Command Sequence Execution Status: ", str(response)]))
                return response
            # todo why not returning False
            return None

    def check_response(self, resp):
        data = self._raw_data[1:]
        response_str = decode(bytearray(data))
        response_str = response_str.replace("\x00", "").strip()
        self.display_debug_msg("Response received raw (%d): %s" % (len(data), data))
        self.display_wire_msg("".join(["Response received: ", response_str]))
        if response_str.upper().startswith(resp):
            self.display_debug_msg("Successful: Command Acknowledged")
            return True
        else:
            self.display_debug_msg("Fail: Command Not Acknowledged")
            self._error_msg = "".join(["Expected response not received. \nReceived: ", response_str])
            return False

    # todo remove this unused function
    def format_data(self, data):
        data = data[1:]
        data_hex = [f"{item:02X}" for item in data]
        self.display_wire_msg("".join(["Data Received: ", str(data_hex)]))
        self.display_debug_msg("".join(["Received length ", str(len(data))]))
        return data

    def close_queue(self):
        if self._q._thread and self._q._thread.is_alive:
            self._q.close()
            self._q.join_thread()

    def close_hid_device(self):
        self.close_queue()
        if self._device and self._device.is_opened():
            self._device.close()
            self._device_open = False

    def set_receive_handle(self):
        if self._device:
            self._device.set_raw_data_handler(self.receive_handler)

    def send_string(self, transmit_string):
        convert_buffer = list(map(ord, transmit_string))
        fill_buffer = [0] * (self.BUFFER_SIZE - len(convert_buffer))
        transmit_buffer = [0]
        transmit_buffer.extend(convert_buffer)
        transmit_buffer.extend(fill_buffer)
        self.display_debug_msg("".join(["Sent: ", str(transmit_buffer)]))
        self.send_data_buffer(transmit_buffer)

    def display_debug_msg(self, msg):
        if self._debug:
            logger.debug("".join(["[D]: ", msg]))

    def display_wire_msg(self, msg):
        if self._wire_dump:
            logger.info(msg)

    def open_check_hid_device(self, index=0):
        self.open_hid_device(index)
        if not self.is_open():
            exception_str = "".join(
                [
                    "An error occurred opening the HID device.\n"
                    "The requested device with the following "
                    "specifications could not be found \n\n"
                    "Vendor ID: 0x",
                    f"{self._vendor_id:04X}",
                    "\n",
                    "Product ID: 0x",
                    f"{self._product_id:02X}",
                    "\n\n",
                    "Please make sure the dpIfGen2 board is connected.",
                ]
            )
            logger.error(exception_str)
            raise Exception(exception_str)


# --- End of File ------------------------------------------------
