from __future__ import annotations

import re
import sys

PY3 = sys.version_info > (3,)


def decode(string):
    if type(string) in (bytes, bytearray):
        try:
            return string.decode("utf-8", "strict")
        except UnicodeDecodeError:
            try:
                return string.decode("latin-1", "strict")
            except UnicodeDecodeError:
                return string.decode("utf-8", "replace")
    return string


class Memory:
    def __init__(self):
        self.address = None
        self.data = None
        self.is_valid = False

    def save(self, filename, header=""):
        adr = self.address
        with open(filename, "w") as f:
            if header != "":
                f.write("# %s\n" % header)
            for value in self.data:
                f.write(f"{adr:08X}:{value:02X}\n")
                adr += 1

    def address_get(self):
        return self.address

    def data_get(self):
        return self.data

    def data_get16(self):
        data_low = self.data[0::2]
        data_high = self.data[1::2]
        data16_zip = zip(data_low, [i << 8 for i in data_high])
        return [a + b for a, b in data16_zip]

    def data_get32(self):
        data_0 = self.data[0::4]
        data_1 = self.data[1::4]
        data_2 = self.data[2::4]
        data_3 = self.data[3::4]
        data32_zip = zip(
            data_0,
            [i << 8 for i in data_1],
            [i << 16 for i in data_2],
            [i << 24 for i in data_3],
        )
        return [a + b + c + d for a, b, c, d in data32_zip]

    def is_data_valid(self):
        return self.is_valid

    def fill_from_data(self, address, data):
        """
        :param address: memory address where the data should be placed to (starting address)
        :type address: int
        :param data: list of 8-bit integers to be written to the memory
        :type data: list
        """
        self.address = address
        self.data = data
        self.is_valid = True
        for item in self.data:
            if item > 0xFF:
                self.is_valid = False
                break

    def fill_from_data16(self, address, data):
        self.address = address
        self.data = []
        for item in data:
            self.data.append(item & 0xFF)
            self.data.append(item >> 8)

        self.is_valid = True
        for item in self.data:
            if item > 0xFF:
                self.is_valid = False
                break

    def fill_from_data32(self, address, data):
        self.address = address
        self.data = []
        for item in data:
            self.data.append(item & 0xFF)
            self.data.append((item >> 8) & 0xFF)
            self.data.append((item >> 16) & 0xFF)
            self.data.append(item >> 24)

        self.is_valid = True
        for item in self.data:
            if item > 0xFF:
                self.is_valid = False
                break

    def fill_from_text(self, text):
        """
        :param: text: memory footprint in textual format e.g. 0x20002000:10
        :type text: str
        """
        raw_text = str(text)
        line_list = raw_text.split("\n")
        first = True
        self.data = []
        line_no = 1
        for item in line_list:
            line = item.strip()
            # empty lines will not be considered
            if not len(line):
                line_no += 1
                continue
            # comment lines will not be considered
            if line.startswith("#"):
                line_no += 1
                continue

            result = re.search("([0-9a-fA-F]{8}):([0-9a-fA-F]+)", line)
            if not result:
                self.is_valid = False
                raise Exception("Parsing failed (line %d): %s" % (line_no, line))

            adr_string = result.group(1)
            value_string = result.group(2)
            # value must be 8, 16 or 32-bit
            if len(value_string) not in [2, 4, 8]:
                self.is_valid = False
                raise Exception("Value is not 8, 16 or 32-bit format (line %d)" % line_no)
            address = int(adr_string, 16)
            value = int(value_string, 16)
            # value representation must be aligned to address
            if len(value_string) == 4 and address & 0x01:
                self.is_valid = False
                raise Exception("16-bit value is not aligned to address (line %d)" % line_no)
            if len(value_string) == 8 and address & 0x03:
                self.is_valid = False
                raise Exception("32-bit value is not aligned to address (line %d)" % line_no)
            if first:
                self.address = address
                first = False
            if len(value_string) == 2:
                self.data.append(value)
            elif len(value_string) == 4:
                self.data.append(value & 0xFF)
                self.data.append((value >> 8) & 0xFF)
            elif len(value_string) == 8:
                self.data.append(value & 0xFF)
                self.data.append((value >> 8) & 0xFF)
                self.data.append((value >> 16) & 0xFF)
                self.data.append((value >> 24) & 0xFF)
            line_no += 1
        self.is_valid = True

    def print_8bit(self):
        adr = self.address
        mem_values_list = []
        for value in self.data:
            mem_values_list.append(f"{adr:08X}:{value:02X}\n")
            adr = adr + 1
        return "".join(mem_values_list)

    def print_16bit(self):
        adr = self.address
        mem_values_list = []
        length = len(self.data)
        for index in range(length >> 1):
            value_low = self.data[2 * index]
            value_high = self.data[2 * index + 1]
            value = (value_high << 8) + value_low
            mem_values_list.append(f"{adr:08X}:{value:04X}\n")
            adr = adr + 2
        return "".join(mem_values_list)

    def print_32bit(self):
        adr = self.address
        mem_values_list = []
        length = len(self.data)
        for index in range(length >> 2):
            value_low = self.data[4 * index]
            value_high = self.data[4 * index + 1]
            value_long_low = (value_high << 8) + value_low
            value_low = self.data[4 * index + 2]
            value_high = self.data[4 * index + 3]
            value_long_high = (value_high << 8) + value_low
            value = (value_long_high << 16) + value_long_low
            mem_values_list.append(f"{adr:08X}:{value:08X}\n")
            adr = adr + 4
        return "".join(mem_values_list)
