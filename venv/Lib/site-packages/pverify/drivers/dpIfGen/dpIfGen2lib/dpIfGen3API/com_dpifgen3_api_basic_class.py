#!/usr/bin/python
# ===========================================================================
# Name:        com_dpifgen3_api_basic_class.py
#
# Purpose:     Basic API for dpIFGen3 communication
#
# Author:      Philipp Fuchs (IFAG PMM SYS SWT SWI) <Philipp.Fuchs@infineon.com>
#              Langaschek Richard (IFAG PMM SYS SWT SWI) <Richard.Langaschek@infineon.com>
#
# Created:     14.09.2016
#
# Python Version: v2.7.2
#
# Dependency:
#
# ===========================================================================
# Copyright (C) 2014-2017 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#

""" This Documentation describes the .dp Interface Gen 2 (dpIfGen2) board's
    basic API to communicate with the dp3 chip. The API is
    meant to serve as an abstraction layer between the PC and the
    dp3 chip hiding the unnecessary details in the low level
    communication between the Interface board and the chip itself.
    The API has been partitioned into the following major command categories::

        1. Connection Commands
        2. Interface Commands
        3. Read Commands
        4. Write Commands
        5. Burn Commands
        6. Check Commands
        7. Other Commands
"""
from __future__ import annotations

import re
import time

from dpIfGen2lib.dpIfGen3API.com_dpifgen3_commands_list import DpIfGen3Commands as Cmds
from dpIfGen2lib.dpIfGen3API.com_dpifgen3_executor import CmdDataRead, CmdDataWrite, CmdSingle
from dpIfGen2lib.dpIfGen3API.com_dpifgen3_lld import DpIfGen3LLD
from dpIfGen2lib.dpIfGen3API.info_get import InfoGet
from dpIfGen2lib.dpIfGen3API.misc import Memory
from dpIfGen2lib.dpIfGen3API.nak_codes import NakCodes
from dpIfGen2lib.dpIfGen3API.xml_utils import XML_reader
from dpIfGen2lib.support.com_dpifgen2_validator import Validator
from dpIfGen2lib.support.config_dpifgen2_api import PrintConfigAPI
from intelhex import IntelHex


class ShowDocumentation:
    @staticmethod
    def show(obj):
        print(obj.__doc__)


class ApiSettings:
    """
    This class is internal and stores some settings.
    These settings may be modified during usage of the API.
    Reason is that the methods of the API are all static.
    """

    def __init__(self):
        # set defaults
        self.baud_rate = 9600
        # max_block_length defines the maximum number of bytes the dpIfGen2 can store with every data command
        # e.g. for memory write
        # We select a slightly smaller value, because all oder firmware versions of dpIfGen2 (v <= 3.0.23) are not
        # supporting the value they are reporting.
        self.max_block_length = 0x2000 - 16
        self.dpifgen2_version = None

    def baud_rate_set(self, baud_rate):
        self.baud_rate = baud_rate

    def baud_rate_get(self):
        return self.baud_rate

    def max_block_length_set(self, block_length):
        # We select a slightly smaller value, because all oder firmware versions of dpIfGen2 (v <= 3.0.23) are not
        # supporting the value they are reporting.
        # todo remove the reduction once it is clear that older versions are not in the field
        # or MinDpIfGen2FWVersion is set to a version supporting the reported value fully
        self.max_block_length = block_length - 16

    def max_block_length_get(self):
        return self.max_block_length

    def version_set(self, version):
        """
        Create/set a validation object with given version information.
        :param version: version string (e.g. 'dpIfGen2_V3.1.21_something')
        """
        self.dpifgen2_version = Validator(version)

    def version_get(self):
        """
        Returns a validator object containing version information of dpIfGen2 firmware
        :return: validator object
        :rtype: Validator
        """
        return self.dpifgen2_version


api_settings = ApiSettings()


class DpIfGen2APIBasicDp3Class:
    """The Detailed API is as follows:

    Connection Commands:
        1. :func:`connection_establish`
        2. :func:'sync_set'
        3. :func:`set_baud_rate`
        4. :func:'set_voltage_level'

    Read Commands:


    Write Commands:
        1. :func:``

    Burn Commands:
        1. :func:``


    Check Commands:
        1. :func:``


    Other Commands:
        1. :func:`info_get`


    """

    #: dpIfGen3 API version v1.2.1
    VERSION = "1.2.1"

    # Note: Following constants determine for which versions of the dpIfGen2 FW this API is build for.
    #       There is no check in this module, because it has no knowledge about the dpIfGen2 FW version.
    #       The check is done outside by a separate script.
    MIN_DPIFGEN2_FW_VERSION = "3.0.23"
    MAX_DPIFGEN2_FW_VERSION = "4.0.0"

    def __init__(self):
        self._lld = DpIfGen3LLD()
        self._nack_codes = NakCodes()

        self.info = InfoGet()
        for value in Cmds.INFO_TYPES.get_values():
            name = Cmds.INFO_TYPES.get_name_by_value(value)
            desc = Cmds.INFO_TYPES.get_description_by_value(value)
            self.info.add_info(name, value, desc)

        self.if_info = InfoGet()
        self.if_info.add_info("if_serial_number", self.read_if_serial_number, "Serial number of dpIfGen2")
        self.if_info.add_info("if_hw_version", self.read_if_hardware_version, "Hardware version of dpIfGen2")
        self.if_info.add_info("if_fw_version", self.read_if_firmware_version, "Firmware version of dpIfGen2")
        self.if_info.add_info("if_buf_size", self.if_buffer_size_get, "Buffer size of dpIfGen2")

    @staticmethod
    def list_of_functions():
        # Attention: it is not allowed to use a docstring here!
        #
        # Generates a list of functions (callables) which do not start with underscore.
        # All these functions may be accessed from outer world.
        #
        # E.g. The GUI is using the list for auto-completion.
        #
        # :return: list of functions

        function_list = []
        for item in dir(DpIfGen2APIBasicDp3Class):
            if not item.startswith("_"):
                attrib = getattr(DpIfGen2APIBasicDp3Class, item)
                docu = attrib.__doc__
                if callable(attrib) and docu is not None:
                    function_list.append("%s()" % item)
        return function_list

    @staticmethod
    def _get_brief(text):
        # extract first line of text
        line_list = text.split("\n") if text is not None else ["empty"]
        return line_list[0]

    @staticmethod
    def _get_class(text):
        # extract class tag from text
        pattern = re.compile("@@Class:\\s(.+)\n", re.MULTILINE)
        result = pattern.search(text)
        if result:
            return result.group(1)
        return "class"

    @staticmethod
    def _remove_attribute(text):
        t_list = text.splitlines(True)
        result = []
        for item in t_list:
            line = item.strip()
            if not line.startswith("@@"):
                result.append(item)
        return "".join(result)

    @staticmethod
    def _sort(dict_list):
        result_dict = {}
        class_list = [
            "Connection",
            "Read",
            "Write",
            "Burn",
            "Interface",
            "EEPROM",
            "Others",
        ]
        index = 1
        for Class in class_list:
            List = []
            for item in dict_list:
                if item["Class"] == Class:
                    List.append(item)
            newlist = sorted(List, key=lambda k: k["Name"])
            index2 = 1
            for item in newlist:
                name = "C{}_{}:{}".format(index, index2, item["Name"])
                result_dict[name] = item
                index2 += 1
            index += 1

        return result_dict

    # Todo move the function to a separate module common to all APIs
    @staticmethod
    def dict_of_api_functions():
        # generate and return a dictionary out of the function documentation
        dict_list = []
        for item in dir(DpIfGen2APIBasicDp3Class):
            if not item.startswith("_"):
                attrib = getattr(DpIfGen2APIBasicDp3Class, item)
                if callable(attrib):
                    item_dict = {}
                    docu = attrib.__doc__
                    if docu is not None:
                        brief = DpIfGen2APIBasicDp3Class._get_brief(docu)
                        Class = DpIfGen2APIBasicDp3Class._get_class(docu)
                        description = DpIfGen2APIBasicDp3Class._remove_attribute(docu)
                        item_dict["Name"] = brief
                        item_dict["Usage"] = "DpIfGen2APIBasicDp3.%s()" % item
                        item_dict["Description"] = description
                        item_dict["Class"] = Class
                        # Todo add attribute for color
                        dict_list.append(item_dict)
        return DpIfGen2APIBasicDp3Class._sort(dict_list)

    def open(self, index=0):
        # This function is needed to open a communication channel to a connected HID device
        # e.g. dpIfGen2 box
        # Instances of class DpIfGen2APIBasicDp3Class will not do it automatically when sending any command.
        # It must be done from outside before sending any command or multiple commands.
        # Parameter 'index' denotes the index of an array of all detected HID devices.
        # Currently only one device can be operated at the same time.
        if not self._lld.is_open():
            self._lld.open_check_hid_device(index)
            self._lld.set_receive_handle()

    def is_open(self):
        return self._lld.is_open()

    def close(self):
        if self._lld.is_open():
            self._lld.close_hid_device()

    def combo_enable(self):
        """Enable combo mode

        Combo telegrams contain both command and data and are used to
        decrease communication overhead. Thus communication speed is
        increased in case low amount of data is used.

        :return: none

        Example Usage:

        >>> self.combo_enable()

        @@Class: Others
        """
        PrintConfigAPI.instance().combo_enable()

    def combo_disable(self):
        """Disable combo mode

        Combo telegrams contain both command and data and are used to
        decrease communication overhead. Thus communication speed is
        increased in case low amount of data is used.

        :return: none

        Example Usage:

        >>> self.combo_disable()

        @@Class: Others
        """
        PrintConfigAPI.instance().combo_disable()

    def connection_establish(self, delay_before_voltage_s=0.15, delay_before_sync_s=0.4):
        """Establish Connection

        Establishes connection with the dp3 chip.

        :param delay_before_voltage_s: Delay after applying 0 V before applying default voltage (default 150ms)
        :type delay_before_voltage_s: float
        :param delay_before_sync_s: Delay after applying default voltage before sending sync (default 400ms)
        :type delay_before_sync_s: float
        :returns: none.

        Connection Establish is a combinatorial command that performs the
        following operations::

            1. Set Baudrate: Default Value (9600)
            2. Set Voltage: 0V to trigger power on reset (aka POR)
            3. Set Voltage: Default Value (Voltage 12V)
            4. Set Sync: Default Value (3 Sync tries)

        .. note::

           This module will be the only command you need to start communication
           with the chip if you do not have any special requirements.

        Example Usage:

        >>> self.connection_establish()

        @@Class: Connection
        """

        # With every new connection, scan the HID devices again, because it could be
        # that somebody re-connected the interface box. Especially this can happen
        # if the GUI has not been restarted after re-connecting the interface box.
        self._lld.scan_devices()

        self.set_baud_rate(api_settings.baud_rate_get())
        self.voltage_level_set(0)
        time.sleep(delay_before_voltage_s)  # delay e.g. for shutting down external RAM
        self.voltage_level_set(12)
        time.sleep(delay_before_sync_s)  # delay e.g. for booting from eeprom
        self.sync_set(3)
        # see DP3-1572: UART Commands are timing out after sending protocol ID get command
        # Note: New versions of dpIfGen2 are requesting the protocl ID with the first sync.
        #       Therefore we send another synch to heal the system again.
        #       The issue only applies to ROM version 2.2
        self.sync_set(3)

    def sync_set(self, num_tries=3):
        """Set Sync

        Synchronizes the baudrate with the dp3 chip.

        :param num_tries: Number of tries to perform the synchronization
        :type num_tries: int

        :returns:  none.

        This command is used to establish a common communication baudrate with
        the dp3 chip. Number of synchronization attempts can be configured.
        Default value is 3. Maximum value is 100.

        .. warning::

            This command requires some knowledge about the dpIFGen3 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.

        Example Usage:

        >>> self.sync_set()
        >>> self.sync_set(4)

        @@Class: Connection
        """
        if num_tries not in range(1, 100, 1):
            msg = "Number of Sync-tries not in valid Range!"
            raise Exception(msg)
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.SYNC)
        cmd.add_16bit_parameter(num_tries)
        # todo move exception handling to executor everywhere, because it is always the same
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def set_baud_rate(self, baud_rate=57600):
        """Set Baud Rate

        Sets the communication baudrate.

        :param baud_rate: The selected baudrate for communication with dp3
        :type baud_rate: int

        :returns: none.

        .. note::

           9600 is the standard baudrate for communication with the chip.
           Other supported baudrates include::

            * 9600
            * 19200
            * 38400
            * 57600
            * 82000
            * 105000
            * 115200

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip. Otherwise a
            synchronization command is necessary after selecting the baudrate.

        Example Usage:

        >>> self.set_baud_rate()
        >>> self.set_baud_rate(9600)

        @@Class: Connection
        """
        allowed_baud_rates = [9600, 19200, 38400, 57600, 82000, 105000, 115200]
        if baud_rate in allowed_baud_rates:
            baudrate_selected = allowed_baud_rates.index(baud_rate)
        else:
            raise Exception("Baud_rate %s ist not allowed." % baud_rate)
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.SET_SERIALPORT_PARAMETER)
        cmd.add_16bit_parameter(1)  # indicates that the second parameter is the baud rate
        cmd.add_16bit_parameter(baudrate_selected)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        # store the knowledge about the configured baudrate
        api_settings.baud_rate_set(baud_rate)

    def voltage_level_set(self, v_level=12):
        """Set Voltage Level

        Sets the voltage level of interface board to a constant level.

        :param v_level: Constant voltage level for the dpIFGen2 Board.
        :type v_level: float

        :returns: none

        This command is used to supply a constant voltage level to the dpIFGen2
        interface board. Setting the voltage level to zero can be regarded as
        a special case of clearing the voltage.

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip.
            A too high voltage can destroy the device.

        Example Usage:

        >>> self.voltage_level_set(12)
        >>> self.voltage_level_set()

        @@Class: Connection
        """

        if v_level * 10 not in range(0, 300, 1):
            msg = "Voltage Level not in valid range!"
            raise Exception(msg)
        voltage = f"{v_level:.1f}"
        voltage_dec = int(float(voltage) * 10)
        parameter = voltage_dec

        cmd = CmdSingle(self._lld)
        cmd.set_timeout(5)
        cmd.set_command_string(Cmds.SET_VOLTAGE_LEVEL)
        cmd.add_16bit_parameter(parameter)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def if_configuration_set(self, param_list):
        """Configure interface box

        Send a command to configure the interface box.

        :param param_list: list of arguments to be sent to the interface box
        :type param_list: list of int

        :returns: none.

        .. note::

            Currently following parameter combinations are known:
            param_list[0] | param_list[1] | note
            1             | 0..6          | index of baud rate: 0=9600
            2             | 0 or 1        | 0=UART off, 1=UART on
            3             | 0 or 1        | 0=edge boos off, 1=edge boost on
            4             | 0 or 1        | 0=ignore UART short off, 1=ignore UART short on

        .. warning::

            This command requires some knowledge about the dpIFGen2 board.
            It is highly recommended to use the  :func:`connection_establish`
            command for establishing communication with the chip. Otherwise a
            synchronization command is necessary after selecting the baudrate.

        Example Usage:

        >>> self.if_configuration_set([1, 0])

        @@Class: Interface
        """
        if len(param_list) < 2:
            msg = "Not enough parameters provided!"
            raise Exception(msg)
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.SET_SERIALPORT_PARAMETER)
        cmd.add_16bit_parameter(param_list[0])
        cmd.add_16bit_parameter(param_list[1])
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def if_buffer_size_get(self):
        """Read Interface Buffer Size

        Reads size of buffer of interface box.
        Read value will be used for write commands to take advantage of the maximum buffer size.

        :returns: size of buffer as int

        Example Usage:

        >>> if_buffer_size = self.if_buffer_size_get()

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.HOST_BUFFER_SIZE_GET)

        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

        value_string = cmd.get_data_as_string()
        value_string_low = f"{value_string[0]}{value_string[1]}"
        value_string_high = f"{value_string[2]}{value_string[3]}"
        value_low = int(value_string_low, 16)
        value_high = int(value_string_high, 16)
        buffer_size = value_low + (value_high << 8)
        api_settings.max_block_length_set(buffer_size)
        return buffer_size

    def read_if_serial_number(self):
        """Read Interface Serial Number

        Reads the serial number from the interface box.

        :returns: serial number as string

        Each interface box has a unique serial number.

        Example Usage:

        >>> if_sn = self.read_if_serial_number()

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.READ_SERIALNUMBER)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        return cmd.get_data_as_string()

    def write_if_serial_number(self, param_string):
        """Write Interface Serial Number

        Writes the serial number to the interface box.

        :param param_string: new serial number
        :type param_string: string
        :returns: None

        Each interface box has a unique serial number.

        Example Usage:

        >>> self.write_if_serial_number("12345678")

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.WRITE_SERIALNUMBER)
        cmd.add_parameter_as_string(param_string)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def read_if_hardware_version(self):
        """Read Interface Hardware Version

        Reads the hardware version from the interface box.

        :returns: hardware version number as string

        Example Usage:

        >>> if_hw = self.read_if_hardware_version()

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.READ_HARDWARE_VERSION)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        return cmd.get_data_as_string()

    def write_if_hardware_version(self, param_string):
        """Write Interface Hardware Version

        Writes the hardware version number to the interface box.

        :param param_string: new hardware version number
        :type param_string: string
        :returns: None

        Example Usage:

        >>> self.write_if_hardware_version("12345678")

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.WRITE_HARDWARE_VERSION)
        cmd.add_parameter_as_string(param_string)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def read_if_firmware_version(self):
        """Read Interface Firmware Version

        Reads the firmware version from the interface box.

        :returns: firmware version number as string

        Example Usage:

        >>> if_fw = self.read_if_firmware_version()

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.READ_FIRMWARE_VERSION)
        if not cmd.execute(True):
            raise Exception(self._decode_error_code(cmd.requested_data))
        version = cmd.get_data_as_string()
        api_settings.version_set(version)
        return version

    def if_info_get(self):
        """Read Interface Information

        Reads all version info from the interface box.

        :rtype: dict
        :returns: serial number, hardware and firmware version, size of buffer, etc.

        Example Usage:

        >>> if_info = self.if_info_get()

        @@Class: Interface
        """
        default_string = "NA"
        info_out = {}
        for name in self.if_info.get_info_names():
            key = self.if_info.description_get(name)
            try:
                function = self.if_info.info_code_get(name)
                value_string = function()
                self.info.result_set(name, value_string)
                info_out[key] = value_string
            except Exception:
                info_out[key] = default_string

        # todo after alignment with teams change the return value of the function
        #      return 'info'-class instead of info_out dictionary
        #      then the user can access all infos via get-methods
        return info_out

    def chip_info_get_single(self, param):
        """Read Single Chip Information

        Reads given information from the device.

        :param param: info code
        :type param: int
        :returns: requested information as string

        Example Usage:

        >>> chip_info = self.chip_info_get_single(0x14)
        @@Class: Others
        """
        # todo check for valid param range
        cmd = CmdDataRead(self._lld)
        if PrintConfigAPI.instance().is_combo_enabled():
            cmd.set_command_string(Cmds.GET_INFO_COMBO)
        else:
            cmd.set_command_string(Cmds.GET_INFO)
        cmd.add_16bit_parameter(param)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        return cmd.get_answered_data_as_string()

    def chip_info_get_single_raw(self, param):
        """Read Single Chip Information (Raw)

        Reads given information from the device.

        :param param: info code
        :type param: int
        :returns: requested information as byte list

        Example Usage:

        >>> chip_info_raw = self.chip_info_get_single_raw(0x14)

        @@Class: Others
        """
        cmd = CmdDataRead(self._lld)
        if PrintConfigAPI.instance().is_combo_enabled():
            cmd.set_command_string(Cmds.GET_INFO_COMBO)
        else:
            cmd.set_command_string(Cmds.GET_INFO)
        cmd.add_16bit_parameter(param)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        return cmd.requested_data

    def chip_info_get(self):
        """Read Chip Information

        Reads all available information from the device.

        :returns: all information as dictionary
        :rtype: dict key=string, value=string

        Example Usage:

        >>> chip_info_full = self.chip_info_get()

        @@Class: Others
        """
        default_string = "NA"
        info_out = {}
        for name in self.info.get_info_names():
            key = self.info.description_get(name)
            try:
                value_string = self.chip_info_get_single(self.info.info_code_get(name))
                self.info.result_set(name, value_string)
                info_out[key] = value_string
            except Exception:
                info_out[key] = default_string

        # todo after alignment with teams change the return value of the function
        #      return 'info'-class instead of info_out dictionary
        #      then the user can access all infos via get-methods
        return info_out

    def is_fw_running_in_ram(self):
        """Run in RAM?

        Check if firmware on the device is running in RAM or ROM.

        .. note::
            Before downloading a firmware to the device it must be ensured that
            the device is running from ROM. Otherwise the firmware could crash.

        :return: True or False

        Example Usage:

        >>> run_in_ram = self.is_fw_running_in_ram()

        @@Class: Others
        """
        result = self.chip_info_get_single_raw(Cmds.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_RUN_IN_RAM"))
        return result[0] != 0

    def app_status_get(self):
        """Get Application Status

        Read the application status from the device.

        :return: application status as list of bytes

        Example Usage:

        >>> status = self.app_status_get()

        @@Class: Others
        """
        return self.chip_info_get_single_raw(Cmds.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_FW_STATUS"))

    def protocol_id_get(self):
        """Get Protocol ID

        Reads protocol ID from the device.

        :returns: protocol ID as string

        Example Usage:

        >>> id_prot = self.protocol_id_get()

        @@Class: Others
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.PROTOCOL_ID)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        # see DP3-1572: UART Commands are timing out after sending protocol ID get command
        # Note: New versions of dpIfGen2 are requesting the protocl ID with the first sync.
        #       Therefore we send another synch to heal the system again.
        #       The issue only applies to ROM version 2.2
        self.sync_set()
        return cmd.get_data_as_string()

    def read_memory(self, address, length):
        """Read Memory

        Reads data from memory of the device.

        :param address: memory address
        :type address: int
        :param length: amount of bytes to be read
        :type length: int

        :return: read data in 8-bit format
        :rtype: list

        Example Usage:

        >>> data = self.read_memory(0x20002000, 100)

        @@Class: Read
        """
        read_data = []
        max_block_length = api_settings.max_block_length_get()

        while length > max_block_length:
            cmd = CmdDataRead(self._lld)
            cmd.set_command_string(Cmds.MEMORY_READ)
            cmd.set_timeout(self._timeout_get(max_block_length))
            cmd.add_32bit_parameter(address)
            cmd.add_16bit_parameter(max_block_length)
            if not cmd.execute():
                raise Exception(self._decode_error_code(cmd.requested_data))
            read_data.extend(cmd.requested_data)
            address += max_block_length
            length -= max_block_length
        cmd = CmdDataRead(self._lld)
        # todo remove magic value
        if length <= 48 and PrintConfigAPI.instance().is_combo_enabled():
            cmd.set_command_string(Cmds.MEMORY_READ_COMBO)
        else:
            cmd.set_command_string(Cmds.MEMORY_READ)
        cmd.set_timeout(self._timeout_get(length))
        cmd.add_32bit_parameter(address)
        cmd.add_16bit_parameter(length)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        read_data.extend(cmd.requested_data)
        return read_data

    def read_memory16(self, address, length):
        """Read Memory 16-bit

        Reads data from memory of the device.

        :param address: memory address
        :type address: int
        :param length: amount of 16-bit words to be read
        :type length: int

        :return: read data in 16-bit format
        :rtype: list

        Example Usage:

        >>> data = self.read_memory16(0x20002000, 50)

        @@Class: Read
        """
        if address & 0x01:
            msg = "Address is not word aligned (16-bit)"
            raise Exception(msg)
        data = self.read_memory(address, length * 2)
        mem = Memory()
        mem.fill_from_data(address, data)
        return mem.data_get16()

    def read_memory32(self, address, length):
        """Read Memory 32-bit

        Reads data from memory of the device.

        :param address: memory address
        :type address: int
        :param length: amount of 32-bit words to be read
        :type length: int

        :return: read data in 32-bit format
        :rtype: list

        Example Usage:

        >>> data = self.read_memory32(0x20002000, 25)

        @@Class: Read
        """
        if address & 0x01:
            msg = "Address is not word aligned (32-bit)"
            raise Exception(msg)
        data = self.read_memory(address, length * 4)
        mem = Memory()
        mem.fill_from_data(address, data)
        return mem.data_get32()

    def write_memory(self, address, data):
        """Write Memory

        Write data to specified memory location of the device.

        :param address: memory address
        :type address: int
        :param data: memory data in 8-bit format
        :type data: list of int

        :return: none

        Example Usage:

        >>> self.write_memory(0x200020000, [0x01, 0x02, 0x03])

        @@Class: Write
        """
        for x in data:
            if x > 0xFF:
                raise Exception("Value %s is too big. Data range 0x00 - 0xff!" % hex(x))
        cmd = CmdDataWrite(self._lld)
        cmd.set_command_string(Cmds.MEMORY_WRITE)
        cmd.set_timeout(self._timeout_get(len(data)))
        cmd.add_32bit_parameter(address)
        cmd.add_16bit_parameter(len(data))
        cmd.add_data(data)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.get_answer()))

    def write_memory16(self, address, data):
        """Write Memory 16-bit

        Write data to specified memory location of the device.

        :param address: memory address
        :type address: int
        :param data: memory data in 16-bit format
        :type data: list of int

        :return: none

        Example Usage:

        >>> self.write_memory16(0x200020000, [0x1000, 0x1002, 0x1003])

        @@Class: Write
        """
        if address & 0x01:
            msg = "Address is not word aligned (16-bit)"
            raise Exception(msg)
        mem = Memory()
        mem.fill_from_data16(address, data)
        self.write_memory(address, mem.data_get())

    def write_memory32(self, address, data):
        """Write Memory 32-bit

        Write data to specified memory location of the device.

        :param address: memory address
        :type address: int
        :param data: memory data in 32-bit format
        :type data: list of int

        :return: none

        Example Usage:

        >>> self.write_memory32(0x200020000, [0x100000, 0x100002, 0x100003])

        @@Class: Write
        """
        if address & 0x03:
            msg = "Address is not word aligned (32-bit)"
            raise Exception(msg)
        mem = Memory()
        mem.fill_from_data32(address, data)
        self.write_memory(address, mem.data_get())

    def read_transparent(self, command):
        """Read Transparent

        Reads data from the device assuming a read command.

        :param command: command to be sent to device
        :type command: list of int

        :return: read data as byte list

        Example Usage:

        >>> self.read_transparent([0x40,0x0B,..])

        @@Class: Others
        """
        read_data = []

        cmd = CmdDataRead(self._lld)
        cmd.set_command_string(Cmds.TRANSPARENT_READ)
        cmd.set_timeout(self._timeout_get(api_settings.max_block_length_get()))
        for byt in command:
            cmd.add_8bit_parameter(byt)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        read_data.extend(cmd.requested_data)
        return read_data

    def write_transparent(self, command, data):
        """Write Transparent

        Send a command transparently to the device assuming a write command.

        :param command: command to be sent to device
        :type command: list of int
        :param data: data to be sent to device
        :type data: list of int

        :return: none

        Example Usage:

        >>> self.write_transparent([0x40,0x09,..], [0x01, 0x02, 0x03])

        @@Class: Others
        """
        for x in command:
            if x > 255:
                raise Exception("Value %s is to big. Data range 0x00 - 0xff!" % hex(x))
        for x in data:
            if x > 255:
                raise Exception("Value %s is to big. Data range 0x00 - 0xff!" % hex(x))
        if len(data):
            cmd = CmdDataWrite(self._lld)
            cmd.combo_disable()
            cmd.set_command_string(Cmds.TRANSPARENT_WRITE)
        else:
            cmd = CmdSingle(self._lld)
            cmd.set_command_string(Cmds.TRANSPARENT_EXECUTE)
        cmd.set_timeout(self._timeout_get(len(data)))
        for byte in command:
            cmd.add_8bit_parameter(byte)
        if len(data):
            cmd.add_data(data)
        cmd.execute()

    def execute_transparent(self, command):
        """Execute Transparent

        Sends a command to the device assuming a single execution command.

        :param command: command to be sent to device
        :type command: list of int

        :return: none

        Example Usage:

        >>> self.execute_transparent([0x7F])

        @@Class: Others
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.TRANSPARENT_EXECUTE)
        for byt in command:
            cmd.add_8bit_parameter(byt)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def record_read(self, record_type):
        """Read Record

        Read a record of given type from the device.

        :param record_type: record ID
        :type record_type: int

        :return: record data as list of bytes

        Example Usage:

        >>> record = self.record_read(0x01)

        @@Class: Read
        """
        cmd = CmdDataRead(self._lld)
        if PrintConfigAPI.instance().is_combo_enabled():
            cmd.set_command_string(Cmds.RECORD_READ_COMBO)
        else:
            cmd.set_command_string(Cmds.RECORD_READ)
        cmd.add_16bit_parameter(record_type)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        return cmd.requested_data

    def record_write(self, record_type, data):
        """Write Record

        Write a record of given type to the device.

        :param record_type: record ID
        :type record_type: int
        :param data: record data
        :type data: list of int

        :return: none

        Example Usage:

        >>> self.record_write(0x01, [0x01, 0x02, 0x03])

        @@Class: Write
        """
        cmd = CmdDataWrite(self._lld)
        cmd.set_command_string(Cmds.RECORD_WRITE)
        cmd.set_timeout(self._timeout_get(len(data)))
        cmd.add_16bit_parameter(record_type)
        cmd.add_16bit_parameter(len(data))
        cmd.add_data(data)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.get_answer()))

    def record_write_xml(self, filename, record_type=3):
        """Write Record XML

        Write a record given by XML file to the device.

        :param filename: name of XML file
        :type filename: str
        :param record_type: type of record to write (default 3)
        :type record_type: int

        :return: none

        Example Usage:

        >>> self.record_write_xml('use_case_306.xml')
        >>> self.record_write_xml('use_case_306_with_patch.xml', 1)

        @@Class: Write
        """
        instance = XML_reader(filename, record_type)
        data = instance.get_data()
        record_type = instance.get_record_type()
        self.record_write(record_type, data)

    def record_write_hex(self, filename, record_type=1):
        """Write Record Intel Hex

        Write a record given by Intel Hex file to the device (e.g. patch).

        :param filename: name of HEX file
        :type filename: str
        :param record_type: type of record to write (default 1)
        :type record_type: int

        :return: none

        Example Usage:

        >>> self.record_write_hex('patch.hex')

        @@Class: Write
        """
        mp = MemoryPartitioner(api_settings.max_block_length_get())
        mp.add_data_from_file(filename)
        if len(mp.get_block_list()) > 1:
            msg = "Data from HEX file cannot be written as a single block."
            raise Exception(msg)
        else:
            for start, size in mp.get_block_list():
                data = mp.get_data(start, size)
                self.record_write(record_type, data)

    def record_burn(self, record_type, data):
        """Burn Record

        Burn record of given type to the device (OTP).

        :param record_type: record ID
        :type record_type: int
        :param data: record data
        :type data: list of int

        :return: none

        Example Usage:

        >>> self.record_burn(0x01, [0x01, 0x02, 0x03])
        >>> self.record_burn(0x01, []) # invalidate record

        @@Class: Burn
        """
        # Record invalidate command is available since version 3.1.1
        dpIfGen2Version = api_settings.version_get()
        if dpIfGen2Version is not None and dpIfGen2Version.validate_less("3.1.1") and len(data) == 0:
            msg = "Command without data not supported"
            raise Exception(msg)

        cmd = CmdDataWrite(self._lld)
        cmd.set_command_string(Cmds.RECORD_BURN)
        cmd.set_timeout(self._timeout_get(len(data)))
        cmd.add_16bit_parameter(record_type)
        cmd.add_16bit_parameter(len(data))
        cmd.add_data(data)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.get_answer()))

    def record_burn_xml(self, filename, record_type=3):
        """Burn Record XML

        Burn a record given by XML file to the device.

        :param filename: name of XML file
        :type filename: str
        :param record_type: type of record to burn (default 3)
        :type record_type: int

        :return: none

        Example Usage:

        >>> self.record_burn_xml('use_case_306.xml')
        >>> self.record_burn_xml('use_case_306_with_patch.xml', 1)

        @@Class: Burn
        """
        instance = XML_reader(filename, record_type)
        data = instance.get_data()
        record_type = instance.get_record_type()
        self.record_burn(record_type, data)

    def record_burn_hex(self, filename, record_type=1):
        """Burn Record Intel Hex

        Burn a record given by Intel Hex file to the device (e.g. patch).

        :param filename: name of HEX file
        :type filename: str
        :param record_type: type of record to write (default 1)
        :type record_type: int

        :return: none

        Example Usage:

        >>> self.record_burn_hex('patch.hex')

        @@Class: Burn
        """
        mp = MemoryPartitioner(api_settings.max_block_length_get())
        mp.add_data_from_file(filename)
        if len(mp.get_block_list()) > 1:
            msg = "Data from HEX file cannot be burnt as a single block."
            raise Exception(msg)
        else:
            for start, size in mp.get_block_list():
                data = mp.get_data(start, size)
                self.record_burn(record_type, data)

    def app_reset(self):
        """Reset Application

        Send application reset command to device.
        This triggers a digital reset (aka soft start) of the device.

        :return: none

        Example Usage:

        >>> self.app_reset()

        @@Class: Others
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.APP_RESET)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        # the device needs some time to boot again
        # EEPROM boot takes about 400us (just in case the RAM has been invalidated before)
        # todo add time as parameter
        # Since ROM 2.2 the delay must be higher because of structural changes -> increase by one second
        time.sleep(1.6)
        # todo think about to add a sync here

    def app_stop(self):
        """Stop Application

        Send application stop command to the device.

        :return: none

        Example Usage:

        >>> self.app_stop()

        @@Class: Others
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.APP_STOP)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
            # return cmd.get_data_as_string()

    def write_hex_file(self, file_path):
        """Write Hex File

        Write image to device retrieved from given file (IntelHex format).
        Data is written to memory directly.

        :param file_path: file path
        :type file_path: string

        :return: none

        Example Usage:

        >>> self.write_hex_file("c:/test/image.hex")

        @@Class: Write
        """
        mp = MemoryPartitioner(api_settings.max_block_length_get())
        mp.add_data_from_file(file_path)
        for start, size in mp.get_block_list():
            data = mp.get_data(start, size)
            self.write_memory(start, data)

    def write_eeprom(self, file):
        """Write Image File to EEPROM

        Download image to RAM of the device, stores image to EEPROM and invalidates RAM.

        :param file: file path
        :type file: string

        :return: none

        Example Usage:

        >>> self.write_eeprom("c:/test/image.hex")

        @@Class: EEPROM
        """
        self.write_hex_file(file)
        self.store_fw()
        self.store_fw(2)

    def store_fw(self, command=0):
        """Store Firmware

        Stores firmware (i.e. RAM content of device) into EEPROM.
        It is assumed that a valid firmware already has been downloaded to the device.

        command = 0: Store firmware from RAM to EEPROM (default)
        command = 1: Erase EEPROM
        command = 2: Invalidate RAM
        command = 3: Store APARAMs to EEPROM

        .. note::
            Invalidation of RAM will only destroy the signature in RAM.
            If the device is restarted (by method app_reset) by a digital reset (aka soft start),
            it will find invalid content in RAM and will boot from EEPROM or ROM again.

        :param command: store/erase EEPROM or invalidate RAM
        :type command: int

        :return: none

        Example Usage:

        >>> self.store_fw()

        @@Class: EEPROM
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.STORE_FW)
        # storing of data to EEPROM will take some time
        # todo add time as parameter
        cmd.set_timeout(5)
        cmd.add_16bit_parameter(command)
        cmd.add_16bit_parameter(0)
        cmd.add_32bit_parameter(0)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))

    def dump_ram(self, file_path, address=0x20002000, length=0x8000):
        """Dump RAM

        Dump memory of device to given file.

        :param file_path: file path
        :type file_path: string
        :param address: memory address
        :type address: int
        :param length: amount of bytes to dump
        :type length: int

        :return: none

        Example Usage:

        >>> self.dump_ram("./out.dump", 0x20002000, 4000)

        @@Class: Read
        """
        mem = Memory()
        ram_dump = self.read_memory(address, length)
        mem.fill_from_data(address, ram_dump)
        mem.save(file_path, header="RAM DUMP of DP3")

    def wire_dump_enable(self):
        """Enable Wire Dump

        Enables wire dumping for debugging.

        :return: none

        Example Usage:

        >>> self.wire_dump_enable()

        @@Class: Others
        """
        PrintConfigAPI.instance()._enable_wire_dumping()

    def wire_dump_disable(self):
        """Disable Wire Dump

        Disables wire dumping for debugging.

        :return: none

        Example Usage:

        >>> self.wire_dump_disable()

        @@Class: Others
        """
        PrintConfigAPI.instance()._disable_wire_dumping()

    def ping(self, pattern):
        """Ping

        Send ping command to device. The device should echo the specified pattern in the response.

        :param pattern: pattern to be sent
        :type pattern: int

        :return: echoed pattern as int

        Example Usage:

        >>> echo = self.ping(0x1234)

        @@Class: Others
        """
        cmd = CmdDataRead(self._lld)
        cmd.set_command_string(Cmds.PING)
        cmd.set_timeout(1)
        cmd.add_16bit_parameter(pattern)
        if not cmd.execute():
            raise Exception(self._decode_error_code(cmd.requested_data))
        return cmd.requested_data

    def stress_write_read(self):
        """Stress Test

        Trigger stress test between interface box and device.

        .. note::
            Please make sure the firmware of the device is not running from RAM before
            sending this command

        :return: record data as list of bytes

        Example Usage:

        >>> self.stress_write_read()

        @@Class: Others
        """
        cmd = CmdSingle(self._lld)
        cmd.set_timeout(100)
        cmd.set_command_string(Cmds.STRESS_DP3)
        cmd.add_16bit_parameter(10)
        result = cmd.execute()
        if not result:
            raise Exception(self._decode_error_code(cmd.requested_data))
        return result

    def tristate_control(self, control):
        """Do tristate control

        Controls the tristate feature for UART and VCC output.

        :param control: parameter for setting the output state
        :type control: int

        :returns:  none.

        This command is used to control the output state of the UART and VCC output.

        The three LSBs are available to control the output state:
        * bit0: if 1, the command targets VCC
        * bit1: if 1, the command targets UART
        * bit2: 1 enters tristate mode, 0 leaves tristate mode

        Example Usage:

        >>> self.tristate_control(5)

        @@Class: Others
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.VCC_UART_STATUS_CONTROL)
        cmd.add_16bit_parameter(control)
        result = cmd.execute()
        if not result:
            raise Exception(self._decode_error_code(cmd.requested_data))

    def timeout_config(self, t_type, value):
        """Interface timeout config

        Configure the Timeout of the DpIfGen2

        :param t_type: 0 Default; 1 Burn; 2 Generic
        :type t_type: int
        :param value: in ms (1ms ... 65s)
        :type value: int
        :return: none

        This command sets the timeout on .dpIfGen2.

        Example Usage:

        >>> self.timeout_config(1, 100)

        @@Class: Interface
        """
        cmd = CmdSingle(self._lld)
        cmd.set_command_string(Cmds.IF_TIMEOUT_CONFIG)
        cmd.add_16bit_parameter(t_type)
        cmd.add_16bit_parameter(value)
        result = cmd.execute()
        if not result:
            raise Exception(self._decode_error_code(cmd.requested_data))

    #########################################################################
    ############### Helper Functions ########################################
    #########################################################################
    @staticmethod
    def _timeout_get(length_in_bytes):
        """
        Calculate timeout depending on amount of data and selected baudrate

        :param length_in_bytes: amount of bytes to be considered for timeout calculation
        :return: timeout value in seconds
        """
        baud_rate = api_settings.baud_rate_get()
        # - each byte is transferred with one start and one stop bit i.e. 10 bits per byte
        # - we assume that DP3 polls the incoming bytes every 512us, it is polled in background i.e.
        #   there is some jitter. To be on the safe side we assume 768ms as mean value.
        # - we consider some constant delay of the interface box of 1 second
        time_us = (10000000 / baud_rate + 768) * length_in_bytes
        if time_us < 800000:
            time_us = 800000
        # we consider some margin (+25%)
        return time_us / 800000 + 1
        # print("time for %d bytes calculated to %d seconds" % (length_in_bytes, result_s))

    def _decode_error_code(self, error_raw_data):
        """
        :type error_raw_data: list
        """
        error_decoded = None

        error_raw_reduced = []
        for item in error_raw_data:
            if item != 0:
                error_raw_reduced.append(chr(item))
            else:
                break
        error_str = "".join(error_raw_reduced)

        if error_str.startswith("NAK") and len(error_str) >= 7:
            error_code = error_str[3:7]

            result = re.search("[0-9a-fA-F]{4}", error_code)
            if result:
                code_string_low = result.group()[0:2]
                code_string_high = result.group()[2:4]
                code_string = "".join([code_string_high, code_string_low])
                code_value = int(code_string, 16)
                if (code_value & 0xFF) == 0xFF:
                    # These messages are coming from the dpIFGen2 board only.
                    err_name = self._nack_codes.get_name(code_value)
                    err_desc = self._nack_codes.get_description(code_value)
                    err_action = self._nack_codes.get_action(code_value)

                    error_decoded = "".join(
                        [
                            error_str,
                            "\nError Details: \n",
                            "ERROR NAME: ",
                            err_name,
                            "\n",
                            "ERROR DESCRIPTION: ",
                            err_desc,
                            "\n",
                            "ERROR ACTION: ",
                            err_action,
                            "\n",
                        ]
                    )
                elif (code_value & 0xFF) == 0:
                    # These messages are coming from the device directly.
                    nibble_high = code_string_low[0]
                    if nibble_high in ["7", "B", "F"]:
                        # replace the lower nibble with 'X'
                        code_string_low = "".join([code_string_low[0], "X"])
                    if code_string_low in Cmds.NACK_LIST_DP3:
                        dpifgen2_err = Cmds.NACK_LIST_DP3.get(code_string_low)
                        err_name = dpifgen2_err.get("Name")
                        err_desc = dpifgen2_err.get("Description")
                        err_action = dpifgen2_err.get("Action")

                        error_decoded = "".join(
                            [
                                error_str,
                                "\nError Details: \n",
                                "ERROR NAME: ",
                                err_name,
                                "\n",
                                "ERROR DESCRIPTION: ",
                                err_desc,
                                "\n",
                                "ERROR ACTION: ",
                                err_action,
                                "\n",
                            ]
                        )
                    else:
                        error_string = "Unknown Error Code. This indicates that the NAK list is not up to date."
                        error_decoded = "".join([error_str, "Error Details: ", "\n", error_string])

                else:
                    error_string = "Unknown Error Code. This indicates that the NAK list is not up to date."
                    error_decoded = "".join([error_str, "Error Details: ", "\n", error_string])

        return error_decoded

    @staticmethod
    def display_msg(msg, parent=None):
        if not parent:
            print("".join(["[I]: ", msg]))


class MemoryPartitioner:
    def __init__(self, max_length=0x2000):
        self.memory_dict = {}
        self.MAX_BLOCK_LENGTH = max_length
        self.block_list = []

    def add_data_from_file(self, file_path):
        self.memory_dict = self.extract_data_from_hex_file(file_path)
        self.create_block_list()

    def add_data_from_dict(self, a_dict):
        self.memory_dict = a_dict
        self.create_block_list()

    def get_data(self, start, size):
        data = []
        address = start
        for _i in range(size):
            data.append(self.memory_dict[address])
            address += 1
        return data

    def get_block_list(self):
        return self.block_list

    def create_block_list(self):
        address_list = self.memory_dict.keys()
        address_list = sorted(address_list)
        if len(address_list):
            adr_start = address_list[0]
            adr_prev = adr_start
            adr_expected = adr_start
            count = 0
            for address in address_list:
                if (address == adr_expected) and (count != self.MAX_BLOCK_LENGTH):
                    adr_prev = address
                    adr_expected += 1
                    count += 1
                    continue
                else:
                    self.block_list.append((adr_start, adr_prev - adr_start + 1))
                    adr_start = address
                    adr_prev = adr_start
                    adr_expected = adr_start + 1
                    count = 1
            self.block_list.append((adr_start, adr_prev - adr_start + 1))

    def extract_data_from_hex_file(self, file_path):
        try:
            ih = IntelHex()
            ih.fromfile(file_path, "hex")
            pydict = ih.todict()
            del pydict["start_addr"]
            return pydict
        except Exception:
            msg = "An exception occurred while extracting data from the hex file. Check Format of hex file!"
            raise Exception(msg)


def main():
    print("This script is not executable. It contains library functions only.")
    print("Version", DpIfGen2APIBasicDp3Class.VERSION)


if __name__ == "__main__":
    main()


# --- End of File ------------------------------------------------
