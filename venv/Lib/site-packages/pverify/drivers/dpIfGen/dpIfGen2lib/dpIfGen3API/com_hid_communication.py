#!/usr/bin/python
# ===========================================================================
# Name:        com_hid_communication.py
#
# Purpose:     A wrapper class to enable easier communication using HID
#              interface
#
# Author:      Aslam Faizan Muhammad (IFAG PMM SYS SWT SWI)
#                                       <Faizan.Aslam@infineon.com>
# Created:     26.06.2014
#
# Python Version: v2.7.2
#
# Dependency: pywinusb, argparse
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
""" This Documentation describes the basic HID (Human Interface Device)
    library implemented in Python.

    The library allows the user to open and close an HID, to send
    data to and receive data from an open HID.

    The user can set the HID configuration either through the command line or
    using the class members. The configuration includes vendor and product IDs
    which are used to identify an HID.
"""
from __future__ import annotations

import argparse

import pywinusb.hid as hid
from dpIfGen2lib.support.logger import logger


class HIDCommunication:
    """
    The following arguments from the command line are supported:
        1. **-vid/- -vendor_id** Sets the vendor ID for the HID
        2. **-pid/- -product_id** Sets the product ID for the HID
        3. **-v/- -verbose** Displays additional information during execution of the script.
        4. **-d/- -debug** Displays debug information to verify/debug script functionality.
        5. **-V/- -version** Displays the current version of the script


    Example Usage:

        >>> com_hid_communication.py -vid 1419 -pid 544
        >>> com_hid_communication.py -vid 1419 -pid 544 -v -d
    """

    #: hid communication library v1.0.2
    VERSION = "1.0.2"

    #: Buffer Size of HID communication packet
    BUFFER_SIZE = 64

    def __init__(self):
        """Initialize the class. Default values for the HID variables."""
        self._vendor_id = 0x058B
        self._product_id = 0x0220
        self._device_open = False
        # currently used device
        self._device = None
        self._verbose = False
        self._debug = False
        # list of all found devices
        self._all_devices = []
        self.scan_devices()

    def parse_arguments(self):
        parser = argparse.ArgumentParser(description=self.__doc__)
        # Parsing for two arguments from the command line
        group_basic = parser.add_argument_group("Options")
        group_basic.add_argument("-vid", "--vendor_id", help="Vendor Id", type=int, required=False)
        group_basic.add_argument("-pid", "--product_id", help="Product Id", type=int, required=False)
        group_basic.add_argument(
            "-v",
            "--verbose",
            help="provide additional printout",
            action="store_true",
            required=False,
        )
        group_basic.add_argument(
            "-d",
            "--debug",
            help="provide debug information",
            action="store_true",
            required=False,
        )

        args = parser.parse_args()

        # assign argument values to class variables
        # if the user provided example argument
        if args.vendor_id:
            self._vendor_id = args.vendor_id
        if args.product_id:
            self._product_id = args.product_id
        if args.verbose:
            self._verbose = args.verbose
        if args.debug:
            self._debug = args.debug

        # print(the values of the parameters to be used in the script)
        if self._verbose:
            print("Vendor Id: 0x%04X" % self._vendor_id)
            print("Product Id: 0x%04X" % self._product_id)

    def _append_device(self, device):
        """
        :type device: HidDevice
        """
        if self._debug:
            logger.debug("Device found %s." % device)
        self._all_devices.append(device)

    def scan_devices(self):
        # start scanning from scratch i.e. discard previous scan
        self._all_devices = []

        all_devices = hid.HidDeviceFilter(vendor_id=self._vendor_id, product_id=self._product_id).get_devices()
        # Favour dp3 interface box:
        # If more than one interface box is detected, check, if we find one for dp3
        if len(all_devices) > 1:
            all_devices = hid.HidDeviceFilter(
                vendor_id=self._vendor_id,
                product_id=self._product_id,
                product_name="dp Interface Gen2V3",
            ).get_devices()
        if not all_devices:
            if self._debug:
                logger.debug(
                    f"Can't find target device with Vendor Id: = 0x{self._vendor_id:04X} and Product Id: = 0x{self._product_id:04X} !"
                )
        else:
            for device in all_devices:
                self._append_device(device)

    def is_open(self):
        if self._device:
            return self._device.is_opened()
        return False

    def open_device(self, index):
        self._device_open = False
        if index < len(self._all_devices):
            self._device = self._all_devices[index]
            try:
                if not self._device.is_opened():
                    self._device.open()
                self._device_open = True
            except Exception as e:
                logger.error("An exception occurred while opening device")
                print(str(e))

    def open_hid_device(self, index=0):
        self.open_device(index)

    def set_receive_handle(self):
        if self._device:
            self._device.set_raw_data_handler(self.rx_handler)

    # handler called when a report is received
    def rx_handler(self, data):
        if self._debug:
            data_hex = [f"{item:02X}" for item in data]
            logger.debug("recv: ", data_hex)
            logger.debug("Received length %s " % len(data))

    def send_data_buffer(self, data_buffer):
        # try sending data
        try:
            report = self._device.find_output_reports()[0]
            report.send(data_buffer)
        except Exception as e:
            logger.error("An exception occurred while sending data buffer")
            print(str(e))

    def close_hid_device(self):
        if self._device and self._device.is_opened():
            self._device.close()
            self._device_open = False


def main():
    # create an instance of the class
    hid_communication = HIDCommunication()
    # parse the arguments
    hid_communication.parse_arguments()
    # execute rest of the script flow in multiple functions.
    # open device
    hid_communication.open_hid_device()
    hid_communication.set_receive_handle()
    hid_communication.close_hid_device()


if __name__ == "__main__":
    main()

# --- End of File ------------------------------------------------
