#!/usr/bin/python
# ===========================================================================
# Name:        flow_process_ahex_file.py
#
# Purpose:     This script process the ahex and extract the information as
#              address value pair to return as a dictionary.
#
# Author:      Aslam Faizan Muhammad (IFAG PMM SYS SWT SWI)
#                                       <Faizan.Aslam@infineon.com>
# Created:     26.06.2014
#
# Python Version: v2.7.2
#
# Dependency: argparse, re, struct
#
# ===========================================================================
# Copyright (C) 2014-2015 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
from __future__ import annotations

import argparse
import re

from dpIfGen2lib.dpIfGen2API.misc import decode


class ProcessAhexFile:
    """
    This script reads an ahex file in order to extract the important information
    out of it. The start address, length and CRC of the data in the ahex file can
    be calculated using this function. Moreover, the extracted data information is
    returned as an address value pair in form of a Python dictionary to be used by
    other scripts. The missing address values are filled with zeros.

    This script can either be used by another script or it can be run from
    the command line using the arguments.

    The following arguments from the command line are supported:

        1. **-f/- -filename** Input ahex file to be processed
        2. **-v/- -verbose** Displays additional information during execution of the script.
        3. **-d/- -debug** Displays debug information to verify/debug script functionality.
        4. **-V/- -version** Displays the current version of the script.


    Example Usage:

        >>> flow_process_ahex_file.py -f "filename.ahex"
        >>> flow_process_ahex_file.py -f "filename.ahex" -v

    """

    #: Version 1.0.2
    VERSION = "1.0.2"

    def __init__(self):
        """
        Initialization of the class. Call the __init__ for the super class
        """
        self.filename = None
        self.verbose = False
        self.debug = False
        self.data_extracted = {}
        self.file_info = {}

    def parse_arguments(self):
        parser = argparse.ArgumentParser(description=self.__doc__)

        group_basic = parser.add_argument_group("Options")
        group_basic.add_argument("-f", "--file", help="Path of ahex file", required=True)
        group_basic.add_argument(
            "-v",
            "--verbose",
            help="provide additional printout",
            action="store_true",
            required=False,
        )
        group_basic.add_argument("-V", "--version", help="print(version", action="store_true", required=False)
        group_basic.add_argument(
            "-d",
            "--debug",
            help="provide debug information",
            action="store_true",
            required=False,
        )
        args = parser.parse_args()

        # assign argument values to class variables ##
        self.filename = args.file
        self.verbose = args.verbose

        # show values ##
        if self.verbose:
            print("File name : %s" % self.filename)
        if args.debug:
            self.debug = True

        # special handler for version information
        if args.version:
            # show the version and exit
            print("Version: ", self.VERSION)
            exit()

    def extract_data(self):
        if not self.filename:
            return False
        try:
            with open(self.filename, "rb") as input_data:
                for line in input_data:
                    if line == "\r\n":
                        continue
                    line = decode(line)
                    chk_format = re.match(r"([0-9a-fA-F]{6}:[0-9a-fA-F]{4})", line)
                    (data_address, data_value) = chk_format.group(0).split(":")
                    self.data_extracted[data_address.upper()] = data_value

                # insert missing keys and assign them 0
                min_key = int(min(self.data_extracted.keys()), 16)
                max_key = int(max(self.data_extracted.keys()), 16)
                for key in range(min_key, max_key + 1):
                    if f"{key:06X}" not in self.data_extracted:
                        # print("Missing key %s" % '{:06X}'.format(key))
                        self.data_extracted[f"{key:06X}"] = "0000"

                # print(dict for debugging)
                if self.debug:
                    print(self.data_extracted)
                    for key in sorted(self.data_extracted.keys()):
                        print(key, ":", self.data_extracted[key])

            return True
        except Exception as e:
            print("An exception occurred while loading the file")
            print(str(e))
            return False

    def get_start_address(self):
        start_address = min(self.data_extracted.keys())
        if self.verbose:
            print(start_address)
        address_low = start_address[4:6]
        address_high = start_address[2:4]
        return "".join([address_low, address_high])

    def get_buffer(self):
        data_buffer = []
        start_address = min(self.data_extracted.keys())
        # in case the complete file has to be sent
        address_search = start_address
        try:
            check_format = re.match(r"([0-9a-fA-F]{4})", start_address)
            if check_format.group(0):
                # in case address is input from the user
                # address_low = start_address[0:2]
                # address_high = start_address[2:4]
                # address_search = ''.join(["00", address_high, address_low])
                if address_search not in self.data_extracted:
                    print("Address not found")
                    return None
                else:
                    max_key = int(max(self.data_extracted.keys()), 16)
                    curr_key = int(address_search, 16)
                    for key in range(curr_key, max_key + 1):
                        data_byte = self.data_extracted[f"{key:06X}"]
                        data_buffer.append(int(data_byte[2:], 16))
                        data_buffer.append(int(data_byte[0:2], 16))

                    if self.verbose:
                        print(data_buffer)
                    return data_buffer

        except Exception as e:
            raise e

    def get_length(self, buffer_trans):
        length_buffer = len(buffer_trans)
        if self.verbose:
            print("Length of buffer: %s" % length_buffer)
        # length_address = struct.pack('<H', length_buffer)
        # print(length_address)
        # return length_address
        length_buffer_hex = f"{length_buffer:04X}"
        length_low = length_buffer_hex[2:4]
        length_high = length_buffer_hex[0:2]
        return "".join([length_low, length_high])

    def get_crc(self, datalist):
        crc_bytes = self.calculate_crc(datalist, 0)
        crc_bytes_hex = f"{crc_bytes:04X}"
        crc_low = crc_bytes_hex[2:4]
        crc_high = crc_bytes_hex[0:2]
        crc = "".join([crc_low, crc_high])
        if self.verbose:
            print("CRC: ", crc_bytes)
        return crc

    def calculate_crc(self, datalist, i_crc):
        i_polynom = 0x100B
        i = 0
        j = 0
        val = 0
        # data_hex = ['{:02X}'.format(item) for item in datalist]
        # print(data_hex)

        for i in range(len(datalist)):
            j = 1
            while j < 0x100:
                val = i_crc & 0x8000
                # i_crc<<= 1
                i_crc = (i_crc << 1) & 0xFFFF
                if datalist[i] & j:
                    val ^= 0x8000
                if val:
                    # i_crc^= i_polynom
                    i_crc ^= i_polynom
                j = j << 1
        return i_crc

    def prepare_write_buffer_command(self):
        start_address = self.get_start_address()
        self.transmit_buffer = self.get_buffer()
        if self.transmit_buffer:
            length_bytes = self.get_length(self.transmit_buffer)
            # calculate crc
            crc_bytes = self.get_crc(self.transmit_buffer)
            # send command
            send_string = "".join(["CMD1E", start_address, length_bytes, crc_bytes, "\r"])
            if self.verbose:
                print(send_string)
            return send_string
        return None

    def get_file_info(self):
        """Extracts relevant information from ahex file.

        :returns:  file_info(dict)

        Reads an ahex file and returns the following information:

            1. Start address of the ahex file
            2. Length of the ahex file (The difference between the first and the last address in the ahex file)
            3. CRC (Checksum calculated over the data)

        The information is returned as a Python dictionary, with the respective information stored in the keys
        as below:

            1. "Start Address"
            2. "Length"
            3. "CRC"

        .. warning::

            This function assumes that the class members are initialized either by the
            arguments call or by class member accesses.

        .. warning::

            The script assumes that the addresses not specified in the ahex file are zero. If the address
            range is not zero the calculated CRC will not match the actual CRC in the chip.

        """
        self.file_info["Start Address"] = min(self.data_extracted.keys())
        length_dec = len(list(self.data_extracted.keys()))
        self.file_info["Length"] = f"{length_dec:04X}"
        crc_bytes_hex = self.get_crc(self.get_buffer())
        crc_low = crc_bytes_hex[2:4]
        crc_high = crc_bytes_hex[0:2]
        crc = "".join([crc_low, crc_high])
        self.file_info["CRC"] = crc
        return self.file_info

    def get_extracted_data(self):
        """Extracts data from the ahex file and return it as a Python dictionary, where each address is the key.

        :returns:  extracted_data(dict)

        .. note::

            The address keys are 6 hexadecimal digits as in the ahex file.

        .. warning::

            This function assumes that the class members are initialized either by the
            arguments call or by class member accesses.

        .. warning::

            All the addresses not specified in the ahex file lying in the range will be initialized to zeros.

        """
        return self.data_extracted


def main():
    process_ahex_file = ProcessAhexFile()
    process_ahex_file.parse_arguments()
    process_ahex_file.extract_data()
    process_ahex_file.get_start_address()
    process_ahex_file.prepare_write_buffer_command()
    print(process_ahex_file.get_file_info())


if __name__ == "__main__":
    main()

# --- End of File ------------------------------------------------
