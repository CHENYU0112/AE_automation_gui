# every command call in the test initialize a new interface_box
# to save a state of the interface_box or to make initialise setups
# use this class
# it must be import as IFP to the test first and then to the interface_box
from __future__ import annotations

from dpIfGen2lib.test.dp25.support import memory


class IFBoxPersistent:
    """
    This class holds persistent data of an interface box model!
    The purpose of this model is to support the test environment.
    """

    def __init__(self):
        self.init_with_voltage_cycle()
        self.buf512 = None
        self.buf16k = None
        self.debug = False
        self.pw_high_word = 0xABCD
        self.pw_low_word = 0x1234
        # The host may send a command to set the baudrate of the interface box model.
        # Default is 9600 baud
        self.baudrate = 9600

        # Here we model the FW ID of the interface box.
        # For communication to old devices, version 1.x.y is valid. Old devices are dp2a, dp2b-b11
        # For communication to dp2b-b13, version 2.x.y is valid.
        # For communication to dp3x, version 3.x.y is valid
        self.firmware_id = []
        # The expect_data flag determines if the inteface box expects further USB telegrams from the host.
        # e.g. a memory write command expects the memory data
        self.expect_data = False
        # The host may send a command to enable automatic detection of the device id.
        # This is only relevant for older devices.
        self.auto_chip_id_enabled = False
        # The default state is True
        # This is only False when command 'dpx_chip_disconnect' is called earlier
        self.chip_is_connected = True
        # The host may send a command to get the serial number.
        # This is default set by "0000"
        self.serialnumber = "0000"

    def init_with_voltage_cycle(self):
        self.protocol_version = ""
        self.application_started = False
        self.device_id = []
        self.customer_id = []
        self.patch_id = []
        self.aparam_id = []
        self.rom_id = []
        self.autostart = 0
        self.chip_is_locked = False
        # Per default, the voltage cycle has not been executed when powering the interface box (model)
        # The host first must send a voltage cycle command.
        # The voltage cycle applies to the connected device.
        self.voltage_cycle_executed = False
        # After powering the interface box (model) the voltage for the connected device is 0 V.
        # The host may send a command to set a different voltage (applied to the device).
        self.voltage_level_device = 0
        # After powering the device (within the model) a sync must be sent to the device to start communication.
        # with the device.
        # The host first needs to send a certain command to the interface bos to do that.
        self.synchronized = False

    def set_debug(self, _debug):
        self.debug = _debug

    def get_debug(self):
        return self.debug

    def set_baudrate(self, baudrate_id):
        allowed_baudrates = {0: 9600, 1: 19200, 2: 38400, 3: 57600, 4: 82000, 5: 105000}
        if baudrate_id in range(6):
            self.baudrate = allowed_baudrates[baudrate_id]
            return True
        else:
            return False

    def get_baudrate(self):
        return self.baudrate

    def set_voltage_cycle_executed(self, bool_vc):
        if bool_vc is True:
            self.init_with_voltage_cycle()
        self.voltage_cycle_executed = bool_vc

    def is_voltage_cycle_executed(self):
        return self.voltage_cycle_executed

    def set_auto_chip_id(self, _id):
        self.auto_chip_id_enabled = _id

    def get_auto_chip_id(self):
        return self.auto_chip_id_enabled

    def set_synchronized(self, _sync):
        if self.voltage_cycle_executed:
            self.synchronized = _sync
            return True
        else:
            return False

    def is_synchronized(self):
        return self.synchronized

    def set_expect_data(self, _expect_data):
        self.expect_data = _expect_data

    def get_expect_data(self):
        return self.expect_data

    def set_firmware_id(self, _firmware_id):
        self.firmware_id = []
        for item in _firmware_id:
            self.firmware_id.append(int(item, 16))

    def get_firmware_id(self):
        return self.firmware_id

    def set_voltage_level(self, _voltage_level):
        if 0 <= _voltage_level <= 270:
            # this if is only for dp3, because there is no voltage cycle command
            # so you have to sent to voltage set commands
            if self.voltage_level_device >= 22:
                self.set_voltage_cycle_executed(True)
            self.voltage_level_device = _voltage_level
            return True
        else:
            return False

    def get_voltage_level(self):
        return self.voltage_level_device

    def set_chip_is_connected(self, connected):
        self.chip_is_connected = connected

    def get_chip_is_connected(self):
        return self.chip_is_connected

    def set_serialnumber(self, serialnumber):
        self.serialnumber = serialnumber

    def get_serialnumber(self):
        return self.serialnumber

    def set_device_id(self, device_id):
        self.device_id = []
        for item in device_id:
            self.device_id.append(int(item, 16))

    def get_device_id(self):
        return self.device_id

    def set_customer_id(self, customer_id):
        self.customer_id = []
        for item in customer_id:
            self.customer_id.append(int(item, 16))

    def get_customer_id(self):
        return self.customer_id

    def set_patch_id(self, patch_id):
        self.patch_id = []
        for item in patch_id:
            self.patch_id.append(int(item, 16))

    def get_patch_id(self):
        return self.patch_id

    def set_aparam_id(self, aparam_id):
        self.aparam_id = []
        for item in aparam_id:
            self.aparam_id.append(int(item, 16))

    def get_aparam_id(self):
        return self.aparam_id

    def set_rom_id(self, rom_id):
        self.rom_id = []
        for item in rom_id:
            self.rom_id.append(int(item, 16))

    def get_rom_id(self):
        return self.rom_id

    def set_application_start(self):
        self.application_started = True

    def set_application_stop(self):
        self.application_started = False

    def get_application_start(self):
        return self.application_started

    def set_protocol_version(self, protocol_version):
        self.protocol_version = protocol_version

    def get_protocol_version(self):
        return self.protocol_version

    def set_autostart(self, value):
        self.autostart = value

    def get_autostart(self):
        return self.autostart

    def set_respond_data(self, data):
        self.respond_data = data

    def get_respond_data(self):
        return self.respond_data

    def set_data_receive_flag(self):
        self.data_receive = True

    def get_data_receive_flag(self):
        return self.data_receive

    def lock_chip(self, low_word, high_word):
        if self.pw_low_word == low_word and self.pw_high_word == high_word:
            self.chip_is_locked = True
            return True
        else:
            return False

    def unlock_chip(self, low_word, high_word):
        if self.pw_low_word == low_word and self.pw_high_word == high_word:
            self.chip_is_locked = False
            return True
        else:
            return False

    def create_pic_buffer(self, parameter):
        if parameter == 1:
            self.buf16k = memory.Memory()
            self.buf512 = None
            return True
        elif parameter == 2:
            self.buf512 = memory.Memory()
            self.buf16k = None
            return True
        else:
            return False

    def buf16k(self):
        if self.buf16k is not None:
            return self.buf16k
        return None

    def buf512(self):
        if self.buf512 is not None:
            return self.buf512
        return None


IFP = IFBoxPersistent()
