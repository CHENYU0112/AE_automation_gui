from __future__ import annotations


class Memory:
    def __init__(self):
        self.mem = {}
        self.debug = False
        self.burned_addresses = []
        self.otp = 0xBFFF, 0xE000, 1

        # Prepare memory for ROM version read via get_info command
        # self.write(1, 1)
        # self.write(2, 2)

    def write(self, address, value):
        if address not in self.burned_addresses:
            self.mem[address] = value
        if self.debug:
            print(self.mem)

    def burn(self, address, value):
        if address in self.burned_addresses:
            self.mem[address] = self.mem[address] & value
        else:
            self.mem[address] = value
        self.burned_addresses.append(address)

    def burn_otp(self, address, value):
        if address in range(*self.otp):
            self.burn(address, value)
            return True
        else:
            return False

    def read(self, address):
        if self.debug:
            print(self.mem)
        if address in self.mem:
            return self.mem[address]
        else:
            return False

    def __str__(self):
        result = ""
        for key in sorted(self.mem.keys()):
            result = f"{result}{key:06X}:{self.mem[key]:04X}\n"
        return result

    def read_block(self, address, size):
        block = []
        for i in range(size):
            block.append(self.read(address + i))
        return block

    def blank_check(self, address, length):
        blank = True
        for i in range(length):
            if (address + i) in self.mem:
                blank = False
        return blank

    def clear(self):
        del_addresses = []
        for address in self.mem:
            if address not in range(*self.otp):
                del_addresses.append(address)
        for address in del_addresses:
            del self.mem[address]

    def memory_clear_all(self):
        self.mem = {}
        self.burned_addresses = []


MEMORY = Memory()
