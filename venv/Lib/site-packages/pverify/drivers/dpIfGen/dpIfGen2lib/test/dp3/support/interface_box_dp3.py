from __future__ import annotations

from dpIfGen2lib.dpIfGen3API.com_dpifgen3_commands_list import DpIfGen3Commands as Cmd
from dpIfGen2lib.dpIfGen3API.misc import decode
from dpIfGen2lib.test.dp3.support.interface_box_persistent import IFP

DATA_CHUNK_SIZE = 60


class Command:
    def __init__(self, telegram, is_transparent=False):
        self.is_transparent = is_transparent
        self.telegram = telegram
        self.extracted_string = ""
        self.is_combo = False
        self.command = self.extract_command()
        self.args = self.extract_arguments
        self.data = self.extract_data()
        self.name = ""
        self.debug = False

    def extract_command(self):
        result = "".join(chr(i) for i in self.telegram[1:6])
        if "NXT" in result:
            result = "".join(chr(i) for i in self.telegram[1:4])
        return result

    @property
    def extract_arguments(self):
        data = self.extract_string()
        args = []
        # typicall a command with parameters has following format:
        # CMDaabbbbccccddddeeee
        # aa is the command ID
        # bbbb, cccc, dddd etc. are 16-bit parameters in little endian format
        #
        # A transparent command has format:
        # CMDaabbccddee
        # aa is the command ID
        # bb, cc, dd etc. are byte values to be sent transparently

        # offset indicates start of parameters
        offset = 5
        if self.is_transparent:
            # for transparent commands we treat parameters as byte values
            size = 2
        else:
            # for other commands we treat parameters as 16-bit values
            size = 4

        is_string = False
        for i in data[3:]:
            # here we check if each character is a hex digit
            if 48 <= i <= 57 or 65 <= i <= 70 or 97 <= i <= 102:
                pass
                # print('')
            else:
                # as soon we have one non-hex-digit we declare the parameter as string
                is_string = True

        if not is_string:
            arg_count = int((len(data) - 5) / size)
            for _r in range(arg_count):
                arg = "".join(chr(i) for i in data[offset : (offset + size)])
                if size == 4:
                    # convert little endian to big endian for 16-bit parameters
                    arg = "".join([arg[2], arg[3], arg[0], arg[1]])
                arg = int(arg, 16)

                args.append(arg)
                offset += size
        else:
            self.extracted_string = "".join(chr(i) for i in data[5:])
        return args

    def extract_string(self):
        data = []
        for item in self.telegram[1:]:
            if item != 0:
                data.append(item)
            else:
                break
        return data

    def get_arg(self, number):
        if number < len(self.args):
            return self.args[number]
        else:
            return 0

    def is_cmd(self, cmd):
        if self.command == cmd:
            return True
        return False

    def __str__(self):
        result = "Cmd: %s\n" % self.command
        for count, item in enumerate(self.args):
            result = "%sParameter%d: %04X\n" % (result, count, item)

    def set_name(self, name):
        self.name = name

    def extract_data(self):
        # check for combo telegram
        offset = len(self.extract_string()) + 2
        if self.telegram[offset] == ord("D"):
            self.is_combo = True
            return self.telegram[offset - 1 :]

        if self.is_cmd("DAT"):
            return self.telegram[0:]
        else:
            return None


class InterfaceBox:
    def __init__(self, rx_handler):
        self.rx_handler = rx_handler
        self.EXPECT_CMD = 0
        self.EXPECT_DATA = 1
        self.EXPECT_DATA_RECORD = 2
        self.EXPECT_DATA_TRANSPARENT = 3
        self.state = self.EXPECT_CMD
        self.current_record_type = None

    def receive(self, data_buffer):
        """
        Here the interface box receives a telegram
        :param data_buffer: the 'USB' telegram
        :return: None
        """
        if self.state == self.EXPECT_DATA_RECORD:
            # we are here, if we expect data from the host
            # we can get following data types
            # 1. data for memory
            # 2. record data
            # 3. transparent data
            # All of them come as DAT-telegrams from the host
            # here we receive data for a record command (write or burn)
            if decode(bytearray(data_buffer[1:4])) == "DAT":
                data = data_buffer[5:]
                length = data_buffer[4]
                IFP.add_data_to_record(data[0:length])
                if length == 0:
                    # DAT0 event
                    self.state = self.EXPECT_CMD
                    # if we have a DAT0 event without preceeding data, we have an invalidation command
                    if len(IFP.get_record_data(self.current_record_type)) == 0:
                        IFP.invalidate_record(self.current_record_type)
                    self.respond("ACK")
                else:
                    self.respond("ACK")
            else:
                self.state = self.EXPECT_CMD
                self.respond("NAKRecordNonDAT")
            return

        if self.state == self.EXPECT_DATA_TRANSPARENT:
            # here we receive data for a transparent write command
            if decode(bytearray(data_buffer[1:4])) == "DAT":
                data = data_buffer[5:]
                length = data_buffer[4]
                IFP.add_transparent_data(data)
                if length == 0:
                    # DAT0 event
                    self.state = self.EXPECT_CMD
                self.respond("ACK")
            else:
                self.state = self.EXPECT_CMD
                self.respond("NAKTransparentNonDAT")
            return

        if self.state == self.EXPECT_DATA:
            # here we receive data for memory write commands
            if decode(bytearray(data_buffer[1:4])) == "DAT":
                data = data_buffer[5:]
                length = data_buffer[4]
                IFP.add_data_to_memory(data[0:length])
                IFP.receive_handler_start_address += length
                if length == 0:
                    # DAT0 event
                    self.state = self.EXPECT_CMD
                self.respond("ACK")
            else:
                self.state = self.EXPECT_CMD
                self.respond("NAKMemoryNonDAT")
            return

        if self.state == self.EXPECT_CMD:
            command = Command(data_buffer)

            # define one command to trigger a timeout
            if command.is_cmd("CMDFF"):
                return

            if command.is_cmd("CMD03"):
                self.respond("ACK")

            if command.is_cmd(Cmd.SET_VOLTAGE_LEVEL):
                level_in_tenth_volts = command.get_arg(0)
                IFP.set_voltage_level(level_in_tenth_volts)
                self.respond("ACK")
                # print(command.get_arg(0))

            elif command.is_cmd(Cmd.SYNC):
                if IFP.is_tristated():
                    self.respond("NAKUartTristated")
                elif IFP.set_synchronized(True):
                    self.respond("ACK")
                else:
                    self.respond("NAKNotSynchronized")

            elif command.is_cmd(Cmd.PROTOCOL_ID):
                self.respond("ACK0003")

            elif command.is_cmd(Cmd.GET_INFO) or command.is_cmd(Cmd.GET_INFO_COMBO):
                is_combo = command.is_cmd(Cmd.GET_INFO_COMBO)
                IFP.ensure_synchronized()
                if command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_PATCH_VERSION"):
                    # format is [major, minor, step low, step high, commit ID (32bit)]
                    data = IFP.get_patch_version()
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_CHIP_ID"):
                    # e.g. wafer coordinates (64 bit)
                    data = [0, 1, 2, 3, 4, 5, 6, 7]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_OTP_SIZE_AVAILABLE"):
                    data = [IFP.get_otp_size() & 0xFF, (IFP.get_otp_size() >> 8) & 0xFF]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_FW_VERSION"):
                    # indicate DP3B
                    platform_id = 0x3B
                    # indicate ROM ID 3.0
                    design_step_id = 0x30
                    data = [
                        platform_id,
                        design_step_id,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                    ]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_RUN_IN_RAM"):
                    data = [1] if IFP.is_eeprom_valid() else [0]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_EXCEPTION_STATUS"):
                    data = [IFP.exception, 0xFE]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_JTAG_ID"):
                    # indicate FRED device
                    data = [0, 0, 0, 0x80]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                elif command.get_arg(0) == Cmd.INFO_TYPES.get_value_by_name("CMDH_CMD_INFO_GET_FW_STATUS"):
                    data = [0]
                    if is_combo:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                else:
                    self.respond("NAKUnknownInfo")

            elif command.is_cmd(Cmd.READ_FIRMWARE_VERSION):
                self.respond("ACK%s" % IFP.get_firmware_version())

            elif command.is_cmd("CMD66"):
                self.respond("ACK")
                self.respond("OldWayWithSecondTelegram")

            elif command.is_cmd(Cmd.READ_HARDWARE_VERSION):
                self.respond("ACK%s" % IFP.get_if_hardware_version())

            elif command.is_cmd(Cmd.READ_SERIALNUMBER):
                self.respond("ACK%s" % IFP.get_serialnumber())

            elif command.is_cmd(Cmd.SET_SERIALPORT_PARAMETER):
                p1 = command.get_arg(0)
                p2 = command.get_arg(1)
                if p1 == 1 and p2 in range(7):
                    IFP.set_baudrate(command.get_arg(1))
                    self.respond("ACK")
                elif p1 in [2, 3, 4] and p2 in [0, 1]:
                    self.respond("ACK")
                else:
                    self.respond("NAKInvalidParam")

            elif command.is_cmd(Cmd.WRITE_HARDWARE_VERSION):
                if command.extracted_string != "":
                    IFP.set_if_hardware_version(command.extracted_string)
                    self.respond("ACK")
                else:
                    self.respond("NAKEmptyString")

            elif command.is_cmd(Cmd.WRITE_SERIALNUMBER):
                string = "".join(chr(i) for i in data_buffer[6:14])
                IFP.set_serialnumber(string)
                self.respond("ACK")

            elif command.is_cmd(Cmd.MEMORY_WRITE):
                IFP.ensure_synchronized()
                start_address = command.get_arg(0)
                start_address += command.get_arg(1) << 16
                IFP.receive_handler_start_address = start_address
                self.state = self.EXPECT_DATA
                if not command.is_combo:
                    self.respond("ACK")
                else:
                    self.receive(command.data)
                    self.state = self.EXPECT_CMD

            elif command.is_cmd(Cmd.RECORD_WRITE) or command.is_cmd(Cmd.RECORD_BURN):
                IFP.ensure_synchronized()
                rtype = command.get_arg(0)
                size = command.get_arg(1)
                IFP.add_record(rtype, size)
                self.current_record_type = rtype
                self.state = self.EXPECT_DATA_RECORD
                if not command.is_combo:
                    self.respond("ACK")
                else:
                    self.receive(command.data)
                    self.state = self.EXPECT_CMD

            elif command.is_cmd(Cmd.MEMORY_READ):
                IFP.ensure_synchronized()
                start_address = command.get_arg(0)
                start_address += command.get_arg(1) << 16
                length = command.get_arg(2)
                data = IFP.memory.read_block(start_address, length)
                IFP.set_respond_data(data)
                self.respond("ACK")

            elif command.is_cmd(Cmd.MEMORY_READ_COMBO):
                IFP.ensure_synchronized()
                start_address = command.get_arg(0)
                start_address += command.get_arg(1) << 16
                length = command.get_arg(2)
                data = IFP.memory.read_block(start_address, length)
                if len(data) < 56:
                    self.respond_string_and_data("ACK\0DAT", data)
                else:
                    IFP.set_respond_data(data)
                    self.respond("ACK")

            elif command.is_cmd(Cmd.RECORD_READ):
                IFP.ensure_synchronized()
                rtype = command.get_arg(0)
                data = IFP.get_record_data(rtype)
                if data:
                    IFP.set_respond_data(data)
                    self.respond("ACK")
                else:
                    self.respond("NAKUnkownRecordType")

            elif command.is_cmd(Cmd.RECORD_READ_COMBO):
                IFP.ensure_synchronized()
                rtype = command.get_arg(0)
                data = IFP.get_record_data(rtype)
                if data:
                    if len(data) < 56:
                        self.respond_string_and_data("ACK\0DAT", data)
                    else:
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                else:
                    self.respond("NAKUnkownRecordType")

            elif command.is_cmd(Cmd.STRESS_DP3):
                self.respond("ACK")

            elif command.is_cmd(Cmd.APP_STATUS_GET):
                IFP.ensure_synchronized()
                data = [0]
                IFP.set_respond_data(data)
                self.respond("ACK")

            elif command.is_cmd(Cmd.STORE_FW):
                IFP.ensure_synchronized()
                option = command.get_arg(0)
                if option == 0:
                    # store writes the memory data to an EEPROM
                    data = IFP.memory.read_block(0x20002000, 0x8000)
                    IFP.eeprom.block_write(0, data)
                    if data[-1] == 0:
                        IFP.set_eeprom_valid(False)
                    else:
                        IFP.set_eeprom_valid(True)
                elif option == 2:
                    # invalidate RAM content by overwriting the last RAM position (CRC)
                    IFP.memory.block_write(0x20009FFC, [0, 0, 0, 0])
                elif option == 1:
                    # erase EEPROM
                    IFP.eeprom.clear()
                    IFP.set_eeprom_valid(False)
                self.respond("ACK")

            elif command.is_cmd(Cmd.APP_RESET):
                IFP.ensure_synchronized()
                # when we do a reset, we restore the image from EEPROM to extended RAM (Fred)
                data = IFP.eeprom.read_block(0, 0x8000)
                address = 0x20002000
                IFP.memory.block_write(address, data)
                # we declare non-sync because chip has restarted and needs a new sync
                IFP.set_synchronized(False)
                self.respond("ACK")

            elif command.is_cmd(Cmd.APP_STOP):
                IFP.ensure_synchronized()
                self.respond("ACK")

            elif command.is_cmd(Cmd.PING):
                IFP.ensure_synchronized()
                data_int = command.get_arg(0)
                data = [data_int & 0xFF, (data_int >> 8) & 0xFF]
                IFP.set_respond_data(data)
                self.respond("ACK")

            elif command.is_cmd(Cmd.VCC_UART_STATUS_CONTROL):
                param = command.get_arg(0)
                if param >= 7 or param in [3, 4]:
                    self.respond("NAKInvalidParameter")
                else:
                    if param == 6:
                        IFP.set_tristated(True)
                    if param == 2:
                        IFP.set_tristated(False)
                    self.respond("ACK")

            elif command.is_cmd(Cmd.HOST_BUFFER_SIZE_GET):
                self.respond("ACK0020")

            elif command.is_cmd(Cmd.IF_TIMEOUT_CONFIG):
                type = command.get_arg(0)
                command.get_arg(1)
                # todo save values
                if type > 2:
                    self.respond("NAKTimeoutConfig")
                else:
                    self.respond("ACK")

            elif (
                command.is_cmd(Cmd.TRANSPARENT_WRITE)
                or command.is_cmd(Cmd.TRANSPARENT_EXECUTE)
                or command.is_cmd(Cmd.TRANSPARENT_READ)
            ):
                command_t = Command(data_buffer, True)

                IFP.ensure_synchronized()
                cmd_class = command_t.get_arg(0)
                if cmd_class == 0x7F:
                    self.respond("ACK")
                    return
                if cmd_class == 0x7E:
                    self.respond("ACK0003")
                    return

                cmd_id = command_t.get_arg(1)
                if cmd_class == 0x40:
                    # check data write commands
                    if cmd_id in [9, 0x12, 0x13]:
                        self.state = self.EXPECT_DATA_TRANSPARENT
                        self.respond("ACK")
                    # check for read commands
                    elif cmd_id in [0x11, 0x0B]:
                        data = IFP.get_transparent_data()
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                    else:
                        self.respond("ACK")
                elif cmd_class == 0x7C:
                    # check for read commands
                    if cmd_id in [0x04, 0x07]:
                        data = [1, 2, 3]
                        IFP.set_respond_data(data)
                        self.respond("ACK")
                    else:
                        self.respond("ACK")
                else:
                    self.respond("NAKTransparent")

            elif command.is_cmd("NXT"):
                data = IFP.get_respond_data()
                if len(data):
                    if len(data) > DATA_CHUNK_SIZE:
                        IFP.set_respond_data(data[DATA_CHUNK_SIZE:])
                        data = data[:DATA_CHUNK_SIZE]
                    else:
                        IFP.set_respond_data([])
                    self.respond_data(data)
                else:
                    self.respond_data([])

            else:
                self.respond("NAKUnknownCommand")

    def respond(self, string_data):
        # first element is report number
        result = [0]
        result.extend([ord(i) for i in string_data])
        self.rx_handler(result)

    def respond_data(self, data):
        self.respond_string_and_data("DAT", data)

    def respond_string_and_data(self, string, data):
        # first element is report number
        result = [0]
        result.extend([ord(i) for i in string])
        result.extend([len(data)])
        result.extend(data)
        self.rx_handler(result)
