# Every command call in the test initializes a new interface_box.
# To save a state of the interface_box or to make initializing setups
# use this class.
# It must be imported as IFP to the test first and then to the interface_box.
from __future__ import annotations

from dpIfGen2lib.test.dp3.support.memory import Memory


class Record:
    def __init__(self, rtype, size):
        self.type = rtype
        self.size_expected = size
        self.data = []
        self.size_real = 0

    def add_data(self, data):
        self.size_real += len(data)
        self.data.extend(data)

    def get_data(self):
        return self.data

    def get_type(self):
        return self.type

    def is_type(self, rtype):
        return self.type == rtype

    def remove_data(self):
        self.data = []

    def is_valid(self):
        return len(self.data) != 0


class Records:
    """
    Handling of different record types (Record())
    """

    def __init__(self):
        self.records = {}
        self.last_added_type = None
        self.otp_size = 8192

    def add_record(self, rtype, size):
        """
        Adds/Overwrites a record
        :param rtype: record type ID
        :param size: lenght of record in bytes
        :return:
        """
        self.records[rtype] = Record(rtype, size)
        self.last_added_type = rtype
        self.otp_size -= size

    def add_data(self, data):
        """
        Add data to the lately added record
        :param data: list of data bytes
        :return:
        """
        self.records[self.last_added_type].add_data(data)

    def get_data(self, rtype):
        """
        Returns data of the specified record type ID
        :param rtype:
        :return: list of data bytes
        """
        return self.records[rtype].get_data()

    def is_valid(self, rtype):
        """
        Checks if specific record is valid
        :param rtype:
        :return:
        """
        return self.records[rtype].is_valid()

    def clear(self, rtype):
        """
        Clears/Removes specified record
        :param rtype:
        :return:
        """
        self.records[rtype].remove_data()

    def get_otp_size(self):
        return self.otp_size


class IFBoxPersistent:
    """
    This class holds persistent data of an interface box model!
    The purpose of this model is to support the test environment.
    """

    def __init__(self):
        self.receive_handler_start_address = None
        # memory models the device memory (see class Memory in memory.py)
        self.memory = Memory()
        self.firmware_version = "dpIfGen2_V3.1.0_simulated"
        self.if_hardware_version = "DPIFGEN2-V1.1_simulated"
        self.debug = False
        # eeprom is a Memory class modelling an EEPROM
        self.eeprom = Memory()
        self.records = Records()
        self._init_dparam_record()
        # The host may send a command to set the baudrate of the interface box model.
        # Default is 9600 baud
        self.baudrate = 9600
        self.transparent_data = []
        self.patch_version = [0, 0, 0, 0, 0, 0, 0, 0]

        # Here we model the FW ID of the interface box.
        # For communication to old devices, version 1.x.y is valid. Old devices are dp2a, dp2b-b11
        # For communication to dp2b-b13, version 2.x.y is valid.
        # For communication to dp3x, version 3.x.y is valid
        self.firmware_id = "04110078"
        # The host may send a command to get the serial number.
        self.serial_number = "04110078"
        self.eeprom_valid = False

        # section for members of init_with_voltage_cycle
        self.respond_data = []
        self.voltage_cycle_executed = False
        self.voltage_level_device = 0
        self.synchronized = False
        self.exception = 0
        self.uart_tristated = False

        self.init_with_voltage_cycle()

    def _init_dparam_record(self):
        # create record with initial calibration data
        record_id_dparam_fe = 2
        data = list(range(54))
        self.records.add_record(record_id_dparam_fe, len(data))
        self.records.add_data(data)

        record_id_dparam_be = 6
        data = [i + 54 for i in range(32)]
        self.records.add_record(record_id_dparam_be, len(data))
        self.records.add_data(data)

    def init_with_voltage_cycle(self):
        self.respond_data = []
        # Per default, the voltage cycle has not been executed when powering the interface box (model)
        # The host first must send a voltage cycle command.
        # The voltage cycle applies to the connected device.
        self.voltage_cycle_executed = False
        # After powering the interface box (model) the voltage for the connected device is 0 V.
        # The host may send a command to set a different voltage (applied to the device).
        self.voltage_level_device = 0
        # After powering the device (within the model) a sync must be sent to the device to start communication.
        # with the device.
        # The host first needs to send a certain command to the interface bos to do that.
        self.synchronized = False
        # clear RAM
        self.memory.clear()
        if self.records.is_valid(2) and self.records.is_valid(6):
            self.exception = 0
        else:
            self.exception = 1
        self.uart_tristated = False

    def set_tristated(self, setting):
        self.uart_tristated = setting

    def is_tristated(self):
        return self.uart_tristated

    def set_debug(self, _debug):
        self.debug = _debug

    def get_debug(self):
        return self.debug

    def set_baudrate(self, baudrate_id):
        allowed_baudrates = {0: 9600, 1: 19200, 2: 38400, 3: 57600, 4: 82000, 5: 105000}
        if baudrate_id in range(6):
            self.baudrate = allowed_baudrates[baudrate_id]
            return True
        else:
            return False

    def get_baudrate(self):
        return self.baudrate

    def is_voltage_cycle_executed(self):
        return self.voltage_cycle_executed

    def set_synchronized(self, _sync):
        if self.voltage_cycle_executed:
            self.synchronized = _sync
            return True
        else:
            return False

    def is_synchronized(self):
        return self.synchronized

    def ensure_synchronized(self):
        if not self.synchronized:
            msg = "Device is not synchronized"
            raise Exception(msg)

    def set_firmware_id(self, _firmware_id):
        self.firmware_id = []
        for item in _firmware_id:
            self.firmware_id.append(int(item, 16))

    def get_firmware_id(self):
        return self.firmware_id

    def set_voltage_level(self, level_in_tenth_volts):
        if level_in_tenth_volts > 0:
            self.init_with_voltage_cycle()
            self.voltage_cycle_executed = True
        else:
            self.voltage_cycle_executed = False
        self.voltage_level_device = level_in_tenth_volts

    def get_voltage_level(self):
        return self.voltage_level_device

    def set_serialnumber(self, serialnumber):
        self.serial_number = serialnumber

    def get_serialnumber(self):
        return self.serial_number

    def set_respond_data(self, data):
        self.respond_data = data

    def get_respond_data(self):
        return self.respond_data

    def set_eeprom_valid(self, value):
        self.eeprom_valid = value

    def is_eeprom_valid(self):
        return self.eeprom_valid

    def set_firmware_version(self, version):
        self.firmware_version = version

    def get_firmware_version(self):
        return self.firmware_version

    def get_if_hardware_version(self):
        return self.if_hardware_version

    def set_if_hardware_version(self, if_hardware_version):
        self.if_hardware_version = if_hardware_version

    def add_data_to_memory(self, data):
        self.memory.block_write(self.receive_handler_start_address, data)

    def add_transparent_data(self, data):
        self.transparent_data.extend(data)

    def get_transparent_data(self):
        return self.transparent_data

    def add_record(self, rtype, size):
        self.records.add_record(rtype, size)
        if rtype == 1:
            self.patch_version = [0, 1, 2, 3, 0x10, 0x11, 0x12, 0x13]

    def add_data_to_record(self, data):
        # data will be added to the last added record type
        self.records.add_data(data)

    def get_record_data(self, rtype):
        data = self.records.get_data(rtype)
        self.set_respond_data(data)
        return data

    def invalidate_record(self, rtype):
        self.records.clear(rtype)
        if rtype == 1:
            self.patch_version = [0, 0, 0, 0, 0, 0, 0, 0]

    def is_record_valid(self, rtype):
        return self.records.is_valid(rtype)

    def get_otp_size(self):
        return self.records.otp_size

    def get_patch_version(self):
        return self.patch_version


IFP = IFBoxPersistent()
