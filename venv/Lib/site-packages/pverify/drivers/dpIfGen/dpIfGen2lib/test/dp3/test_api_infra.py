from __future__ import annotations

import os
import unittest

# set an environment variable to bring API into test mode

os.environ["TEST_ENV_DP_TOOLS_2016-04-15"] = "true"
os.environ["INTERFACE_BOX"] = "dp3"

from dpIfGen2lib.dpIfGen3API.com_dpifgen3_api_basic_class import (
    DpIfGen2APIBasicDp3Class,
    MemoryPartitioner,
    api_settings,
)
from dpIfGen2lib.dpIfGen3API.misc import Memory
from dpIfGen2lib.dpIfGen3API.xml_utils import XML_reader


def get_full_path(path_relative):
    return os.path.join(os.path.dirname(os.path.abspath(__file__)), path_relative)


class TestAPI3Infra(unittest.TestCase):
    def setUp(self):
        self.api = DpIfGen2APIBasicDp3Class()
        self.no_of_api_functions = 48

    def test_version_exists_and_is_valid(self):
        version = self.api.VERSION
        assert len(version)

        # version must have three fields x.y.z
        version_list = version.split(".")
        assert len(version_list) == 3

    def test_min_max_version_is_valid(self):
        min_version = self.api.MIN_DPIFGEN2_FW_VERSION
        max_version = self.api.MAX_DPIFGEN2_FW_VERSION
        # for DP3 mayor version of min must be 3, of max must be 4
        assert min_version.startswith("3.")
        assert max_version.startswith("4.")

    def test_list_of_functions_is_valid(self):
        f_list = self.api.list_of_functions()
        # check number of filtered functions
        # this test will fail, if a new api function is added
        # Note: you probably have to add the new API function in the corresponding Sphinx .rst file
        # TODO build the rst file automatically,
        assert len(f_list) == self.no_of_api_functions

        # no function of the list is allowed to start with underscore i.e.
        # no private functions must be in list
        for item in f_list:
            assert not item.startswith("_")

    def test_remove_attribute(self):
        text = "hallo\n  \n  @@Class: testclass\n  \n"
        new_text = self.api._remove_attribute(text)
        assert new_text == "hallo\n  \n  \n"

    def test_get_class(self):
        text = "hallo\n  \n  @@Class: testclass\n  \n"
        class_ = self.api._get_class(text)
        assert class_ == "testclass"

    def test_dict_of_functions_is_valid(self):
        d_list = self.api.dict_of_api_functions()
        if 0:
            print(d_list)
            for key, value in d_list.items():
                print(key)
                for a, b in value.items():
                    print(f"  {a}: {b}")

        # number of dictionary entries must fit to number of functions i.e.
        # each function must have an dictionary entry
        assert len(d_list) == self.no_of_api_functions

    def test_error_codes(self):
        # check existing error
        raw_list = list(map(ord, "NAKFF05"))
        raw_list.extend([0] * 20)
        result = self.api._decode_error_code(raw_list)
        print(result)
        assert result.startswith("NAKFF05\nError Details:")
        # check non existing error of interface class
        result = self.api._decode_error_code(map(ord, "NAKFF06"))
        print(result)
        # check non existing error of device class
        result = self.api._decode_error_code(map(ord, "NAK00d1"))
        print(result)

    def test_timout_calculation(self):
        # minimum must be 2 seconds
        api_settings.baud_rate = 9600
        time_s = self.api._timeout_get(0)
        assert time_s == 2

        # 8192 bytes at 9600 with 512us distance between the bytes (10 bit per byte)
        # ceil(8192 * 10 / 9600 + 8192 * 512us) = 13 seconds
        # timeout should not be too high
        time_s = self.api._timeout_get(8192)
        assert 13 <= time_s <= 26

        # 8192 bytes at 115200 with 512us distance between the bytes (10 bit per byte)
        # ceil(8192 * 10 / 115200 + 8192 * 512us) = 5 seconds
        # timeout should not be too high
        # self.api.set_baud_rate(115200)
        api_settings.baud_rate = 115200
        time_s = self.api._timeout_get(8192)
        assert 5 <= time_s <= 10

    def test_memory_partitioner(self):
        a_dict = {0: 7, 1: 8, 2: 9, 3: 0, 5: 0, 6: 0, 8: 0}
        mw = MemoryPartitioner(2)
        mw.add_data_from_dict(a_dict)
        assert [(0, 2), (2, 2), (5, 2), (8, 1)] == mw.get_block_list()

        data = mw.get_data(0, 3)
        assert [7, 8, 9] == data
        assert len(data) == 3

    def test_api_needs_open_to_work(self):
        assert not self.api.is_open()
        self.api.open()
        assert self.api.is_open()
        self.api.connection_establish()
        self.api.close()
        assert not self.api.is_open()

    def test_xml_number_of_parameters(self):
        filename = get_full_path("./support/use_case_306.xml")
        record_type = 3
        instance = XML_reader(filename, record_type)
        assert instance.params.size_in_bytes_get() == 136

    def test_xml_bytes_read(self):
        filename = get_full_path("./support/use_case_306.xml")
        record_type = 3
        instance = XML_reader(filename, record_type)
        params = instance.get_data()
        # print(instance.params.byte_list_get())
        # check first element
        assert params[0] == 1
        # padding should return 0
        assert params[1] == 0
        # padding should return 0 according to bitsize
        assert params[42] == 0
        assert params[43] == 0
        # decimal values are read correctly even if smaller than bitsize
        assert params[32] == 2
        assert params[33] == 8
        assert params[34] == 0
        assert params[35] == 0
        # filling is correct
        assert params[28] == 0
        assert params[29] == 255
        assert params[30] == 0
        assert params[31] == 0

        # todo NA and not padding should throw error

    def test_xml_record_type_get(self):
        filename = get_full_path("./support/use_case_306.xml")
        record_type = 3
        instance = XML_reader(filename, record_type)
        assert instance.get_record_type() == 3
        assert len(instance.get_data()) == 136

    def test_xml_patch_bytes_read(self):
        filename = get_full_path("./support/aparams_uc306_CCM_240W.xml")
        record_type = 1
        instance = XML_reader(filename, record_type)
        params = instance.get_data()
        # print(instance.params.byte_list_get())
        # check first element
        assert params[0] == 45
        assert params[1] == 5
        assert params[2] == 0

        assert len(params) == 1994

    def test_xml_aparam_bytes_read(self):
        filename = get_full_path("./support/xdpvision_aparams_uc306_CCM_240W.xml")
        record_type = 3
        instance = XML_reader(filename, record_type)
        params = instance.get_data()
        # print(instance.params.byte_list_get())
        # check first element
        assert params[0] == 1
        assert params[1] == 0
        assert params[2] == 0
        assert params[11] == 72

        assert len(params) == 948

    def test_memory_class_valid_data(self):
        m = Memory()
        text = (
            "20002000:12\n"
            "20002001:00\n"
            "20002002:34\n"
            "20002003:55\n"
            "20002004:00\n"
            "20002005:00\n"
            "20002006:00\n"
            "20002007:AA\n"
        )
        m.fill_from_text(text)
        assert m.is_data_valid()
        assert text == m.print_8bit()
        assert m.address_get() == 536879104
        self.assertListEqual([0x12, 0, 0x34, 0x55, 0, 0, 0, 0xAA], m.data_get())

        text = "20002000:0012\n20002002:5534\n20002004:0000\n20002006:AA00\n"
        assert text == m.print_16bit()

        text = "20002000:55340012\n20002004:AA000000\n"
        assert text == m.print_32bit()

    def test_memory_class_invalid_data(self):
        m = Memory()
        # number of data bytes is not power of 2
        text = "20002000:553400"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        # data is empty
        text = "20002000:"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        # address is not 32-bit
        text = "2000200:1234"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        # string is empty
        # in this case there is no exception
        text = ""
        m.fill_from_text(text)
        assert m.is_data_valid()

        # string is comment
        # in this case there is no exception
        text = "# this is a comment"
        m.fill_from_text(text)
        assert m.is_data_valid()

        # string does not contain separator ':'
        text = "20002000"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        # wrong alignment 16-bit
        text = "20002001:1234"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        # wrong alignment 32-bit
        text = "20002001:12345678"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        text = "20002002:12345678"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        text = "20002003:12345678"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

        text = "20002000:zz"
        self.assertRaises(Exception, m.fill_from_text, text)
        assert not m.is_data_valid()

    def test_memory_class_8bit(self):
        m = Memory()
        m.fill_from_data(0x20002000, [0x12])
        assert m.is_data_valid()
        assert [18] == m.data_get()
        m.fill_from_data(0x20002000, [0x100])
        assert not m.is_data_valid()

    def test_memory_class_16bit(self):
        m = Memory()
        m.fill_from_data16(0x20002000, [0x1234])
        assert m.is_data_valid()
        assert [52, 18] == m.data_get()
        assert [4660] == m.data_get16()
        m.fill_from_data16(0x20002000, [0x10000])
        assert not m.is_data_valid()

    def test_memory_class_32bit(self):
        m = Memory()
        m.fill_from_data32(0x20002000, [0x12345678])
        assert m.is_data_valid()
        assert [120, 86, 52, 18] == m.data_get()
        assert [305419896] == m.data_get32()
        m.fill_from_data32(0x20002000, [0x100000000])
        assert not m.is_data_valid()

    def tearDown(self):
        # tearDown method is called at the end
        pass


if __name__ == "__main__":
    unittest.main()
