from __future__ import annotations

from dpIfGen2lib.dpIfGen2API.lib_dpifgen2_commands_list import DpIfGen2Commands as Cmd
from dpIfGen2lib.test.dp25.support.interface_box_persistent import IFP
from dpIfGen2lib.test.dp25.support.memory import MEMORY


def convert_data(data):
    # input is the USB data buffer (telegram)
    # first byte is always zero and can be discarded
    # buffer contains a byte stream in little endian format
    in_low = data[1::2]
    in_high = data[2::2]

    # output must be a list of 16-bit values
    return [low + high * 256 for low, high in zip(in_low, in_high)]


def print_buffer(data):
    result = []
    for item in data:
        result.append(chr(item))
    return result


class Command:
    def __init__(self, telegram):
        self.telegram = telegram
        self.cmd_string = self.extract_command()
        self.args = self.extract_arguments()
        self.name = ""
        self.debug = False

    def extract_command(self):
        return "".join(chr(i) for i in self.telegram[1:6])

    def extract_arguments(self):
        data = self.extract_string()
        args = []
        offset = 5
        size = 4

        arg_count = (len(data) - 5) >> 2
        for _r in range(arg_count):
            arg = "".join(chr(i) for i in data[offset : (offset + size)])
            arg = "".join([arg[2], arg[3], arg[0], arg[1]])
            arg = int(arg, 16)
            args.append(arg)
            offset += size
        return args

    def extract_string(self):
        data = []
        for item in self.telegram:
            if item != 0:
                data.append(item)
        return data

    def get_arg(self, number):
        return self.args[number]

    def is_cmd(self, cmd):
        if self.cmd_string == cmd:
            return True
        return False

    def __str__(self):
        result = "Cmd: %s\n" % self.cmd_string
        for count, item in enumerate(self.args):
            result = "%sParameter%d: %04X\n" % (result, count, item)

    def set_name(self, name):
        self.name = name


# Note:
# Instances of this class are generated with every step of a sequence.
# This means every command received from the host interface will reset any
# previously configured instance. Instances of the class are not persistent!
# To hold data persistent for more than one command, refer to IFBoxPersistent.
class InterfaceBox:
    def __init__(self, rx_handler):
        self.rx_handler = rx_handler
        self.block_start = 0
        self.block_length = 0
        self.block_crc = 0

    def receive(self, data_buffer):
        if IFP.expect_data:
            # directly write to memory
            data_size = len(data_buffer) - 1
            if self.block_length < data_size:
                data_size = self.block_length

            for data in convert_data(data_buffer):
                address = self.block_start
                value = data
                if IFP.buf16k is not None:
                    IFP.buf16k.write(address, value)
                if IFP.buf512 is not None:
                    IFP.buf512.write(address, value)
                # MEMORY.write(address, value)
                self.block_start += 1
                self.block_length -= 2
                data_size -= 2
                if data_size <= 0:
                    break

            if self.block_length == 0:
                # confirm reception of last data
                self.respond("ACK")
                IFP.expect_data = False
        else:
            # data_buffer is the USB telegram (consisting of 64 characters) which is sent to the interface box
            # Actually here we fake the functionality of the interface box
            # first byte is 0
            # We are mainly working with strings.
            if IFP.debug:
                print(zip(data_buffer, print_buffer(data_buffer)))

            command = Command(data_buffer)

            is_executed = False

            if command.is_cmd(Cmd.SYNC_COMMAND):
                command.set_name("send SYNC")
                sync_trials = command.get_arg(0)
                if IFP.is_voltage_cycle_executed() and sync_trials <= 100:
                    IFP.set_synchronized(True)
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.READ_VALUES_COMMAND):
                command.set_name("memory read value")
                address = command.get_arg(0)
                size = command.get_arg(1)
                # todo check for valid address and size. Send NAK if invalid.
                if IFP.is_voltage_cycle_executed():
                    self.respond("ACK")
                    self.respond_block(MEMORY.read_block(address, size))
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.WRITE_ONE_VALUE_COMMAND):
                command.set_name("memory write value")
                address = command.get_arg(0)
                value = command.get_arg(1)
                if IFP.is_voltage_cycle_executed():
                    MEMORY.write(address, value)
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.WRITE_RAM_COMMAND):
                command.set_name("memory write block")
                if IFP.is_voltage_cycle_executed():
                    data = IFP.buf16k.mem
                    for key in data:
                        MEMORY.write(key, data[key])
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.BUF_SELECT_COMMAND):
                command.set_name("select buffer")
                # arg0 is discarded - we do not care
                if IFP.create_pic_buffer(command.get_arg(0)):
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.READ_DPIFGEN2_FW_ID_COMMAND):
                command.set_name("read firmware id")
                self.respond("ACK")
                fw_id = IFP.get_firmware_id()
                respond_sting = ""
                for item in fw_id:
                    respond_sting = respond_sting + f"{item:x}"
                self.respond(respond_sting)
                is_executed = True

            if command.is_cmd(Cmd.EXECUTE_CUSTOM_VOLTAGE_CYCLE_COMMAND):
                command.set_name("execute voltage cycle")
                IFP.set_voltage_cycle_executed(True)
                IFP.set_voltage_level(command.get_arg(0))
                IFP.set_voltage_level(command.get_arg(1))
                MEMORY.clear()
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.SET_CUSTOM_VOLTAGE_LEVEL_COMMAND):
                command.set_name("set voltage level")
                voltage_level = command.get_arg(0)
                if IFP.set_voltage_level(voltage_level):
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.CONFIGURE_UART_COMMAND):
                command.set_name("set baud rate")
                baudrate_code = command.get_arg(1)
                # decodes the parameter behind CMD1B0100
                if IFP.set_baudrate(baudrate_code):
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.WRITE_PIC_BUFFER_COMMAND):
                command.set_name("buffer write")
                # args: start, length, crc
                # print("%s %s %s" % (arg0, arg1, arg2))
                self.block_start = command.get_arg(0)
                self.block_length = command.get_arg(1)
                self.block_crc = command.get_arg(2)
                self.respond("ACK")
                IFP.expect_data = True
                is_executed = True

            if command.is_cmd(Cmd.AUTO_CHIP_SET_COMMAND):
                command.set_name("auto chip id")
                IFP.auto_chip_id_set = True
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.CONNECT_DP25_COMMAND):
                command.set_name("connect chip")
                if command.get_arg(0) == 1:
                    IFP.chip_is_connected = False
                    self.respond("ACK")
                elif command.get_arg(0) == 0:
                    IFP.chip_is_connected = True
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.CHIP_IDENTIFY_COMMAND):
                command.set_name("chip identify")
                self.respond("ACK")
                self.respond_word(2)
                is_executed = True

            if command.is_cmd(Cmd.DMEM_WRITE_COMMAND):
                command.set_name("DMEM write command")
                address = command.get_arg(0)
                value = command.get_arg(1)
                if IFP.is_voltage_cycle_executed():
                    # todo check for valid address if invalid send NAK
                    MEMORY.write(address, value)
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.DMEM_READ_COMMAND):
                command.set_name("memory read value")
                address = command.get_arg(0)
                # todo check for valid address. Send NAK if invalid.
                if IFP.is_voltage_cycle_executed():
                    self.respond("ACK")
                    self.respond_word(MEMORY.read(address))
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_WRITE_COMMAND):
                command.set_name("APARAM write command")
                address = command.get_arg(0)
                value = command.get_arg(1)
                if IFP.is_voltage_cycle_executed():
                    # todo check for valid address if invalid send NAK
                    MEMORY.write(address, value)
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_READ_COMMAND):
                command.set_name("APARAM read value")
                address = command.get_arg(0)
                size = command.get_arg(1)
                # todo check for valid address. Send NAK if invalid.
                if IFP.is_voltage_cycle_executed():
                    self.respond("ACK")
                    if size == 1:  # block read is implemented as read command with two arguments 1. address 2. size
                        self.respond_word(MEMORY.read(address))
                    else:
                        self.respond_block(MEMORY.read_block(address, size))
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_BLOCK_WRITE_COMMAND):
                command.set_name("APARAM block write command")
                if IFP.is_voltage_cycle_executed():
                    data = IFP.buf512.mem
                    for key in data:
                        MEMORY.write(key, data[key])
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.BURN_ONE_VALUE_COMMAND):
                command.set_name("Burn Single OTP command")
                answer_string = "ACK"
                address = command.get_arg(0)
                value = command.get_arg(1)
                if IFP.is_voltage_cycle_executed():
                    # todo check for valid address if invalid send NAK
                    if not MEMORY.burn_otp(address, value):
                        answer_string = "NAK"
                else:
                    answer_string = "NAK"
                self.respond(answer_string)
                is_executed = True

            if command.is_cmd(Cmd.WRITE_OTP_COMMAND):
                command.set_name("APARAM write command")
                answer_string = "ACK"
                if IFP.is_voltage_cycle_executed():
                    data = IFP.buf16k.mem
                    for key in data:
                        if not MEMORY.burn_otp(key, data[key]):
                            answer_string = "NAK"
                else:
                    answer_string = "NAK"
                self.respond(answer_string)
                is_executed = True

            if command.is_cmd(Cmd.BLANK_CHECK):
                command.set_name("APARAM write command")
                address = command.get_arg(0)
                length = command.get_arg(1)
                if MEMORY.blank_check(address, length):
                    self.respond("ACK")
                else:
                    self.respond("NAK3F00")
                is_executed = True

            if command.is_cmd(Cmd.BURN_APARAM_PATCH_COMMAND):
                command.set_name("APARAM patch command")
                address = command.get_arg(0)
                if IFP.is_voltage_cycle_executed():
                    data = MEMORY.read(address)
                    MEMORY.burn(address, data)
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.MEMORY_GET_CRC_COMMAND):
                command.set_name("Memory get crc command")
                if IFP.is_voltage_cycle_executed():
                    self.respond("ACK")
                    self.respond_word(self.crc_calculate(command.get_arg(0), command.get_arg(1)))
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.OTP_GET_CRC_COMMAND):
                command.set_name("Memory get crc command")
                if IFP.is_voltage_cycle_executed():
                    self.respond("ACK")
                    self.respond_word(self.crc_calculate(command.get_arg(0), command.get_arg(1)))
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_GET_CRC_COMMAND):
                command.set_name("Memory get crc command")
                if IFP.is_voltage_cycle_executed():
                    self.respond("ACK")
                    self.respond_word(self.crc_calculate(command.get_arg(0), command.get_arg(1)))
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_BLOCK_BURN_COMMAND):
                command.set_name("APARAM block burn command")
                if IFP.is_voltage_cycle_executed():
                    data = IFP.buf512.mem
                    for key in data:
                        MEMORY.burn(key, data[key])
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.FW_PATCH_BURN_COMMAND):
                command.set_name("Fw patch command")
                address = command.get_arg(0)
                if IFP.is_voltage_cycle_executed():
                    data = MEMORY.read(address)
                    MEMORY.burn(address, data)
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.FW_PATCH_BLOCK_BURN_COMMAND):
                command.set_name("Fw patch command")
                if IFP.is_voltage_cycle_executed():
                    data = IFP.buf16k.mem
                    for key in data:
                        MEMORY.burn(key, data[key])
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.GET_INFO_COMMAND):
                command.set_name("Get info command")
                info_code = command.get_arg(0)
                if info_code == 0x0000:
                    self.respond("ACK")
                    self.respond_fill_to_64(IFP.get_device_id())
                elif info_code == 0x0001:
                    self.respond("ACK")
                    self.respond_fill_to_64(IFP.get_firmware_id())
                elif info_code == 0x0002:
                    self.respond("ACK")
                    self.respond_fill_to_64(IFP.get_customer_id())
                elif info_code == 0x0003:
                    self.respond("ACK")
                    self.respond_fill_to_64(IFP.get_patch_id())
                elif info_code == 0x0010:
                    self.respond("ACK")
                    self.respond_fill_to_64(IFP.get_aparam_id())
                elif info_code == 0x0011:
                    self.respond("ACK")
                    self.respond_fill_to_64(IFP.get_rom_id())
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APPLICATION_START_COMMAND):
                command.set_name("Application start command")
                if not IFP.get_application_start():
                    IFP.set_application_start()
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.APPLICATION_STOP_COMMAND):
                command.set_name("Application stop command")
                if not IFP.get_application_start():
                    self.respond("NAK")
                else:
                    IFP.set_application_stop()
                    self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.GET_PROTOCOL_VERSION_COMMAND):
                command.set_name("Get protocol version command")
                string = IFP.get_protocol_version()
                # self.respond('ACK' + string)
                self.respond("ACK" + string[2] + string[3] + string[0] + string[1])
                is_executed = True

            if command.is_cmd(Cmd.AUTOSTART_SET_COMMAND):
                command.set_name("Autostart set command")
                value = command.get_arg(0)
                IFP.set_autostart(value)
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.AUTOSTART_GET_COMMAND):
                command.set_name("Autostart get command")
                self.respond("ACK")
                self.respond_word(IFP.get_autostart())
                is_executed = True

            if command.is_cmd(Cmd.BOOT_STATUS_GET_COMMAND):
                command.set_name("Boot status get command")
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_API_LOCK_COMMAND):
                command.set_name("APARAM api lock command")
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.APARAM_APPLY_COMMAND):
                command.set_name("APARAM apply command")
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.FW_PATCH_APPLY_COMMAND):
                command.set_name("FW patch apply command")
                self.respond("ACK")
                is_executed = True

            if command.is_cmd(Cmd.LOCK_CHIP_COMMAND):
                command.set_name("Lock chip command")
                low_word = command.get_arg(0)
                high_word = command.get_arg(1)
                if IFP.lock_chip(low_word, high_word):
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if command.is_cmd(Cmd.UNLOCK_CHIP_COMMAND):
                command.set_name("Unlock chip command")
                low_word = command.get_arg(0)
                high_word = command.get_arg(1)
                if IFP.unlock_chip(low_word, high_word):
                    self.respond("ACK")
                else:
                    self.respond("NAK")
                is_executed = True

            if not is_executed:
                print(command)
                print("Data: ", data_buffer)

    # build up responses

    def respond(self, string_data):
        # first byte in buffer must be zero
        result = [0]
        result.extend([ord(i) for i in string_data])
        self.rx_handler(result)

    def respond_word(self, value):
        value_high = (value & 0xFF00) >> 8
        value_low = value & 0xFF
        # first byte in buffer must be zero
        result = [0, value_low, value_high]
        self.rx_handler(result)

    def respond_fill_to_64(self, data):
        result = [0]
        for item in data:
            value_high = (item & 0xFF00) >> 8
            value_low = item & 0xFF
            # first byte in buffer must be zero
            result.append(value_low)
            result.append(value_high)
        while len(result) <= 64:
            result.append(0)
        self.rx_handler(result)

    def respond_block(self, data):
        result = [0]
        for item in data:
            value_high = (item & 0xFF00) >> 8
            value_low = item & 0xFF
            # first byte in buffer must be zero
            result.append(value_low)
            result.append(value_high)
        self.rx_handler(result)

    # CRC helper function

    def crc_calculate(self, start_address, size):
        datalist = MEMORY.read_block(start_address, size)
        i_crc = 0
        # def calculate_crc(self, datalist, i_crc):
        # Inputs: datalist (array of 16-Bit-integer) and initial crc (16-Bit-integer, must be 0 at start of crc
        # calculation)
        i_polynom = 0x100B  # 16 bit polynomioum with 4 feedbacks
        for i in range(2 * len(datalist)):  # loop bytewise over words
            if i % 2:  # bytewise processing, process low byte of word first
                i_d = (datalist[int(i / 2)] & 0xFF00) >> 8  # process high byte
            else:
                i_d = datalist[int(i / 2)] & 0x00FF  # process low byte
            # print("%04X" % datalist[int(i/2)])
            for j in range(8):  # processing byte
                i_bit = i_crc & 0x8000
                i_crc = (i_crc << 1) & 0xFFFF  # AND to suppress bit 17
                if i_d & (1 << j):  # Check the byte for ones
                    i_bit ^= 0x8000
                if i_bit:
                    i_crc ^= i_polynom
                    # print("       Intermediate bitwise %04X" %i_crc)
                    # print("Intermediate by word %04X" %i_crc)
        return i_crc  # Output: crc (integer)
