from __future__ import annotations

import unittest

from dpIfGen2lib.test.dp3.support.interface_box_persistent import IFBoxPersistent


class TestIFBoxAbstraction(unittest.TestCase):
    def setUp(self):
        self.IFP = IFBoxPersistent()

    def test_set_baudrate_to_9600(self):
        self.IFP.set_baudrate(0)
        assert self.IFP.get_baudrate() == 9600

    def test_set_baudrate_to_invalid_value(self):
        assert False is self.IFP.set_baudrate(100)

    def test_set_baudrate_to_highest(self):
        self.IFP.set_baudrate(5)
        assert self.IFP.get_baudrate() == 105000

    def test_exception_after_record_invalidation(self):
        # per default, exception is zero
        assert self.IFP.exception == 0
        # and two record types exist (DPARAM BE and FE)
        assert self.IFP.is_record_valid(2)
        assert self.IFP.is_record_valid(6)
        # now invalidate one of it
        self.IFP.invalidate_record(2)
        assert not self.IFP.is_record_valid(2)
        # we should have exception after power cycle
        self.IFP.init_with_voltage_cycle()
        assert self.IFP.exception == 1

    def test_exception_after_record_invalidation_aparams(self):
        # per default, exception is zero
        assert self.IFP.exception == 0
        # Since ROM 3.4 we expect the default APARAM already in OTP
        # If this record is invalidated and we do a POR, we still
        # see no exception. The missing APARAM set is indicated in
        # the firmware status.
        # Unfortunately the firmware status has different coding between
        # ROM 3.4 and ROM 4.0. Thus we need some version dependent check here.
        # TODO think about a good test

    def test_otp_size(self):
        size_old = self.IFP.get_otp_size()
        data = [1, 2, 3, 4]
        self.IFP.add_record(3, len(data))
        self.IFP.add_data_to_record(data)
        size_new = self.IFP.get_otp_size()
        assert size_new < size_old

    def test_patch_version(self):
        # initial patch version id zero
        assert [0, 0, 0, 0, 0, 0, 0, 0] == self.IFP.get_patch_version()
        # add a patch record
        data = [1, 2, 3, 4]
        self.IFP.add_record(1, len(data))
        self.IFP.add_data_to_record(data)
        assert [0, 1, 2, 3, 16, 17, 18, 19] == self.IFP.get_patch_version()
        # invalidate patch
        self.IFP.invalidate_record(1)
        assert [0, 0, 0, 0, 0, 0, 0, 0] == self.IFP.get_patch_version()
