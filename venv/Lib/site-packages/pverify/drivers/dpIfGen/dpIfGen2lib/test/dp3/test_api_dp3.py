from __future__ import annotations

import os
import unittest

from dpIfGen2lib.dpIfGen3API.xml_utils import XML_reader

# set an environment variable to bring API into test mode
os.environ["TEST_ENV_DP_TOOLS_2016-04-15"] = "true"
os.environ["INTERFACE_BOX"] = "dp3"

from dpIfGen2lib.dpIfGen3API.com_dpifgen3_api_basic import DpIfGen2APIBasicDp3
from dpIfGen2lib.dpIfGen3API.com_dpifgen3_commands_list import DpIfGen3Commands as Cmds
from dpIfGen2lib.test.dp3.support.interface_box_persistent import IFP
from intelhex import IntelHex

IFP.set_firmware_id(["0000", "0000", "0000", "0000"])


def get_full_path(path_relative):
    return os.path.join(os.path.dirname(os.path.abspath(__file__)), path_relative)


class TestAPI3(unittest.TestCase):
    def setUp(self):
        IFP.__init__()
        IFP.set_eeprom_valid(False)
        self.api = DpIfGen2APIBasicDp3
        self.api.voltage_level_set(0)
        self.api.voltage_level_set(12)
        self.api.combo_enable()
        # self.api.combo_disable()

    def _helper_read_hex_file(self, filename):
        ih = IntelHex()
        ih.fromfile(filename, "hex")
        pydict = ih.todict()
        # remove first element
        del pydict["start_addr"]
        addresses = sorted(pydict.keys())
        values = [pydict[i] for i in addresses]
        return addresses, values

    def test_voltage_level_set_to_invalid_value(self):
        self.assertRaises(Exception, self.api.voltage_level_set, 31)

    def test_voltage_level_set_to_valid_value(self):
        self.api.voltage_level_set(20)

    def test_sync(self):
        # Simulate that devices has successfully been powered
        # IFP.set_voltage_cycle_executed(True)

        # check, if too many sync tries result in exception
        # todo I do not know where this requirement comes from
        self.api.voltage_level_set(22)
        self.api.voltage_level_set(8)
        self.assertRaises(Exception, self.api.sync_set, 101)
        # Now send a valid request
        self.api.sync_set()
        # self.assertEqual(True, IFP.is_synchronized())

        # Simulate that device is not powered.
        # We expect that Sync is failing (even after 10 times).
        # IFP.set_voltage_cycle_executed(False)
        # IFP.set_synchronized(False)
        # self.assertRaises(Exception, self.api.sync_set, 10)

    if 0:

        def test_identify_chip(self):
            fw_id = self.api.chip_identify()
            assert fw_id == "dp3"

    # will pass when the api is configuration to the new firmware version of the interfaceboard
    # (little and big endian problem)

    def test_voltage_level_set(self):
        voltage_level_device = 22
        self.api.voltage_level_set(voltage_level_device)
        # self.assertEqual(IFP.get_voltage_level(), voltage_level_device)

    def test_sync_interface_box(self):
        self.api.sync_set()

    def test_read_if_serial_number(self):
        assert self.api.read_if_serial_number() == "04110078"

    def test_write_if_serial_number(self):
        serial_number = self.api.read_if_serial_number()
        self.api.write_if_serial_number("03110078")
        assert self.api.read_if_serial_number() == "03110078"
        self.api.write_if_serial_number(serial_number)

    def test_read_if_hardware_version(self):
        assert self.api.read_if_hardware_version().startswith("DPIFGEN2-V1.1")

    def test_write_if_hardware_version(self):
        self.api.write_if_hardware_version("DPIFGEN2-V1.1")
        assert self.api.read_if_hardware_version().startswith("DPIFGEN2-V1.1")

    def test_read_if_firmware_version(self):
        assert self.api.read_if_firmware_version().startswith("dpIfGen2_V3.")

    def test_if_buffer_size(self):
        assert self.api.if_buffer_size_get() == 8192

    def test_if_info(self):
        info = self.api.if_info_get()
        results = info.values()
        found_fw_ver = False
        found_hw_ver = False
        found_ser_no = False
        buff_size = 0
        for result in results:
            if isinstance(result, str):
                if result.startswith("dpIfGen2_V3."):
                    found_fw_ver = True
                if result.startswith("DPIFGEN2-V1."):
                    found_hw_ver = True
                if result.startswith("04110078"):
                    found_ser_no = True
            if isinstance(result, int):
                buff_size = result
        assert found_fw_ver
        assert found_hw_ver
        assert found_ser_no
        assert buff_size > 0

    def test_set_baud_rate(self):
        self.api.sync_set()
        self.api.set_baud_rate(9600)
        self.assertRaises(Exception, self.api.set_baud_rate, 2)

    def test_chip_info_get(self):
        self.api.sync_set()
        info_dict = self.api.chip_info_get()
        assert info_dict["Chip ID"] == "0001020304050607"
        assert info_dict["Chip available OTP size"] == "AA1F"
        assert info_dict["Chip ROM ID"][0:2] == "3B"

    def test_chip_info_get_patch(self):
        self.api.sync_set()
        info_dict = self.api.chip_info_get()
        assert info_dict["Chip patch version"] == "0000000000000000"
        data = [0xAB, 0x23, 0x12]
        record_type = 1
        self.api.record_burn(record_type, data)
        info_dict = self.api.chip_info_get()
        assert info_dict["Chip patch version"] == "0001020310111213"

    def test_write_read_memory(self):
        self.api.sync_set()
        self.api.write_memory(0x20001FF0, [123, 200, 0xFF])
        assert [123, 200, 255] == self.api.read_memory(536879088, 3)
        # only 8-bit values are allowed
        self.assertRaises(Exception, self.api.write_memory, 0x20001FF0, [0x100])

    def test_write_read_memory_combo(self):
        self.api.sync_set()
        self.api.combo_enable()
        self.api.write_memory(0x20001FF0, [123, 200, 222])
        assert [123, 200, 222] == self.api.read_memory(536879088, 3)
        self.api.combo_disable()

    def test_write_read_memory16(self):
        self.api.sync_set()
        self.api.write_memory16(0x20001FF0, [1230, 2000, 0xFFFF])
        assert [1230, 2000, 65535] == self.api.read_memory16(536879088, 3)
        # only 16-bit values are allowed
        self.assertRaises(Exception, self.api.write_memory, 0x20001FF0, [0x10000])
        # address must be 16-bit aligned
        self.assertRaises(Exception, self.api.write_memory, 0x20001FF1, [0x100])

    def test_ahex_write(self):
        self.api.sync_set()
        file_path = get_full_path("./support/image_ram.hex")
        self.api.write_hex_file(file_path)
        addresses, values = self._helper_read_hex_file(file_path)
        read_data = self.api.read_memory(addresses[0], len(addresses))
        assert values == read_data

    def test_app_status_get(self):
        self.api.sync_set()
        assert [0] == self.api.app_status_get()

    def test_get_rom_id_and_check_platform_and_design_step(self):
        self.api.sync_set()
        data_read = self.api.chip_info_get_single_raw(0x11)
        # check first byte: it reflects the platform for DP3B
        # all other values do not need to be checked because they will change from release to release
        # if "TEST_ENV_DP_TOOLS_2016-04-15" not in os.environ:
        if 1:
            assert data_read[0] == 59
            assert data_read[1] == 48

    def test_get_jtag_id_and_check_if_fred(self):
        self.api.sync_set()
        data_read = self.api.chip_info_get_single_raw(0x14)
        assert data_read[3] == 128

    def test_ping(self):
        self.api.sync_set()
        assert [95, 245] == self.api.ping(62815)

    def test_protocol_id_get(self):
        self.api.sync_set()
        assert self.api.protocol_id_get() == "0003"

    def test_record_dparam_read(self):
        # simulate some default DPARAMs
        self.api.sync_set()
        record_type = 2
        data = list(range(54))
        assert data == self.api.record_read(record_type)

    def test_record_write_read(self):
        # write and read another record type
        self.api.sync_set()
        data = [0xAB, 0x23, 0x12]
        record_type = 3
        self.api.record_write(record_type, data)
        assert data == self.api.record_read(record_type)

    def test_record_burn_read(self):
        self.api.sync_set()
        data = [0xAB, 0x23, 0x12]
        record_type = 2
        self.api.record_burn(record_type, data)
        assert data == self.api.record_read(record_type)

    def test_record_read(self):
        # self.api.wire_dump_enable()
        self.api.sync_set()
        dummy_calibration_data = [0x48, 0x61, 0x6C, 0x6C, 0x6F]
        self.api.record_write(
            Cmds.RECORD_TYPES.get_value_by_name("OTP_FS_DPARAM_FE"),
            dummy_calibration_data,
        )
        record = self.api.record_read(Cmds.RECORD_TYPES.get_value_by_name("OTP_FS_DPARAM_FE"))
        # print(record)
        assert "".join(chr(i) for i in record) == "Hallo"

    def test_write_record_from_xml(self):
        filename = get_full_path("./support/use_case_306.xml")
        self.api.sync_set()
        self.api.record_write_xml(filename)
        data = self.api.record_read(3)
        instance = XML_reader(filename, 3)
        assert data == instance.get_data()

    def test_write_record_from_hex(self):
        filename = get_full_path("./support/patch.hex")
        self.api.sync_set()
        self.api.record_write_hex(filename)
        data = self.api.record_read(1)
        addresses, values = self._helper_read_hex_file(filename)
        assert data == values

    def test_burn_record_from_xml(self):
        filename = get_full_path("./support/use_case_306.xml")
        self.api.sync_set()
        self.api.record_burn_xml(filename)
        data = self.api.record_read(3)
        instance = XML_reader(filename, 3)
        assert data == instance.get_data()

    def test_burn_record_from_hex(self):
        filename = get_full_path("./support/patch.hex")
        self.api.sync_set()
        self.api.record_burn_hex(filename)
        data = self.api.record_read(1)
        addresses, values = self._helper_read_hex_file(filename)
        assert data == values

    def test_otp_size_reduction(self):
        filename = get_full_path("./support/use_case_306.xml")
        self.api.sync_set()
        result = self.api.chip_info_get_single_raw(0x05)
        size_pre = (result[1] << 8) | result[0]
        self.api.record_burn_xml(filename)
        result = self.api.chip_info_get_single_raw(0x05)
        size_post = (result[1] << 8) | result[0]
        assert size_post < size_pre

    def test_record_invalidate(self):
        # arrange
        # invalidating of records is done by sending no data
        # we need to read the interface box version to enable the version check
        IFP.set_firmware_version("dpIfGen2_V3.1.1_something")
        self.api.read_if_firmware_version()
        self.api.sync_set()

        # act
        # self.api.wire_dump_enable()
        record_type = 2
        self.api.record_burn(record_type, [])

        # assert
        self.assertRaises(Exception, self.api.record_read, record_type)

    def test_record_invalidate_old_version(self):
        # arrange
        # invalidating of records is done by sending no data
        IFP.set_firmware_version("dpIfGen2_V3.0.23_something")
        # we need to read the interface box version to enable the version check
        self.api.read_if_firmware_version()
        self.api.sync_set()

        # act
        # self.api.wire_dump_enable()
        record_type = 2

        # assert
        self.assertRaises(Exception, self.api.record_burn, record_type, [])

    def test_if_configure(self):
        self.api.sync_set()
        self.api.if_configuration_set([1, 0])
        self.api.if_configuration_set([2, 1])

    # ----------------------------------------------------------------------------------------------------------------------

    # THE TRANSPARAENT TESTS WILL BE CARRIED OUT ON ALREADY DEFINED COMMANDS
    # TRANSPARENT COMMANDS ARE MADE TO BE ABLE TO BUILD NEW COMMANDS
    # WITHOUT ADDING NEW CODE TO DPIFEGEN2
    # TO TEST YOUR TRANSPARENT COMMAND YOU HAVE TO BUILD YOUR COMMAND BASED ON THE TREE PROTOTYPES
    # JUST WRAP YOUR NEW COMMAND INTO THE COMMANDS DEFINED IN COM_DPIFGEN3_LLD.PY
    # FOR WRITE, READ AND EXECUTE THERE ARE 3 COMMANDS AVALIABLE TO WRAP YOUR NEW COMMANDS

    # FOR TRANSPARENT_WRITE I HAVE TO ADD CRC CALCULATION INSIDE self.api.write_transparent FOR WRITE_MEMORY NEEDS CRC
    # ON UART SIDE AS LAST ARGUMENT ALWAYS ADD 20 ASCII CAHR TO CMD85

    # FOR TRANSPARENT_READ I HAVE TO ADD 0000 GET CORRECT LENGTH
    # ALWAYS ADD 20 ASCII CAHR TO CMD2B

    # FOR TRANSPARENT EXECUTE USER IS FREE TO DEFINE NUMBER OF PARAMETER BY HIMSELF
    # HERE USER CAN USE 1....32 VALUES NO CHECK FOR SIZE IS CARRIED OUT

    def test_transparent_sync(self):
        self.api.sync_set()
        self.api.write_transparent([0x7F], [])

    def test_transparent_protocol_id(self):
        self.api.sync_set()
        self.api.write_transparent([0x7E], [])

    def test_transparent_buffer_request(self):
        self.api.sync_set()
        cmd = [0x7C, 0x14, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        self.api.write_transparent(cmd, [])

    def test_transparent_data_write(self):
        # self.api.wire_dump_enable()
        self.api.sync_set()
        data = [123, 200, 222]
        wr_cmd = [0x40, 0x09, 0xF0, 0x1F, 0x00, 0x20, len(data), 0x00, 0x2B, 0x51]
        self.api.write_transparent(wr_cmd, data)

    def test_transparent_write_read(self):
        # self.api.wire_dump_enable()
        self.api.sync_set()
        data = [123, 200, 222]
        wr_cmd = [0x40, 0x09, 0xF0, 0x1F, 0x00, 0x20, len(data), 0x00, 0x2B, 0x51]
        rd_cmd = [0x40, 0x0B, 0xF0, 0x1F, 0x00, 0x20, len(data), 0x00, 0x00, 0x00]
        self.api.write_transparent(wr_cmd, data)
        data_read = self.api.read_transparent(rd_cmd)
        assert data == data_read[0 : len(data)]

    def _test_transparent_write_read_2(self):
        # This test will fail because the interpretation of transparent commands is not implemented in the
        # interface box model.
        self.api.wire_dump_enable()
        self.api.sync_set()
        data = [123, 200, 222]
        wr_cmd = [0x40, 0x09, 0xF0, 0x1F, 0x00, 0x20, len(data), 0x00, 0x2B, 0x51]
        self.api.write_transparent(wr_cmd, data)
        data_read = self.api.read_memory(0x20001FF0, 3)
        assert data == data_read[0 : len(data)]

    def test_transparent_execute(self):
        # self.api.wire_dump_enable()
        self.api.sync_set()
        assert not self.api.execute_transparent([127])

    # __----------------------------------------------------------------------------------------------------------------

    def test_eeprom_start(self):
        self.api.sync_set()
        file_path = get_full_path("./support/image_ram.hex")
        self.api.write_hex_file(file_path)
        self.api.store_fw(0)
        self.api.app_reset()
        # after reset, we SYNC again
        self.api.sync_set()
        status = DpIfGen2APIBasicDp3.app_status_get()
        assert [0] == status

    def test_dump_ram(self):
        self.api.sync_set()
        file_path = get_full_path("./support/image_ram.hex")
        self.api.write_hex_file(file_path)
        store_file_path = get_full_path("./support/image_dump_ram.hex")
        self.api.dump_ram(store_file_path)
        ref_file_path = get_full_path("./support/image_dump_ram_expected.hex")
        file1 = open(store_file_path).readlines()
        file2 = open(ref_file_path).readlines()
        for a, b in zip(file1, file2):
            assert a == b

    def test_running_in_ram(self):
        self.api.sync_set()
        IFP.set_eeprom_valid(False)
        assert not self.api.is_fw_running_in_ram()
        IFP.set_eeprom_valid(True)
        assert self.api.is_fw_running_in_ram()

    def test_start_fw_from_eeprom(self):
        # self.api.wire_dump_enable()
        self.api.sync_set()
        assert not self.api.is_fw_running_in_ram()
        file_path = get_full_path("./support/image_ram.hex")
        self.api.write_eeprom(file_path)
        self.api.app_reset()
        self.api.sync_set()
        assert self.api.is_fw_running_in_ram()

    def test_write_memory_two_telegrams(self):
        self.api.sync_set()
        data = list(range(70))
        self.api.write_memory(0x20001FF0, data)
        assert data == self.api.read_memory(536879088, len(data))

    def test_uart_tristate(self):
        self.api.sync_set()
        self.api.tristate_control(6)
        self.assertRaises(Exception, self.api.sync_set)
        self.api.tristate_control(2)
        self.api.sync_set()

    def test_uart_tristate_commands(self):
        self.api.sync_set()
        self.api.tristate_control(0)
        self.api.tristate_control(1)
        self.api.tristate_control(5)
        self.assertRaises(Exception, self.api.tristate_control, 4)
        self.assertRaises(Exception, self.api.tristate_control, 3)
        self.assertRaises(Exception, self.api.tristate_control, 7)

    def test_timeout_config(self):
        self.api.timeout_config(1, 100)
        self.assertRaises(Exception, self.api.timeout_config, 3, 123345)

    def test_exception_after_removing_default_record(self):
        # per default, there is no excepiont
        self.api.connection_establish()
        result = self.api.chip_info_get_single_raw(0x13)
        assert result[0] == 0

        # remove one of the default records
        self.api.record_burn(6, [])
        self.api.connection_establish()
        result = self.api.chip_info_get_single_raw(0x13)
        assert result[0] == 1

    def test_closing_after_exception(self):
        self.assertRaises(Exception, self.api.sync_set())
        # TODO how to assert that closing took place?

    def tearDown(self):
        self.api.voltage_level_set(0)
        # tearDown method is called at the end


if __name__ == "__main__":
    unittest.main()
