/* ===========================================================================
** Copyright (C) 2016 Infineon Technologies AG
** All rights reserved.
** ===========================================================================
**
** ===========================================================================
** This document contains proprietary information of Infineon Technologies AG.
** Passing on and copying of this document, and communication of its contents
** is not permitted without Infineon's prior written authorization.
** ===========================================================================
*/

#ifndef COMMAND_HANDLER_H_
#define COMMAND_HANDLER_H_

/**
  * @file: command_handler.h
  *
  * @brief This module handles the command processing. This includes to manage all executable
  * commands with individual permission and an individual interpretation of the frame argument Bytes.
  *
  */

/*
==============================================================================
   1. INCLUDE FILES
==============================================================================
*/
#include <stdint.h>     //uint*_t
#include <stdbool.h>    //bool

/**
 * @defgroup group_command_handler_interface Interface of the command handler
 * @ingroup group_interface_description
 *
 * @{
 */

/*
==============================================================================
   2. DEFINITIONS
==============================================================================
*/

/**
 * While sending data to the host, the data must be consistent in memory.
 * This define describes the size of the local response buffer which can be used
 * to ensure this requirement.
 */
#define CMDH_RESPONSE_BUFFER_SIZE_IN_U32        6u

/*
==============================================================================
   3. TYPES
==============================================================================
*/


/** states of cmdh_process() */
typedef enum
{
    CMDH_IDLE = 0x0,
    CMDH_LISTENING,
    CMDH_EXECUTING_CMD,
    CMDH_STOPPED,
    CMDH_FAIL
} Cmdh_Processing_State_t;

/** all command classes
 *
 * These are the allowed start bytes of any message sent to the device.
 * All bytes result in two falling edges which trains the baud rate detector.
 */
enum Cmdh_Classes_e
{
    CMDH_CLASS_SYN      = 0x7F, //!< 0x7F: performs synchronization (single byte command)
    CMDH_CLASS_ID       = 0x7E, //!< 0x7E: requests protocol ID (single byte command)
    CMDH_CLASS_PUBLIC   = 0x7C, //!< 0x7C: starts public command frame (see ::Cmdh_Cmds_e)
    CMDH_CLASS_0        = 0x78, //!< 0x78: reserved for future use
    CMDH_CLASS_1        = 0x70, //!< 0x70: reserved for future use
    CMDH_CLASS_2        = 0x60, //!< 0x60: reserved for future use
    CMDH_CLASS_PRIVATE  = 0x40  //!< 0x40: starts private command frame (see ::Cmdh_Cmds_e)
};

/** all command IDs */
enum Cmdh_Cmds_e
{
    /** Public commands */
    CMDH_CMD_APP_STOP                   = 0x01, //!< 0x01: stop command
    CMDH_CMD_PRIVATE_COMMANDS_LOCK      = 0x02, //!< 0x02: lock private commands
    CMDH_CMD_PRIVATE_COMMANDS_UNLOCK    = 0x03, //!< 0x03: unlock private commands
    CMDH_CMD_INFO_GET                   = 0x04, //!< 0x04: read info (mainly version IDs)
    CMDH_CMD_PING                       = 0x07, //!< 0x07: ping command
    CMDH_CMD_COMMAND_IS_REGISTERED      = 0x0A, //!< 0x0A: check, if command ID and class is registered
    CMDH_CMD_APP_RESET                  = 0x19, //!< 0x19: fw reset (soft reset of device)
    CMDH_CMD_TIMEOUT_CONFIG             = 0x20, //!< 0x20: configures the timeout function of the driver
    CMDH_CMD_PUBLIC_MAX                 = 0xFF, //!< 0xFF: This is the maximum allowed value. Disregarding this can lead to undefined behavior!

    /** Private commands */
    CMDH_CMD_MEMORY_WRITE               = 0x09, //!< 0x09: write data to memory
    CMDH_CMD_MEMORY_READ                = 0x0B, //!< 0x0B: read data from memory
    CMDH_CMD_MEMORY_CRC_GET             = 0x0C, //!< 0x0C: check CRC over memory region
    CMDH_CMD_RECORD_READ                = 0x11, //!< 0x11: read data of a given record
    CMDH_CMD_RECORD_WRITE               = 0x12, //!< 0x12: write record to RAM
    CMDH_CMD_RECORD_BURN                = 0x13, //!< 0x13: burn record to device
    CMDH_CMD_EEPROM                     = 0x27, //!< 0x27: EEPROM related command
    CMDH_CMD_PRIVATE_MAX                = 0xFF  //!< 0xFF: This is the maximum allowed value. Disregarding this can lead to undefined behavior!
} ;

/** Protocol ID, see ::CMDH_CLASS_ID */
#define TRANSPORT_PROTOCOL_VER_MAJOR   3
#define TRANSPORT_PROTOCOL_VER_MINOR   0

/** ACK and NACK used by command handler */
enum
{
    CMDH_ACK                        = 0x00, //!< 0x00: command has been received w/o error and is acknowledged
    CMDH_NACK                       = 0x01  //!< 0x01: command has been received w/ error or is not acknowledged
};

typedef enum
{
    CMDH_EVT_NONE,
    CMDH_EVT_START,
    CMDH_EVT_STOP
} Cmdh_Events_t;


/** Size of a command's argument, in aggregates of 32bit words. */
#define CMDH_CMD_ARGS_SIZE_U32             2u

/** Arguments of @b any command.
 *
 * The arguments are hidden in an array, so Cmdh_CmdArgs_t
 * is an opaque data type (ODT).
 * Each command casts the instance of ODT Cmdh_CmdArgs_t into
 * whatever transparent data type the respective command expects.
 */
typedef struct
{
    /** Arguments of a command
     *
     * @note Each command may cast the arguments into
     * whatever is necessary, so make sure that it is
     * aligned to the largest scalar data type of the underlying
     * core. */
    uint32_t word32[CMDH_CMD_ARGS_SIZE_U32];
} Cmdh_CmdArgs_t;

/* tell compiler and linker to pack Cmdh_CmdFrame_t.
 * There are no padding bytes allowed because it is accessed
 * byte by byte on 'physical' level, i.e. from the uart driver.
 * Any padding bytes will kill the implementation, size must be 11 bytes.
 */
#pragma pack(push,1)
/** command frame, made of header, command arguments and checksum.
 *
 * See also @ref sctDp3_CmdHandler_frame
 */
typedef struct
{
    /** command class, must be one (supported) class from
     * ::Cmdh_Classes_e to form a legal command.
     *
     * @note the trailing _ is required because 'class' is a reserved keyword
     * in C++. This struct is used within SC/C++, therefore we must avoid
     * such keywords. */
    uint8_t         class_;
    /** command id, must be one  id from ::Cmdh_Cmds_e to form a legal
     * command. */
    uint8_t         id;
    /** arguments, casted to whatever needs of actual command */
    Cmdh_CmdArgs_t  args;
    /** XOR checksum of all above bytes. */
    uint8_t         checksum;
} Cmdh_CmdFrame_t;
#pragma pack(pop)           // make sure we are back to normal

/* tell compiler and linker to pack Cmdh_RxBuf_t.
 * There are no padding bytes allowed because it is accessed
 * byte by byte on 'physcial' level, i.e. from the uart driver.
 * Any compiler-introduced (!) padding bytes will
 * kill the implementation, size must be 13 bytes.
 */
#pragma pack(push,1)
/** receive buffer for command handler, this is where communication (uart)
 * driver (well, it's receiver to be precise) fills in the received bytes.
 * Hence, the name 'rx buffer'.
 */
typedef struct
{
    /** padding bytes to align Cmdh_CmdFrame_t.args to 32bit */
    uint8_t         reserved[2];
    /** command frame */
    Cmdh_CmdFrame_t cmd;
} Cmdh_RxBuf_t;
#pragma pack(pop)           // make sure we are back to normal

/**Buffer which can be used to temporary store response data in memory.*/
typedef struct
{
    uint32_t buffer[CMDH_RESPONSE_BUFFER_SIZE_IN_U32];

    /*Data pointer.
     * Safes the data pointer for response frames
     * until the header is sent.
     */
    const void*  data;

    /*Data length.
     * Safes the data length for response frames
     * until the header is sent.
     */
    uint16_t data_len;
} Cmdh_Response_t;


/* Temporary enable Byte packing to ensure that 'sizeof(x)' of the following structure
 * element does not add any trailing Bytes. The following structure defines the
 * packet context sent over the UART interface. Any added trailing Bytes enlarges
 * the amount of transmitted Bytes. */
#pragma pack(push,1)

/** response frame with (leading) ACK
 *
 * Such response frame looks as follows:
 @code
  ACK | num_payload_bytes(LSB) | num_payload_bytes(MSB) |
        CRC16_payload(LSB)     | CRC16_payload(high)    | XOR-checksum
@endcode
 *
 * The payload bytes are transmitted after the response frame, not covered in this struct.
 */
typedef struct ack_frame
{
    /** CMDH_ACK */
    uint8_t ack;
    /** number of payload bytes */
    uint16_t data_len;
    /** CRC16 of payload bytes */
    uint16_t crc16;
    /** checksum (XOR) calculated over ack, data_len and crc16. */
    uint8_t checksum;
} response_frame_ack_t;

/* Deactivate the temporary enabled Byte packing option again */
#pragma pack(pop)

/**
 * Definition of the negative response frame
 */
typedef struct
{
    /**
     * nack_code will be set to ::CMDH_NACK
     */
    uint8_t nack_code;
    /**
     * Low byte of the error code
     */
    uint8_t error_code_low;
    /**
     * High byte of the error code
     */
    uint8_t error_code_high;
    /**
     * Checksum (XOR) calculated over the frame.
     *
     * Note: checksum must be the last element in this structure.
     */
    uint8_t checksum;
} response_frame_nack_t;

/**
 * @ingroup group_command_handler_interface
 * This enum
 *
 */
typedef enum
{
    /** a command from the host or a command-apply function has done its job successfully.
     * See
     */
    CMDH_STATUS_SUCCESSFUL                               = 0x0001,
    CMDH_STATUS_RECORD_TYPE_FAILURE                      = 0x0003, //!< 0x0003: CMDH_STATUS_RECORD_TYPE_FAILURE
    CMDH_STATUS_COMMAND_UNKNOWN                          = 0x0004, //!< 0x0004: called command is not known
    CMDH_STATUS_COMMAND_NOT_REGISTERED                   = 0x0005, //!< 0x0005: given command is not registered
    CMDH_STATUS_PASSWORD_INVALID                         = 0x0005, //!< 0x0005: CMDH_STATUS_PASSWORD_INVALID
    CMDH_STATUS_CRC_MISMATCH                             = 0x0006, //!< 0x0006: CMDH_STATUS_CRC_MISMATCH
    CMDH_STATUS_OUT_OF_MEMORY                            = 0x0007, //!< 0x0007: CMDH_STATUS_OUT_OF_MEMORY
    CMDH_STATUS_RECORD_READ_FAILURE                      = 0x000A, //!< 0x000A: CMDH_STATUS_RECORD_READ_FAILURE
    CMDH_STATUS_ILLEGAL_PARAMETER                        = 0x000B, //!< 0x000B: given parameter is illegal
    CMDH_STATUS_LOCKED_ALREADY                           = 0x000C, //!< 0x000C: CMDH_STATUS_LOCKED_ALREADY
    CMDH_STATUS_DPARAMS_NOT_INITIALIZED                  = 0x000D, //!< 0x000D: CMDH_STATUS_DPARAMS_NOT_INITIALIZED
    CMDH_STATUS_SUCCESSFUL_FORCE_ACK                     = 0x000E, //!< 0x000E: CMDH_STATUS_SUCCESSFUL_FORCE_ACK
    CMDH_STATUS_EEPROM_FAILURE                           = 0x000F, //!< 0x000F: something went wrong while using EEPROM
    CMDH_STATUS_RECORD_VALIDATION_FAILS                  = 0x0010, //!< 0x0010: CMDH_STATUS_RECORD_VALIDATION_FAILS

    CMDH_STATUS_IFBOX_RESERVED                           = 0xFFFF  //!< 0x--FF: Error code region reserved for Interface Box
} Cmdh_Cmd_Execution_State_t;

typedef Cmdh_Cmd_Execution_State_t (*fdef_process_cmd_pload_t) (const Cmdh_CmdArgs_t* args);

typedef struct
{
    fdef_process_cmd_pload_t    fctptr;
    Cmdh_CmdArgs_t              args;
} fctor_process_cmd_pload_t;

/** The prototype of any command.
 *
 * In case the command can or is sucessfully executed, it must
 * implement one of the following:
 * - send a simple ACK to the host
 * - send an ACK and the required response data to the host
 * The command must return ::CMDH_STATUS_SUCCESSFUL in this case.
 *
 * In case the command cannot be executed (for whatever reason), it returns
 * an error code from ::Cmdh_Cmd_Execution_State_t. The @b caller (cmdh_process())
 * takes care of sending the NACK.
 *
 * This prototype is required when registering and executing a command,
 * see e.g. cmdh_process() for an example.
 *
 * @todo This rule avoids duplicate code, but makes the scheme somewhat inconsistent: ACK is
 * done within the command, but NACK is done through the caller. Let the team decide ...
 */
typedef Cmdh_Cmd_Execution_State_t (*Cmdh_Callback_Function) (const Cmdh_CmdArgs_t* args);

/** static data of a command handler object
 */
typedef struct
{
    Cmdh_Events_t               event;
    Cmdh_Processing_State_t     state;
    /** convenience, holds CMDH_ACK, avoids repetitive assignments when
     * transmitting only CMDH_ACK and nothing else. */
    const   uint8_t             ack;
    fctor_process_cmd_pload_t   close_functor;
} Cmdh_t;


/*
==============================================================================
   4. EXPORTED DATA
==============================================================================
*/
extern Cmdh_Response_t cmdh_response;

/*
==============================================================================
   5. FUNCTION PROTOTYPES
==============================================================================
*/

/** cmdh_initialize() initializes
 * - any data memory required by the cmdh
 * - the command tables
 * - underlying uart driver
 *
 * It does @b not start any command handling or uart driver activity, this
 * is done by cmdh_start_event_set().
 */
void cmdh_initialize(void);

/** cmdh_start_event_set() prepares the command handler for
 * starting its work.
 * cmdh_initialize() has been called (long) before and has done all
 * the exhaustive and potentially time consuming set-up work.
 *
 * @note as the name says, cmdh_start_event_set() sets an event (::CMDH_EVT_START).
 * Such event becomes processed once cmdh_process() is called, so remember to
 * call cmdh_process() eventually to actually process the event ...
 */
void cmdh_start_event_set(void);

/** cmdh_stop_event_stop() prepares the command handler for
 * stopping its work.
 *
 * @note as the name says, cmdh_stop_event_set() sets an event (::CMDH_EVT_STOP).
 * Such event becomes processed once cmdh_process() is called, so remember to
 * call cmdh_process() eventually to actually process the event ...
 */
void cmdh_stop_event_set(void);

/** cmdh_process() executes the 'machinery' that is necessary to communicate
 * with a host. cmdh_process() handles both the lower level of the communication
 * (i.e., the UART part, see @ref pgDp3_Uart) and the handling of incoming and outgoing commands
 * (i.e., the command handler, see @ref pgDp3_CmdHandler).
 *
 * Consequently, cmdh_process() must be called periodically (e.g. by the application) in background
 * in order to keep host communication alive. Its calling rate decides the throughput
 * of the communication channel. As a rule of a thumb, calling cmdh_process() once
 * either processes one incoming byte (if available) @b or one outgoing byte (if available).
 * Therefore, calling it 8000 times per second allows a maximum throughput of 8kb.
 *
 *@return               Status of Command Handler. See ::Cmdh_Processing_State_t
 *                      for further information.
 */
Cmdh_Processing_State_t cmdh_process(void);

/**
 * cmdh_command_add() adds a new command to the callback catalog.
 *
 * If the command is already in the catalog, the respective function pointer is overwritten.
 *
 *
 * @param cmd_class         New commands can be private or public (see ::Cmdh_Classes_e).
 * @param cmd_id            The new command ID of the callback (see ::Cmdh_Cmds_e).
 * @param func              Pointer to the function which should be called. See ::Cmdh_Callback_Function.
 *
 * Note: An Exceptions is thrown if the command could not be added to the catalog or if there are permissions errors.
 *
 */
void cmdh_command_add(uint8_t cmd_class, uint8_t cmd_id, Cmdh_Callback_Function func);

/**
 * Sends an error code inside a NACK frame
 *
 * @param error_code    Error code sent after NACK.
 *
 * The frame bytes are assembled as followed (LSB):
 * NACK |   Reason (low)   | Reason (high)  | Checksum (XOR)
 *
 * The first NACK indicates an error which is followed by two reason bytes
 * which specify the error in detail. The last byte is an XOR checksum calculated
 * over the first three header bytes to ensure the correctness of the data.
 */
void cmdh_nack_response_send(uint16_t error_code);

/**
 * Call the callback related to the given command.
 *
 * @param cmd_class         The frame class (see ::Cmdh_Cmds_e).
 * @param cmd_id            Command to be called (see ::Cmdh_Cmds_e).
 * @return                  True if successfully executed
 *
 * The chip needs to be unlocked if private functions should be called.
 */
Cmdh_Cmd_Execution_State_t cmdh_callback_call(uint8_t cmd_class, uint8_t cmd_id);
/// @}
#endif /* COMMAND_HANDLER_H_ */
