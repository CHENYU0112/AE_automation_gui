from __future__ import annotations


class Memory:
    def __init__(self):
        self.mem = {}
        self.debug = False
        self.burned_addresses = []
        self.otp = 0xBFFF, 0xE000, 1

    def write(self, address, value):
        if address not in self.burned_addresses:
            self.mem[address] = value
        else:
            msg = "Tried to write to OTP"
            raise Exception(msg)

    def block_write(self, address, values):
        for i in range(0, len(values), 1):
            self.write(address + i, values[i])

    def burn(self, address, value):
        if address in self.burned_addresses:
            # burn new ONEs
            self.mem[address] = self.mem[address] & value
        else:
            self.mem[address] = value
        # register this address as a burnt one
        self.burned_addresses.append(address)

    def read(self, address):
        if address in self.mem:
            return self.mem[address]
        else:
            return 0

    def __str__(self):
        result = ""
        for key in sorted(self.mem.keys()):
            result = f"{result}{key:06X}:{self.mem[key]:04X}\n"
        return result

    def read_block(self, address, size):
        block = []
        for i in range(size):
            block.append(self.read(address + i))
        return block

    def blank_check(self, address, length):
        return all(self.read(address + i) == 0 for i in range(length))

    def clear(self):
        del_addresses = []
        for address, _value in self.mem.items():
            if address not in self.burned_addresses:
                del_addresses.append(address)
        for address in del_addresses:
            del self.mem[address]

    def memory_clear_all(self):
        self.mem = {}
        self.burned_addresses = []
