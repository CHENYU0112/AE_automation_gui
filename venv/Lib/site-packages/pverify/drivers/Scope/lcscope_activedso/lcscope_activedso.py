from __future__ import annotations

import os
import tempfile
from pathlib import Path
from typing import Any

import arrow
import numpy as np
import pandas as pd
import win32com.client

if __name__ == "__main__":
    from utils import xmlDIG2Dataframe
else:
    from .utils import xmlDIG2Dataframe


class LeCroyScopeActiveDSO:
    """
    Refer to the ActiveDSO Developer's Guide at https://teledynelecroy.com/doc/docview.aspx?id=9224

    ActiveDSO can be downloaded at https://teledynelecroy.com/support/softwaredownload/download.aspx?did=8147
    """

    class ActiveDSOError(Exception):
        pass

    def __init__(self):
        self.dso = win32com.client.Dispatch("LeCroy.ActiveDSOCtrl.1")

    def check_status(self, status):
        if not status and self.ErrorFlag:
            raise LeCroyScopeActiveDSO.ActiveDSOError(self.ErrorString)

    def ConnectIP(self, ip_address: str):
        if not self.dso.MakeConnection(f"IP: {ip_address}"):
            msg = "Failed to connect to device!"
            raise ConnectionError(msg)

    def ConnectUSBTMC(self, visa_rsrc: str):
        if not self.dso.MakeConnection(f"USBTMC: {visa_rsrc}"):
            msg = "Failed to connect to device!"
            raise ConnectionError(msg)

    def ConnectGPIB(self, gpib_address: int, interface: int = -1):
        if interface not in (0, 1, 2, 3):
            interface = ""
        if not self.dso.MakeConnection(f"GPIB{interface}: {gpib_address}"):
            msg = "Failed to connect to device!"
            raise ConnectionError(msg)

    def Disconnect(self):
        self.dso.Disconnect()

    @property
    def BytesAvail(self) -> int:
        """
        The BytesRead property is a read-only Long value that indicates the number of
        bytes read from the device by the last method used.
        """
        return self.dso.BytesRead

    @property
    def SerialNumber(self) -> str:
        """
        The SerialNumber property is a read-only String value that is set to the device
        serial number string extracted from the *IDN? query when the MakeConnection method is called.
        """
        return self.dso.SerialNumber

    @property
    def ScreenType(self) -> str:
        """
        The ScreenType property is a read-only String value that is set to the type of
        display supported by the device when the MakeConnection method is called
        """
        return self.dso.ScreenType

    @property
    def NumChannels(self) -> int:
        """
        The NumChannels property is a read-only Long value that is set to the number of
        channels supported by the device when the MakeConnection method is called
        """
        return self.dso.NumChannels

    @property
    def ErrorString(self):
        """
        The ErrorString property is a read-only String value that should be read if the
        ErrorFlag property is set TRUE to extract a
        verbose description of the error that occurred.
        NOTE: The ErrorString property is cleared by a call to the MakeConnection method,
        or when the ErrorString property is read.
        """
        return self.dso.ErrorString

    @property
    def ErrorFlag(self) -> bool:
        """
        The ErrorFlag property is a read-only Boolean value that is set TRUE if an error
        occurred since either the MakeConnection call or the last time that it was read.
        If the ErrorFlag is set TRUE the ErrorString property may be used to extract a
        verbose description of the error. It is highly advisable to check the state of
        the ErrorFlag frequently during a remote control session
        """
        return bool(self.dso.ErrorFlag)

    @property
    def DeviceModel(self) -> str:
        """
        The DeviceModel property is a read-only String
        value that is set to the device model string extracted from the *IDN?
        query when the MakeConnection method is called.
        """
        return self.dso.DeviceModel

    @property
    def BinTransferSupport(self) -> bool:
        """
        The BinTransferSupport property is a read-only Boolean value that is set TRUE during a call to the MakeConnection
        method if it is determined that the connection can support binary data transfers.
        NOTE: Binary data transfers are supported by the GPIB and Network interfaces but not by the RS232 interface. The
        GetBinaryWaveform and SetBinaryWaveform methods automatically compensate for an interface that does not support
        binary data transfers by transferring the waveform in hex-ascii form
        """
        return bool(self.dso.BinTransferSupport)

    def WriteString(self, cmd: str, EOI: bool = True):
        """
        The WriteString method sends a string to the connected device with or without
        a terminating EOI (End or Identify).

        Remarks
            If EOI is set to TRUE then the device will start to interpret
            the command immediately. This is normally the desired behavior.

            If EOI is set to FALSE then a command may be sent in several parts
            with the device starting to interpret the command
            only when it receives the final part which should have EOI set TRUE

        :param cmd: Text string to send to the device
        :param EOI: TRUE = terminate with EOI
        """
        self.check_status(self.dso.WriteString(cmd, EOI))

    def WriteVBScmd(self, cmd: str):
        """
        Sends a VBS write command "VBS '{cmd}' "

        :param cmd: Text string to send to the device. Will be formatted into "VBS '{cmd}' "
        """
        self.check_status(self.dso.WriteString(f"""VBS 'app.{cmd.replace("'", '"')}' """, True))

    def QueryVBScmd(self, cmd: str, maxBytes=100, converter: type | None = None) -> Any:
        """
        Sends a VBS query command "VBS? 'return={cmd}' " and performs a read afterwards.

        :param cmd: Text string to send to the device. Will be formatted into "VBS? 'return={cmd}' "
        """
        self.check_status(self.dso.WriteString(f"""VBS? 'return=app.{cmd.replace("'", '"')}' """, True))
        ret = self.ReadString(maxBytes=maxBytes)
        if isinstance(converter, type):
            ret = converter(ret)
        return ret

    def ReadString(self, maxBytes: int = 0) -> str:
        """
        The ReadString method reads a string response from the instrument.

        Remarks
            This method reads a string response from the instrument.
            The maxBytes argument indicates the maximum number of characters to read.
            If there is more to read than the indicated maxBytes,
            then the remaining characters will be left unread in the instrument.

        :param maxBytes: Maximum number of bytes to read. 0 means auto
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        return self.dso.ReadString(maxBytes)

    def ReadBinary(self, maxBytes: int = 0) -> bytes:
        """
        The ReadBinary method reads a binary response from the instrument.

        Remarks
            This method reads a binary response from the instrument.
            The maxBytes argument indicates the maximum number of bytes to read.
            If there is more to read than the indicated maxBytes, then the remaining
            bytes will be left unread in the instrument.

        :param maxBytes: Maximum number of bytes to read. 0 means auto
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        return bytes(self.dso.ReadBinary(maxBytes))

    def WaitForSRQ(self, timeoutS: float):
        """
        The WaitForSRQ method may be used to wait for an SRQ (Service Request) from the device

        Remarks
            If an SRQ is detected from the device within the specified time the method will return TRUE

        :param timeoutS: Time to wait (in seconds) for an SRQ
        """
        self.check_status(self.dso.WaitForSRQ(timeoutS))

    def WaitForOPC(self):
        """
        The WaitForOPC method may be used to wait for previous commands to be interpreted before continuing

        Remarks
            This method sends the query '*OPC?' to the device and waits for its reply.

        """
        self.check_status(self.dso.WaitForOPC())

    def DeviceClear(self, reboot: bool = False):
        """
        The DeviceClear method clears the connection to the device.

        Remarks
            This method will send a device clear signal to the instrument. Any unread response currently
            in the device's output buffer will be cleared.
            If the reboot argument is true then this method will reboot the instrument.
            This operation may take up to 20 seconds to complete depending upon the type of device.

        :param reboot: normally FALSE, if TRUE the device will be rebooted
        """
        self.check_status(self.dso.DeviceClear(reboot))

    def TransferFileToPc(self, remoteFileName: str, localFileName: str, remoteDevice: str = "HDD"):
        """
        The TransferFileToPc method transfers a file from a mass storage device on the instrument to the PC

        Remarks
            CARD applies only to legacy models.

        :param remoteFileName: The name (and path) of the source file on the instrument
        :param localFileName: The name (and path) of the destination file on the PC
        :param remoteDevice: The device name for instrument end (CARD, HDD, FLPY).
        """
        Path(localFileName).parent.mkdir(parents=True, exist_ok=True)
        self.check_status(self.dso.TransferFileToPc(remoteDevice, remoteFileName, localFileName))

    def TransferFileToDso(self, remoteFileName: str, localFileName: str, remoteDevice: str = "HDD"):
        """
        The TransferFileToDso method transfers a file from the PC to a mass storage device on the oscilloscope

        Remarks
            CARD applies only to legacy models.

        :param remoteFileName: The name (and path) of the source file on the instrument
        :param localFileName: The name (and path) of the destination file on the PC
        :param remoteDevice: The device name for instrument end (CARD, HDD, FLPY).
        """
        if not Path(localFileName).exists():
            msg = f"File {localFileName} does not exist!"
            raise FileNotFoundError(msg)
        self.check_status(self.dso.TransferFileToDso(remoteDevice, remoteFileName, localFileName))
        self.check_status(self.dso.TransferFileToPc(remoteDevice, remoteFileName, localFileName))

    def StoreHardcopyToFile(
        self,
        format: str,
        targetdir: str,
        filename: str | None = None,
        auxFormat: str = "",
        **kwargs,
    ):
        """
        The StoreHardcopyToFile method transfers a hardcopy image from the instrument and
        stores it in a file on the controlling PC.

        Remarks
            This method uses the instrument's HARDCOPY_SETUP and SCREEN_DUMP remote commands to retrieve a hardcopy
            image and store it in a file on the controlling PC.

            The format string may be any device shown in the remote control manual on the HARDCOPY_SETUP command page.
            Depending on the family (93xx, LCxxx, and LSAxxxx) and the software version, these could include:
            BMP, BMPCOMP, CANONCOL, EPSON, EPSONCOL, HPDJ, HPDJBW, HPPJ, HPTJ, HPLJ, HP7470A, HP7550A, TIFF,
            TIFFCOL, TIFFCOMP, HPGL

            The auxFormat string may be used to send extra information to the HARDCOPY_SETUP command. This could include
            the paper orientation ("FORMAT,PORTRAIT", or "FORMAT,LANDSCAPE"), page-feed ("PFEED,ON"or "PFEED,OFF"), etc.
            Again, see the HARDCOPY_SETUP page of the instrument remote control manual for more details.

        :param format: String, Hardcopy format. See list/explanation below
        :param auxFormat: String, Auxiliary format, normally empty ("").
        :param filename: Destination filename
        """
        targetdir = Path(targetdir)
        targetdir.mkdir(parents=True, exist_ok=True)

        if filename in (None, ""):
            filename = f"screenshot_{_get_timestamp(ms_precision=True)}"
        else:
            filename = os.path.splitext(filename)[0]
        filepath = targetdir / f"{filename}.{format.lower()}"

        if len(auxFormat) and not auxFormat.endswith(","):
            auxFormat += ","
        auxFormat += ",".join([f"{k.upper()},{v.upper()}" for k, v in kwargs.items()])

        self.check_status(self.dso.StoreHardcopyToFile(format, auxFormat, str(filepath)))
        return filepath

    def SetupWaveformTransfer(self, firstPoint: int = 0, sparsing: int = 0, segmentNo: int = 0):
        """
        The SetupWaveformTransfer configures various parameters that control the transfer of
        waveforms from the instrument to the PC.

        Remarks
            This method affects how the various GetWaveform functions transfer a waveform.
            For the majority of cases the default settings will be sufficient. These are:

                Start Transfer at first point
                Transfer all data points
                Transfer all segments.

        :param firstPoint: The index of the first point to transfer (0 = first point)
        :param sparsing:  The sparsing factor (0 = all points, 2 = skip every other pt.)
        :param segmentNo: Destination filename
        """
        self.check_status(self.dso.SetupWaveformTransfer(firstPoint, sparsing, segmentNo))

    def SetTimeout(self, timeoutS: float = 0):
        """
        The SetTimeout method sets the control's time-out time.

        Remarks
            This method sets the time that the control will wait for a response from the instrument.
            The methods to which this applies are:

                ReadString, ReadBinary, WaitForOPC, GetByteWaveform, GetIntegerWaveform GetNativeWaveform,
                GetScaledWaveform, GetScaledWaveformWithTimes

        :param timeoutS: Time-out time in seconds
        """
        self.check_status(self.dso.SetTimeout(timeoutS))

    def SetRemoteLocal(self, mode: int = 0):
        """
        The SetRemoteLocal method controls the Remote/Local state of the device.

        Remarks
            This method sets the instrument to Remote or Local mode, if the mode argument is set
            to 1 then the oscilloscope is set to Remote Mode, otherwise oscilloscope is set to Local Mode.

            NOTE: All 94xx and 93xx/LCxxx oscilloscopes with firmware revisions prior to legacy
            firmware 7.2.0 require the oscilloscope to be in Remote mode before remote commands
            (not queries) would be accepted.

            All 93xx/LCxxx/LSAxxxx instruments running legacy 7.2.0 or later accept commands
            both in Local and Remote modes.

        :param mode: Long, 1 = Remote mode, 0 = Local mode
        """
        self.check_status(self.dso.SetRemoteLocal(mode))

    def SetPanel(self, buffer: str):
        """
        The SetPanel method sets the instrument's control state using a panel string captured
        using the method GetPanel.

        Remarks
            Use the GetPanel method to read the panel string

        :param buffer: panel string captured with GetPanel.
        """
        self.check_status(self.dso.SetPanel(buffer))

    def GetPanel(self) -> str:
        """
        The GetPanel method reads the instrument's control state into a String,
        allowing a future call to SetPanel to reproduce the state.

        Remarks
            Use the SetPanel Method to send the panel back into the instrument.
            The size of the panel will be approximately 5000 bytes, depending upon the
            instrument's firmware revision.

        :returns: A string containing the hex-ascii Panel.
        """
        return str(self.dso.GetPanel())

    def GetScaledWaveformWithTimes(self, traceName: str, maxBytes: int, whichArray: int) -> pd.Series:
        """
        The GetScaledWaveformWithTimes method reads a scaled waveform from the
        instrument and stores the time and amplitude at each sample point.

        Remarks
            Use the GetByteWaveform or GetIntegerWaveform method to retrieve a waveform in its raw binary form.
            This may be preferable in a time-critical application.
            If the time value corresponding to each sample amplitude is not required use the GetScaledWaveform method.
            The whichArray parameter should normally be zero, it is used only to specify that the second array of a
            dual-array waveform is required. Examples of dual-array waveforms are envelope waveforms which have
            a min and a max value at each sample, or a complex FFT which creates a real,imaginary pair.

        See Also
            SetupWaveformTransfer, GetNativeWaveform, SetNativeWaveform, GetByteWaveform, GetIntegerWaveform,
            GetScaledWaveform

        :param traceName: Source trace name.
                          { C1 | C2 | C3 | C4 | M1 | M2 | M3 | M4 | TA | TB | TC | TD TD | F1 | Z1 | … }
                          Some scopes/options support many more trace names, refer to the documentation
                          for each scope/option.
        :param maxBytes: maximum number of bytes to read
        :param whichArray: 0 = first array, 1 = second array (for dual-array waveform)
        :returns: A variant containing the scaled waveform, stored as a two-dimensional array of single-precision
                  floating point values. Time values are stored in the first column of the array,
                  amplitude values are stored in the second column
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        time, data = self.dso.GetScaledWaveformWithTimes(traceName, maxBytes, whichArray)
        return pd.Series(data=data, index=time, name=traceName)

    def GetScaledWaveform(self, traceName: str, maxBytes: int, whichArray: int) -> pd.Series:
        """
        The GetScaledWaveform method reads a scaled waveform from the instrument

        Remarks
            Use the GetByteWaveform or GetIntegerWaveform method to retrieve a waveform in its raw binary form.
            This may be preferable in a time-critical application.

            If the time value corresponding to each sample amplitude is required use the GetScaledWaveformWithTimes method.

            The whichArray parameter should normally be zero, it is used only to specify that the second array of a dual-array
            waveform is required. Examples of dual-array waveforms are envelope waveforms which have a min and a max value at
            each sample, or a complex FFT which creates a real,imaginary pair.

        See Also
            SetupWaveformTransfer, GetNativeWaveform, SetNativeWaveform, GetByteWaveform, GetIntegerWaveform,
            GetScaledWaveform

        :param traceName: Source trace name.
                          { C1 | C2 | C3 | C4 | M1 | M2 | M3 | M4 | TA | TB | TC | TD TD | F1 | Z1 | … }
                          Some scopes/options support many more trace names, refer to the documentation
                          for each scope/option.
        :param maxBytes: maximum number of bytes to read
        :param whichArray: 0 = first array, 1 = second array (for dual-array waveform)
        :returns: A variant containing the scaled waveform, stored as an array of single-precision floating point values.
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        return pd.Series(self.dso.GetScaledWaveform(traceName, maxBytes, whichArray), name=traceName)

    def GetNativeWaveform(self, traceName: str, maxBytes: int, wordData: bool, blockName: str) -> pd.Series:
        """
        The GetNativeWaveform method reads a waveform from the instrument in its native binary form.

        Remarks
            Channel waveforms (C1..C4) should be transmitted in 8-bit form by setting wordData FALSE.

            Processed waveforms are usually 16 bit waveforms and should be transmitted in 16-bit form to avoid loosing precision.
            Set wordData TRUE to do this.

            Use the GetScaledWaveform function to retrieve waveform data that has already been scaled.
            blockName should be used to transfer the descriptor (DESC), the user text (TEXT),
            the time descriptor (TIME), the data (DAT1) block and optionally a second block of data (DAT2) or all entities (ALL).

            Only complete waveforms transferred with (ALL) can be sent back into the instrument using the
            SetNativeWaveformSetNativeWaveform_Method Method.

            Use the BytesRead property to determine how many bytes were placed in the destination buffer. This value will be
            required to know how many bytes to send back into the instrument with the SetNativeWaveform Method

        See Also
            SetupWaveformTransfer, GetNativeWaveform, SetNativeWaveform, GetByteWaveform, GetIntegerWaveform,
            GetScaledWaveform

        :param traceName: Source trace name.
                          { C1 | C2 | C3 | C4 | M1 | M2 | M3 | M4 | TA | TB | TC | TD TD | F1 | Z1 | … }
                          Some scopes/options support many more trace names, refer to the documentation
                          for each scope/option.
        :param maxBytes: maximum number of bytes to read
        :param wordData:  if TRUE transmit data as 16 bit words, FALSE for 8 bit words.
        :param blockName: Waveform block name { DESC | TEXT | TIME | DAT1 | DAT2 | ALL }
        :returns: A variant containing the scaled waveform, stored as an array of single-precision floating point values.
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        return pd.Series(
            self.dso.GetNativeWaveform(traceName, maxBytes, wordData, blockName),
            name=traceName,
        )

    def GetIntegerWaveform(self, traceName: str, maxBytes: int, whichArray: int) -> pd.Series:
        """
        The GetIntegerWaveform method reads raw 16-bit waveform data from the instrument into an Integer array

        Remarks
            This method should be used when unscaled 16-bit waveform data is required.

            NOTE: Waveforms read using this function cannot be sent back into the instrument.

            Use the SetupWaveformTransfer method to define the sparsing factor (to reduce large waveforms), first point to
            transfer, and segment number to transfer (for sequence waveforms).

            Processed waveforms are usually 16 bit waveforms and should be transmitted in 16-bit form to avoid losing precision.
            Channel waveforms are usually 8 bit waveforms and may be transferred using the GetByteWaveform method to reduce
            transfer time and storage requirements.

            Use the GetScaledWaveform function to retrieve waveform data that has already been scaled.

            The whichArray parameter should normally be zero, it is used only to specify that the second array of a dual-array
            waveform is required. Examples of dual-array waveforms are envelope waveforms which have a min and a max value at
            each sample, or a complex FFT which creates a real,imaginary pair.

        :param traceName: Source trace name.
                          { C1 | C2 | C3 | C4 | M1 | M2 | M3 | M4 | TA | TB | TC | TD TD | F1 | Z1 | … }
                          Some scopes/options support many more trace names, refer to the documentation
                          for each scope/option.
        :param maxBytes: maximum number of bytes to read
        :param whichArray: 0 = first array, 1 = second array (for dual-array waveform)
        :returns: A variant containing the scaled waveform, stored as an array of single-precision floating point values.
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        return pd.Series(self.dso.GetIntegerWaveform(traceName, maxBytes, whichArray), name=traceName)

    def GetByteWaveform(self, traceName: str, maxBytes: int, whichArray: int) -> pd.Series:
        """
        The GetByteWaveform method reads raw 8-bit waveform data from the instrument into a Byte array

        Remarks
            This method should be used when unscaled 8-bit waveform data is required. It is especially useful for transferring huge
            waveforms due to its efficient use of memory (1 byte per sample as opposed to 4 for the GetScaledWaveform).

            Note that waveforms read using this function cannot be sent back into the instrument.

            An important point to note when using this function is that in order to store the signed data that the scope emits (-128
            to 127) into Visual-Basic's unsigned 'Byte' data type it has been shifted by 128 (0 to 255). This should be remembered
            when scaling the data.

            Use the SetupWaveformTransfer method to define the sparsing factor (to reduce large waveforms), first point to
            transfer, and segment number to transfer (for sequence waveforms).

            Processed waveforms are usually 16 bit waveforms and should be transmitted in 16 bit form to avoid losing precision.
            Call the GetIntegerWaveform method to do this.

            Use the GetScaledWaveformfunction to retrieve waveform data that has already been scaled.

            The whichArray parameter should normally be zero, it is used only to specify that the second array of a dual-array
            waveform is required. Examples of dual-array waveforms are envelope waveforms which have a min and a max value at
            each sample, or a complex FFT which creates a real,imaginary pair.

        :param traceName: Source trace name.
                          { C1 | C2 | C3 | C4 | M1 | M2 | M3 | M4 | TA | TB | TC | TD TD | F1 | Z1 | … }
                          Some scopes/options support many more trace names, refer to the documentation
                          for each scope/option.
        :param maxBytes: maximum number of bytes to read
        :param whichArray: 0 = first array, 1 = second array (for dual-array waveform)
        :returns: A variant containing the scaled waveform, stored as an array of single-precision floating point values.
        """
        if maxBytes <= 0:
            maxBytes = self.BytesAvail
        return pd.Series(self.dso.GetByteWaveform(traceName, maxBytes, whichArray), name=traceName)

    def xmlDIG2Dataframe(self, remotePath: str | Path, remoteDevice: str = "HDD") -> pd.DataFrame:
        """
        Transfers an xmlDIG file from the LeCroy scope and return the digital data as Pandas Dataframe

        :param remotePath: The remote file path of the binary digital waveform dump
        :param remoteDevice: The device name for instrument end (CARD, HDD, FLPY).
        :return: A Pandas Dataframe containing the lines as columns and the time as index.
                  The dataframe also has an additional attribute **header**, which is the pretty printed
                  LeCroyXStreamDSOdata/Header xml section.
        """
        remotePath = Path(remotePath)
        with tempfile.TemporaryDirectory(prefix="XMLdig_") as tdir:
            localFile = Path(tdir) / "digdata.XMLdig"
            self.TransferFileToPc(str(remotePath), localFile, remoteDevice)
            return xmlDIG2Dataframe(localFile)

    def StoreAllDispDigitalLinesToFile(
        self,
        traceNr: int,
        tracetitle: str = "PyVerify",
        source_prefix: bool = False,
        counter_suffix: bool = False,
        savedir: str = "D:\\Waveforms",
    ) -> Path:
        """
        Stores all displayed digital lines of a digital trace to a remote directory on the scope.

        :param traceNr: The number of the digital bus (1-4)
        :param tracetitle: The trace title (included in the filename)
        :param source_prefix: If True, the trace name will be prepended to the filename
        :param counter_suffix: If True, the counter value will be appended to the filename
        :param savedir: The directory to store the waveforms
        :returns: The remote path of the stored file
        """
        self.WriteVBScmd(f"SaveRecall.Waveform.SaveSource = 'Digital{traceNr}'")
        self.WriteVBScmd("SaveRecall.Waveform.SaveTo = 'File'")
        self.WriteVBScmd("SaveRecall.Waveform.WaveFormat = 'WaveML'")
        self.WriteVBScmd(f"SaveRecall.Waveform.TraceTitle = '{tracetitle}'")
        self.WriteVBScmd(f"SaveRecall.Waveform.WaveformDir = '{Path(savedir).absolute()!s}'")
        self.WriteVBScmd(f"SaveRecall.Waveform.EnableSourcePrefix = {bool(source_prefix)}")
        self.WriteVBScmd(f"SaveRecall.Waveform.EnableCounterSuffix = {bool(counter_suffix)}")
        self.WriteVBScmd("SaveRecall.Waveform.SaveFile")
        fp = self.QueryVBScmd("SaveRecall.Waveform.LastSavedFilepath")
        return Path(fp)

    def get_time_array(self, traceName, start_at_zero=True) -> np.ndarray:
        """
        Returns

        :param traceName: Source trace name.
                          { C1 | C2 | C3 | C4 | M1 | M2 | M3 | M4 | TA | TB | TC | TD TD | F1 | Z1 | … }
                          Some scopes/options support many more trace names, refer to the documentation
                          for each scope/option.
        :param start_at_zero: If True the time vector will start at 0, otherwise at the negative trigger offset
        :return: A numpy array.
        """
        sr = self.QueryVBScmd("Acquisition.Horizontal.SampleRate", 100, float)
        sr_inv = 1.0 / sr
        t0 = self.QueryVBScmd(f"Acquisition.{traceName}.Out.Result.HorizontalOffset", 100, float)
        t0 = 0.0 if start_at_zero else t0
        nrs = self.QueryVBScmd(f"Acquisition.{traceName}.Out.Result.Samples", 100, int)
        return np.fromiter((t0 + sr_inv * i for i in range(nrs)), dtype=np.float64, count=nrs)


def _get_timestamp(compact_format=False, ms_precision=False):
    """
    This method fetches the current time and returns a formated string, useful in filename generation. Optionally allows
    for microsecond precision.

    Parameters
    ----------
    compact_format: bool, default = False
        By default it returns the string in a more readable fashion where day, month and year are seperated by under-
        scores. If True the underscores are removed from the returned string.
    ms_precision: bool, default = False
        By default only seconds precision is used in the timestamp. When True microsecond precision is used.

    Returns
    -------
    timestamp: str
        The timestamp as string.
    """

    if ms_precision:
        if compact_format:
            timestamp = arrow.now().strftime("%Y%m%d-%H%M%S%f")
        else:
            timestamp = arrow.now().strftime("%Y_%m_%d-%H%M%S_%f")
    else:
        timestamp = arrow.now().strftime("%Y%m%d-%H%M%S") if compact_format else arrow.now().strftime("%Y_%m_%d-%H%M%S")
    return timestamp


if __name__ == "__main__":
    pass
    # d = LeCroyScopeActiveDSO()
    # d.ConnectIP("169.254.254.2")
    # s = d.GetScaledWaveformWithTimes("C2", 0, 0)
    # p = d.StoreAllDispDigitalLinesToFile(1, savedir=r"D:\Waveforms\PyVerify", source_prefix=True)
    # df = d.xmlDIG2Dataframe(p)
    # d.Disconnect()
