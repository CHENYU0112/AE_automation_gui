from __future__ import annotations

import time as _time
from collections import namedtuple as _namedtuple
from datetime import datetime as _datetime

import pyvisa as _pyvisa
from pyvisa.resources.messagebased import MessageBasedResource as _MessageBasedResource

# visa related module level variables, needed for save_screenshot()
_resource_manager = None
_visa_instrument = None


def save_waveforms(si_scope, save_path, labels=None, file_format=".npz", comment=False, fname_padding=4, verbose=False):
    """
    Simple method to save waveform data to disk.
    Every enabled channel is captured, like a screenshot (including every active channel, also memory, zoom, and math
    waveforms). Autoincrements filename if invoked more than once and if the save_path and file_format remains is the
    same.

    When a list of labels is supplied, then these are incorporated in the filenames. Labels must not contain spaces.
    First element of the list is used to label the first channel and so on. To get the list of enabled channels and
    their order you can simply invoke another helper method like this:
        pprint_channels_description(create_channels_description(simplescope_instance))

    Tested with:
        - Lecroy WavePro 7000 (win2k)
        - Lecroy WaveSurfer 44Xs (winxp)
        - Lecroy WaveRunner 625Zi (win7)


    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.
    save_path: Path
        A pathlib Path instance where the waveforms should be saved to.
    labels: list, default = None
        A list of strings that will be used to label the channels and enhance the filenames.
    file_format: str, default = '.npz'
        A string identifying the fileformat the waveforms will be saved in. Currently only '.npz' is supported.
    comment: str, default = False
        An optional string that will be appended to the filename of all waveforms.
    fname_padding: int
        The number of padding digits for automatic filename generation.
    verbose: bool, default = False
        This switch enables the pretty print output of channel names and labels.

    Returns
    -------
    paths: list
        A list of paths to the stored waveforms.
    """

    # autoincrement: look for files matching filename pattern and increment
    fname_increment = 0
    inc_found = "none"

    # check if save_path exists and create if necessary
    if not save_path.exists():
        save_path.mkdir(parents=True)

    # extract highest filename increment currently in folder
    for file in save_path.iterdir():
        # check if fileformat is the same
        if file.name.endswith(file_format):
            fname_found = file.name
            fname_parts = fname_found.split(sep="_")
            try:
                inc_found = int(fname_parts[0])
                if inc_found >= fname_increment:
                    fname_increment = inc_found + 1
            except ValueError:
                print(f"filename pattern mismatch! can't do autoincrementing based on this filename: '{file.name}'")
    if inc_found == "none":
        print("found no existing waveform filenames. will start naming from zero.")
        print(f"found_inc:\t{inc_found}\n\tnext inc:\t {fname_increment}")

    # set labels if supplied
    if isinstance(labels, list):
        set_channel_labels(si_scope, labels)
    elif labels is not None:
        msg = "labels must be of type list. instead got type: " + str(type(labels))
        raise Exception(msg)

    # collect channel info from scope and craft a handy list of dicts
    channels_desc = create_channels_description(si_scope, verbose=verbose)

    # generate filenames from dict values
    for channel in channels_desc:
        # increment has to be the first element of filename, or autoincrement won't work
        label = "" if channel["label"] is None else "_" + channel["label"]

        filename = "{increment:0{padding}d}_{ch_name}{label}_{timestamp}".format(
            padding=fname_padding,
            ch_name=channel["ch_name"],
            label=label,
            increment=fname_increment,
            timestamp=get_timestamp(compact_format=True),
        )
        # if a comment string was passed to the method, it it appended to the current filename
        if comment is not False:
            filename = f"{filename}_{comment}"

        channel["path"] = save_path / filename

    # fetch waveforms
    for channel in channels_desc:
        channel["waveform"] = channel["ch_handle"].GetProbeWaveform(Timeout=0)

    # append file_extension and save waveforms to disk
    paths = []
    for channel in channels_desc:
        filepath = channel["path"].parent / (channel["path"].name + file_format)
        channel["waveform"].save_to_file(str(filepath))
        paths.append(filepath)

    if verbose:
        print(f"Saved waveform(s) to:\n\t{save_path}")

    return paths


def create_channels_description(si_scope, verbose=False):
    """
    This method gets all the channel info in a list of dicts from get_channels_info_from_scope()
    and creates a new list of dicts for all the enabled channels. These dicts contain the
    channel-handle, channel name, channel description, the save path and the waveform handle.
    Most of these keys are still have a None value at this point and will be filled by other methods.

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.
    verbose: bool, default = False
        This switch enables the pretty print output of channel names and labels.

    Returns
    -------
    channel_desc: list
        Channels description list of dicts containing names, labels, handles, waveform handles, paths.
    """

    channels_info = get_channels_info_from_scope(si_scope)
    channels_desc = []
    # from all the enabled channels, copy their key/value pairs to a new list of dicts and append new keys to the dicts
    for cdict in channels_info:
        if cdict["enabled"] is True:
            new_dict = {x: cdict[x] for x in cdict}
            new_dict["path"] = None
            new_dict["waveform"] = None

            channels_desc.append(new_dict)

    if verbose is True:
        pprint_channels_description(channels_desc)

    return channels_desc


def get_channels(si_scope):
    """
    This method creates a nested named tuple for all available channels from a SimpleScope instance. The named tuple
    allows easy access to all available the channel handles and their methods.

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.

    Returns
    -------
    tchannels: namedtuple
        A named tuple containing all available channels of a SimpleScope.
    """

    # get a list of dicts with channels handles, names and enabled status
    cinfo = get_channels_info_from_scope(si_scope)
    channel_names = []
    # create a list of channel names
    for cdict in cinfo:
        channel_names.append(cdict["ch_name"])

    # define two named tuples which will be nested
    Channels = _namedtuple("Channels", channel_names)
    Channel = _namedtuple("Channel", cinfo[0])

    # create channels instance from the list of channel names
    channels = Channels._make(channel_names)
    # create list of named tuple Channel instances for each available channel
    tupled_cinfo = []
    for cdict in cinfo:
        tupled_cinfo.append(Channel(**cdict))
    # nest named tuples
    return channels._make(tupled_cinfo)


def get_channels_info_from_scope(si_scope):
    """
    This method checks what channels are available on the scope, checks the enabled status,
    retrieves their SimpleScope channel-handle and stores all that info in a list of dicts.

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.

    Returns
    -------
    channels_info: list
        List of dicts containing channel handles, names and enabled status.
    """

    # get the number of available channels
    channels_count = range(1, si_scope.lld.Channels.Count + 1, 1)
    channels_info = []
    # get a visa resource handle from the SimpleScope instance
    visa_scope = visa_from_simple_instrument(si_scope)

    # get the SimpleScope channel handle for all available channels
    for idx in channels_count:
        channels_info.append({"ch_handle": si_scope.GetChannel(idx), "ch_name": "", "enabled": None})

    # check each available channel and query his channel name, enabled status and any label
    for cdict in channels_info:
        cdict["ch_name"] = cdict["ch_handle"].lld.Channels.Name(cdict["ch_handle"]._channel)
        cdict["enabled"] = cdict["ch_handle"].lld.Channels.Item(cdict["ch_name"]).Enabled
        if cdict["enabled"]:
            if cdict["ch_name"].startswith("C", 0, 1):
                vbs_cmd = r"""VBS? 'return = app.Acquisition.{}.LabelsText'""".format(cdict["ch_name"])
            elif cdict["ch_name"].startswith("F", 0, 1):
                vbs_cmd = r"""VBS? 'return = app.Math.{}.LabelsText'""".format(cdict["ch_name"])
            elif cdict["ch_name"].startswith("M", 0, 1):
                vbs_cmd = r"""VBS? 'return = app.Memory.{}.LabelsText'""".format(cdict["ch_name"])
            elif cdict["ch_name"].startswith("Z", 0, 1):
                vbs_cmd = r"""VBS? 'return = app.Zoom.{}.LabelsText'""".format(cdict["ch_name"])
            visa_scope.write(vbs_cmd)
            label = visa_scope.read(termination="\n")
            cdict["label"] = label
        else:
            cdict["label"] = None

    return channels_info


def pprint_channels_description(channels_desc):
    """
    This method pretty prints the channels description, a list of dicts.

    Parameters
    ----------
    channels_desc: list
        Channels description list of dicts containing names, labels, handles, waveform handles, paths.
    """

    for idx_desc, channel in enumerate(channels_desc):
        print("channels_desc[{idx}][ch_name]:\t\t{c_name}".format(idx=idx_desc, c_name=channel["ch_name"]))
        print("channels_desc[{idx}][label]:\t\t{label}\n".format(idx=idx_desc, label=channel["label"]))


def plot_waves_from_channels_description(channels_desc):
    """
    This method plots all waveforms from a channels description dict with their inbuilt plot() method.

    Parameters
    ----------
    channels_desc: list
        Channels description list of dicts containing names, labels, handles, waveform handles, paths.
    """

    for desc in channels_desc:
        print("Channel name:\t", desc["ch_name"])
        print("Channel label:\t", desc["label"])
        desc["waveform"].plot()


def get_timestamp(compact_format=False, ms_precision=False):
    """
    This method fetches the current time and returns a formated string, useful in filename generation. Optionally allows
    for microsecond precision.

    Parameters
    ----------
    compact_format: bool, default = False
        By default it returns the string in a more readable fashion where day, month and year are seperated by under-
        scores. If True the underscores are removed from the returned string.
    ms_precision: bool, default = False
        By default only seconds precision is used in the timestamp. When True microsecond precision is used.

    Returns
    -------
    timestamp: str
        The timestamp as string.
    """

    if ms_precision:
        if compact_format:
            timestamp = _datetime.strftime(_datetime.now(), "%Y%m%d-%H%M%S%f")
        else:
            timestamp = _datetime.strftime(_datetime.now(), "%Y_%m_%d-%H%M%S_%f")
    else:
        if compact_format:
            timestamp = _datetime.strftime(_datetime.now(), "%Y%m%d-%H%M%S")
        else:
            timestamp = _datetime.strftime(_datetime.now(), "%Y_%m_%d-%H%M%S")
    return timestamp


def visa_from_simple_instrument(si_instance):
    """
    This method returns a VISA resource instance that shares the session with the supplied IIviInstrument instance.
    Repeated calls to this method will return the previously instantiated VISA resource.

    Parameters
    ----------
    si_instance: SimpleInstrument
        A SimpleInstrument instance from one of the pverify driver library.

    Returns
    -------
    _visa_instrument: MessageBasedResource
        A VISA resource instance.
    """

    global _resource_manager
    global _visa_instrument

    if _visa_instrument is None:
        resource_name = "LPT1"
        _resource_manager = _pyvisa.ResourceManager()
        _visa_instrument = _MessageBasedResource(_resource_manager, resource_name)
        _visa_instrument.session = si_instance.lld.dllwrap._vi
        # Note: changing read_termination to "\n" will break screenshot capturing

    return _visa_instrument


def clear_sweeps(si_scope):
    """
    Clears the sweeps used for averaging signals.

    Tested with:
        - Lecroy WaveSurfer 44Xs (winxp)

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.
    """

    visa_scope_instance = visa_from_simple_instrument(si_scope)
    # visa_scope_instance.write('*OPC?')
    visa_scope_instance.write("CLSW")


def save_screenshot(
    si_scope,
    save_path,
    labels=None,
    capture_menues=False,
    background="black",
    file_format="png",
    destination="remote",
    filename=None,
    comment=None,
):
    """
    This method configures the Hardcopy settings of Lecroy scopes, triggers a screenshot and saves it to a remote path.

    IMPORTANT: If you want to capture a triggered waveform you have to make sure the scope finished capturing the
    waveform. You could do this by using the wait_for_has_triggered() method.

    Tested with:
        - Lecroy WavePro 7000 (win2k)
        - Lecroy WaveSurfer 44Xs (winxp)
        - Lecroy WaveRunner 625Zi (win7)

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.
    save_path: Path
        A pathlib Path instance where the screenshot should be saved to.
    labels: list, default = None
        A list of strings that will be used to label the channels and enhance the filenames.
    capture_menues: bool, default = False
        This switch determines if the application menu of the scope should also be captured.
    background: str, default = 'black'
        Available options are 'black' and 'white' background of the screenshot.
    file_format: str, default = 'png'
        Available options are 'png', 'jpeg', 'bmp' and 'tiff' as fileformats.
    destination: str, default = 'remote'
        Currently supported save destination is only 'remote'. USB drive can be implemented if needed.
    filename: str, default = None
        A custom filename can be supplied. Otherwise one will be generated from a timestamp and the comment parameter.
    comment: str, default = None
        A comment can be supplied which will be appended to the filename.

    Returns
    -------
    save_path: pathlib.Path
        The path the screenshot was saved to.
    """

    visa_scope_instance = visa_from_simple_instrument(si_scope)

    # set labels if supplied
    if isinstance(labels, list):
        set_channel_labels(si_scope, labels)
    elif labels is not None:
        msg = "labels must be of type list. instead got type: " + str(type(labels))
        raise Exception(msg)

    supported_file_formats = ["PNG", "JPEG", "BMP", "TIFF"]
    supported_backgrounds = ["BLACK", "WHITE"]
    supported_destinations = ["REMOTE"]

    # configure hardcopy in scope
    if destination.upper() not in supported_destinations:
        # TODO: implement saving to USB
        msg = f'Unsupported destination: "{destination}". Supported destinations are "{supported_destinations}".'
        raise Exception(msg)

    # check if save_path exists in remote mode
    if destination.upper() == "REMOTE" and not save_path.exists():
        save_path.mkdir(parents=True)

    area = "DSOWINDOW" if capture_menues else "GRIDAREAONLY"

    if background.upper() not in supported_backgrounds:
        msg = f'Unsupported background color: "{background}". Supported colors are "{supported_backgrounds}".'
        raise Exception(msg)

    if file_format.upper() not in supported_file_formats:
        msg = f'Unsupported background file format: "{file_format}". Supported formats are "{supported_file_formats}".'
        raise Exception(msg)

    config_cmd = "HCSU DEV, {},BCKG, {}, DEST, {}, AREA, {}, PORT, NET".format(
        file_format.upper(), background.upper(), destination.upper(), area
    )
    sc_cmd = "SCDP"
    display_off_cmd = "DISP OFF"
    display_on_cmd = "DISP ON"

    # send chained commands with turned off screen for max performance
    # seperate *OPC? query is essential to capture the latest screen content!
    visa_scope_instance.write("*OPC?")
    visa_scope_instance.write(f"{display_off_cmd};{config_cmd};{sc_cmd};{display_on_cmd};")

    # capture image, create filename and save to filesystem
    image_data = visa_scope_instance.read_raw()

    if filename is None:
        if comment is None:
            filename = f"screenshot_{get_timestamp(ms_precision=True)}"
        else:
            comment = "_" + comment
            filename = f"screenshot_{get_timestamp(ms_precision=True)}_{comment}"
    else:
        print("Comment is ignored when filename is supplied.")

    filepath = save_path / f"{filename}.{file_format.lower()}"

    with open(filepath, "wb") as fp_screenshot:
        fp_screenshot.write(image_data)

    print(f"Saved screenshot to:\n\t{filepath}")

    return filepath


def wait_for_trigger_set(si_scope, timeout_s=1):
    visa_scope = visa_from_simple_instrument(si_scope)
    trigger_modes = ["Normal", "Auto", "Single"]
    cmd = r"""VBS? 'return = app.Acquisition.TriggerMode'"""

    start = _time.clock()
    trigger_set = False
    while not trigger_set:
        diff = _time.clock() - start
        if diff > timeout_s:
            msg = f"timeout of {timeout_s}s exceeded!"
            raise Exception(msg)
        response = visa_scope.query(cmd).strip("\n")
        if response in trigger_modes:
            trigger_set = True
        _time.sleep(3e-3)


def wait_for_has_triggered(si_scope, timeout_s=10):
    """
    This method takes a SimpleScope instance and waits until it's HasTriggered property turns True or a timeout is
    reached.

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.
    timeout_s: int, default = 10
        The timeout when an exception occurs of the HasTriggered property has not turned to True.
    """

    start = _time.clock()
    triggered = False
    while not triggered:
        diff = _time.clock() - start
        if diff > timeout_s:
            msg = f"timeout of {timeout_s}s exceeded!"
            raise Exception(msg)
        triggered = si_scope.HasTriggered
        _time.sleep(3e-3)


def set_channel_labels(si_scope, labels):
    """
    This method sets the channel labels on the scope.

    Parameters
    ----------
    si_scope: SimpleScope
        A SimpleScope instance from the pverify driver library.
    labels: list, default = None
        A list of strings that will be used to label the channels.
    """

    # check labels for proper type
    if not isinstance(labels, list):
        msg = "labels must be of type list. instead got type: " + str(type(labels))
        raise Exception(msg)

    # fetch visa resource and channels description (currently enabled channels)
    visa_scope = visa_from_simple_instrument(si_scope)
    channels_desc = create_channels_description(si_scope)

    # loop through channels dict and use info to set labels in scope

    for cdict, label in zip(channels_desc, labels):
        if cdict["ch_name"].startswith("C", 0, 1):
            vbs_set_cmd = r"""VBS 'app.Acquisition.{}.LabelsText = "{}"'""".format(cdict["ch_name"], label)
            vbs_show_cmd = r"""VBS 'app.Acquisition.{}.ViewLabels = true'""".format(cdict["ch_name"])
        elif cdict["ch_name"].startswith("F", 0, 1):
            vbs_set_cmd = r"""VBS 'app.Math.{}.LabelsText = "{}"'""".format(cdict["ch_name"], label)
            vbs_show_cmd = r"""VBS 'app.Math.{}.ViewLabels = true'""".format(cdict["ch_name"])
        elif cdict["ch_name"].startswith("M", 0, 1):
            vbs_set_cmd = r"""VBS 'app.Memory.{}.LabelsText = "{}"'""".format(cdict["ch_name"], label)
            vbs_show_cmd = r"""VBS 'app.Memory.{}.ViewLabels = true'""".format(cdict["ch_name"])
        elif cdict["ch_name"].startswith("Z", 0, 1):
            vbs_set_cmd = r"""VBS 'app.Zoom.{}.LabelsText = "{}"'""".format(cdict["ch_name"], label)
            vbs_show_cmd = r"""VBS 'app.Zoom.{}.ViewLabels = true'""".format(cdict["ch_name"])

        visa_scope.write(vbs_set_cmd)
        visa_scope.write(vbs_show_cmd)

    # unfortunately the command execution is an asynchronous task without knowing when it finished.
    # for this reason we hardcode a 50ms delay which hopefully also works for older Lecroy models.
    _time.sleep(50e-3)


def get_cursor(scope, cname):
    return Cursor(parent=scope, cname=cname)


def get_measurement_slot(scope, slot_idx):
    return MeasurementSlot(parent=scope, slot_idx=slot_idx)


class Cursor:
    def __init__(self, parent, cname):
        self._parent = parent
        """:type : SimpleScope"""
        self._cname = cname.upper()
        self._vi = self._parent.lld.vi

    def _write(self, msg):
        self._parent.lld.dllwrap.WriteString(self._vi, msg)

    def _read(self, timeout_ms, retval_size):
        return self._parent.lld.dllwrap.ReadString(
            self._vi, MaxTimeMilliseconds=int(timeout_ms), retValBufferSize=int(retval_size)
        ).rstrip("\n")

    def _query(self, msg, timeout_ms, retval_size):
        self._write(msg)
        return self._read(timeout_ms, retval_size)

    def get_deltas(self, timeout_ms=1e3, retval_size=1024):
        """Returns x and y delta value of cursor. If not applicable it returns zero."""

        delta_x = self._query(
            rf"""vbs? 'return=app.Cursors.StdCursOf{self._cname}.DeltaX.Result.Value'""",
            timeout_ms,
            retval_size,
        )
        delta_y = self._query(
            rf"""vbs? 'return=app.Cursors.StdCursOf{self._cname}.DeltaY.Result.Value'""",
            timeout_ms,
            retval_size,
        )

        # gracefully convert to float
        deltas = [delta_x, delta_y]
        for idx, value in enumerate(deltas):
            try:
                deltas[idx] = float(value)
            except ValueError:
                deltas[idx] = 0
        return deltas

    def get_absolutes(self, timeout_ms=1e3, retval_size=1024):
        """Returns x1, x2, y1 and y2 absolute values of cursor. If not applicable it returns zero."""

        x1 = self._query(
            rf"""vbs? 'return=app.Cursors.StdCursOf{self._cname}.X1.Result.Value'""", timeout_ms, retval_size
        )
        x2 = self._query(
            rf"""vbs? 'return=app.Cursors.StdCursOf{self._cname}.X2.Result.Value'""", timeout_ms, retval_size
        )
        y1 = self._query(
            rf"""vbs? 'return=app.Cursors.StdCursOf{self._cname}.Y1.Result.Value'""", timeout_ms, retval_size
        )
        y2 = self._query(
            rf"""vbs? 'return=app.Cursors.StdCursOf{self._cname}.Y2.Result.Value'""", timeout_ms, retval_size
        )

        # gracefully convert to float
        absolutes = [x1, x2, y1, y2]
        for idx, value in enumerate(absolutes):
            try:
                absolutes[idx] = float(value)
            except ValueError:
                absolutes[idx] = 0
        return absolutes


class MeasurementSlot:
    def __init__(self, parent, slot_idx):
        self._parent = parent
        """:type : SimpleScope"""
        self._slot = slot_idx
        self._vi = self._parent.lld.vi

    def _write(self, msg):
        self._parent.lld.dllwrap.WriteString(self._vi, msg)

    def _read(self, timeout_ms, retval_size):
        return self._parent.lld.dllwrap.ReadString(
            self._vi, MaxTimeMilliseconds=int(timeout_ms), retValBufferSize=int(retval_size)
        ).rstrip("\n")

    def _query(self, msg, timeout_ms, retval_size):
        self._write(msg)
        return self._read(timeout_ms, retval_size)

    def get_measurement(self, timeout_ms=1e3, retval_size=1024):
        value = self._query(rf"""vbs? 'return=app.measure.p{self._slot}.out.result.value'""", timeout_ms, retval_size)
        return float(value)

    def get_stats(self, in_mV=False, timeout_ms=1e3, retval_size=1024):
        MeasurementStats = _namedtuple("MeasurementStats", ["name", "mean", "min", "max", "sdev", "samples"])
        v_to_mv = 1e3

        name = self._query(rf"""vbs? 'return=app.measure.p{self._slot}.equation'""", timeout_ms, retval_size)
        mean = self._query(rf"""vbs? 'return=app.measure.p{self._slot}.histo.result.mean'""", timeout_ms, retval_size)
        minimum = self._query(rf"""vbs? 'return=app.measure.p{self._slot}.histo.result.min'""", timeout_ms, retval_size)
        maximum = self._query(rf"""vbs? 'return=app.measure.p{self._slot}.histo.result.max'""", timeout_ms, retval_size)
        sdev = self._query(rf"""vbs? 'return=app.measure.p{self._slot}.histo.result.sdev'""", timeout_ms, retval_size)
        samples = self._query(
            rf"""vbs? 'return=app.measure.p{self._slot}.histo.result.sweeps'""", timeout_ms, retval_size
        )
        if in_mV:
            return MeasurementStats(
                name,
                float(mean) * v_to_mv,
                float(minimum) * v_to_mv,
                float(maximum) * v_to_mv,
                float(sdev) * v_to_mv,
                int(samples),
            )
        else:
            return MeasurementStats(name, float(mean), float(minimum), float(maximum), float(sdev), int(samples))
