from __future__ import annotations

from time import sleep
from typing import TYPE_CHECKING

from pverify.drivers.SimplifiedLabInstruments._simple_instr.simple_instrument import (
    SimpleInstrument,
    SimpleInstrumentChannel,
)

from .IIfxELoad import IIfxELoad

if TYPE_CHECKING:
    from . import IIfxELoadChannel


class chr6310Simple(SimpleInstrument):
    def __init__(self, driver=None):
        super().__init__(IIfxELoad() if driver is None else driver, "Simple Chroma 6310 ProgLoad")

    @property
    def Initialized(self):
        return self._lowlevel_driver.Initialized

    @property
    def drivername(self):
        return self.__class__.__name__

    @property
    def lld(self) -> IIfxELoad:
        return super().lld

    def Initialize(self, ResourceName, IdQuery, Reset, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
            of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: The user can use the OptionsString parameter to specify the initial values of
            certain IVI inherent attributes for the session. The format of an assignment in
            the OptionsString parameter is "Name=Value", where Name is one of: RangeCheck,
            QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck, or
            DriverSetup. Value is either true or false except for DriverSetup. If the
            Options String parameter contains an assignment for the Driver Setup attribute,
            the Initialize function assumes that everything following "DriverSetup=" is part
            of the assignment.
        :type OptionString: str
        """
        self._lowlevel_driver.Initialize(ResourceName, IdQuery, Reset, OptionString)

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        self._lowlevel_driver.Close()

    def GetChannel(self, Index):
        """
        Returns a channel object for the probe. The different probe channels can be set up indepentently from each other

        :param Index: The index of the channel
        :type Index: int
        :return: _SimpleProgLoadChannel instance
        :rtype: _SimpleProgLoadChannel
        """
        return SimpleChroma6310Channel(self, Index)


class SimpleChroma6310Channel(SimpleInstrumentChannel):
    """
    A Class providing all fuunctionality of a progload channel
    """

    @property
    def lld(self) -> IIfxELoad:
        return super().lld

    @property
    def lld_ch(self) -> IIfxELoadChannel.ModuleBase:
        if not hasattr(self, "_chitem"):
            self._chitem = self.lld.Channels.Item(self._ch_index)
        return self._chitem

    def ReadOCPLimit(self):
        """
        Returns the OCP limit which measured by a previously called CurrentLoad_Stair or CurrentLoad_Ramp

        :return: OCP limit or None if failed
        """

        if self._lowlevel_driver.Initialized:
            return self.lld_ch.OCPResult()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ReadOPPLimit(self):
        """
        Returns the OPP limit which measured by a previously called PowerLoad_Stair or PowerLoad_Ramp

        :return: OPP limit or None if failed
        """

        if self._lowlevel_driver.Initialized:
            return self.lld_ch.OPPResult()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ReadCurrent(self):
        """
        Returns the current that is currently sinked.

        :return: Current level
        """

        if self._lowlevel_driver.Initialized:
            return self.lld_ch.readI()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ReadVoltage(self):
        """
        Returns the voltage that is currently sinked.

        :return: Voltage level
        """

        if self._lowlevel_driver.Initialized:
            return self.lld_ch.readV()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Short_Circuit(self, Enable):
        """
        Performs a short circuit on the load channel.
        """
        if self._lowlevel_driver.Initialized:
            if Enable:
                self.lld_ch.outShortOn()
            else:
                self.lld_ch.outShortOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def CurrentLoad(
        self,
        Level,
        SlewRateRise=1e-12,
        SlewRateFall=1e-12,
        ExpectedVoltage=-1,
        Sync=False,
        Von=0.0,
        Voff=0.0,
    ):
        """
        Enables a static current load.

        :param Level: The current to sink. LAB: Negative values switch off the channel.
        :type Level: float
        :param SlewRateRise: The slew rate of a decreasing current in A/uS. Value 0 means MAX.
        :type SlewRateRise: float
        :param SlewRateFall: The slew rate of an increasing current in A/uS. Value 0 means MAX.
        :type SlewRateFall: float
        :param ExpectedVoltage: The expected voltage that will occur due to the current load. Used for the device
                                    to differ between low range and high range to gain more accuracy.
        :type ExpectedVoltage: float
        :param Sync: If True, the channel is not activated after configuring.
                         A call to CurrentLoad_SyncronizedEnable afterwards enables all channels simultaneously.
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """

        if self._lowlevel_driver.Initialized:
            if Level >= 0 and SlewRateRise >= 0 and SlewRateFall >= 0:
                self.lld_ch.setVon(Von)
                self.lld_ch.setVoff(Voff)
                self.lld_ch.setILoad(Level, SlewRateRise, SlewRateFall, ExpectedVoltage)
                self.lld_ch.Syncronize(enabled=Sync)
                if not Sync:
                    self.lld_ch.outOn()
            else:
                self.lld_ch.Syncronize(enabled=False)
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def CurrentLoad_SyncronizedEnable(self, enabled):
        """Enables/Disables all previously defined synchronized channels."""

        self._lowlevel_driver.Channels.EnableSynced(enabled)

    def CurrentLoad_Stair(
        self,
        Istart,
        Istep,
        Nstep,
        DwellTime,
        ExpectedVoltage=-1,
        TriggerVoltage=2,
        Von=0.0,
        Voff=0.0,
    ):
        """
        Sinks a current that is rising step-by-step for a delta value from a starting point with a specific
        number of steps and a specific dwell time at each step.
        LAB: Invalid values switch off the channel.

        :param Istart: The start level of the current stair.
        :type Istart: float
        :param Istep: The delta current that is added for each step.
        :type Istep: float
        :param Nstep: The number of steps.
        :type Nstep: int
        :param DwellTime: The step duration in seconds
        :type DwellTime: float
        :param ExpectedVoltage: The expected voltage that will occur due to the current load. Used for the device
                                to differ between low range and high range to gain more accuracy.
        :type ExpectedVoltage: float
        :param TriggerVoltage: The channel's voltage (falling slope) where the progr. load notices an
                               over-current situation and then sets the OCP value
                               to the actual current as well as stops sinking current.
        :type TriggerVoltage: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """

        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Istep > 0 and Istart >= 0 and Nstep > 0:
                self.lld_ch.genIStairs2(Istart, Istep, Nstep, DwellTime, TriggerVoltage, ExpectedVoltage)
            elif Istep < 0 and Istart >= 0 and Nstep > 0:
                if DwellTime <= 0.2:
                    msg = "Dwelltime at negative step must be greater than 0.2s."
                    raise ValueError(msg)
                self.lld_ch.setILoad(Istart, 0, 0, ExpectedVoltage)
                for i in range(int(Nstep)):
                    sleep(DwellTime - 0.140)
                    self.lld_ch.setILoad(Istart + (i + 1) * Istep, 0, 0, ExpectedVoltage)
                sleep(DwellTime - 0.001)
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def CurrentLoad_Ramp(
        self,
        Istart,
        Istop,
        RiseTime,
        ExpectedVoltage=-1,
        TriggerVoltage=2,
        Von=0.0,
        Voff=0.0,
    ):
        """
        Sinks a current ramp from Istart to Istop during the time RiseTime.
        LAB: Invalid values switch off the channel.

        :param Istart: The start level of the current ramp.
        :param Istop: The stop level of the current ramp.
        :param RiseTime: The duration of the ramp in seconds
        :param ExpectedVoltage: The expected voltage that will occur due to the current load. Used for the device
                                    to differ between low range and high range to gain more accuracy.
        :type ExpectedVoltage: float
        :param TriggerVoltage: The channel's voltage (falling slope) where the progr. load notices an
                               over-current situation and then sets the OCP value
                               to the actual current as well as stops sinking current.
        :type TriggerVoltage: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """

        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Istart != Istop and RiseTime >= 0:
                self.lld_ch.genIRamp(Istart, Istop, RiseTime, TriggerVoltage, ExpectedVoltage)
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def CurrentLoad_Pulsed(
        self,
        Level1,
        Level2,
        DwellTime1,
        DwellTime2,
        SlewRateRise,
        SlewRateFall,
        Von=0.0,
        Voff=0.0,
        Sync=False,
    ):
        """
        Sinks a current that is toggled between two levels with a defined frequency and dutycycle as well as with a
        specific slew rate.

        :param Level1: First current level
        :param Level2: Second current level
        :param DwellTime1: The time in s the first current level is applied
        :param DwellTime2: The time in s the second current level is applied
        :param SlewRateRise: The slew rate of a decreasing current in A/uS. Value 0 means MAX.
        :type SlewRateRise: float
        :param SlewRateFall: The slew rate of an increasing current in A/uS. Value 0 means MAX.
        :type SlewRateFall: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        :param Sync: If True, the channel is not activated after configuring.
                     A call to CurrentLoad_SyncronizedEnable afterwards enables all channels simultaneously.
        """
        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Level1 != Level2 and DwellTime1 != 0 and DwellTime2 != 0 and SlewRateRise >= 0 and SlewRateFall >= 0:
                self.lld_ch.Syncronize(Sync)
                self.lld_ch.setDynILoad(Level1, DwellTime1, Level2, DwellTime2, SlewRateRise, SlewRateFall)
                if not Sync:
                    self.lld_ch.outOn()
            elif Level1 == 0 and Level2 == 0:
                self.lld_ch.outOff()
            elif Level1 == Level2:
                self.CurrentLoad(
                    Level=Level1,
                    SlewRateRise=SlewRateRise,
                    SlewRateFall=SlewRateFall,
                    ExpectedVoltage=-1,
                    Sync=Sync,
                    Von=Von,
                    Voff=Voff,
                )
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def VoltageLoad(self, Level, Von=0.0, Voff=0.0):
        """
        Sets a static voltage load.

        :param Level: The voltage to set. LAB: Negative values switch off the channel.
        :type Level: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """
        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Level >= 0:
                self.lld_ch.setVLoad(Level, -1)
                self.lld_ch.outOn()
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ResistiveLoad(self, Level, ExpectedVoltage=-1, Von=0.0, Voff=0.0, SlewRateRise=-1, SlewRateFall=-1):
        """
        Enables a static resistive load.

        :param Level: The resistance to set. LAB: Negative values switch off the channel.
        :type Level: float
        :param ExpectedVoltage: The expected voltage that will occur due to the resistive load. Used for the device
                                to differ between low range and high range to gain more accuracy.
        :type ExpectedVoltage: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        :param SlewRateRise: Slew rate rise
        :type SlewRateRise: float
        :param SlewRateFall: Slew rate fall
        :type SlewRateFall: float
        """
        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Level >= 0:
                self.lld_ch.setRLoad(Level, ExpectedVoltage, SlewRateRise, SlewRateFall)
                self.lld_ch.outOn()
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def PowerLoad(self, Level, ExpectedCurrent=-1, Von=0.0, Voff=0.0):
        """
        Sink a static power.

        :param Level: The power to set. LAB: Negative values switch off the channel.
        :type Level: float
        :param ExpectedCurrent: The expected voltage that will occur due to the current load. Used for the device
                                    to differ between low range and high range to gain more accuracy.
        :type ExpectedCurrent: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """

        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Level >= 0:
                self.lld_ch.setPload(Level, ExpectedCurrent)
                self.lld_ch.outOn()
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def PowerLoad_Ramp(self, Pstart, Pstop, RiseTime, TriggerVoltage=2, Von=0.0, Voff=0.0):
        """
        Sinks a power ramp from Pstart to Pstop during the time RiseTime.
        LAB: Invalid values switch off the channel.

        :param Pstart: The start level of the power ramp.
        :type Pstart: float
        :param Pstop: The stop level of the power ramp.
        :type Pstop: float
        :param RiseTime: The duration of the ramp in seconds.
        :type RiseTime: float
        :param TriggerVoltage: The channel's voltage (falling slope) where the progr. load notices an
                               over-power situation and then sets the OPP value
                               to the actual power as well as stops sinking current.
        :type TriggerVoltage: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """
        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Pstart != Pstop and RiseTime > 0:
                self.lld_ch.genPRamp(Pstart, Pstop, RiseTime, TriggerVoltage)
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def PowerLoad_Stair(self, Pstart, Pstop, Nstep, DwellTime, TriggerVoltage=2, Von=0.0, Voff=0.0):
        """
        Sinks a power that is rising step-by-step for a delta value from a starting point with a specific
        number of steps and a specific dwell time at each step.
        LAB: Invalid values switch off the channel.

        :param Pstart: The start level of the power stair.
        :type Pstart: float
        :param Pstop: The delta power that is added for each step.
        :type Pstop: float
        :param Nstep: The number of steps.
        :type Nstep: int
        :param DwellTime: The step duration in seconds
        :type DwellTime: float
        :param TriggerVoltage: The channel's voltage (falling slope) where the progr. load notices an
                               over-power situation and then sets the OPP value
                               to the actual power as well as stops sinking current.
        :type TriggerVoltage: float
        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        """
        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            if Pstart != Pstop and Nstep > 0 and DwellTime > 0:
                self.lld_ch.genPStairs(Pstart, Pstop, DwellTime, Nstep, TriggerVoltage)
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def LEDLoad_VoIoRd(self, Vo, Io, Rd):
        """
        Sets an LED load by configuring its operating point and the dynamic resistance at the operating point.

        :param Vo: The operating voltage. A negative value turns off the channel.
        :type Vo: float
        :param Io: The operating current. A negative value turns off the channel.
        :type Io: float
        :param Rd: The dynamic resistance at the operating point. A negative or 0 value turns off the channel.
        :type Rd: float
        """
        if self._lowlevel_driver.Initialized:
            if Vo >= 0 and Io >= 0 and Rd > 0:
                self.lld_ch.setLEDLoad(Vo, Io, Rd)
                self.lld_ch.outOn()
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def LEDLoad_VfRdN(self, Vf, Rd, N, **kwargs):
        """
        Sets an LED load by configuring its forward voltage and dynamic resistance.

        :param Vf: The forward voltage of the LEDs. A negative value turns off the channel.
        :type Vf: float
        :param Rd: The dynamic resistance at the operating point of one LED.
                   Will be multipied with N to get the entire resistance.
                   A negative value or 0 turns off the channel.
        :type Rd: The dynamic resistance at the operating point of one LED.
        :param N: The number of LEDs. Will be multipied with Rd to get the entire resistance.
                  A negative value or 0 turns off the channel.
        :type N: int|float
        :keyword ForceHVRange: Lab-only, module 63113 only: Forces LEDH mode
        """
        if self._lowlevel_driver.Initialized:
            if Vf >= 0 and Rd > 0 and N > 0:
                self.lld_ch.setLEDString(Vf, Rd, N, kwargs.get("ForceHVRange", False))
                self.lld_ch.outOn()
            else:
                self.lld_ch.outOff()
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def SetVonVoff(self, Von, Voff, VonLatch=True):
        """
        Configures Von/Voff for the channel

        :param Von: Voltage at which the load starts sinking current
        :type Von: float
        :param Voff: Voltage at which the load stops sinking current
        :type Voff: float
        :param VonLatch: True for Latch behaviour, False otherwise
        :type VonLatch: bool
        """
        if self._lowlevel_driver.Initialized:
            self.lld_ch.setVon(Von)
            self.lld_ch.setVoff(Voff)
            self.lld_ch.setVonLatch(VonLatch)
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)
