# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $Rev$
# Date           : $Date$
# Last change by : $Author$
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

from pverify.drivers.ProgrammableLoad.chr6310 import IIfxELoadBase


class IIfxELoadChannels(IIfxELoadBase.IIfxELoadBase):
    """IfxELoad class-compliant channel collection interface.

    NOTE:
        Attributes/Methods marked with '#' do not exist for this instrument.
        Attributes/Methods marked with '*' are specific for this instrument.
        !Please consider when trying to program instrument independent.

    Attributes:
        Count


    Methods:
        Item(Name)
            Gets a pointer to a channel object.
    """

    def __init__(self, interface):
        IIfxELoadBase.IIfxELoadBase.__init__(self, interface)
        self.__channels = {}

    def _getModules(self):
        modules = self.interface.vi_query("*RDT?", rformat="%s")
        return str(modules).strip().split(",")

    def Item(self, ChannelNumber):
        """
        Returns an object for the specified chroma 631xx module.

        :type ChannelNumber: int
        :param ChannelNumber: The channel number of the load module
        """
        ChannelNumber = int(ChannelNumber)

        modules = self.interface.vi_query("*RDT?", rformat="%s")
        modules = str(modules).strip().split(",")
        ModuleName = modules[ChannelNumber - 1]

        if str(ModuleName).find("63103") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63103

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63103(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        elif str(ModuleName).find("63105") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63105

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63105(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        elif str(ModuleName).find("63108") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63108

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63108(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        elif str(ModuleName).find("63112") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63112

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63112(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        elif str(ModuleName).find("63110") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63110

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63110(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        elif str(ModuleName).find("63113") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63113

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63113(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        elif str(ModuleName).find("63106") >= 0:
            from pverify.drivers.ProgrammableLoad.chr6310.IIfxELoadChannel import Module_63106

            if int(ChannelNumber) in self.__channels:
                return self.__channels[int(ChannelNumber)]
            else:
                chan = Module_63106(self.interface, ChannelNumber)
                self.__channels.update({int(ChannelNumber): chan})
                return chan
        else:
            msg = f"Module '{ModuleName!s}' can not be found."
            raise LookupError(msg)

    def EnableSynced(self, enabled):
        if enabled:
            self.interface.vi_write(":RUN")
        else:
            self.interface.vi_write(":ABOR")
