# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $
# Date           : $
# Last change by : $
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

from math import ceil
from time import sleep

from pverify.drivers.ProgrammableLoad.chr6310 import IIfxELoadBase


class ModuleBase(IIfxELoadBase.IIfxELoadBase):
    def __init__(self, interface, channelNumber):
        IIfxELoadBase.IIfxELoadBase.__init__(self, interface)
        """
        constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 60
        self._I_LMAX = 6
        self._I_MIN = 0
        self._V_HMAX = 80
        self._V_LMAX = 16
        self._V_MIN = 0
        self._R_HMAX = 5000
        self._R_HMIN = 1.25
        self._R_LMAX = 100
        self._R_LMIN = 0.025
        self._P_HMAX = 300
        self._P_LMAX = 30
        self._ISR_HMIN = 0.01
        self._ISR_HMAX = 2.5
        self._ISR_LMAX = 0.25
        self._ISR_LMIN = 0.001
        self._Rd_LMIN = 1
        self._Rd_LMAX = 1000
        self._Rd_HMIN = 10
        self._Rd_HMAX = 10000

        self.channelNumber = channelNumber
        self.interface = interface

        self.setVonLatch(True)
        self.setVon(1.0)
        self.setVoff(0.0)

    def setVLoad(self, Voltage, Ilimit=-1):
        """
        Configures channel in voltage load mode with the specified values.

        :param Voltage: float
        :param Ilimit: float
        :return:
        """
        if Voltage > self._V_HMAX or Voltage < self._V_MIN:
            msg = f"Voltage settings out of range, Vmax: {self._V_HMAX:f}"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        self.interface.vi_write(":VOLTAGE:MODE FAST")
        self.interface.vi_write(":MODE CV")
        self.interface.vi_write(f":VOLT:L1 {Voltage:f}")
        if Ilimit == -1:
            self.interface.vi_write(":VOLT:CURR MAX")
        else:
            self.interface.vi_write(f":VOLT:CURR {Ilimit:f}")

        self.GetError()

    def setPload(self, Power, ExpMaxCurrent=-1):
        """
        Sets load in Power mode and specifies the Power to be sink.

        :param Power: float
        :param ExpMaxCurrent: float
        :return:
        """
        if (Power > self._P_HMAX) or (Power < 0):
            raise ValueError('"Power settings out of range, Pmax: %d' % self._P_HMAX)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        if (ExpMaxCurrent == -1) or (ExpMaxCurrent > self._I_LMAX) or (Power > self._P_LMAX):
            self.interface.vi_write(":MODE CPH")
        else:
            self.interface.vi_write(":MODE CPL")

        self.interface.vi_write(f":POW:STAT:L1 {Power:f}")

        self.GetError()

    def setILoad(self, Current, SlewRateRise=0, SlewRateFall=0, ExpVoltage=-1):
        """
        Sets load in current mode and specifies the current to sink.

        :param Current: The current level to apply
        :param ExpVoltage: The expected voltage that will occur due to the current load. Used for the device
                           to differ between low range and high range to gain more accuracy.
        :param SlewRateRise: Rise speed of the current slope
        :param SlewRateFall: Fall speed of the current slope
        :return:
        """
        if (Current > self._I_HMAX) or (Current < 0):
            raise ValueError("Current settings out of range, Imax: %d" % self._I_HMAX)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        Vmax = self._V_HMAX if ExpVoltage == -1 else ExpVoltage * 1.1

        if (Current * Vmax) > self._P_LMAX:
            # print("CCH, Current: %.2f, Vmax: %.2f" % (Current, Vmax))
            self.interface.vi_write(":MODE CCH")
            self.interface.vi_write(f":CURR:STAT:RISE {self._ISR_HMAX:f}" if SlewRateRise <= 0 else SlewRateRise)
            self.interface.vi_write(f":CURR:STAT:FALL {self._ISR_HMAX:f}" if SlewRateFall <= 0 else SlewRateFall)
        else:
            # print("CCL, Current: %.2f, Vmax: %.2f" % (Current, Vmax))
            self.interface.vi_write(":MODE CCL")
            self.interface.vi_write(f":CURR:STAT:RISE {self._ISR_LMAX:f}" if SlewRateRise <= 0 else SlewRateRise)
            self.interface.vi_write(f":CURR:STAT:FALL {self._ISR_LMAX:f}" if SlewRateFall <= 0 else SlewRateFall)

        self.interface.vi_write(f":CURR:STAT:L1 {Current:f}")

        self.GetError()

    def setRLoad(self, Ohms, expectedVMax_V=-1, SlewRateRise=-1, SlewRateFall=-1):
        """
        Sets load in resistance mode and specifies the value in ohms.

        :param Ohms: float
        :param expectedVMax_V: float
        :return:
        """
        if ((expectedVMax_V < 0) or (expectedVMax_V > self._V_LMAX * 0.9)) and (
            (Ohms < self._R_HMIN) or (Ohms > self._R_HMAX)
        ):
            msg = f"Settings out of high voltage range resistance, possible ranges: Rmin: {self._R_HMIN} & Rmax: {self._R_HMAX}"
            raise ValueError(msg)
        elif (Ohms < self._R_LMIN) or (Ohms > self._R_HMAX):
            msg = f"Resistance settings out of possible ranges: Rmin: {self._R_LMIN}& Rmax: {self._R_HMAX}"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        if (expectedVMax_V < 0) or (expectedVMax_V > self._V_LMAX * 0.9) or (Ohms > self._R_LMAX):
            self.interface.vi_write(":MODE CRH")
        else:
            self.interface.vi_write(":MODE CRL")

        if SlewRateRise >= 0:
            self.interface.vi_write(f":RES:RISE {SlewRateRise}")
        if SlewRateFall >= 0:
            self.interface.vi_write(f":RES:FALL {SlewRateRise}")

        self.interface.vi_write(f":RES:L1 {Ohms:f}")

        self.GetError()

    def OCPResult(self):
        """
        Gets result for the OCP measurement

        :return: str (if not found return value is NaN)
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        for _i in range(36000):
            sleep(0.1)
            answ = self.interface.vi_query("OCP:RES?", rformat="%s")
            if answ != "-3":
                break

        if answ.lower().find("pass") != -1 or answ.lower().find("fail") != -1:
            ret = float(answ.strip().split(",")[1])
        else:
            ret = None

        self.GetError()

        return ret

    def OPPResult(self):
        """
        Gets result for the OPP measurement

        :return: str (if not found return value: NaN)
        """

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        for _i in range(36000):
            sleep(0.1)
            answ = self.interface.vi_query("OPP:RES?", rformat="%s")
            if answ != "-3":
                break

        if answ.lower().find("pass") != -1 or answ.lower().find("fail") != -1:
            ret = float(answ.strip().split(",")[1])
        else:
            ret = None

        self.GetError()

        return ret

    def genIStairs2(self, Istar, Istep, Nstep, Tstep, Vtrig=2, ExpVoltage=-1):
        """
        Generate an increasing current ramp with steps

        :param Istar: float
        :param Istep: float
        :param Tstep: float
        :param Nstep: int
        :param Vtrig: float
        :param ExpVoltage: float
        :return:
        """
        Istop = Istar + Nstep * Istep

        if Istop > self._I_HMAX:
            raise ValueError("Current settings out of range, maximum value: %d" % self._I_HMAX)

        if Istop < Istar:
            msg = "Istop can not be smaller than Istart"
            raise ValueError(msg)

        if Nstep > 1000:
            msg = "Nstep out of range, maximum number of steps: 1000"
            raise ValueError(msg)

        if Tstep > 1 or Tstep < 0.001:
            msg = "Time step out of range, max. 1, min.: 0.001"
            raise ValueError(msg)

        if Vtrig < 0:
            msg = "Trigger voltage value can not be negative"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        Vmax = self._V_HMAX if ExpVoltage == -1 else ExpVoltage * 1.1

        if Istop * Vmax > self._I_LMAX:
            self.interface.vi_write(":MODE CCH")
            self.interface.vi_write(":OCP:RANGE H")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")
        else:
            self.interface.vi_write(":MODE CCL")
            self.interface.vi_write(":OCP:RANGE L")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")

        self.interface.vi_write(f":OCP:SPEC:L {Istar:f}")
        self.interface.vi_write(f":OCP:SPEC:H {Istop:f}")
        self.interface.vi_write(f":OCP:ISTA {Istar:f}")
        self.interface.vi_write(f":OCP:IEND {Istop:f}")
        self.interface.vi_write(":OCP:DWEL %d" % int(Tstep * 1000))
        self.interface.vi_write(":OCP:STEP %d" % int(Nstep))
        self.interface.vi_write(f":OCP:TRIG:VOLT {Vtrig:f}")
        self.interface.vi_write(":OCP ON")

        self.GetError()

    def genIStairs(self, Istar, Istop, Tstep, Nstep, Vtrig=2, ExpVoltage=-1):
        """
        Generate an increasing current ramp with steps

        :param Istar: float
        :param Istop: float
        :param Tstep: float
        :param Nstep: int
        :param Vtrig: float
        :param ExpVoltage: float
        :return:
        """
        if Istop > self._I_HMAX:
            raise ValueError("Current settings out of range, maximum value: %d" % self._I_HMAX)

        if Istop < Istar:
            msg = "Istop can not be smaller than Istart"
            raise ValueError(msg)

        if Nstep > 1000:
            msg = "Nstep out of range, maximum number of steps: 1000"
            raise ValueError(msg)

        if Tstep > 1 or Tstep < 0.001:
            msg = "Time step out of range, max. 1, min.: 0.001"
            raise ValueError(msg)

        if Vtrig < 0:
            msg = "Trigger voltage value can not be negative"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        Vmax = self._V_HMAX if ExpVoltage == -1 else ExpVoltage * 1.1

        if Istop * Vmax > self._I_LMAX:
            self.interface.vi_write(":MODE CCH")
            self.interface.vi_write(":OCP:RANGE H")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")
        else:
            self.interface.vi_write(":MODE CCL")
            self.interface.vi_write(":OCP:RANGE L")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")

        self.interface.vi_write(f":OCP:SPEC:L {Istar:f}")
        self.interface.vi_write(f":OCP:SPEC:H {Istop:f}")
        self.interface.vi_write(f":OCP:ISTA {Istar:f}")
        self.interface.vi_write(f":OCP:IEND {Istop:f}")
        self.interface.vi_write(":OCP:DWEL %d" % int(Tstep * 1000))
        self.interface.vi_write(":OCP:STEP %d" % int(Nstep))
        self.interface.vi_write(f":OCP:TRIG:VOLT {Vtrig:f}")
        self.interface.vi_write(":OCP ON")

        self.GetError()

    def genIRamp2(self, Istar, Istop, Islew_As, Vtrig=2, ExpVoltage=-1):
        """
        Generate an increasing current ramp from Istart to Istop with the indicated slew rate in A/us

        :param Istar: float
        :param Istop: float
        :param Islew_As: float
        :param Vtrig: float
        :param ExpVoltage: float
        :return:
        """
        Rtime = Islew_As / (Istop - Istar)
        if Istop > self._I_HMAX:
            raise ValueError("Current settings out of range, maximum value: %d" % self._I_HMAX)
        if Istop < Istar:
            msg = "Istop can not be smaller than Istart"
            raise ValueError(msg)
        if (Rtime > 1000) or (Rtime < 0.002):
            msg = "Resulting ramp time out of range, min: 0.002, max: 1000"
            raise ValueError(msg)
        if Vtrig < 0:
            msg = "Trigger voltage value can not be negative"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        Vmax = self._V_HMAX if ExpVoltage == -1 else ExpVoltage * 1.1

        if Istop * Vmax > self._P_LMAX:
            self.interface.vi_write(":MODE CCH")
            self.interface.vi_write(":OCP:RANGE H")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")
        else:
            self.interface.vi_write(":MODE CCL")
            self.interface.vi_write(":OCP:RANGE L")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")

        self.interface.vi_write(f":OCP:SPEC:L {Istar:f}")
        self.interface.vi_write(f":OCP:SPEC:H {Istop:f}")
        self.interface.vi_write(f":OCP:ISTA {Istar:f}")
        self.interface.vi_write(f":OCP:IEND {Istop:f}")

        if Rtime < 1:
            self.interface.vi_write(":OCP:DWEL 1")
            self.interface.vi_write(":OCP:STEP %d" % (int(round(Rtime * 1000))))
        else:
            DwelI = int(ceil(Rtime))
            self.interface.vi_write(":OCP:DWEL %d" % DwelI)
            self.interface.vi_write(":OCP:STEP %d" % (int(round((Rtime * 1000) / DwelI))))

        self.interface.vi_write(f":OCP:TRIG:VOLT {Vtrig:f}")
        self.interface.vi_write(":OCP ON")

        self.GetError()

    def genIRamp(self, Istar, Istop, Rtime, Vtrig=2, ExpVoltage=-1):
        """
        Generate an increasing current ramp from Istart to Istop with the indicated slew rate in A/us

        :param Istar: float
        :param Istop: float
        :param Rtime: float
        :param Vtrig: float
        :param ExpVoltage: float
        :return:
        """
        if Istop > self._I_HMAX:
            raise ValueError("Current settings out of range, maximum value: %d" % self._I_HMAX)
        if Istop < Istar:
            msg = "Istop can not be smaller than Istart"
            raise ValueError(msg)
        if (Rtime > 1000) or (Rtime < 0.002):
            msg = "Resulting ramp time out of range, min: 0.002, max: 1000"
            raise ValueError(msg)
        if Vtrig < 0:
            msg = "Trigger voltage value can not be negative"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        Vmax = self._V_HMAX if ExpVoltage == -1 else ExpVoltage * 1.1

        if (Istop * Vmax) > self._P_LMAX:
            self.interface.vi_write(":MODE CCH")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")
            self.interface.vi_write(":OCP:RANGE H")
        else:
            self.interface.vi_write(":MODE CCL")
            self.interface.vi_write(f":CURR:STAT:L1 {Istar:f}")
            self.interface.vi_write(":OCP:RANGE L")

        self.interface.vi_write(f":OCP:SPEC:L {Istar:f}")
        self.interface.vi_write(f":OCP:SPEC:H {Istop:f}")
        self.interface.vi_write(f":OCP:ISTA {Istar:f}")
        self.interface.vi_write(f":OCP:IEND {Istop:f}")

        if Rtime < 1:
            self.interface.vi_write(":OCP:DWEL 1")
            self.interface.vi_write(":OCP:STEP %d" % (int(round(Rtime * 1000))))
        else:
            DwelI = int(ceil(Rtime))
            self.interface.vi_write(":OCP:DWEL %d" % DwelI)
            self.interface.vi_write(":OCP:STEP %d" % (int(round((Rtime * 1000) / DwelI))))

        self.interface.vi_write(f":OCP:TRIG:VOLT {Vtrig:f}")
        self.interface.vi_write(":OCP ON")

        self.GetError()

    def genPRamp(self, Pstar, Pstop, Rtime, Vtrig=2):
        """
        Generate an increasing current ramp from Istart to Istop with the indicated slew rate in A/us

        :param Pstar: float
        :param Pstop: float
        :param Rtime: float
        :param Vtrig: float
        :return:
        """
        if Pstop > self._P_HMAX:
            raise ValueError("Power settings out of range, maximum value: %d" % self._P_HMAX)
        if Pstop < Pstar:
            msg = "Pstop can not be smaller than Pstart"
            raise ValueError(msg)
        if (Rtime > 1000) or (Rtime < 0.002):
            msg = "Resulting ramp time out of range, min: 0.002, max: 1000"
            raise ValueError(msg)
        if Vtrig < 0:
            msg = "Trigger voltage value can not be negative"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        if Pstop > self._P_LMAX:
            self.interface.vi_write(":MODE CPH")
            self.interface.vi_write(f":POW:STAT:L1 {Pstar:f}")
            self.interface.vi_write(":OPP:RANGE H")
        else:
            self.interface.vi_write(":MODE CPL")
            self.interface.vi_write(f":POW:STAT:L1 {Pstar:f}")
            self.interface.vi_write(":OPP:RANGE L")

        self.interface.vi_write(f":OPP:SPEC:L {Pstar:f}")
        self.interface.vi_write(f":OPP:SPEC:H {Pstop:f}")
        self.interface.vi_write(f":OPP:PSTA {Pstar:f}")
        self.interface.vi_write(f":OPP:IEND {Pstop:f}")

        if Rtime < 1:
            self.interface.vi_write(":OPP:DWEL 1")
            self.interface.vi_write(":OPP:STEP %d" % (int(round(Rtime * 1000))))
        else:
            DwelI = int(ceil(Rtime))
            self.interface.vi_write(":OPP:DWEL %d" % DwelI)
            self.interface.vi_write(":OPP:STEP %d" % (int(round((Rtime * 1000) / DwelI))))

        self.interface.vi_write(f":OPP:TRIG:VOLT {Vtrig:f}")
        self.interface.vi_write(":OPP ON")

        self.GetError()

    def genPStairs(self, Pstar, Pstop, Tstep, Nstep, Vtrig=2):
        """
        Generate an increasing current ramp from Istart to Istop with the indicated slew rate in A/us

        :param Pstar: float
        :param Pstop: float
        :param Tstep: float
        :param Nstep: int
        :param Vtrig: float
        :return:
        """
        if Pstop > self._P_HMAX:
            raise ValueError("Power settings out of range, maximum value: %d" % self._P_HMAX)
        if Pstop < Pstar:
            msg = "Pstop can not be smaller than Pstart"
            raise ValueError(msg)
        if Nstep > 1000:
            msg = "Nstep out of range, maximum number of steps: 1000"
            raise ValueError(msg)
        if Tstep > 1 or Tstep < 0.001:
            msg = "Time step out of range, max. 1, min.: 0.001"
            raise ValueError(msg)
        if Vtrig < 0:
            msg = "Trigger voltage value can not be negative"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        if Pstop > self._P_LMAX:
            self.interface.vi_write(":MODE CPH")
            self.interface.vi_write(f":POW:STAT:L1 {Pstar:f}")
            self.interface.vi_write(":OPP:RANGE H")
        else:
            self.interface.vi_write(":MODE CPL")
            self.interface.vi_write(f":POW:STAT:L1 {Pstar:f}")
            self.interface.vi_write(":OPP:RANGE L")

        self.interface.vi_write(f":OPP:SPEC:L {Pstar:f}")
        self.interface.vi_write(f":OPP:SPEC:H {Pstop:f}")
        self.interface.vi_write(f":OPP:PSTA {Pstar:f}")
        self.interface.vi_write(f":OPP:PEND {Pstop:f}")
        self.interface.vi_write(":OPP:DWEL %d" % int(Tstep * 1000))
        self.interface.vi_write(":OPP:STEP %d" % int(Nstep))
        self.interface.vi_write(f"OPP:TRIG:VOLT {Vtrig:f}")
        self.interface.vi_write(":OPP ON")

        self.GetError()

    def outOn(self):
        """
        Set ouptut on.

        :return:
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":LOAD ON")

        self.GetError()

    def outOff(self):
        """
        Set output off.

        :return:
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":LOAD OFF")

        self.GetError()

    def outShortOn(self):
        """
        Enable output short circuit.

        :return:
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        answ = self.interface.vi_query(":MODE?", rformat="%s")
        if "CCL" in answ:
            ret = self.interface.vi_query(":CURR:STAT:L1?", rformat="%s")
            self.interface.vi_write(":MODE CCH")
            self.interface.vi_write(f"CURR:STAT:L1 {ret}")
        elif "CPL" in answ:
            ret = self.interface.vi_query(":POW:STAT:L1?", rformat="%s")
            self.interface.vi_write(":MODE CPH")
            self.interface.vi_write(f"POW:STAT:L1 {ret}")

        self.interface.vi_write(":LOAD ON")
        self.interface.vi_write(":LOAD:SHORT ON")

        self.GetError()

    def outShortOff(self):
        """
        Disable output short circuit.

        :return:
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":LOAD:SHORT OFF")

        self.GetError()

    def readV(self):
        """
        Reads voltage at the output.

        :return: float
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        ret = self.interface.vi_query(":FETC:VOLT?", rformat="%f")

        self.GetError()

        return ret

    def readI(self):
        """
        Reads current at the output.

        :return: float
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        ret = self.interface.vi_query(":FETCH:CURRENT?", rformat="%f")
        self.GetError()

        return ret

    def setDynILoad(self, I1, T1, I2, T2, SlewRateRise=0.2, SlewRateFall=0.2):
        """
        Specifies dynamic current load. High and low values of the function vbCrLf.

        Timing for the function
        :param I1: float
        :param T1: float
        :param I2: float
        :param T2: float
        :param ISlewRate_A_us: float
        :return:
        """
        if (I1 < self._I_MIN) or (I2 < self._I_MIN) or (I1 > self._I_HMAX) or (I2 > self._I_HMAX):
            raise ValueError("Current settings out of range: %d to %d" % (self._I_MIN, self._I_HMAX))

        if T1 < self._T_MIN or T2 < self._T_MIN or T1 > self._T_MAX or T2 > self._T_MAX:
            raise ValueError("Timing settings out of range: %d to %d" % (self._T_MIN, self._T_MAX))

        if SlewRateRise > self._ISR_HMAX or SlewRateFall > self._ISR_HMAX:
            raise Warning("ISlewRate out of range, maximum value %d" % self._ISR_HMAX)

        if SlewRateRise < self._ISR_LMIN or SlewRateFall < self._ISR_LMIN:
            raise Warning("ISlewRate out of range, minimum value: %d" % self._ISR_LMIN)

        if (SlewRateRise < self._ISR_HMIN or SlewRateFall < self._ISR_HMIN) and max(I1, I2) > 6:
            msg = "ISlewRate and current settings not allowed by the instrument: see instrument current and SR settings"
            raise Warning(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        if (SlewRateRise > 0.2) or (SlewRateFall > 0.2) or (max(I1, I2) * self._V_HMAX > self._P_LMAX):
            self.interface.vi_write(":MODE CCDH")
        else:
            self.interface.vi_write(":MODE CCDL")

        self.interface.vi_write(f":CURR:DYN:L1 {I1:f}")
        self.interface.vi_write(f":CURR:DYN:L2 {I2:f}")
        self.interface.vi_write(f":CURR:DYN:T1 {T1:f}")
        self.interface.vi_write(f":CURR:DYN:T2 {T2:f}")
        self.interface.vi_write(f":CURR:DYN:RISE {SlewRateRise:f}")
        self.interface.vi_write(f":CURR:DYN:FALL {SlewRateFall:f}")

        self.GetError()

    def setDynVLoad(self, V1, T1, V2, T2, nCycles, ILimit=-1):
        """
        Specifies dynamic voltage load. High and low values of the function vbCrLf.
        Timing for the function. Note: this will execute dynamic function for
        sepecified number cicles

        :param V1: float
        :param T1: time1 in s
        :param V2: float
        :param T2: time2 in s
        :param nCycles: int
        :param ILimit: float
        :return:
        """
        if (V1 < self._V_MIN) or (V2 < self._V_MIN) or (V1 > self._V_HMAX) or (V2 > self._V_HMAX):
            msg = "Current settings out of range"
            raise ValueError(msg)

        if T1 < self._T_MIN or T2 < self._T_MIN or T1 > self._T_MAX or T2 > self._T_MAX:
            msg = "Time settings out of range"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")

        if (V1 > 18) or (V2 > 18):
            self.interface.vi_write(":CONF:VOLT:RANG H")
        else:
            self.interface.vi_write(":CONF:VOLT:RANG L")

        self.interface.vi_write(":MODE CV")

        if ILimit == -1:
            self.interface.vi_write(":VOLT:CURR MAX")
        else:
            self.interface.vi_write(f":VOLT:CURR {ILimit:f}")

        self.interface.vi_write(":VOLT:MODE FAST")
        for _i in range(nCycles):
            self.interface.vi_write(f":VOLT:L1 {V1:f}")
            sleep(T1)
            self.interface.vi_write(f":VOLT:L1 {V2:f}")
            sleep(T2)

        self.GetError()

    def reset(self):
        """
        Reset to default settings.

        :return:
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        self.interface.vi_write(":CHAN:ACT ON")
        self.interface.vi_write(":LOAD OFF")
        self.interface.vi_write(":CONF:VOLT:RANG H")
        self.interface.vi_write(":CONF:CR:RANG:HIGH")
        self.interface.vi_write(":CONF:VOLT:ON 0")
        self.setVonLatch(True)

        self.GetError()

    def setVon(self, VOnThreshold):
        """
        Set the minimum required Voltage to start sinking current.

        :param VOnThreshold: float
        :return:
        """
        if VOnThreshold is None:
            return
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(f":CONF:VOLT:ON {VOnThreshold:f}")

        self.GetError()

    def setVonLatch(self, state):
        """
        Sets the action type of Von.

        :param state: True for Latch behaviour, False otherwise
        :return:
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":CONF:VOLT:LATC %d" % int(bool(state)))

        self.GetError()

    def VonLatchReset(self):
        """
        Resets the Von signal
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":CONF:VOLT:LATC:RES")

        self.GetError()

    def setVoff(self, VOffThreshold):
        """
        Set the minimum required Voltage to stop sinking current.

        :param VOffThreshold: float
        :return:
        """
        if VOffThreshold is None:
            return
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        if VOffThreshold <= 0:
            self.interface.vi_write(":CONF:VOFF:STAT 0")
            self.interface.vi_write(":CONF:VOFF:FINALVOLT 0")
        else:
            self.interface.vi_write(":CONF:VOFF:STAT 1")
            self.interface.vi_write(f":CONF:VOFF:FINALVOLT {VOffThreshold:.2f}")

        self.GetError()

    def getMode(self):
        """
        Gets Prog. load mode: CC, CV, LED..

        :rtype: IfxELoadPLModeEnum
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        ret = self.interface.vi_query(":MODE?", rformat="%s")

        self.GetError()

        return self.Enums.enum_from_value(self.Enums.IfxELoadPLModeEnum, ret)

    def setLEDLoad(self, Vo, Io, Rd):
        """
        Sets LED load: Vo & Io define the operation point, Rd defines the dynamic resistance at the operation point

        :type Vo: float
        :type Io: float
        :type Rd: float
        """
        if (Vo > self._V_HMAX) or (Vo < self._V_MIN):
            msg = "Vo settings out of range"
            raise ValueError(msg)
        if (Vo > self._V_LMAX) and (Rd < 10):
            msg = "Set Vo and Rd not possible, out of range"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":CONF:RDSEL DEFAULT")
        self.interface.vi_write(":MODE LEDL")
        self.interface.vi_write(f":LED:Vo {Vo:f}")
        self.interface.vi_write(f":LED:Io {Io:f}")
        self.interface.vi_write(f":LED:Rd:OHM {Rd:f}")

        self.GetError()

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        """
        Sets a LED string load by specifing 1 LED characteristics: Vf, Rd and the number or LEDs: N

        :type Vf: float
        :type Rd: float
        :type N: int
        :param ForceHVRange: Only for 63113
        """
        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":CONF:RDSEL VFRD")
        self.interface.vi_write(":MODE LEDL")
        self.interface.vi_write(f":LED:VFRD:VF {Vf:f}")
        self.interface.vi_write(f":LED:VFRD:RD {Rd:f}")
        self.interface.vi_write(":LED:VFRD:N %d" % N)

        self.GetError()


class Module_63103(ModuleBase):
    """
    Chroma_63103
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 60
        self._I_LMAX = 6
        self._I_MIN = 0
        self._V_HMAX = 80
        self._V_MIN = 0
        self._V_LMAX = 16
        self._R_HMAX = 5000
        self._R_HMIN = 1.25
        self._R_LMAX = 100
        self._R_LMIN = 0.025
        self._P_HMAX = 300
        self._P_LMAX = 30
        self._ISR_HMIN = 0.01
        self._ISR_HMAX = 2.5
        self._ISR_LMAX = 0.25
        self._ISR_LMIN = 0.001

    def setLEDLoad(self, Vo, Io, Rd):
        raise NotImplementedError

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        raise NotImplementedError


class Module_63105(ModuleBase):
    """
    Chroma_63105
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 10
        self._I_LMAX = 1
        self._I_MIN = 0
        self._V_HMAX = 500
        self._V_MIN = 0
        self._V_LMAX = 125
        self._R_HMAX = 200000
        self._R_HMIN = 50
        self._R_LMAX = 5000
        self._R_LMIN = 1.25
        self._P_HMAX = 300
        self._P_LMAX = 30
        self._ISR_LMAX = 0.04
        self._ISR_LMIN = 0.00016
        self._ISR_HMAX = 0.4
        self._ISR_HMIN = 0.0016

    def setLEDLoad(self, Vo, Io, Rd):
        """
        :param Vo: float
        :param Io: float
        :param Rd: float
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        """
        :param Vf: float
        :param Rd: float
        :param N: int
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError


class Module_63106(ModuleBase):
    """
    Chroma_63106
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 120
        self._I_LMAX = 12
        self._I_MIN = 0
        self._V_HMAX = 80
        self._V_MIN = 0
        self._V_LMAX = 16
        self._R_HMAX = 2500
        self._R_HMIN = 0.625
        self._R_LMAX = 50
        self._R_LMIN = 0.0125
        self._P_HMAX = 600
        self._P_LMAX = 60
        self._ISR_LMAX = 0.5
        self._ISR_LMIN = 0.002
        self._ISR_HMAX = 5
        self._ISR_HMIN = 0.02

    def setLEDLoad(self, Vo, Io, Rd):
        """
        :param Vo: float
        :param Io: float
        :param Rd: float
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        """
        :param Vf: float
        :param Rd: float
        :param N: int
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError


class Module_63108(ModuleBase):
    """
    Chroma_63108
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        Constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 20
        self._I_LMAX = 2
        self._I_MIN = 0
        self._V_HMAX = 500
        self._V_MIN = 0
        self._V_LMAX = 125
        self._R_HMAX = 100000
        self._R_HMIN = 25
        self._R_LMAX = 2500
        self._R_LMIN = 0.625
        self._P_HMAX = 600
        self._P_LMAX = 60
        self._ISR_LMAX = 0.08
        self._ISR_LMIN = 0.00032
        self._ISR_HMAX = 0.8
        self._ISR_HMIN = 0.0032

    def setLEDLoad(self, Vo, Io, Rd):
        """
        :param Vo: float
        :param Io: float
        :param Rd: float
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        """
        :param Vf: float
        :param Rd: float
        :param N: int
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError


class Module_63112(ModuleBase):
    """
    Chroma_63112
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        Constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 240
        self._I_LMAX = 24
        self._I_MIN = 0
        self._V_HMAX = 80
        self._V_MIN = 0
        self._V_LMAX = 16
        self._R_HMAX = 1250
        self._R_HMIN = 0.3125
        self._R_LMAX = 25
        self._R_LMIN = 0.00625
        self._P_HMAX = 1200
        self._P_LMAX = 120
        self._ISR_LMAX = 1.0
        self._ISR_LMIN = 0.004
        self._ISR_HMAX = 10.0
        self._ISR_HMIN = 0.04

    def setLEDLoad(self, Vo, Io, Rd):
        """
        :param Vo: float
        :param Io: float
        :param Rd: float
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        """
        :param Vf: float
        :param Rd: float
        :param N: int
        :return:
        """

        # raise IndexError('63103 Prog. load modules does not support LED mode')
        raise NotImplementedError


class Module_63110(ModuleBase):
    """
    Chroma 63110
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 2
        self._I_LMAX = 0.6
        self._I_MIN = 0
        self._V_HMAX = 500
        self._V_MIN = 0
        self._V_LMAX = 100
        self._R_HMAX = 10000
        self._R_HMIN = 10
        self._R_LMAX = 1000
        self._R_LMIN = 3
        self._Rd_LMIN = 1
        self._Rd_HMIN = 10
        self._Rd_LMAX = 1000
        self._Rd_HMAX = 10000
        self._P_HMAX = 100
        self._P_LMAX = 100
        self._ISR_HMAX = 10
        self._ISR_LMAX = 10
        self._ISR_HMIN = 0.32
        self._ISR_LMIN = 0.32

    def setPload(self, Power, ExpMaxCurrent=-1):
        """
        Sets load in Power mode and specifies the Power to be sink.

        :param Power: float
        :param ExpMaxCurrent: float
        :return:
        """
        raise NotImplementedError

    def setDynILoad(self, I1, T1, I2, T2, SlewRateRise=0.2, SlewRateFall=0.2):
        raise NotImplementedError

    def genPRamp(self, Pstar, Pstop, Rtime, Vtrig=2):
        raise NotImplementedError

    def genPStairs(self, Pstar, Pstop, Tstep, Nstep, Vtrig=2):
        raise NotImplementedError


class Module_63113(ModuleBase):
    """
    Chroma 63113
    """

    def __init__(self, interface, channelNumber):
        ModuleBase.__init__(self, interface, channelNumber)
        """
        constants
        """
        self._T_MAX = 30
        self._T_MIN = 0.000025
        self._I_HMAX = 20
        self._I_LMAX = 5
        self._I_MIN = 0
        self._V_HMAX = 300
        self._V_MIN = 0
        self._V_LMAX = 60
        self._P_HMAX = 300
        self._P_LMAX = 300
        self._ISR_HMAX = 0.8
        self._ISR_LMAX = 0.2
        self._ISR_HMIN = 0.0032
        self._ISR_LMIN = 0.0008
        self._R_VLCLMIN = 0.8
        self._R_VLCLMAX = 800
        self._R_VLCHMIN = 0.2
        self._R_VLCHMAX = 200
        self._R_VHCLMIN = 4
        self._R_VHCLMAX = 4000
        self._Rd_VLCLMIN = 0.8
        self._Rd_VLCLMAX = 800
        self._Rd_VLCHMIN = 0.05
        self._Rd_VLCHMAX = 50
        self._Rd_VHCLMIN = 4
        self._Rd_VHCLMAX = 4000

    def setRLoad(self, Ohms, expectedVMax_V=-1, SlewRateRise=-1, SlewRateFall=-1):
        """
        Sets load in resistance mode and specifies the value in ohms.

        :param Ohms: float
        :param expectedVMax_V: float
        :return:
        """
        if not (self._R_VLCHMIN <= Ohms <= self._R_VHCLMAX):
            msg = "Resistance settings out of range."
            raise Exception(msg)

        if expectedVMax_V == -1:
            if Ohms < (
                self._V_LMAX / self._I_LMAX
            ):  # 60/5 = 12 = Ilowrange * Ilowrange * 12 = 300W -> bellow 12Ohms V < 60V, over 12 Ohms I < 5A
                VrangeHigh = False
                IrangeHigh = True
            else:
                IrangeHigh = False
                VrangeHigh = True
        else:
            if Ohms < self._R_VLCLMIN:
                IrangeHigh = True
                VrangeHigh = False
            elif Ohms < (self._V_LMAX / self._I_LMAX):
                VrangeHigh = False
                IrangeHigh = not expectedVMax_V / Ohms < self._I_LMAX
            elif Ohms > self._R_VLCLMAX:
                IrangeHigh = False
                VrangeHigh = True
            else:  # between 12 and 800
                IrangeHigh = False
                VrangeHigh = expectedVMax_V > self._V_LMAX

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        self.interface.vi_write(":OCP OFF;:OPP OFF")
        if IrangeHigh:
            self.interface.vi_write(":CONF:LEDLCRL:RANG HIGH")
        else:
            self.interface.vi_write(":CONF:LEDLCRL:RANG LOW")
        if VrangeHigh:
            self.interface.vi_write(":MODE CRH")
        else:
            self.interface.vi_write(":MODE CRL")

        if SlewRateRise >= 0:
            self.interface.vi_write(f":RES:RISE {SlewRateRise}")
        if SlewRateFall >= 0:
            self.interface.vi_write(f":RES:FALL {SlewRateRise}")

        self.interface.vi_write(f":RES:L1 {Ohms:f}")

        self.GetError()

    def setPload(self, Power, ExpMaxCurrent=-1):
        """
        Sets load in Power mode and specifies the Power to be sink.

        :param Power: float
        :param ExpMaxCurrent: float
        :return:
        """
        raise NotImplementedError

    def genPRamp(self, Pstar, Pstop, Rtime, Vtrig=2):
        raise NotImplementedError

    def genPStairs(self, Pstar, Pstop, Tstep, Nstep, Vtrig=2):
        raise NotImplementedError

    def setLEDLoad(self, Vo, Io, Rd):
        """
        Sets LED load: Vo & Io define the operation point, Rd defines the dynamic resistance at the operation point

        :type Vo: float
        :type Io: float
        :type Rd: float
        """
        if ((Vo + Io * Rd) > self._V_HMAX) or (Vo < self._V_MIN):
            msg = "Vo settings out of range"
            raise ValueError(msg)
        if not (self._Rd_VLCHMIN <= Rd <= self._Rd_VHCLMAX):
            msg = "Rd out of range"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")

        if ((Vo + 2 * Io * Rd) < self._V_LMAX) and (Rd < self._Rd_VLCLMAX):
            self.interface.vi_write(":MODE LEDL")
            if Rd < self._Rd_VLCHMAX:
                self.interface.vi_write(":CONF:LEDLCRL:RANG HIGH")
            else:
                self.interface.vi_write(":CONF:LEDLCRL:RANG LOW")
        elif Rd > self._Rd_VHCLMIN:
            self.interface.vi_write(":CONF:LEDLCRL:RANG LOW")
            self.interface.vi_write(":MODE LEDH")
        else:
            msg = "Settings close to the limit, please either increase Rd or reduce Vf or N"
            raise Exception(msg)

        self.interface.vi_write(":CONF:RDSEL DEFAULT")
        self.interface.vi_write(f":LED:Vo {Vo:f}")
        self.interface.vi_write(f":LED:Io {Io:f}")
        self.interface.vi_write(f":LED:Rd:OHM {Rd:f}")

        self.GetError()

    def setLEDString(self, Vf, Rd, N, ForceHVRange=False):
        """
        Sets a LED string load by specifing 1 LED characteristics: Vf, Rd and the number or LEDs: N

        :type Vf: float
        :type Rd: float
        :type N: int
        """
        IoTimes = 4

        if not (self._V_MIN < Vf < self._V_HMAX):
            msg = "Vf out of range"
            raise ValueError(msg)
        if not (self._Rd_VLCHMIN < N * Rd < self._Rd_VHCLMAX):
            msg = "N * Rd out of range"
            raise ValueError(msg)
        if (((N * Vf + IoTimes * N * Rd) > self._V_LMAX) or ForceHVRange) and ((N * Rd) < self._Rd_VHCLMIN):
            msg = "Settings close to the limit, please either increase Rd or reduce Vf or N or do not force HV"
            raise ValueError(msg)

        self.interface.vi_write(f":CHAN {self.channelNumber}")
        if ((N * Vf + IoTimes * N * Rd) < self._V_LMAX) and ((N * Rd) < self._Rd_VLCLMAX) and not ForceHVRange:
            self.interface.vi_write(":MODE LEDL")
            if (Rd * N) < self._Rd_VLCHMAX:
                self.interface.vi_write(":CONF:LEDLCRL:RANG HIGH")
            else:
                self.interface.vi_write(":CONF:LEDLCRL:RANG LOW")
        elif (N * Rd) > self._Rd_VHCLMIN:
            self.interface.vi_write(":CONF:LEDLCRL:RANG LOW")
            self.interface.vi_write(":MODE LEDH")
        else:
            if ForceHVRange:
                msg = f"If High voltage range is force N*Rd can not be lower than {self._Rd_VHCLMIN:f}"
                raise Exception(msg)
            else:
                msg = (
                    f"N * Vf leads to high voltage range, in such case N*Rd can not be lower than {self._Rd_VHCLMIN:f}"
                )
                raise Exception(msg)

        self.interface.vi_write(":CONF:RDSEL VFRD")
        self.interface.vi_write(f":LED:VFRD:VF {Vf:f}")
        self.interface.vi_write(f":LED:VFRD:RD {Rd:f}")
        self.interface.vi_write(":LED:VFRD:N %d" % N)

        self.GetError()
