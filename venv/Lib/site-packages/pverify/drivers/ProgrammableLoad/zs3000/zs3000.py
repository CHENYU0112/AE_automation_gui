from __future__ import annotations

import contextlib

from pverify.core.lab.driver_identity import *
from pverify.drivers.BaseInstrument import BaseVisaInstrument, InstrumentError

CONDITIONBITS = {
    1: "VOLT",  # Over-voltage error. LED OVP at front panel lights up.
    2: "CURR",  # Over-current error. LED OCP at front panel lights up.
    8: "POW",  # Over-power error. LED OPP at front panel lights up.
    16: "TEMP",  # Over-temperature error. LED OTP at front panel lights up.
    512: "WD",  # Watchdog. Is set when the software watchdog shuts off the load input.
    1024: "UV",  # Under voltage. Is set when the input voltage is not high enough to maintain the desired load setting.
    # 2048: "TV",    # Trigger voltage. Is set when the input voltage is below the programmed trigger voltage (VOLTage:PROTection)
    4096: "DATA",  # Data memory. Is set when the maximum number of data records is stored in the internal measurement memory.
}


class ZS3000:
    def __init__(self):
        self.interface = BaseVisaInstrument()
        self.__Initialized = False
        self.__Identity = Identity_SCPI(parent=self, rsrc_attr_name="interface")

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Initialized(self):
        """
        Initialized is True between a successful call to the Initialize method
        and a successful call to the Close method, and False at all other
        times.
        """
        return self.__Initialized

    def Initialize(self, ResourceName, IdQuery=1, Reset=1, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties
        that access the instrument are only accessible after Initialize is
        called. Initialize optionally performs a Reset and queries the
        instrument to validate the instrument model.

        :param ResourceName:
            An IVI logical name or an instrument specific string that identifies
            the address of the instrument, such as a VISA resource descriptor
            string.
        :type ResourceName: str

        :param IdQuery:
            Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int

        :param Reset:
            Specifies whether to reset the instrument.
        :type Reset: bool|int

        :param OptionString:
            Provides additional functionality for the initialization process.

        :type OptionString: str
        """
        self.interface.ResourceName = ResourceName
        self.interface.vi_open()
        self.__Initialized = True

        self.SetRemoteMode()
        self.interface.vi_write("STAT:QUES:ENAB %d" % sum(CONDITIONBITS.keys()))

        if IdQuery:
            ret = self.interface.vi_query("*IDN?")
            ret = ret.strip()
            self.IDN = ret
            if ret.find("HOECHERL&HACKL") == -1:
                self.__Initialized = False
                self.interface.vi_close()
                msg = "Identification Error: Can't find '{}' in the returned IDN string '{}'".format(
                    ret, "HOECHERL&HACKL"
                )
                raise ValueError(msg)

        if Reset:
            self.Reset()

        with contextlib.suppress(Exception):
            self.GetError()

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and
        properties that access the instrument are not accessible after Close
        is called.
        """
        if self.__Initialized:
            self.__Initialized = False
            try:
                self.SetLocalMode()
            finally:
                self.interface.vi_close()

    def SetLocalMode(self):
        """
        Sets the instrument in LOCAL mode
        """
        self.interface.vi_write("GTL")
        self.GetError()

    def SetRemoteMode(self):
        """
        Sets the instrument in REMOTE mode
        """
        self.interface.vi_query("*IDN?")

    def ConfigureMode(self, mode, range=None, speed=None):
        """
        Configures the output mode

        :param mode: The output mode. Choice(current,resistance,power,voltage)
        :type mode: The output mode. Choice(current,resistance,power,voltage)
        :param range: The output range Choice(auto,max,min) or a float value
        :type range: float|int|str
        :param speed: Control time constant of the device. Choice(medium,slow,fast)
        :type speed: str
        """
        mode = str(mode).lower()
        if "curr" in mode:
            mode = "CURR"
        elif "volt" in mode:
            mode = "VOLT"
        elif "res" in mode:
            mode = "RES"
        elif "pow" in mode:
            mode = "POW"
        else:
            msg = f"Unknown mode: {mode}"
            raise ValueError(msg)
        self.interface.vi_write("MODE:" + mode.upper())
        self.GetError()

        if range is not None:
            if "auto" in str(range).lower():
                if mode != "POW":
                    self.interface.vi_write(mode.upper() + ":RANG:AUTO ON")
            else:
                if mode != "POW":
                    self.interface.vi_write(mode.upper() + ":RANG:AUTO OFF")

                if "max" in str(range).lower():
                    self.interface.vi_write(mode.upper() + ":RANG MAX")
                elif "min" in str(range).lower():
                    self.interface.vi_write(mode.upper() + ":RANG MIN")
                else:
                    self.interface.vi_write(mode.upper() + ":RANG %d" % int(range))

        self.GetError()

        if speed is not None:
            speed = str(speed).lower()
            if "slow" in speed:
                speed = "SLOW"
            elif "fast" in speed:
                speed = "FAST"
            elif "med" in speed or speed is None:
                speed = "MED"
            else:
                msg = f"Unknown speed: {speed}"
                raise ValueError(msg)

            self.interface.vi_write(f"SYST:SPE {speed}")

        self.GetError()

    def SetLoadLevel(self, level=None):
        """
        Sets the nominal load level
        """
        mode = self.interface.vi_query("MODE?")
        self.interface.vi_write(f"{mode.upper()}:LEV {level:f}")
        self.GetError()

    def __check_mode(self, mode):
        _mode = self.interface.vi_query("MODE?")
        return str(mode).lower() in str(_mode).lower()

    def GetVoltage(self):
        """
        Measures the current voltage.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:VOLT?", rformat="%f")
        self.GetError()
        return val

    def GetCurrent(self):
        """
        Measures the current.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:CURR?", rformat="%f")
        self.GetError()
        return val

    def GetPower(self):
        """
        Measures the current power.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:POW?", rformat="%f")
        self.GetError()
        return val

    def GetResitance(self):
        """
        Measures the current resistance.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:RES?", rformat="%f")
        self.GetError()
        return val

    @property
    def OutputEnabled(self):
        enabled = "on" in self.interface.vi_query("OUTP?").lower()
        self.GetError()
        return enabled

    @OutputEnabled.setter
    def OutputEnabled(self, value):
        """
        Enables/Disabled the output
        """
        self.interface.vi_write("OUTP %d" % bool(value))
        self.GetError()

    def Reset(self):
        """
        Resets the instrument
        """
        self.interface.vi_write("*RST")
        self.interface.vi_write("STAT:QUES:ENAB %d" % sum(CONDITIONBITS.keys()))

        self.GetError()

    def GetError(self):
        """
        Queries the instrument for alarms and setup/programming errors and raises an Exception in this case
        """
        self.GetAlarm()

        ret = self.interface.vi_query("SYST:ERR?")
        if "no error" in ret.lower():
            return
        else:
            raise InstrumentError("An Instrument Error occurred: " + ret)

    def GetAlarm(self):
        """
        Queries the instrument for alarms and raises an Exception if an alarm occurred
        """
        event = int(self.interface.vi_query("STAT:QUES:EVEN?", rformat="%d"))
        errors = []
        errormsg = "One or multiple alarms occurred: "
        if event > 0 and event in CONDITIONBITS:
            self.interface.vi_query("SYST:ERR?")
            for bitvalue, name in CONDITIONBITS.items():
                if event & bitvalue > 0:
                    errors.append(name)
            if len(errors):
                raise InstrumentError(errormsg + ", ".join(errors))
