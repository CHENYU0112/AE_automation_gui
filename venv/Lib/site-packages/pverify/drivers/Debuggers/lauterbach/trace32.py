"""
Some links:
    http://www2.lauterbach.com/pdf/api_remote.pdf
    https://www2.lauterbach.com/pdf/app_t32start.pdf

    https://confluencewikiprod.intra.infineon.com/display/DP3MOD/Lauterbach+and+DAS+Installation

Prerequisites:
 -  DAS installation (32-bit, even on 64-bit windows)
 -  The VP (as executable or build from source code)
 -  Lauterbach (portable installation is enougth)
"""

from __future__ import annotations

import os
import subprocess as sp
import time
from struct import calcsize
from typing import *

from pverify.drivers.Debuggers.pygd.lauterbach.api.t32api_cffi import ffi

from .api.errors import check_error

PY_BITS = calcsize("P") * 8


class Trace32:
    VERSION = 1.0
    T32_OK = 0
    EXIT_SUCCESS = 0
    EXIT_FAILURE = 1

    def __init__(self, **kwargs):
        super().__init__()
        if PY_BITS == 64:
            t32api_dll = os.path.join(os.path.dirname(__file__), "t32api64.dll")
        else:
            t32api_dll = os.path.join(os.path.dirname(__file__), "t32api.dll")
        self.dll = ffi.dlopen(t32api_dll)
        """:type : T32API_STUBS"""
        self.ffi = ffi

    def initialize(self, **kwargs):
        """
        Initializes the Lauterbach T32 PowerView debugger

        :keyword t32_starter: An executable file used to start the debugger. This file usually modifies the T32 config and startup file and starts
                              an appropriate target debugger like "t32marm.exe"
        :keyword t32_node: The node. Default: "localhost"
        :keyword t32_port: The port. Default: 20000
        :keyword t32_packlen: The package length. Default: 1024
        """
        self._node = kwargs.get("t32_node", "localhost")
        self._port = str(kwargs.get("t32_port", 20000))
        self._packlen = str(kwargs.get("t32_packlen", 1024))
        self._starter = kwargs.get("t32_starter", None)

        # Initialize communication from DLL to T32PowerView
        self.dll.T32_Config(b"NODE=", encode(self._node))
        if self.dll.T32_Config(b"PORT=", encode(self._port)) != self.T32_OK:
            msg = f"Invalid port number '{self._port}' specified."
            raise ValueError(msg)
        self.dll.T32_Config(b"PACKLEN=", encode(self._packlen))

        # try to start communication
        if self.__comm_start(max_tries=1) != self.EXIT_SUCCESS:
            if isinstance(self._starter, str):
                if not os.path.exists(self._starter):
                    msg = "If given, the keyword argument 't32_starter' has to be an existing file path!"
                    raise ValueError(msg)
                else:
                    sp.call([self._starter])
                    if self.__comm_start() != self.EXIT_SUCCESS:
                        msg = "Failed to establish a connection to Trace32 PowerView!"
                        raise Exception(msg)
            else:
                msg = "Failed to establish a connection to Trace32 PowerView!"
                raise Exception(msg)

    def close(self, **kwargs):
        self.dll.T32_ReleaseAllObjects()
        self.dll.T32_Terminate(0)
        self.dll.T32_Exit()

    def __comm_start(self, max_tries=5):
        assert max_tries > 0
        print("Host: trying to establish connection to T32...")

        for i in range(max_tries):
            time.sleep(1.0)
            if self.dll.T32_Init() == self.T32_OK:
                print(" Successfully initialized a remote connection with TRACE32 PowerView.")

                if self.dll.T32_Attach(self.dll.T32_DEV_ICD) == self.T32_OK:
                    # need some more time until we can actually send commands
                    time.sleep(3)
                    self.dll.T32_Printf(b"\n")
                    print(" Successfully established a remote connection with TRACE32 PowerView.")
                    break
                print(" Failed to establish a remote connection with TRACE32 PowerView.")
                if i < max_tries - 1:
                    self.dll.T32_Terminate(0)
                    self.dll.T32_Exit()
                elif i == max_tries - 1:
                    return self.EXIT_FAILURE
            else:
                print(" Failed to initialize a remote connection with TRACE32 PowerView.")
                if i < max_tries - 1:
                    self.dll.T32_Terminate(0)
                    self.dll.T32_Exit()
                elif i == max_tries - 1:
                    return self.EXIT_FAILURE

        return self.EXIT_SUCCESS

    def load_executable(self, file: str):
        self.send_cmd(f"Data.LOAD {file}")

    def run(self):
        self.dll.T32_Go()

    def halt(self):
        self.dll.T32_Break()

    def step_over(self):
        self.dll.T32_StepMode(0x81)
        self.dll.T32_Step()

    def step_into(self):
        self.dll.T32_StepMode(0x01)
        self.dll.T32_Step()

    def is_halted(self) -> bool:
        """
        0 Debug system is down
        1 This value is returned in two situations:
            1. (ICE only) Debug system is halted, CPU makes no cycles (no access)
            2. (Intel x86/x64 debugger only) Target is in bootstall
        2 Target execution is stopped (Break)
        3 Target execution is running (Go)
        """
        systemstate = self.ffi.new("int *")
        check_error(self.dll.T32_GetState(systemstate))
        return systemstate[0] == 2

    def set_breakpoint(self, location, type=None, impl=None):
        adr_handle = self.ffi.new("T32_AddressHandle *")
        bp_handle = self.ffi.new("T32_BreakpointHandle *")

        if isinstance(location, int):
            pass
        elif isinstance(location, str):
            location, _ = self.get_symbol_info(location)
        else:
            raise TypeError

        self.dll.T32_RequestAddressObjA32(adr_handle, location)
        self.dll.T32_RequestBreakpointObjAddr(bp_handle, adr_handle[0])

        if type is not None:
            type = str(type).lower()
            if type == "program":
                self.dll.T32_SetBreakpointObjType(bp_handle[0], self.dll.T32_BP_TYPE_PROGRAM)
            elif type == "read":
                self.dll.T32_SetBreakpointObjType(bp_handle[0], self.dll.T32_BP_TYPE_READ)
            elif type == "write":
                self.dll.T32_SetBreakpointObjType(bp_handle[0], self.dll.T32_BP_TYPE_WRITE)
            elif type == "readwrite":
                self.dll.T32_SetBreakpointObjType(bp_handle[0], self.dll.T32_BP_TYPE_RW)

        if impl is not None:
            impl = str(impl).lower()
            if impl == "soft":
                self.dll.T32_SetBreakpointObjImpl(bp_handle[0], self.dll.T32_BP_IMPL_SOFT)
            elif impl == "onchip":
                self.dll.T32_SetBreakpointObjImpl(bp_handle[0], self.dll.T32_BP_IMPL_ONCHIP)

        self.dll.T32_WriteBreakpointObj(bp_handle[0], 1)
        self.dll.T32_ReleaseAllObjects()

    def remove_breakpoint(self, location):
        adr_handle = self.ffi.new("T32_AddressHandle *")
        bp_handle = self.ffi.new("T32_BreakpointHandle *")

        if isinstance(location, int):
            pass
        elif isinstance(location, str):
            location, _ = self.get_symbol_info(location)
        else:
            raise TypeError

        self.dll.T32_RequestAddressObjA32(adr_handle, location)
        self.dll.T32_RequestBreakpointObjAddr(bp_handle, adr_handle[0])

        self.dll.T32_WriteBreakpointObj(bp_handle[0], 0)
        self.dll.T32_ReleaseAllObjects()

    def remove_all_breakpoints(self):
        self.send_cmd("Break.Delete")

    def get_symbol_info(self, symbolname) -> Tuple[int, int]:
        address = self.ffi.new("uint32_t *")
        size = self.ffi.new("uint32_t *")
        reserved = self.ffi.new("uint32_t *")
        check_error(self.dll.T32_GetSymbol(encode(str(symbolname)), address, size, reserved))
        return address[0], size[0]

    def read_var_symbol(self, symbol):
        lower32 = self.ffi.new("uint32_t *", 0)
        upper32 = self.ffi.new("uint32_t *", 0)
        check_error(self.dll.T32_ReadVariableValue(encode(symbol), lower32, upper32))
        return lower32[0] + (upper32[0] << 32)

    def write_var_symbol(self, symbol, value):
        lower32 = self.ffi.new("uint32_t *", (value >> 0) & 0xFFFFFFFF)
        upper32 = self.ffi.new("uint32_t *", (value >> 32) & 0xFFFFFFFF)
        check_error(self.dll.T32_WriteVariableValue(encode(symbol), lower32, upper32))

    def send_cmd(self, cmd):
        check_error(self.dll.T32_Cmd(encode(cmd)))

    def T32_GetMessage(self):
        """
        Returns the latest message from the AREA window of T32 PowerView
        """
        typeMap = {
            1: "General Information",
            2: "Error",
            8: "Status Information",
            16: "Error Information",
            32: "Temporary Display",
            64: "Temporary Information",
        }

        AreaMessage = self.ffi.new("char[256]", b"")
        pMessageType = self.ffi.new("uint16_t *")
        check_error(self.dll.T32_GetMessage(AreaMessage, pMessageType))
        pMessageType = pMessageType[0]
        AreaMessage = decode(self.ffi.string(AreaMessage))
        if pMessageType in typeMap:
            return f"{typeMap[pMessageType]} ({pMessageType}): {AreaMessage}"
        else:
            return ""

    def T32_ReadPP(self) -> int:
        pp = self.ffi.new("uint32_t *")
        check_error(self.dll.T32_ReadPP(pp))
        return pp[0]

    def write_mem(self, address: int, buffer: bytes):
        """
        Write a byte-buffer to an address

        :param address: The address to write to
        :param buffer: The buffer to write
        """
        myBufferHandle = self.ffi.new("T32_BufferHandle *")
        myAddressHandle = self.ffi.new("T32_AddressHandle *")

        check_error(self.dll.T32_RequestBufferObj(myBufferHandle, 0))
        check_error(self.dll.T32_RequestAddressObjA32(myAddressHandle, address))
        check_error(self.dll.T32_CopyDataToBufferObj(myBufferHandle[0], len(buffer), buffer))
        check_error(self.dll.T32_WriteMemoryObj(myBufferHandle[0], myAddressHandle[0], len(buffer)))
        check_error(self.dll.T32_ReleaseAllObjects())


def encode(text: str, encoding="latin-1"):
    return str(text).encode(encoding)


def decode(bytestring: bytes, encoding="latin-1"):
    return bytestring.decode(encoding)
