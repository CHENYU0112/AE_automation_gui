from __future__ import annotations

__package__ = "pverify.drivers.Debuggers.jlink"

import logging
import os
import sys
from pathlib import Path
from time import sleep

import numpy as np
import pylink

from .elf2hex import elf2hex
from .symbol_parser import SymbolParser

DEBUG = False
logger = logging.getLogger(__name__)


class JLink(pylink.JLink):
    def __init__(self, elf_file: Path, **kwargs):
        self._elf_file = Path(elf_file)
        if self._elf_file.suffix.lower() not in [".axf", ".elf"]:
            msg = "The JLink class only supports working with ELF/AFX files.For usage with HEX files please use the base class 'pylink.JLink' directly."
            raise Exception(msg)

        self._log = logger
        kwargs.update(
            {
                "log": self._log.info,
                "error": self._log.error,
                "warn": self._log.warning,
                "detailed_log": self._log.debug,
            }
        )
        super().__init__(**kwargs)

        self._symbolparser = SymbolParser(self._elf_file)

    def configure_default_stream_logger(self):
        """
        Adds a default logger configuration to log to stdout
        """
        self._log.setLevel(logging.DEBUG if DEBUG else logging.INFO)
        sh = logging.StreamHandler(sys.stdout)
        sh.setFormatter(logging.Formatter("%(levelname)-7s|%(asctime)s.%(msecs)03d|  %(message)s"))
        self._log.addHandler(sh)

    def jlink_connect_swd(self, serial: int, chip_name: str, speed: str | int = "auto", verbose=False):
        """
        Connects to a chip via SWD interface.

        :param serial: The emulator serial number
        :param chip_name: The chip name
        :param speed: connection speed, one of ``{5-12000, 'auto', 'adaptive'}``
        """
        if not self.opened():
            self.open(serial_no=serial)
            if not self.opened():
                msg = "JLink is not opened!"
                raise ConnectionError(msg)
            self._log.info("Opened JLink connection")
        self._log.info(f"Product name: {self.product_name}")

        self.set_tif(pylink.enums.JLinkInterfaces.SWD)
        self.connect(chip_name, speed=speed, verbose=verbose)
        sleep(0.2)
        self.set_reset_strategy(pylink.enums.JLinkResetStrategyCortexM3.RESETPIN)

        # Check if connected to JLink and Core
        if not self.connected():
            msg = "JLink is not connected!"
            raise ConnectionError(msg)
        elif not self.target_connected():
            msg = "JLink is not connected to target!"
            raise ConnectionError(msg)
        else:
            self._log.info("Connected!")

        self._log.info("Core ID: " + hex(self.core_id()))
        self._log.info("Core Name: " + self.core_name())

    def jlink_download_app(
        self,
        erase: bool = True,
        flash_addr: int = 0,
        flash_power_on: bool = False,
        reset_ms: int = 10,
        reset_halt: bool = False,
    ):
        """
        Flashes an application to a device via JLink.

        If the included sequence is not what you need, take this function as a reference implementation.
        """
        app = Path(self._elf_file)
        str(app).rsplit(".", 1)[-1].lower()
        fw_hex_file = str(elf2hex(app, app.stem + "_autogen.hex"))
        if not os.path.exists(fw_hex_file):
            msg = f"Cannot find HEX file {fw_hex_file!r} to download!"
            raise FileNotFoundError(msg)
        self._log.info(f"Downloading FW {fw_hex_file!r}")
        self.halt()
        assert self.halted()
        self._log.info("Halting Done")
        if erase:
            self.erase()
            self._log.info("Erase Done")

        self._log.info("Flashing target")
        self.flash_file(fw_hex_file, flash_addr, power_on=flash_power_on)
        self._log.info("Reset and run target")
        self.reset(ms=reset_ms, halt=reset_halt)

    def jlink_write_symbol(self, symbol: str, value: int):
        """
        Write a DUT symbol value via the debugger. The symbol can be anything that a GDB instance would understand,
        also access of variables inside structures is possible here.

        :param symbol: The name of the symbol
        :param value: The value to write (1,2 or 4 bytes)
        """
        symbolinfo = self._symbolparser.get_symbol_adr(str(symbol))

        value = {1: np.uint8, 2: np.uint16, 4: np.uint32}[symbolinfo.size](value)
        self._log.info(f"Writing 0x{value:x} ({value}) to symbol {str(symbol)!r} (adr: 0x{symbolinfo.address:x})")
        self.memory_write(addr=symbolinfo.address, data=[value], nbits=int(symbolinfo.size * 8))
        self._log.debug("Writing done")

    def jlink_read_symbol(self, symbol: str) -> int | list[int]:
        """
        Read a DUT symbol via the debugger. The symbol can be anything that a GDB instance would understand,
        also access of variables inside structures is possible here.

        :param symbol: The name of the symbol
        """
        symbolinfo = self._symbolparser.get_symbol_adr(str(symbol))

        data = self.memory_read(addr=symbolinfo.address, num_units=1, nbits=int(symbolinfo.size * 8))[0]

        self._log.info(f"Read 0x{data:x} ({data}) from symbol {str(symbol)!r} (adr: 0x{symbolinfo.address:x})")
        return data

    def jlink_disconnect(self):
        self._symbolparser.exit()

        jlink_dll_error = self.error
        if jlink_dll_error:
            self._log.error(f"DLL error {jlink_dll_error}")
            self.clear_error()
        if self.opened():
            self._log.info("Closing debugger connection...")
            self.close()


if __name__ == "__main__":
    # Example
    ELF = r"E:\samba_mtb_test_results\debug\2021_07_05\SpeedControlTest_20210705_153523\run0000\app\FOC.elf"
    j = JLink(ELF)
    j.jlink_connect_swd(599007338, "TLE9879", 500, True)
    j.jlink_download_app(erase=False)
    j.jlink_write_symbol("controlMode", 1)
    print(j.jlink_read_symbol("controlMode"))
    j.jlink_disconnect()
