from __future__ import annotations

import re
from collections import namedtuple
from collections.abc import Hashable
from functools import partial

from pverify.drivers.Debuggers.gdbmi.gdbmi import GdbCtrl


class memoize:
    """Decorator. Caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned
    (not reevaluated).
    """

    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __call__(self, *args):
        if not isinstance(args, Hashable):
            # uncacheable. a list, for instance.
            # better to not cache than blow up.
            return self.func(*args)
        if args in self.cache:
            return self.cache[args]
        value = self.func(*args)
        self.cache[args] = value
        return value

    def __repr__(self):
        """Return the function's docstring."""
        return self.func.__doc__

    def __get__(self, obj, objtype):
        """Support instance methods."""
        return partial(self.__call__, obj)


SymbolInfo = namedtuple("SymbolInfo", ("size", "address"))


class SymbolParser(GdbCtrl):
    SymbolInfo = SymbolInfo

    @memoize
    def get_symbol_adr(self, symbol: str) -> SymbolInfo:
        symbol = str(symbol).strip()
        resp_sizeof = self.merge_console_msg(self.check_result(self.write(f"print sizeof({symbol})", timeout_sec=1)))
        resp_address = self.merge_console_msg(self.check_result(self.write(f"print &{symbol}", timeout_sec=1)))

        size_match = re.findall(r"^\$\d+ = (\d+).*", resp_sizeof)
        adr_match = re.findall(r"^\$\d+ = .*(0x[0-9a-f]{2,8}).*", resp_address)
        if len(size_match) == 1 and len(adr_match) == 1:
            return SymbolInfo(int(size_match[0]), int(adr_match[0], 16))
        else:
            msg = f"Cannot find either size or address in response string: {resp_sizeof};{resp_address}"
            raise LookupError(msg)

    def exit(self):
        """Terminate gdb process"""
        if self.gdb_process:
            self.gdb_process.terminate()
            # loibljoh: Comment this line, otherwise there's an Exception
            # self.gdb_process.communicate()
        self.gdb_process = None
        return
