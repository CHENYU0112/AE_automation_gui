# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
"""
Module docstring
"""

from __future__ import annotations

from os.path import *
from time import sleep

try:
    import dotnet

    dotnet.add_assemblies(dirname(__file__))
    dotnet.load_assembly("TwinCAT_DllWrapper")
except ImportError:
    import clr

    clr.AddReference("pverify/drivers/TwinCAT_ADS/TwinCAT_DllWrapper")
from TwinCAT_DllWrapper import TWINC_ADS as twc_ads
from TwinCAT_DllWrapper import TWINC_Inputs as twc_inputs
from TwinCAT_DllWrapper import TWINC_Outputs as twc_outputs


class RackSafetySystem:
    def __init__(self):
        self.connected = False
        self.errmsg = ""
        try:
            self.ads = twc_ads()
        except Exception:
            self.ads = None

    def Connect(self):
        if self.ads is not None:
            try:
                self.ads.TWINC_Connect(301)
                sleep(0.5)
                self.ads.TWINC_ReadVariable(twc_inputs.TempCabinet)
                self.connected = True
                return True
            except BaseException as e:
                self.ads = None
                self.connected = False
                self.errmsg = str(e)
                return False
        else:
            self.connected = False
            return False

    def Disconnect(self):
        if self.connected and self.ads is not None:
            self.ads.TWINC_Disconnect()
            self.connected = False

    def get_Start(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.Start))
        return None

    def get_Terminate(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.Terminate))
        return None

    def get_Reset(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.Reset))
        return None

    def get_EmergencyStopPressed(self):
        if self.connected and self.ads is not None:
            ret = self.ads.TWINC_ReadVariable(twc_inputs.EmergencyStopNotPressed)
            return ret != 1
        else:
            return False

    def get_DoorDrawerClosed(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.DoorDrawerClosed))
        else:
            return True

    def get_DoorBackClosed(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.DoorBackClosed))
        else:
            return True

    def get_DoorBottomClosed(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.DoorBottomClosed))
        else:
            return True

    def get_DoorUpClosed(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.DoorUpClosed))
        else:
            return True

    def get_DoorsClosed(self):
        if self.connected and self.ads is not None:
            return (
                self.get_DoorDrawerClosed(),
                self.get_DoorUpClosed(),
                self.get_DoorBottomClosed(),
                self.get_DoorBackClosed(),
            )
        else:
            return [True] * 4

    def get_AllRequiredDoorsClosed(self):
        if self.connected and self.ads is not None:
            keyswitch = self.get_KeySensorStatus()
            if keyswitch == self.Enums.SENSORS_ALL_ACTIVE:
                return all(
                    [
                        self.get_DoorDrawerClosed(),
                        self.get_DoorUpClosed(),
                        self.get_DoorBottomClosed(),
                        self.get_DoorBackClosed(),
                    ]
                )
            elif keyswitch == self.Enums.SENSORS_BACK_DRAWER_ACTIVE:
                return all([self.get_DoorDrawerClosed(), self.get_DoorBackClosed()])
            elif keyswitch == self.Enums.SENSORS_ONLY_BACK_ACTIVE:
                return self.get_DoorBackClosed()
            return None
        else:
            return True

    def get_SmokeDetectorAlarmed(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_inputs.SmokeDetector))
        else:
            return False

    def get_KeySensorStatus(self):
        if self.connected and self.ads is not None:
            var1 = self.ads.TWINC_ReadVariable(twc_inputs.KeySwitchBackAndFlap)
            var2 = self.ads.TWINC_ReadVariable(twc_inputs.KeySwitchBack)
            if var1 == 0 and var2 == 0:
                return self.Enums.SENSORS_ALL_ACTIVE
            elif var1 == 1:
                return self.Enums.SENSORS_BACK_DRAWER_ACTIVE
            elif var2 == 1:
                return self.Enums.SENSORS_ONLY_BACK_ACTIVE
            return None
        return None

    def get_TempCabinet(self):
        if self.connected and self.ads is not None:
            return self.ads.TWINC_ReadVariable(twc_inputs.TempCabinet)
        else:
            return 0

    def get_TempDUT(self):
        if self.connected and self.ads is not None:
            return self.ads.TWINC_ReadVariable(twc_inputs.TempDUT)
        else:
            return 0

    def get_LampGood(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.LampGood))
        return None

    def set_LampGood(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.LampGood, int(value))

    def get_LampBad(self):
        return bool(self.ads.TWINC_ReadVariable(twc_outputs.LampBad))

    def set_LampBad(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.LampBad, int(value))

    def get_LedStart(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.LedStart))
        return None

    def set_LedStart(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.LedStart, int(value))

    def get_LedStop(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.LedStop))
        return None

    def set_LedStop(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.LedStop, int(value))

    def get_SignalLightGreen(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.SignalLightGreen))
        return None

    def set_SignalLightGreen(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.SignalLightGreen, int(value))

    def get_SignalLightOrange(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.SignalLightOrange))
        return None

    def set_SignalLightOrange(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.SignalLightOrange, int(value))

    def get_SignalLightRed(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.SignalLightRed))
        return None

    def set_SignalLightRed(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.SignalLightRed, int(value))

    def get_RackPowerOn(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.PowerOn))
        return None

    def set_RackPowerOn(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.PowerOn, int(value))

    def get_ACSourceOn(self):
        if self.connected and self.ads is not None:
            return bool(self.ads.TWINC_ReadVariable(twc_outputs.ACSourceOn))
        return None

    def set_ACSourceOn(self, value):
        if self.connected and self.ads is not None:
            self.ads.TWINC_SetVariable(twc_outputs.ACSourceOn, int(value))

    class Enums:
        SENSORS_ALL_ACTIVE = 0
        SENSORS_ONLY_BACK_ACTIVE = 1
        SENSORS_BACK_DRAWER_ACTIVE = 2

    class TwinCATError(Exception):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)


if __name__ == "__main__":
    ads = RackSafetySystem()
    ads.Connect()
    ads.Disconnect()
