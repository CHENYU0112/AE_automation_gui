from __future__ import annotations

import contextlib

import numpy as np

from pverify.drivers.SimplifiedLabInstruments._simple_instr.simple_instrument import SimpleInstrument

from .IIviACPwr import IIviACPwr


class chr615xxSimple(SimpleInstrument):
    def __init__(self, driver=None):
        super().__init__(IIviACPwr() if driver is None else driver, "Simple Chroma 615xx AcPwr")

    @property
    def Initialized(self):
        return self.lld.Initialized

    @property
    def lld(self) -> IIviACPwr:
        return self._lld

    @property
    def drivername(self) -> str:
        return self.__class__.__name__

    def GetChannel(self, Index):
        msg = "This is a 1-ch instrument!"
        raise NotImplementedError(msg)

    def Initialize(self, ResourceName, IdQuery, Reset, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies the address
            of the instrument, such as a VISA resource descriptor string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString: The user can use the OptionsString parameter to specify the initial values of
            certain IVI inherent attributes for the session. The format of an assignment in
            the OptionsString parameter is "Name=Value", where Name is one of: RangeCheck,
            QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck, or
            DriverSetup. Value is either true or false except for DriverSetup. If the
            Options String parameter contains an assignment for the Driver Setup attribute,
            the Initialize function assumes that everything following "DriverSetup=" is part
            of the assignment.
        :type OptionString: str
        """
        self.lld.Initialize(ResourceName, IdQuery, Reset, OptionString)
        self._cname = self.lld.OutputPhases.Name(1)

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        self.lld.Close()

    def Enable(self):
        """
        Enables the output
        """
        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            with contextlib.suppress(Exception):
                self.lld.ArbWaveform.AbortArbitraryWaveform()
            ac.Enabled = True
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Disable(self):
        """
        Disables the output
        """
        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            with contextlib.suppress(Exception):
                self.lld.ArbWaveform.AbortArbitraryWaveform()
            ac.Enabled = False
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Sine(self, AmplitudeRMS, Frequency, Phase=0, Offset=0, CurrentLimit=None, **kwargs):
        """
        Applies a normal sine.

        :param AmplitudeRMS: The rms value of the sine.
        :type AmplitudeRMS: float
        :param Frequency: The frequency of the sine.
        :type Frequency: float
        :param Phase: The phase angle the ac starts with when it is enabled.
        :type Phase: float
        :param Offset: The DC offset of the sine.
        :type Offset: float
        :param CurrentLimit: The current for which the ac source throws an error.
        :type CurrentLimit: float
        :keyword skip_autorange: If True, no autorange will be performed by this function. Use ConfigureVoltageRange manually!
        """

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)

            if AmplitudeRMS > 0 or Offset > 0:
                if not kwargs.get("skip_autorange", False):
                    self.ConfigureVoltageRange(AmplitudeRMS, Offset)
                self.ConfigureOutputMode(AmplitudeRMS, Offset)

                if CurrentLimit and ac.CurrentLimit != CurrentLimit:
                    ac.CurrentLimit = CurrentLimit

                if AmplitudeRMS > 0:
                    if ac.PhaseAngle != Phase:
                        ac.PhaseAngle = Phase
                    if self.lld.OutputPhases.Frequency != Frequency:
                        self.lld.OutputPhases.Frequency = Frequency
                    ac.VoltageLevel = AmplitudeRMS

                if Offset > 0 and ac.DCGeneration.DCVoltageLevel != Offset:
                    ac.DCGeneration.DCVoltageLevel = Offset

                with contextlib.suppress(Exception):
                    self.lld.ArbWaveform.AbortArbitraryWaveform()
                ac.Enabled = True
            else:
                with contextlib.suppress(Exception):
                    self.lld.ArbWaveform.AbortArbitraryWaveform()
                ac.Enabled = False
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Amplitude_Stair(
        self,
        StartAmplitudeRMS,
        StepSize,
        StepCount,
        StepDuration,
        Frequency,
        DwellTimeStart=0,
        DwellTimeEnd=0,
        Phase=0,
        Offset=0,
        Count=1,
        CurrentLimit=None,
        **kwargs,
    ):
        """
        Applies a sine which amplitude increases/decreases gradually.

        Lab: Returns to the static SINE voltage level that has been applied before this stimulus
        Do not apply another stimulus after this one because it would interrupt the current stimulus if it is not
        yet finished.

        :param StartAmplitudeRMS: The start amplitude (RMS) in volts.
        :type StartAmplitudeRMS: float
        :param StepSize: The amplitude delta (RMS) in volts for each step.
        :type StepSize: float
        :param StepCount: The number of steps.
        :type StepCount: int
        :param StepDuration: The duration of a step in seconds.
        :type StepDuration: float
        :param Frequency: The sine's frequency in hertz.
        :type Frequency: float
        :param DwellTimeStart: The time in seconds the voltage level is held at the start amplitude before the stair starts
        :type DwellTimeStart: float
        :param DwellTimeEnd: The time in seconds the voltage level is held at the stop amplitude after the ramp ends
        :type DwellTimeEnd: float
        :param Phase: The sine's phase in degree.
        :type Phase: float
        :param Offset: The sine's dc offset in volts
        :type Offset: float
        :param Count: The number of repetitions of the stair
        :type Count: float
        :param CurrentLimit: The current for which the ac source throws an error.
        :type CurrentLimit: float
        :keyword skip_autorange: If True, no autorange will be performed by this function. Use ConfigureVoltageRange manually!
        """

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            if not kwargs.get("skip_autorange", False):
                self.ConfigureVoltageRange(StartAmplitudeRMS + StepCount * StepSize, Offset)
            self.ConfigureOutputMode(StartAmplitudeRMS + StepCount * StepSize, Offset)

            if CurrentLimit:
                ac.CurrentLimit = CurrentLimit

            if StepSize == 0 or StepCount == 0 or StepDuration == 0 or Count < 0:
                with contextlib.suppress(Exception):
                    self.lld.ArbWaveform.AbortArbitraryWaveform()
                return

            voltageList = [StartAmplitudeRMS + StepSize * i for i in range(int(StepCount))]
            dwellTimeList = [StepDuration * 1000.0 for i in range(len(voltageList))]
            dwellTimeList[0] = DwellTimeStart * 1000.0 if DwellTimeStart > 0 else StepDuration * 1000.0
            dwellTimeList[-1] = DwellTimeEnd * 1000.0 if DwellTimeEnd > 0 else StepDuration * 1000.0
            freqList = [Frequency for i in range(len(voltageList))]
            offsetList = [Offset for i in range(len(voltageList))]
            phaseList = [Phase for i in range(len(voltageList))]

            self.lld.ArbWaveform.ArbitraryWaveform(
                DwellTimeList=dwellTimeList,
                StartACVoltageList=voltageList,
                EndACVoltageList=voltageList,
                StartDCVoltageList=offsetList,
                EndDCVoltageList=offsetList,
                StartFrequencyList=freqList,
                EndFrequencyList=freqList,
                PhaseAngleList=phaseList,
                Count=int(Count),
            )
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Amplitude_Ramp(
        self,
        StartAmplitudeRMS,
        StopAmplitudeRMS,
        Duration,
        Frequency,
        DwellTimeStart=0,
        DwellTimeEnd=0,
        Phase=0,
        Offset=0,
        Count=1,
        CurrentLimit=None,
        **kwargs,
    ):
        """
        Applies a sine which amplitude increases/decreases smoothly.

        Lab: Returns to the static SINE voltage level that has been applied before this stimulus
        Do not apply another stimulus after this one because it would interrupt the current stimulus if it is not
        yet finished.

        :param StartAmplitudeRMS: The start amplitude (RMS) in volts.
        :type StartAmplitudeRMS: float
        :param StopAmplitudeRMS: The stop amplitude (RMS) in volts.
        :type StopAmplitudeRMS: float
        :param Duration: The duration of the ramp in seconds.
        :type Duration: float
        :param Frequency: The sine's frequency in hertz.
        :type Frequency: float
        :param DwellTimeStart: The time in seconds the voltage level is held at the start amplitude before the ramp starts
        :type DwellTimeStart: float
        :param DwellTimeEnd: The time in seconds the voltage level is held at the stop amplitude after the ramp end
        :type DwellTimeEnd: float
        :param Phase: The sine's phase in degree.
        :type Phase: float
        :param Offset: The sine's dc offset in volts
        :type Offset: float
        :param Count: The number of repetitions of the stair
        :type Count: float
        :param CurrentLimit: The current for which the ac source throws an error.
        :type CurrentLimit: float
        :keyword skip_autorange: If True, no autorange will be performed by this function. Use ConfigureVoltageRange manually!
        """

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            if not kwargs.get("skip_autorange", False):
                self.ConfigureVoltageRange(max(StartAmplitudeRMS, StopAmplitudeRMS), Offset)
            self.ConfigureOutputMode(max(StartAmplitudeRMS, StopAmplitudeRMS), Offset)

            if CurrentLimit:
                ac.CurrentLimit = CurrentLimit

            if StartAmplitudeRMS == StopAmplitudeRMS or (StartAmplitudeRMS == 0 and StopAmplitudeRMS == 0) or Count < 0:
                with contextlib.suppress(Exception):
                    self.lld.ArbWaveform.AbortArbitraryWaveform()
                return

            tmpStartACVoltageList = [StartAmplitudeRMS]
            tmpEndACVoltageList = [StopAmplitudeRMS]
            tmpDwellTimeList = [Duration * 1000.0]

            stepCnt = 1
            if DwellTimeStart > 0:
                stepCnt += 1
                tmpStartACVoltageList.insert(0, StartAmplitudeRMS)
                tmpEndACVoltageList.insert(0, StartAmplitudeRMS)
                tmpDwellTimeList.insert(0, DwellTimeStart * 1000.0)
            if DwellTimeEnd > 0:
                stepCnt += 1
                tmpStartACVoltageList.append(StopAmplitudeRMS)
                tmpEndACVoltageList.append(StopAmplitudeRMS)
                tmpDwellTimeList.append(DwellTimeEnd * 1000.0)
            freqList = [Frequency] * stepCnt
            offsetList = [Offset] * stepCnt
            phaseList = [Phase] * stepCnt

            self.lld.ArbWaveform.ArbitraryWaveform(
                DwellTimeList=tmpDwellTimeList,
                StartACVoltageList=tmpStartACVoltageList,
                EndACVoltageList=tmpEndACVoltageList,
                StartDCVoltageList=offsetList,
                EndDCVoltageList=offsetList,
                StartFrequencyList=freqList,
                EndFrequencyList=freqList,
                PhaseAngleList=phaseList,
                Count=int(Count),
            )
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Amplitude_Pulsed(
        self,
        AmplitudeRMS_1,
        AmplitudeRMS_2,
        DwellTime_1,
        DwellTime_2,
        Frequency,
        Phase=0,
        Offset=0,
        Count=1,
        CurrentLimit=None,
        **kwargs,
    ):
        """
        Applies a sine which amplitude jumps between two levels while staying at each level for DwellTime_1
        or DwellTime_2 seconds.

        Lab: Returns to the static SINE voltage level that has been applied before this stimulus
        Do not apply another stimulus after this one because it would interrupt the current stimulus if it is not
        yet finished.

        :param AmplitudeRMS_1: The first amplitude (RMS) level in volts.
        :type AmplitudeRMS_1: float
        :param AmplitudeRMS_2: The second amplitude (RMS) level in volts.
        :type AmplitudeRMS_2: float
        :param DwellTime_1: The duration of the first level in seconds.
        :type DwellTime_1: float
        :param DwellTime_2: The duration of the second level in seconds.
        :type DwellTime_2: float
        :param Frequency: The sine's frequency in hertz or a tuple of two frequencies to alternate.
        :type Frequency: float | tuple[float, float]
        :param Phase: The sine's phase in degree.
        :type Phase: float
        :param Offset: The sine's dc offset in volts or a tuple of two offsets to alternate.
        :type Offset: float | tuple[float, float]
        :param Count: The number of repetitions of the pulse
        :type Count: float
        :param CurrentLimit: The current for which the ac source throws an error.
        :type CurrentLimit: float
        :keyword skip_autorange: If True, no autorange will be performed by this function. Use ConfigureVoltageRange manually!
        """
        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            if not kwargs.get("skip_autorange", False):
                self.ConfigureVoltageRange(max(AmplitudeRMS_1, AmplitudeRMS_2), Offset)
            self.ConfigureOutputMode(max(AmplitudeRMS_1, AmplitudeRMS_2), Offset)

            if CurrentLimit:
                ac.CurrentLimit = CurrentLimit

            if (
                AmplitudeRMS_1 == AmplitudeRMS_2
                or AmplitudeRMS_1 < 0
                or AmplitudeRMS_2 < 0
                or DwellTime_1 <= 0
                or DwellTime_2 <= 0
                or Count < 0
            ):
                with contextlib.suppress(Exception):
                    self.lld.ArbWaveform.AbortArbitraryWaveform()
                return

            if isinstance(Frequency, (int, float)):
                Frequencies = [Frequency, Frequency]
            elif isinstance(Frequency, tuple) and len(Frequency) == 2:
                Frequencies = list(Frequency)
            else:
                msg = "Frequency must be a float or a tuple of two floats."
                raise ValueError(msg)

            if isinstance(Offset, (int, float)):
                Offsets = [Offset, Offset]
            elif isinstance(Offset, tuple) and len(Offset) == 2:
                Offsets = list(Offset)
            else:
                msg = "Offset must be a float or a tuple of two floats."
                raise ValueError(msg)

            self.lld.ArbWaveform.ArbitraryWaveform(
                DwellTimeList=[DwellTime_1 * 1000.0, DwellTime_2 * 1000.0],
                StartACVoltageList=[AmplitudeRMS_1, AmplitudeRMS_2],
                EndACVoltageList=[AmplitudeRMS_1, AmplitudeRMS_2],
                StartDCVoltageList=Offsets,
                EndDCVoltageList=Offsets,
                StartFrequencyList=Frequencies,
                EndFrequencyList=Frequencies,
                PhaseAngleList=[Phase] * 2,
                Count=int(Count),
            )
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Amplitude_Arbitrary(
        self,
        AmplitudeRMS_Start,
        AmplitudeRMS_Stop,
        DwellTime,
        Frequency_Start,
        Frequency_Stop,
        Phase=None,
        Offset_Start=None,
        Offset_Stop=None,
        Count=1,
        CurrentLimit=None,
        **kwargs,
    ):
        """
        Runs an arbitrary sequence of AC settings. The sequence consists of multiple steps. For each step a
        start- & stop-rms-amplitude, start- & stop-frequency, a dwell time has to be specified.
        Optionally a phase angle and start- & stop-dc-offset may be specified
        The lists of parameters AmplitudeRMS_Start, AmplitudeRMS_Stop, DwellTime, Frequency_Start, Frequency_Stop,
        Phase, Offset_Start and Offset_Stop must have the same length.

        :param AmplitudeRMS_Start: A list of start amplitudes for all steps
        :type AmplitudeRMS_Start: list
        :param AmplitudeRMS_Stop: A list of stop amplitudes for all steps
        :type AmplitudeRMS_Stop: list
        :param DwellTime: A list of dwell times for all steps
        :type DwellTime: list
        :param Frequency_Start: A list of start frequencies for all steps
        :type Frequency_Start: list
        :param Frequency_Stop: A list of stop frequencies for all steps
        :type Frequency_Stop: list
        :param Phase: A list of phases for all steps
        :type Phase: list
        :param Offset_Start: A list of start amplitudes for all steps
        :type Offset_Start: list
        :param Offset_Stop: A list of stop amplitudes for all steps
        :type Offset_Stop: list
        :param Count: The number of repetitions of the pulse
        :type Count: float
        :param CurrentLimit: The current for which the ac source throws an error.
        :type CurrentLimit: float
        :keyword skip_autorange: If True, no autorange will be performed by this function. Use ConfigureVoltageRange manually!
        """

        from pverify.core.util.numeric_util import is_numeric_iterable

        args = [
            AmplitudeRMS_Start,
            AmplitudeRMS_Stop,
            DwellTime,
            Frequency_Start,
            Frequency_Stop,
        ]
        for index, arg in enumerate(args):
            if not is_numeric_iterable(arg):
                raise Exception("Argument %d is not a numeric list or array." % (index + 1))
        if Phase is not None:
            if not is_numeric_iterable(Phase):
                msg = "Argument 6 is not a numeric list or array."
                raise Exception(msg)
        else:
            Phase = [0] * len(DwellTime)
        if Offset_Start is not None:
            if not is_numeric_iterable(Offset_Start):
                msg = "Argument 7 is not a numeric list or array."
                raise Exception(msg)
        else:
            Offset_Start = [0] * len(DwellTime)
        if Offset_Stop is not None:
            if not is_numeric_iterable(Offset_Stop):
                msg = "Argument 8 is not a numeric list or array."
                raise Exception(msg)
        else:
            Offset_Stop = [0] * len(DwellTime)

        if not (
            len(AmplitudeRMS_Start)
            == len(AmplitudeRMS_Stop)
            == len(DwellTime)
            == len(Frequency_Start)
            == len(Frequency_Stop)
            == len(Phase)
            == len(Offset_Start)
            == len(Offset_Stop)
            >= 1
        ):
            msg = "Amplitude, dwelltime, frequency, phase and offset lists must have the same length of art least 1"
            raise Exception(msg)

        if 0 in DwellTime:
            msg = "Dwelltime list must not contain zeros."
            raise ValueError(msg)
        if 0 in Frequency_Start:
            msg = "Frequency_Start list must not contain zeros."
            raise ValueError(msg)
        if 0 in Frequency_Stop:
            msg = "Frequency_Start list must not contain zeros."
            raise ValueError(msg)

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)

            max_ampl = np.array([AmplitudeRMS_Start, AmplitudeRMS_Stop]).max(axis=0)
            max_offs = np.array([Offset_Start, Offset_Stop]).max(axis=0) / np.sqrt(2)

            if not kwargs.get("skip_autorange", False):
                ac.VoltageRange = max(max_ampl + max_offs)

            actual_range = ac.VoltageRange  # Returns 600 for HV range
            ac.VoltageProtection.Configure(True, True, 0, actual_range)
            if actual_range <= 300:
                if all(max_offs == 0):
                    mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeACOnly
                else:
                    if all(max_ampl == 0):
                        mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeDCOnly
                    else:
                        mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeACPlusDC
            else:  # HV option, only AC allowed
                mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeACOnly

            if ac.DCGeneration.Mode != mode:
                ac.DCGeneration.Mode = mode

            if CurrentLimit:
                ac.CurrentLimit = CurrentLimit

            if len(AmplitudeRMS_Start) == 0 or Count < 0:
                with contextlib.suppress(Exception):
                    self.lld.ArbWaveform.AbortArbitraryWaveform()
                return

            self.lld.ArbWaveform.ArbitraryWaveform(
                DwellTimeList=[x * 1000 for x in DwellTime],
                StartACVoltageList=AmplitudeRMS_Start,
                EndACVoltageList=AmplitudeRMS_Stop,
                StartDCVoltageList=Offset_Start,
                EndDCVoltageList=Offset_Stop,
                StartFrequencyList=Frequency_Start,
                EndFrequencyList=Frequency_Stop,
                PhaseAngleList=Phase,
                Count=int(Count),
            )
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Setup(
        self,
        LineResistance=None,
        LineInductance=None,
        InrushCurrentStart=None,
        InrushCurrentInterval=None,
        CurrentLimit=None,
        CurrentProtDelay=None,
        **kwargs,
    ):
        """
        Setup of simulated line impedance and inrush current settings.

        :param LineResistance: Simulated line resistance.
                               Lab: 0-1 Ohm
        :type LineResistance: float
        :param LineInductance: Simulated line inductance.
                               Lab: 0-1 mH
        :type LineInductance: float
        :param InrushCurrentStart: The start time in s of inrush current measurement after voltage output.
        :type InrushCurrentStart: float
        :param InrushCurrentInterval: The time interval in s where to measure the inrush current peak.
        :type InrushCurrentInterval: float
        :param CurrentLimit: The limit where over current protection
        :type CurrentLimit: float
        :param CurrentProtDelay: Sets the delay time for triggering over current protection.
        :type CurrentProtDelay: float
        """

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            ac.ConfigureCurrent(CurrentLimit, CurrentProtDelay, InrushCurrentStart, InrushCurrentInterval)
            if LineInductance is not None:
                ac.Impedance.Inductive = LineInductance
                ac.Impedance.Enabled = LineInductance > 0
            if LineResistance is not None:
                ac.Impedance.Resistive = LineResistance
                ac.Impedance.Enabled |= LineResistance > 0
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def GetInrushCurrent(self):
        """
        Measures the inrush current occuring at AC on if the DUT is consuming very high power to charge its input cap.
        The measurement is dependent of the set up parameters InrushCurrentStart and InrushCurrentInterval which define
        when to start and stop the measurement after AC on.

        :return: Inrush current
        :rtype: float
        """
        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            inr = ac.InrushCurrent()
            return float(inr)
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ConfigureWaveformShape(self, shape, **kwargs):
        """

        :param shape: The waveform shape. Valid values: SINE|SQUA|CSIN|DST<01..30>|USR<01..06>
        :keyword chr615xx_buffer: The waveform buffer name: A or B
        :keyword chr615xx_csin_thd: If between 0 and 43: The percentage of THD at which the clipped sine clips
        :keyword chr615xx_csin_amp: If between 0 and 100: The percentage of peak at which the clipped sine clips
        """
        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            ac.ConfigureWaveformShape(
                shape=shape,
                buffer=kwargs.get("chr615xx_buffer", "A"),
                csin_thd=kwargs.get("chr615xx_csin_thd", None),
                csin_amp=kwargs.get("chr615xx_csin_amp", None),
            )
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ConfigureVoltageRange(self, AmplitudeRMS, Offset):
        """
        Automatically configures the output range based on the RMS voltage value plus a DC offset (divided by sqrt(2)).

        :param AmplitudeRMS: The RMS voltage to be used
        :param Offset: The DC voltage to be used
        """
        AmplitudeRMS = max(0, AmplitudeRMS)
        Offset = max(0, Offset)

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            ac.VoltageRange = AmplitudeRMS + Offset / np.sqrt(2)
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ConfigureOutputMode(self, AmplitudeRMS, Offset=0.0):
        """
        If the sum of RMS voltage value plus a DC offset (divided by sqrt(2))
        is above 300V the power supply disables DC output generation and goes into HV mode
        (if supported), otherwise AC+DC or AC/DC depending on their values.

        :param AmplitudeRMS: The RMS voltage to be used
        :param Offset: The DC voltage to be used
        """
        AmplitudeRMS = max(0, AmplitudeRMS)
        Offset = max(0, Offset)

        if self.lld.Initialized:
            ac = self.lld.OutputPhases.Item(self._cname)
            actual_range = ac.VoltageRange  # Returns 600 for HV range
            ac.VoltageProtection.Configure(True, True, 0, actual_range)
            if actual_range <= 300:
                if Offset == 0:
                    mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeACOnly
                else:
                    if AmplitudeRMS == 0:
                        mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeDCOnly
                    else:
                        mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeACPlusDC
            else:  # HV option, only AC allowed
                mode = ac.Enums.IviACPwrDCGenerationModeEnum.IviACPwrDCGenerationModeACOnly

            if ac.DCGeneration.Mode != mode:
                ac.DCGeneration.Mode = mode
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)


if __name__ == "__main__":
    pass
