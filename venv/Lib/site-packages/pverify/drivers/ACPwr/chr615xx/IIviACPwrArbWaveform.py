# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $Rev$
# Date           : $Date$
# Last change by : $Author$
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

import contextlib

from . import IIviACPwrBase


class IIviACPwrArbWaveform(IIviACPwrBase.IIviACPwrBase):
    """IVI ACPwr class-compliant Waveform interface.
    NOTE:
        Attributes/Methods marked with '#' do not exist for this instrument.
        Attributes/Methods marked with '*' are specific for this instrument.
        !Please consider when trying to program instrument independent.

    Attributes:
        #AvailableWaveformCount [int]
            The number of additional user defined waveforms the power source can store.

        #FixedWaveformCount [int]
            The number of fixed vendor defined waveforms stored in the power source.

        #NumOptimalDataPoints [int]
            The optimal (native) number of data points the power source uses for arbitrary waveforms.

        #NumWaveformsMax [int]
            The maximum number of arbitrary waveforms the power source can
            store including user defined waveforms and fixed vendor defined waveforms.

        #UserWaveformCount [int]
            The number of user defined waveforms presently stored in the power source.

    Methods:
        #Clear (WaveformName):
            Deletes individual user defined waveforms from the power source memory.
            If the Waveform Name parameter is VI_NULL, all user defined waveforms are deleted.

        #QueryCatalog (CatalogType, Catalog):
            Returns a comma delimited string of waveform names currently stored in the power source.

        #Write (WaveformName, WaveformData):
            Writes an individual user-defined waveform to the power source memory.

        *ArbitraryWaveform (self, DwellTimeList, StartACVoltageList,
                            EndACVoltageList, StartDCVoltageList,
                            EndDCVoltageList, StartFrequencyList = [50],
                            EndFrequencyList = [50], PhaseAngleList = [0],
                            Count=1):
            Defines the steps of an arbitrary waveform for the chr615xx ac power supply

        *AbortArbitraryWaveform
            Aborts an arbitrary waveform.
    """

    def __init__(self, interface):
        IIviACPwrBase.IIviACPwrBase.__init__(self, interface)

        self.__userwaveforms = ["US%d" % i for i in range(1, self.UserWaveformCount + 1)]
        self.__fixedwaveforms = ["SINE", "SQUA"] + ["DST%02d" % i for i in range(1, self.FixedWaveformCount + 1)]

    # Read only dependent properties
    @property
    def NumWaveformsMax(self):
        """
        The maximum number of arbitrary waveforms the power source can store
        including user defined waveforms and fixed vendor defined waveforms.
        """
        return 38

    @property
    def NumOptimalDataPoints(self):
        """
        The optimal (native) number of data points the power source uses for
        arbitrary waveforms.
        """
        return 1024

    @property
    def FixedWaveformCount(self):
        """
        The number of fixed vendor defined waveforms stored in the power
        source.
        """
        return 32

    @property
    def UserWaveformCount(self):
        """
        The number of user defined waveforms presently stored in the power
        source.
        """
        return 6

    @property
    def AvailableWaveformCount(self):
        """
        The number of additional user defined waveforms the power source can
        store.
        """
        return 6

    # Methods
    def Clear(self, WaveformName=""):
        """
        Deletes individual user defined waveforms from the power source
        memory. If the Waveform Name parameter is "", all user defined
        waveforms are deleted.

        Parameter "WaveformName"
            The name of the waveform to be deleted. If this parameter is "",
            all user defined waveforms are deleted

        """
        raise NotImplementedError

    def QueryCatalog(self, CatalogType):
        """
        Returns a comma delimited string of waveform names currently stored in
        the power source.

        Parameter "CatalogType"
            Specifies if the catalog string should returned fixed vendor defined
            and/or user defined waveform names.

        Parameter "Catalog"
            A comma delimited string of waveform names.

        """
        if CatalogType == self.Enums.IviACPwrWaveformCatalogEnum.IviACPwrWaveformCatalogAll:
            return ",".join(self.__fixedwaveforms + self.__userwaveforms)
        elif CatalogType == self.Enums.IviACPwrWaveformCatalogEnum.IviACPwrWaveformCatalogFixed:
            return ",".join(self.__fixedwaveforms)
        elif CatalogType == self.Enums.IviACPwrWaveformCatalogEnum.IviACPwrWaveformCatalogUser:
            return ",".join(self.__userwaveforms)
        return None

    def Write(self, WaveformName, WaveformData):
        """
        Writes an individual user-defined waveform to the power source memory.

        Parameter "WaveformName"
            The name of the new waveform to be written.
            Has to be one of following "US1, US2, US3, US4, US5, US6"

        Parameter "WaveformData"
            An array of waveform data points used to generate a full cycle (360
            degrees) of the output voltage. The driver automatically resamples the
            user supplied waveform data array to the optimal data points of the
            power source. To minimize the effects of resampling and to maximize
            waveform resolution, the user should allocate waveform data using the
            value of the Num Optimal Data Points property. The driver also
            rescales the amplitude of the user supplied data array to the optimal
            amplitude needed by power source. The actual voltage amplitude of the
            waveform at the power source output is determined by the Voltage Level
            property.

        """
        if WaveformName not in self.__userwaveforms:
            msg = "WaveformName name has to be one of following: US1, US2, US3, US4, US5, US6"
            raise ValueError(msg)
        from pverify import Waveform

        wf = Waveform(WaveformData)
        if len(wf) < 1024:
            wf.up_sample_interp(1024)
        elif len(wf) > 1024:
            wf.down_sample(1024)
        wf.scale_to_amplitude(32767)
        wf.cast_int32()
        string = ":TRACE " + WaveformName + " " + " ".join(list(wf.data))
        self.interface.vi_write(string)

    def ArbitraryWaveform(
        self,
        DwellTimeList,
        StartACVoltageList,
        EndACVoltageList,
        StartDCVoltageList=None,
        EndDCVoltageList=None,
        StartFrequencyList=None,
        EndFrequencyList=None,
        PhaseAngleList=None,
        Count=1,
    ):
        """
        This is a function only for Chroma chr615xx models. Don't use with other devices.
        Defines the steps of an arbitrary waveform for the chr615xx ac power supply.

        :param DwellTimeList: Define the dwell times in ms for each single step. Type: list of float

        :param StartACVoltageList: Define the AC start voltage levels of each single step. Type: list of float

        :param EndACVoltageList: Define the AC end voltage levels of each single step. Type: list of float

        :param StartDCVoltageList: Define the DC start voltage levels of each single step. Type: list of float

        :param EndDCVoltageList: Define the DC end voltage levels of each single step. Type: list of float

        :param StartFrequencyList: Define the start frequency of each step. Type: list of float

        :param EndFrequencyList: Define the end frequency of each step. Type: list of float

        :param PhaseAngleList: Defines the phase angle of the AC voltage of each step. Type: list of float

        :param Count:
            Defines the number of repetitions of the arbitrary waveform.
            Default is 1.
            For infinite repetitions set to 0 and abort with function AbortArbitraryWaveform()
        :type Count: int
        """
        if StartDCVoltageList is None or EndDCVoltageList is None:
            StartDCVoltageList = [0]
            EndDCVoltageList = [0]
        if StartFrequencyList is None or EndFrequencyList is None:
            StartFrequencyList = [50]
            EndFrequencyList = [50]
        if PhaseAngleList is None:
            PhaseAngleList = [0]

        maxPoints = max(
            [
                len(DwellTimeList),
                len(StartACVoltageList),
                len(EndACVoltageList),
                len(StartDCVoltageList),
                len(EndDCVoltageList),
                len(StartFrequencyList),
                len(EndFrequencyList),
                len(PhaseAngleList),
            ]
        )
        for _i in range(maxPoints - len(DwellTimeList)):
            DwellTimeList.append(DwellTimeList[-1])
        for _i in range(maxPoints - len(StartACVoltageList)):
            StartACVoltageList.append(StartACVoltageList[-1])
        for _i in range(maxPoints - len(EndACVoltageList)):
            EndACVoltageList.append(EndACVoltageList[-1])
        for _i in range(maxPoints - len(StartDCVoltageList)):
            StartDCVoltageList.append(StartDCVoltageList[-1])
        for _i in range(maxPoints - len(EndDCVoltageList)):
            EndDCVoltageList.append(EndDCVoltageList[-1])
        for _i in range(maxPoints - len(StartFrequencyList)):
            StartFrequencyList.append(StartFrequencyList[-1])
        for _i in range(maxPoints - len(EndFrequencyList)):
            EndFrequencyList.append(EndFrequencyList[-1])
        for _i in range(maxPoints - len(PhaseAngleList)):
            PhaseAngleList.append(PhaseAngleList[-1])

        strDwellTimeList = ",".join(f"{val:.1f}" for val in DwellTimeList) + ",0"
        strStartACVoltageList = ",".join(f"{val:.1f}" for val in StartACVoltageList)
        strEndACVoltageList = ",".join(f"{val:.1f}" for val in EndACVoltageList)
        strStartDCVoltageList = ",".join(f"{val:.1f}" for val in StartDCVoltageList)
        strEndDCVoltageList = ",".join(f"{val:.1f}" for val in EndDCVoltageList)
        strStartFrequencyList = ",".join(f"{val:.1f}" for val in StartFrequencyList)
        strEndFrequencyList = ",".join(f"{val:.1f}" for val in EndFrequencyList)
        strPhaseAngleList = ",".join(f"{val:.1f}" for val in PhaseAngleList)

        self.interface.vi_write(":OUTP:MODE LIST")
        self.interface.vi_write(":TRIG OFF")
        with contextlib.suppress(Exception):
            # Dunno why but sometimes an error occurs here when switching from a lower (previous variation) to a higher voltage range
            self.GetError()
        self.interface.vi_write(":OUTP:MODE FIXED")
        self.interface.vi_write(":LIST:COUNT %d" % Count)
        self.interface.vi_write(":LIST:BASE TIME")
        self.interface.vi_write(f":LIST:DEGR {strPhaseAngleList}")
        self.interface.vi_write(f":LIST:VOLT:AC:STAR {strStartACVoltageList}")
        self.interface.vi_write(f":LIST:VOLT:AC:END {strEndACVoltageList}")
        hv_mode = self.interface.vi_query(":VOLT:RANG?", "%s\n", "%s").strip().upper() == "HV"
        if not hv_mode:
            self.interface.vi_write(f":LIST:VOLT:DC:STAR {strStartDCVoltageList}")
            self.interface.vi_write(f":LIST:VOLT:DC:END {strEndDCVoltageList}")
        self.interface.vi_write(f":LIST:FREQ:STAR {strStartFrequencyList}")
        self.interface.vi_write(f":LIST:FREQ:END {strEndFrequencyList}")
        self.interface.vi_write(f":LIST:DWEL {strDwellTimeList}")
        self.interface.vi_write(":OUTP:MODE LIST")
        self.interface.vi_write(":TRIG ON")

        # self.interface._Log.warning("chr615xx: Compatibility warning: ArbitraryWaveform-method might not "
        #                            "be available when using other instrument drivers.")
        self.GetError()

    def AbortArbitraryWaveform(self):
        """
        This is a function only for Chroma chr615xx models. Don't use with other devices.
        Aborts an arbitrary waveform.
        """
        self.interface.vi_write(":TRIG OFF")
        self.interface.vi_write(":OUTP:MODE FIXED")
        # self.interface._Log.warning("chr615xx: Compatibility warning: AbortArbitraryWaveform-method "
        #                            "might not be available when using other instrument drivers.")
        self.interface.vi_query(":SYST:ERR?")
        self.GetError()
