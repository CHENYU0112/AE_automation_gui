# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $Rev$
# Date           : $Date$
# Last change by : $Author$
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

from time import sleep

from . import (
    IIviACPwrBase,
    IIviACPwrCurrentProtection,
    IIviACPwrDCGeneration,
    IIviACPwrImpedance,
    IIviACPwrVoltageProtection,
)


class IIviACPwrOutputPhase(IIviACPwrBase.IIviACPwrBase):
    """IVI ACPwr class-compliant output Phase interface.

    NOTE:
        Attributes/Methods marked with '#' do not exist for this instrument.
        Attributes/Methods marked with '*' are specific for this instrument.
        !Please consider when trying to program instrument independent.


    Attributes:
        CurrentLimit [float]
            Specifies the output current limit value.

        CurrentProtection
            Extension group that configures current protection capabilities.

        #CurrentRampBusy [bool]
            Indicates if a current ramp is in progress.

        DCGeneration
            Extension group that configures DC generation capabilities.

        Enabled [bool]
            Enables/disables the output contactor/relay on the power source output.

        Impedance
            Extension group that configures output impedance capabilities.

        NumVoltageRanges [int]
            The number of output AC voltage ranges supported by the power source.

        PhaseAngle [float]
            Specifies the Phase Angle of the output phase in relation to Phase A.

        VoltageLevel [float]
            Specifies the output Line to Neutral AC voltage level of the
            power source when operating in constant voltage mode.

        VoltageProtection
            Extension group that configures voltage protection capabilities.

        VoltageRampBusy [bool]
            Indicates if a voltage ramp is in progress.

        VoltageRange [str]
            Configures the AC voltage range of the power source to support the specified maximum RMS voltage.

        Waveform [str]
            Specifies the waveform name used to generate output voltage.


    Methods:
        #AbortCurrentRamp
            Aborts a current ramp.

        AbortVoltageRamp
            Aborts a voltage ramp.

        FetchMeasurement (MeasurementType, Measurement):
            Returns the value measured by a previous call to the Initiate Measurement method.

        #FetchMeasurementArray (MeasurementType, Measurement):
            Returns an array of measured values of a previous call to the Initiate Measurement method.

        QueryVoltageRangeCapabilities (Range, WaveformName, MinVoltage, MaxVoltage):
            Returns the minimum and maximum RMS voltage supported by the specified range and waveform.

        #RampCurrent (StartCurrent, EndCurrent, Duration):
            Starts a linear ramp of the output current from a starting to ending current
            value for a specified duration.

        RampVoltage (StartVoltage, EndVoltage, Duration):
            Starts a linear ramp of the output voltage from a starting to ending voltage
            value for a specified duration.

    """

    def __init__(self, interface, parent):
        IIviACPwrBase.IIviACPwrBase.__init__(self, interface)
        self.Impedance = IIviACPwrImpedance.IIviACPwrImpedance(interface)
        self.CurrentProtection = IIviACPwrCurrentProtection.IIviACPwrCurrentProtection(interface)
        self.VoltageProtection = IIviACPwrVoltageProtection.IIviACPwrVoltageProtection(interface)
        self.DCGeneration = IIviACPwrDCGeneration.IIviACPwrDCGeneration(interface)

        self._parent = parent
        if False:
            from .IIviACPwrOutputPhases import IIviACPwrOutputPhases

            self._parent = IIviACPwrOutputPhases(self.interface, self)

        self.__waveformname = "SINE"
        self.__userwaveforms = ["US1", "US2", "US3", "US4", "US5", "US6"]
        self.__fixedwaveforms = []
        for i in range(1, 31):
            self.__fixedwaveforms.append("DST%02d" % i)

    # Read only dependent properties
    @property
    def NumVoltageRanges(self):
        """
        The number of output AC voltage ranges supported by the power source.

        :rtype: int
        """
        return 2

    @property
    def VoltageRampBusy(self):
        """
        Indicates if a voltage ramp is in progress.

        :rtype: bool
        """
        raise NotImplementedError

    @property
    def CurrentRampBusy(self):
        """
        Indicates if a current ramp is in progress.
        """
        raise NotImplementedError

    # Read-write dependent properties
    @property
    def CurrentLimit(self):
        """
        Specifies the output current limit value.

        :rtype: float
        """
        answ = self.interface.vi_query(":CURR:LIM?", "%s\n", "%f")
        self.GetError()
        return answ

    @CurrentLimit.setter
    def CurrentLimit(self, value):
        """
        Specifies the output current limit value.

        :type value: float
        """
        self.interface.vi_write(f":CURR:LIM {value:.2f}")
        self.GetError()

    @property
    def Enabled(self):
        """
        Enables/disables the output contactor/relay on the power source
        output.

        :rtype: bool
        """
        answ = self.interface.vi_query(":OUTP:STAT?", "%s", "%s")
        self.GetError()
        return answ == "ON"

    @Enabled.setter
    def Enabled(self, value):
        """
        Enables/disables the output contactor/relay on the power source
        output.

        :type value: bool
        """
        if bool(value):
            self.interface.vi_write(":OUTP:STAT ON")
        else:
            for _try in range(20):
                self.interface.vi_write(":OUTP:STAT OFF")
                sleep(0.5)
                if not self.Enabled:
                    break
            if self.Enabled:
                self.interface.vi_write("*RST")
                sleep(7)
                msg = "AC did not switch off after 20 retries, resetting. Check bug with remote inhibit again."
                raise Exception(msg)
        self.GetError()

    @property
    def VoltageLevel(self):
        """
        Specifies the output Line to Neutral AC voltage level of the power
        source when operating in constant voltage mode.

        :rtype: float
        """
        answ = self.interface.vi_query(":VOLT:AC?", "%s\n", "%f")
        self.GetError()
        return answ

    @VoltageLevel.setter
    def VoltageLevel(self, value):
        """
        Specifies the output Line to Neutral AC voltage level of the power
        source when operating in constant voltage mode.

        :type value: float
        """
        self.interface.vi_write(f":VOLT:AC {value:.3f}")
        self.GetError()

    @property
    def Waveform(self):
        """
        Specifies the waveform name used to generate output voltage.
        "Sine" is the default value.
        """
        return self.__waveformname

    @Waveform.setter
    def Waveform(self, value):
        """
        Specifies the waveform name used to generate output voltage.

        Use following values: SINE, SQUA, US1, ..., US6, DST01, ..., DST30
        """
        val = str(value).upper()
        if val not in ["SINE", *self.__userwaveforms, *self.__fixedwaveforms]:
            msg = "Unknown waveform name."
            raise Exception(msg)

        if val in ["SINE", "SQUA", *self.__fixedwaveforms, *self.__userwaveforms]:
            self.interface.vi_write(":OUTP:MODE FIXED")
            self.interface.vi_write(":FUNC:SHAP:A " + val)
        else:
            msg = f"Unknown waveform shape '{value}'!"
            raise ValueError(msg)
        self.GetError()
        self.__waveformname = val

    @property
    def PhaseAngle(self):
        """
        Specifies the Phase Angle of the output phase in relation to Phase A.

        :rtype: float
        """
        answ = self.interface.vi_query(":PHAS:ON?", "%s\n", "%f")
        self.GetError()
        return answ

    @PhaseAngle.setter
    def PhaseAngle(self, value):
        """
        Specifies the Phase Angle of the output phase in relation to Phase A.

        :type value: float
        """
        self.interface.vi_write(f":PHAS:ON {value:.1f}")
        self.GetError()

    @property
    def VoltageRange(self):
        """
        Configures the AC voltage range of the power source to support the
        specified maximum RMS voltage.

        :rtype: str
        """
        answ = self.interface.vi_query(":VOLT:RANG?", "%s\n", "%s")
        if answ == "LOW":
            answ = 150
        elif answ == "HIGH" or answ == "AUTO":
            answ = 300
        elif answ == "HV":
            answ = 600
        self.GetError()
        return answ

    @VoltageRange.setter
    def VoltageRange(self, value):
        """
        Configures the AC voltage range of the power source to support the
        specified maximum RMS voltage.

        :type value: float
        """
        if (value > 0) and (value <= 150):
            value = "LOW"
        elif (value > 150) and (value <= 300):
            value = "HIGH"
        elif (value > 300) and (value <= 600):
            value = "HV"
            model = self._parent._parent.IDN.split(",")[1].lower()
            if model in ("61501", "61502", "61601", "61602"):
                slewr = 0.3
            elif model in ("61503", "61504", "61603", "61604"):
                slewr = 0.4
            else:
                slewr = 0.0
            self.SlewRate = slewr
            self.GetError()
        elif (value < 0) or (value > 600):
            value = "chr615xx: The specified voltage range exceeds the range 0 to 300 (600 for HV option)"
        elif value == 0:
            value = "AUTO"

        actual_range = self.interface.vi_query(":VOLT:RANG?", "%s\n", "%s").strip()
        if actual_range != value:
            if value == "HV" or actual_range == "HV":
                self.Enabled = False
            self.interface.vi_write(f":VOLT:RANG {value}")
        self.GetError()

    # Methods
    def QueryVoltageRangeCapabilities(self, Range, WaveformName=""):
        """
        Returns the minimum and maximum RMS voltage supported by the specified
        range and waveform.

        :param Range:
            The range to query. The Range parameter must be from 1 to the value of
            the Number of Voltage Ranges property.
        :type Range: int

        :param WaveformName:
            The name of the waveform to query the range.
        :type WaveformName: str

        :rtype: list
        :return: list at MinVoltag, MaxVoltage

        """
        if Range == 0:
            MinVoltage = 0
            MaxVoltage = 150
        elif Range == 1:
            MinVoltage = 0
            MaxVoltage = 300
        elif Range == 2:
            MinVoltage = 0
            MaxVoltage = 600
        else:
            msg = "There are only 3 ranges available!"
            raise Exception(msg)
        return MinVoltage, MaxVoltage

    def RampCurrent(self, StartCurrent, EndCurrent, Duration):
        """
        Starts a linear ramp of the output current from a starting to ending
        current value for a specified duration.

        Parameter "StartCurrent"
            The current ramp starting value in Amps.

        Parameter "EndCurrent"
            The current ramp ending value in Amps.

        Parameter "Duration"
            The ramp duration in seconds.

        """
        raise NotImplementedError

    def FetchMeasurementArray(self, MeasurementType):
        """
        Returns an array of measured values of a previous call to the Initiate
        Measurement method.

        Parameter "MeasurementType"
            The type of measurement to fetch.

        Parameter "Measurement"
            Returns the measured values.

        """
        raise NotImplementedError

    def RampVoltage(self, StartVoltage, EndVoltage, Duration, Frequency=50):
        """
        Starts a linear ramp of the output voltage from a starting to ending
        voltage value for a specified duration.

        :param StartVoltage:
            The voltage ramp starting value in Volts RMS.
        :type StartVoltage: float

        :param EndVoltage:
            The voltage ramp ending value in Volts RMS.
        :type EndVoltage: float

        :param Duration:
            The ramp duration in seconds.
        :type Duration: int

        :param Frequency:
            The Frequency
        :type Frequency: int

        """
        self.interface.vi_write(":OUTP:MODE LIST")
        self.interface.vi_write(":TRIG OFF")
        self.interface.vi_write(":OUTP:MODE FIXED")
        self.interface.vi_write(":LIST:COUNT 1")
        self.interface.vi_write(":LIST:BASE TIME")
        self.interface.vi_write(":LIST:DEGR 0")
        self.interface.vi_write(f":LIST:VOLT:AC:STAR {StartVoltage:.3f}")
        self.interface.vi_write(f":LIST:VOLT:AC:END {EndVoltage:.3f}")
        self.interface.vi_write(":LIST:VOLT:DC:STAR 0")
        self.interface.vi_write(":LIST:VOLT:DC:END 0")
        self.interface.vi_write(f":LIST:FREQ:STAR {Frequency:.1f}")
        self.interface.vi_write(f":LIST:FREQ:END {Frequency:.1f}")
        self.interface.vi_write(":LIST:DWEL %d" % (Duration * 1000))
        self.interface.vi_write(":OUTP:MODE LIST")
        self.interface.vi_write(":TRIG ON")

    def AbortVoltageRamp(self):
        """
        Aborts a voltage ramp.
        """
        self.interface.vi_write(":TRIG OFF")
        self.interface.vi_write(":OUTP:MODE FIXED")
        self.GetError()

    def FetchMeasurement(self, MeasurementType):
        """
        :param MeasurementType:
            The type of measurement to fetch.
        :type MeasurementType: IviACPwrMeasurementTypeEnum

        :rtype: Returns an array of measured values of a previous call to the Initiate
                Measurement method: (Measurement)
        """
        if MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeVoltageRmsLN:
            return self._parent._IIviACPwrOutputPhases__measurements["VoltageRmsLN"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeCurrentRms:
            return self._parent._IIviACPwrOutputPhases__measurements["CurrentRms"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeFrequency:
            return self._parent._IIviACPwrOutputPhases__measurements["Frequency"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeVoltageDC:
            return self._parent._IIviACPwrOutputPhases__measurements["VoltageDC"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeCurrentDC:
            return self._parent._IIviACPwrOutputPhases__measurements["CurrentDC"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypePowerFactor:
            return self._parent._IIviACPwrOutputPhases__measurements["PowerFactor"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeCrestFactor:
            return self._parent._IIviACPwrOutputPhases__measurements["CrestFactor"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeCurrentPeak:
            return self._parent._IIviACPwrOutputPhases__measurements["CurrentPeak"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypePowerVA:
            return self._parent._IIviACPwrOutputPhases__measurements["PowerVA"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypePowerReal:
            return self._parent._IIviACPwrOutputPhases__measurements["PowerReal"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypePowerDC:
            return self._parent._IIviACPwrOutputPhases__measurements["PowerDC"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeCurrentTHD:
            return self._parent._IIviACPwrOutputPhases__measurements["CurrentTHD"]
        elif MeasurementType == self.Enums.IviACPwrMeasurementTypeEnum.IviACPwrMeasurementTypeVoltageTHD:
            return self._parent._IIviACPwrOutputPhases__measurements["VoltageTHD"]
        else:
            msg = "Measurement type not supported!"
            raise Exception(msg)

    def AbortCurrentRamp(self):
        """
        Aborts a current ramp.
        """
        raise NotImplementedError

    def ConfigureCurrent(self, CurrentLimit=None, CurrentDelay=None, InrushStart=None, InrushInterval=None):
        """
        This is a function only for Chroma chr615xx models. Don't use with other devices.
        ConfigureCurrent(CurrentLimit, CurrentDelay, InrushStart, InrushInterval)

        :param CurrentLimit:
            RMS current limit of the AC source for software protection
        :type CurrentLimit: float

        :param CurrentDelay:
            Delay time for triggering overcurrent protection in [s]
        :type CurrentDelay: float

        :param InrushStart:
            Start time of inrush current measurement in [s]
        :type InrushStart: float

        :param InrushInterval:
            Measuring interval of inrush current measurement in [s]
        :type InrushInterval: float
        """
        msg = []
        if CurrentLimit is not None:
            msg += [f":CURR:LIM {CurrentLimit:.2f}"]
        if CurrentDelay is not None:
            msg += [f":CURR:DEL {CurrentDelay:.2f}"]
        if InrushStart is not None:
            msg += [":CURR:INR:STAR %d" % int(InrushStart * 1000)]
        if InrushInterval is not None:
            msg += [":CURR:INR:INT %d" % int(InrushInterval * 1000)]
        if len(msg):
            self.interface.vi_write(";".join(msg))
            self.GetError()

    def InrushCurrent(self):
        """
        NON-COMPLIANCE FUNCTION.
        Returns the inrush current.
        """
        answ = self.interface.vi_query(":MEAS:CURR:INR?", rformat="%f")
        self.GetError()
        return answ

    def ConfigureWaveformShape(self, shape="SINE", buffer="A", csin_thd=None, csin_amp=None):
        """

        :param shape: The waveform shape. Valid values: SINE|SQUA|CSIN|DST<01..30>|USR<01..06>
        :param buffer: The waveform buffer name: A or B
        :param csin_thd: If between 0 and 43: The percentage of THD at which the clipped sine clips
        :param csin_amp: If between 0 and 100: The percentage of peak at which the clipped sine clips
        """
        shape = str(shape).upper()
        if shape in ["SINE", "SQUA", "CSIN", *self.__fixedwaveforms, *self.__userwaveforms]:
            self.interface.vi_write(f":FUNC:SHAP:{buffer} " + shape)

            if shape == "CSIN":
                if csin_thd is not None:
                    csin_thd = min(43.0, max(0.0, csin_thd))
                    self.interface.vi_write(f":FUNC:SHAP:{buffer}:MODE THD")
                    self.interface.vi_write(f":FUNC:SHAP:{buffer}:THD {csin_thd:.1f}")
                elif csin_amp is not None:
                    csin_amp = min(100.0, max(0.0, csin_amp))
                    self.interface.vi_write(f":FUNC:SHAP:{buffer}:MODE AMP")
                    self.interface.vi_write(f":FUNC:SHAP:{buffer}:AMP {csin_amp:.1f}")
                else:
                    self.interface.vi_write(f":FUNC:SHAP:{buffer}:MODE AMP")
                    self.interface.vi_write(f":FUNC:SHAP:{buffer}:AMP 100")

            self.GetError()
        else:
            msg = f"Unknown waveform shape '{shape}'!"
            raise ValueError(msg)

    @property
    def SlewRate(self):
        """
        Gets the slew rate (V/ms) of the AC output voltage

        :rtype: str
        """
        answ = self.interface.vi_query(":OUTP:SLEW:VOLT:AC?", "%s\n", "%s")
        self.GetError()
        return answ

    @SlewRate.setter
    def SlewRate(self, value):
        """
        Configures the slew rate (V/ms) of the AC output voltage

        :type value: str
        """
        self.interface.vi_write(f":OUTP:SLEW:VOLT:AC {value}")
        self.GetError()
