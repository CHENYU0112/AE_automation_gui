"""
Date: January 2020
Author: EllerBehr (IFAG ATV SYS SE HW)
This code was developed at and is property of Infineon Technologies AG, Neubiberg, Germany

This module contains a driver for the MCP power supply series from Fug Elektronik.
The methods of this class allows both sending and receiving data to and from the power supply.
Note that not all possible commands are implemented.

Since the communication is based on direct registers control, it is unlikely to work properly in a
shared USB with VISA instruments.
"""

from __future__ import annotations

from time import sleep

import serial.tools.list_ports

from pverify.core.lab.driver_identity import IdentityBasic

VOLTAGE_LIMIT = 1000


class FugMCP:
    __version__ = "1.0.0"

    class FugMCPError(Exception):
        pass

    def __init__(self, functionExecutionSleepTime=0.1):
        self.voltageLimit = VOLTAGE_LIMIT
        self.functionExecSleepTime = functionExecutionSleepTime

        self.__Initialized = False
        self.__Identity = IdentityBasic(fct_idn=self.__idn, fct_drv_rev=self.__drv_rev, fct_fw_rev=self.__fw_rev)

    def __idn(self):
        """
        Returns an identification string of the instrument
        """
        if self.Initialized:
            self.com_port.write(("*IDN?" + "\r\n").encode())
            return self._waitResponse()
        else:
            return ""

    def __drv_rev(self):
        """
        Returns the driver version
        """
        return self.__version__  # Return driver revision.
        # For self developed drivers this might be __version__

    def __fw_rev(self):
        """
        Returns the FW revision of the instrument
        """
        if self.Initialized:
            return "unknown"  # Return FW revision if instrument supports it.
            # For SCPI instruments this is probably returned with *IDN?
        else:
            return ""

    @property
    def Initialized(self):
        """
        Shows if the instrument connection has been established
        """
        return self.__Initialized

    @property
    def Identity(self):
        """
        A pointer to the Identity interface
        """
        return self.__Identity

    def Initialize(self, com_port_idx=0, baudrate=115200):
        """
        Opens the I/O session to the instrument. Driver methods and properties
        that access the instrument are only accessible after Initialize is
        called. Initialize optionally performs a Reset and queries the
        instrument to validate the instrument model.

        """
        self.com_ports = list(serial.tools.list_ports.comports())
        self.no_com_ports = len(self.com_ports)
        if self.no_com_ports > 0:
            # print("Number of available COM ports: " + str(self.no_com_ports))
            # for idx, curr in enumerate(self.com_ports):
            #     print("  " + str(idx) + ".)  " + curr.description)  # show the available COM ports
            self.com_port_idx = int(
                com_port_idx
            )  # initializes the COM port with number given when instancing the class
            self.baudrate = baudrate
            if self.com_port_idx > self.no_com_ports or self.com_port_idx < 0:  # checks if given number is out of range
                raise self.FugMCPError(
                    "Incorrect value for COM port! The number must be between 0 and " + str(self.no_com_ports - 1)
                )
            # configure the COM port to talk to. Default values: 115200,8,N,1
            self.com_port = serial.Serial(
                port=self.com_ports[self.com_port_idx].device,  # chosen COM port
                baudrate=self.baudrate,  # 115200
                bytesize=serial.EIGHTBITS,  # 8
                parity=serial.PARITY_NONE,  # N
                stopbits=serial.STOPBITS_ONE,  # 1
            )
            if self.com_port.is_open:
                self.com_port.flushInput()
                self.com_port.flushOutput()
                # print("Opened Port: " + self.com_ports[self.com_port_idx].device)
            else:
                msg = "Couldn't open Port!"
                raise self.FugMCPError(msg)
        else:
            msg = "No COM ports available!"
            raise self.FugMCPError(msg)
        try:
            self.Identity  # noqa: B018
        except Exception:
            msg = "Power Supply does not respond."
            raise self.FugMCPError(msg) from None

        self.__Initialized = True

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and
        properties that access the instrument are not accessible after Close
        is called.
        """
        if self.Initialized:
            if self.com_port.is_open:
                self.com_port.close()
            self.__Initialized = False

    def _waitResponse(self):
        response = ""
        sleep(self.functionExecSleepTime)
        while self.com_port.in_waiting > 0:
            response = self.com_port.readline()  # all characters received, read line till '\r\n'
        if response != "":
            response = response.decode("utf-8")
            if (
                response[0] == "E"
            ):  # if response is error (starting with 'E'), handle the error (translate to human-readable)
                self.__handleError(
                    response[0:2]
                )  # sends the error code as string and raises an error with its explanation
                return None
            else:  # if no error received, return received value (e.g. as a response to a query command)
                return response
        else:
            msg = "<< Error, no response received from power supply!"
            raise self.FugMCPError(msg)
            # print("Error, no response received!")

    def setOutputState(self, state: bool = False):
        state = ["off", "on"][bool(state)]
        self.voltage = float(self.getVoltage())
        if abs(self.voltage) > self.voltageLimit and abs(self.voltage) > 0:
            self.setVoltage(self.voltageLimit * self.voltage / abs(self.voltage))
        if state.lower() == "off":
            self.com_port.write(("F0" + "\r\n").encode())  # send switch off command
            self._waitResponse()  # wait here for response E0. If error is returned, handle it!
        elif state.lower() == "on":
            self.com_port.write(("F1" + "\r\n").encode())  # send switch on command
            self._waitResponse()  # wait here for response E0.If error is returned, handle it!
        else:
            msg = "Invalid state. Device can be either 'on' or 'off'."
            raise self.FugMCPError(msg)

    def getOutputState(self):
        self.com_port.write((">DON? " + "\r\n").encode())
        currentState = self._waitResponse()
        if "DON:1" in currentState:
            return "on"
        elif "DON:0" in currentState:
            return "off"
        else:
            return "The received state is either invalid or no response was obtained."

    def setBehaviorVoltageRamp(self, value: float = 0):
        """
        input argument value must be an integer:
        0: ramp disabled (default)
        1: ramp enabled for climbing and falling edge
        2: ramp enabled only for climbing edge. Falling edge steps immediately down
        3: read reference from fug!
        4: same as 2, but the voltage values are reset to zero if output is turned off
        The behavior mode decides how the actual valid set voltage value (SOA) will follow the programmed reference (S0)
        """
        self.com_port.write((">S0B " + str(value) + "\r\n").encode())
        self._waitResponse()

    def getBehaviorVoltageRamp(self):
        """
        returned argument value may be:
        0: ramp disabled (default)
        1: ramp enabled for climbing and falling edge
        2: ramp enabled only for climbing edge. Falling edge steps immediately down
        3: read reference from fug!
        4: same as 2, but the voltage values are reset to zero if output is turned off
        The behavior mode decides how the actual valid set voltage value (SOA) will follow the programmed reference (S0)
        """
        self.com_port.write((">S0B ?" + "\r\n").encode())
        return float(self._waitResponse().replace("S0B:", "").replace("\n", ""))

    def setBehaviorCurrentRamp(self, value: float = 0):
        """
        input argument value must be an integer:
        0: ramp disabled (default)
        1: ramp enabled for climbing and falling edge
        2: ramp enabled only for climbing edge. Falling edge steps immediately down
        3: read reference from fug!
        4: same as 2, but the voltage values are reset to zero if output is turned off
        The behavior mode decides how the actual valid set current value (S1A) will follow the programmed reference (S1)
        """
        self.com_port.write((">S1B " + str(value) + "\r\n").encode())
        self._waitResponse()

    def getBehaviorCurrentRamp(self):
        """
        returned argument value may be:
        0: ramp disabled (default)
        1: ramp enabled for climbing and falling edge
        2: ramp enabled only for climbing edge. Falling edge steps immediately down
        3: read reference from fug!
        4: same as 2, but the voltage values are reset to zero if output is turned off
        The behavior mode decides how the actual valid set current value (S1A) will follow the programmed reference (S1)
        """
        self.com_port.write((">S1B ?" + "\r\n").encode())
        return float(self._waitResponse().replace("S1B:", "").replace("\n", ""))

    def setVoltage(self, value: float = 0.0):  # value in Volts
        if abs(value) > self.voltageLimit and abs(value) > 0:
            value = self.voltageLimit * value / abs(value)
            print("\033[91m" + f"Set voltage reached the maximum limited value of {self.voltageLimit}V." + "\033[0m")
        self.com_port.write((">S0 " + str(value) + "\r\n").encode())
        self._waitResponse()

    def setCurrent(self, value: float = 0):  # value in Amperes
        self.com_port.write((">S1 " + str(value) + "\r\n").encode())
        self._waitResponse()

    def setVoltageRampRate(self, value: float = 1):  # value in Volts per seconds
        self.com_port.write((">S0R " + str(value) + "\r\n").encode())
        self._waitResponse()

    def getVoltageRampRate(self):  # value in Volts per seconds
        self.com_port.write((">S0R?" + "\r\n").encode())
        return float(self._waitResponse().replace("S0R:", "").replace("\n", ""))

    def setCurrentRampRate(self, value: float = 0.01):  # value in Amperes per seconds
        self.com_port.write((">S1R " + str(value) + "\r\n").encode())
        self._waitResponse()

    def getCurrentRampRate(self):  # value in Volts per seconds
        self.com_port.write((">S1R?" + "\r\n").encode())
        return float(self._waitResponse().replace("S1R:", "").replace("\n", ""))

    def getVoltage(self):  # get actual value in Volts
        self.com_port.write(
            (">S0A?" + "\r\n").encode()
        )  # the 'A' hierby means 'actual', as opposed by the programmed value
        return float(self._waitResponse().replace("S0A:", "").replace("\n", ""))
        # return self.waitResponse() #get functions need to return the queried value

    def getCurrent(self):  # get actual value in Amperes
        self.com_port.write(
            (">S1A?" + "\r\n").encode()
        )  # the 'A' hierby means 'actual', as opposed by the programmed value
        return float(self._waitResponse().replace("S1A:", "").replace("\n", ""))
        # return self.waitResponse() #get functions need to return the queried value

    def checkVoltage(self, tolerancePercentage: float, referenceSetVoltage: float):
        """
        :param tolerancePercentage: value to allow test to proceed. If the measured voltage is whithin this tolerance
                                    range of the set voltage, the test may proceed
        :return: if the voltage eventually reaches its set value within the given trials, the function returns True
        """
        print(f"Voltage ramp rate: {int(self.getVoltageRampRate())}V/s")
        for _trial in range(1, 10):
            print(f"DC Voltage is {self.getVoltage()} V.")
            if abs(self.getVoltage() - referenceSetVoltage) < referenceSetVoltage * tolerancePercentage / 100:
                print("DC Voltage ready.")
                return True
            else:
                print("DC Voltage not ready yet.")
            sleep(1)
        return None

    def __handleError(self, errorCode):
        if errorCode == "E0":
            pass  # No errors detected. Proceed
        elif errorCode == "E1":
            msg = "no data available"
            raise self.FugMCPError(msg)
        elif errorCode == "E2":
            msg = "unknown register type"
            raise self.FugMCPError(msg)
        elif errorCode == "E3":
            msg = "unknown/unreferenced error"
            raise self.FugMCPError(msg)
        elif errorCode == "E4":
            msg = "invalid argument"
            raise self.FugMCPError(msg)
        elif errorCode == "E5":
            msg = "argument out of range"
            raise self.FugMCPError(msg)
        elif errorCode == "E6":
            msg = "register is read only"
            raise self.FugMCPError(msg)
        elif errorCode == "E7":
            msg = "Receive Overflow"
            raise self.FugMCPError(msg)
        elif errorCode == "E8":
            msg = "EEPROM is write protected"
            raise self.FugMCPError(msg)
        elif errorCode == "E9":
            msg = "address error"
            raise self.FugMCPError(msg)
        elif errorCode == "E10":
            msg = "unknown SCPI command "
            raise self.FugMCPError(msg)
        elif errorCode == "E11":
            msg = "not allowed Trigger-on-Talk"
            raise self.FugMCPError(msg)
        elif errorCode == "E12":
            msg = "invalid argument in ~Tn command"
            raise self.FugMCPError(msg)
        elif errorCode == "E13":
            msg = "invalid N-value"
            raise self.FugMCPError(msg)
        elif errorCode == "E14":
            msg = "register is write only "
            raise self.FugMCPError(msg)
        elif errorCode == "E15":
            msg = "string too long"
            raise self.FugMCPError(msg)
        elif errorCode == "E16":
            msg = "wrong checksum"
            raise self.FugMCPError(msg)
        else:
            msg = "Unknown Error Code received."
            raise self.FugMCPError(msg)


# # Bit of code given as example by the manufacturer, upon which the present code was developed
##
# @file serial_com.py
#
# @author Birkmaier Thomas
#
# @version v0.00
#
# @par Development System
# - Hardware: --
# - IDE     : Microsoft Visual Studio Code
#
# @brief Example program to send commands using a COM Port.
#
# @details How to use this example:
#  - Use this link to set up Visual Studio Code for Python:
#    https://code.visualstudio.com/docs/python/python-tutorial
#  - Use information provided by this link to install pySerial library
#  - Run this Python script
#  - Program shows you available COM ports
#  - Choose the port you want to send commands to
#  - Example command ">S0 10.00"
#  - Device responds "#0 >S0:1.000000E+1"
#  - Example command ">S0?"
#  - Device responds "#1 >S0:0.000000E+00"
#  - Type "exit" to exit the program
#
# @note This is just an example to show how to create a connection. Be aware
# that This is not production ready code!
# def test():
#     # get available COM ports and store as list
#     com_ports = list(serial.tools.list_ports.comports())
#
#     # get number of available COM ports
#     no_com_ports = len(com_ports)
#
#     # print out user information
#     if no_com_ports > 0:
#         print("Total no. of available COM ports: " + str(no_com_ports))
#
#         # show all available COM ports
#         for idx, curr in enumerate(com_ports):
#             print("  " + str(idx) + ".)  " + curr.description)
#
#         # user chooses COM port to connect to -> if wrong value entered, stay in loop
#         while True:
#             try:
#                 com_port_idx = int(input("Enter number of COM port to connect to (0 - " +
#                                          str(no_com_ports - 1) + "): "))
#             except Exception:
#                 print("Incorrect value for COM port! Enter a Number (0 - " + str(no_com_ports - 1) + ")")
#                 continue
#             else:
#                 if com_port_idx > no_com_ports or com_port_idx < 0:
#                     continue
#                 break
#
#         # configure the COM port to talk to. Default values: 115200,8,N,1
#         com_port = serial.Serial(
#             port=com_ports[com_port_idx].device,  # chosen COM port
#             baudrate=115200,  # 115200
#             bytesize=serial.EIGHTBITS,  # 8
#             parity=serial.PARITY_NONE,  # N
#             stopbits=serial.STOPBITS_ONE  # 1
#         )
#
#         if com_port.is_open:
#             com_port.flushInput()
#             com_port.flushOutput()
#             print("Opened Port: " + com_ports[com_port_idx].device)
#
#             # while the entered cmd wasn't "exit"
#             while True:
#                 cmd = input(">>: ")  # get the cmd to send
#
#                 if cmd == 'exit':  # leave loop
#                     break
#                 else:
#                     # send cmd to device # might not work with older devices -> "LF" only needed!
#                     com_port.write((cmd + '\r\n').encode())
#                     sleep(0.1)  # small sleep for response
#
#                 response = ''
#
#                 while com_port.in_waiting > 0:
#                     response = com_port.readline()  # all characters received, read line till '\r\n'
#
#                 if response != '':
#                     print("<<: " + response.decode("utf-8"))  # decode bytes received to string
#                 else:
#                     raise ConnectionError("<< Error, no response received from power supply!")
#                     # print("<< Error, no Response!")
#
#         else:
#             print("Couldn't open Port!")
#             exit()
#
#     else:
#         print("No COM ports available!")
#         exit()


if __name__ == "__main__":
    PS = FugMCP(functionExecutionSleepTime=0.05)
    PS.Initialize(com_port_idx=0)
    print("Output state is: " + str(PS.getOutputState()))
    PS.setBehaviorVoltageRamp(2)
    PS.setCurrent(0.25)  # A
    print("Voltage ramp behavior is: " + str(PS.getBehaviorVoltageRamp()))
    print("Voltage ramp rate WAS: " + str(PS.getVoltageRampRate()))
    PS.setVoltageRampRate(250)  # V/s
    print("Voltage ramp rate changed!")
    print("Voltage ramp rate IS: " + str(PS.getVoltageRampRate()))
    PS.setVoltage(25)  # V
    print("Voltage setpoint changed!")
    PS.setOutputState(True)
    print("present voltage is: " + str(PS.getVoltage()))
    sleep(5)
    PS.setVoltage(50)
    sleep(5)
    PS.setOutputState(False)
    PS.Close()
