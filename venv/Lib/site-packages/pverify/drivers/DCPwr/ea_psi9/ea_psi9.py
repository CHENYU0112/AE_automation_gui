from __future__ import annotations

import contextlib
import typing

from pverify.core.lab.driver_identity import *
from pverify.drivers.BaseInstrument import BaseVisaInstrument, InstrumentError

CONDITIONBITS = {
    1: "OVP",
    2: "OCP",
    4: "OPP",
    8: "OT",
    16: "OVD",
    32: "UVD",
    64: "OCD",
    128: "UCD",
    256: "OPD",
}


class EA_PSI9(IdentityABC):
    # example IDN: HEIDEN power GmbH, PSI 9040-120, 1548100001, V2.08 04.08.2016 V2.14 04.04.2016 V1.6.4, \n
    VALID_IDN_SUBSTRINGS: typing.ClassVar = ["EA Elektro-Automatik", "HEIDEN power GmbH, PSI 9"]

    def __init__(self):
        self.interface = BaseVisaInstrument()
        self.__Initialized = False
        self.__Identity = Identity_SCPI(parent=self, rsrc_attr_name="interface")

    @property
    def Identity(self):
        return self.__Identity

    @property
    def Initialized(self):
        """
        Initialized is True between a successful call to the Initialize method
        and a successful call to the Close method, and False at all other
        times.
        """
        return self.__Initialized

    def Initialize(self, ResourceName, IdQuery=1, Reset=1, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties
        that access the instrument are only accessible after Initialize is
        called. Initialize optionally performs a Reset and queries the
        instrument to validate the instrument model.

        :param ResourceName:
            An IVI logical name or an instrument specific string that identifies
            the address of the instrument, such as a VISA resource descriptor
            string.
        :type ResourceName: str

        :param IdQuery:
            Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int

        :param Reset:
            Specifies whether to reset the instrument.
            :type Reset: bool|int

        :param OptionString:
            Provides additional functionality for the initialization process.

        :type OptionString: str
        """
        self.interface.ResourceName = ResourceName
        self.interface.vi_open()
        self.__Initialized = True

        self.SetRemoteMode()

        if IdQuery:
            ret = self.interface.vi_query("*IDN?")
            ret = ret.strip()
            self.IDN = ret
            if any(idn_substring in self.IDN for idn_substring in EA_PSI9.VALID_IDN_SUBSTRINGS):
                self.__Initialized = False
                self.interface.vi_close()
                msg = "Identification Error: Cant't find '{}' in the returned IDN string '{}'".format(
                    ret, "EA Elektro-Automatik"
                )
                raise ValueError(msg)

        if Reset:
            self.Reset()

        self.interface.vi_write("STAT:QUES:ENAB %d" % sum(CONDITIONBITS.keys()))

        with contextlib.suppress(Exception):
            self.GetError()

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and
        properties that access the instrument are not accessible after Close
        is called.
        """
        if self.__Initialized:
            self.__Initialized = False
            try:
                self.SetLocalMode()
            finally:
                self.interface.vi_close()

    def SetLocalMode(self):
        """
        Sets the instrument in LOCAL mode
        """
        self.interface.vi_write("SYST:LOCK 0")
        self.GetError()

    def SetRemoteMode(self):
        """
        Sets the instrument in REMOTE mode
        """
        self.interface.vi_write("SYST:LOCK 1")
        self.GetError()

    def Reset(self):
        """
        Resets the instrument
        """
        self.interface.vi_write("*RST")
        self.GetError()

    def GetError(self):
        """
        Queries the instrument for alarms and setup/programming errors and raises an Exception in this case
        """
        self.GetAlarm()

        ret = self.interface.vi_query("SYST:ERR:ALL?")
        if "no error" in ret.lower():
            return
        else:
            raise InstrumentError("An Instrument Error occurred: " + ret)

    def GetAlarm(self):
        """
        Queries the instrument for alarms and raises an Exception if an alarm occurred
        """
        event = int(self.interface.vi_query("STAT:QUES:EVEN?", rformat="%d"))
        errors = []
        errormsg = "One or multiple alarms occurred: "
        if event > 0:
            self.interface.vi_query("SYST:ERR:ALL?")
            for bitvalue, name in CONDITIONBITS.items():
                if event & bitvalue > 0:
                    errors.append(name)
            if len(errors):
                raise InstrumentError(errormsg + ", ".join(errors))

    def SetAlarmLevels(self, UVD=None, OVD=None, UCD=None, OCD=None, OPD=None):
        """
        Sets the alarm detection levels for the instrument. If an alarm occurred, calls to GetAlarm/GetError will raise
        an Exception if an alarm occurred

        :param UVD: Level for under-voltage detection
        :param OVD: Level for over-voltage detection
        :param UCD: Level for under-current detection
        :param OCD: Level for over-current detection
        :param OPD: Level for over-power detection
        """
        if UVD is not None:
            self.interface.vi_write(f"SYST:CONF:UVD {UVD:f}")
            self.interface.vi_write("SYST:CONF:UVD:ACT ALARM")
        if OVD is not None:
            self.interface.vi_write(f"SYST:CONF:OVD {OVD:f}")
            self.interface.vi_write("SYST:CONF:OVD:ACT ALARM")
        if UCD is not None:
            self.interface.vi_write(f"SYST:CONF:UCD {UCD:f}")
            self.interface.vi_write("SYST:CONF:UCD:ACT ALARM")
        if OCD is not None:
            self.interface.vi_write(f"SYST:CONF:OCD {OCD:f}")
            self.interface.vi_write("SYST:CONF:OCD:ACT ALARM")
        if OPD is not None:
            self.interface.vi_write(f"SYST:CONF:OPD {OPD:f}")
            self.interface.vi_write("SYST:CONF:OPD:ACT ALARM")
        self.GetError()

    def SetProtectionLevels(self, OVP=None, OCP=None, OPP=None):
        """
        Sets the protection levels for the instrument. If an event occurred, calls to GetAlarm/GetError will raise an
        Exception if an alarm occurred

        :param OVP: Level for over-voltage protection
        :param OCP: Level for over-current protection
        :param OPP: Level for over-power protection
        """

        if OVP is not None:
            self.interface.vi_write(f"VOLT:PROT:LEV {OVP:f}")
        if OCP is not None:
            self.interface.vi_write(f"CURR:PROT:LEV {OCP:f}")
        if OPP is not None:
            self.interface.vi_write(f"POW:PROT:LEV {OPP:f}")
        self.GetError()

    def SetInputLimits(self, Vmin=None, Vmax=None, Imin=None, Imax=None, Pmax=None, Rmax=None):
        """
        Sets the input limits for the instrument.

        Note: Input limits cannot be set lower that the currently set voltage/current/power

        :param Vmin: Minimum voltage
        :param Vmax: Maximum voltage
        :param Imin: Minimum current
        :param Imax: Maximum current
        :param Pmax: Maximum power
        :param Rmax: Maximum resitance
        """
        if Vmin is not None:
            self.interface.vi_write(f"SOUR:VOLT:LIM:LOW {Vmin:f}")
        if Vmax is not None:
            self.interface.vi_write(f"SOUR:VOLT:LIM:HIGH {Vmax:f}")
        if Imin is not None:
            self.interface.vi_write(f"SOUR:CURR:LIM:LOW {Imin:f}")
        if Imax is not None:
            self.interface.vi_write(f"SOUR:CURR:LIM:HIGH {Imax:f}")
        if Pmax is not None:
            self.interface.vi_write(f"SOUR:POW:LIM:HIGH {Pmax:f}")
        if Rmax is not None:
            self.interface.vi_write(f"SOUR:RES:LIM:HIGH {Rmax:f}")
        self.GetError()

    def SetVoltage(self, voltage):
        """
        Sets the nominal voltage
        """
        self.interface.vi_write(f"VOLT {voltage:f}")
        self.GetError()

    def SetCurrent(self, current):
        """
        Sets the nominal current
        """
        self.interface.vi_write(f"CURR {current:f}")
        self.GetError()

    def SetPower(self, power):
        """
        Sets the nominal power
        """
        self.interface.vi_write(f"POW {power:f}")
        self.GetError()

    def SetOutput(self, voltage=None, current=None, power=None):
        """
        Sets nominal voltage, current and power
        """
        if voltage is not None:
            self.SetVoltage(voltage)
        if current is not None:
            self.SetCurrent(current)
        if power is not None:
            self.SetPower(power)

    def GetVoltage(self):
        """
        Measures the current voltage.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:VOLT?", rformat="%f")
        self.GetError()
        return val

    def GetCurrent(self):
        """
        Measures the current current.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:CURR?", rformat="%f")
        self.GetError()
        return val

    def GetPower(self):
        """
        Measures the current power.

        :rtype: float
        """
        val = self.interface.vi_query("MEAS:POW?", rformat="%f")
        self.GetError()
        return val

    @property
    def OutputEnabled(self):
        enabled = "on" in self.interface.vi_query("OUTP?").lower()
        self.GetError()
        return enabled

    @OutputEnabled.setter
    def OutputEnabled(self, value):
        """
        Enables/Disabled the output
        """
        self.interface.vi_write("OUTP %d" % bool(value))
        self.GetError()


if __name__ == "__main__":
    dc = EA_PSI9()
    dc.Initialize(ResourceName="ASRL3::INSTR", IdQuery=1, Reset=1)
    dc.SetRemoteMode()

    dc.Close()
