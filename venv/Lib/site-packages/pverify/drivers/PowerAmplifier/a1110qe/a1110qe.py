from __future__ import annotations

import re
import time
from functools import wraps
from re import Pattern
from typing import AnyStr

import serial

from pverify.core.internals.logging_util import get_test_logger
from pverify.core.lab.driver_identity import IdentityBasic


class RetryOnError:
    def __init__(
        self,
        exceptiontype,
        retries,
        msg_regex: str | Pattern[AnyStr] | None = None,
        delay: int | float = 0,
        backoff: int | float = 1,
    ):
        """"""
        self.exceptiontype = exceptiontype
        self.msg_regex = re.compile(msg_regex) if msg_regex is not None else None
        self.retries = max(0, int(retries))
        self.delay = max(0, float(delay))
        self.backoff = backoff

    def __call__(self, f):
        """
        If there are decorator arguments, __call__() is only called
        once, as part of the decoration process! You can only give
        it a single argument, which is the function object.
        """

        @wraps(f)
        def retry_decorator(*args, **kwargs):
            mdelay = self.delay
            log = get_test_logger()

            for i in range(1, self.retries + 2, 1):
                try:
                    return f(*args, **kwargs)
                except self.exceptiontype as e:
                    if i == self.retries + 1:
                        raise
                    if self.msg_regex is None or self.msg_regex.match(str(e)):
                        log.warning(
                            f"RetryOnError: Try {i} of function {f.__name__!r} failed: {e.__class__.__name__}({str(e)!r}). Retrying..."
                        )
                        time.sleep(mdelay)  # wait...
                        mdelay *= self.backoff  # make future wait longer
                    else:
                        log.error(
                            f"Unspecified exception class {e.__class__.__name__}({str(e)!r}) occurred, not retrying..."
                        )
                        raise
                except Exception as e:
                    log.error(
                        f"Unspecified exception class {e.__class__.__name__}({str(e)!r}) occurred, not retrying..."
                    )
                    raise
            return None

        return retry_decorator


SUPPORTED_MODELS = "A1110-40-QE"


# Command Words
class Attr:
    class Readonly:
        # Read-only
        Temp = 0x04
        DeviceState = 0x10
        TurnOnState = 0x22
        TurnOnDelayAfterOL = 0x23
        AmplifierType = 0x24
        FirmwareVersion = 0x25
        AmplExtTurnOnConfig = 0x2F
        WorkParameters = 0x38
        FirmwareRevision = 0x3A
        ErrorStore = 0x42
        DeviceID = 0x51
        SensingOption = 0x5E

    class Writable:
        TurnOnState = 0x20
        TurnOnDelayAfterOL = 0x21
        CurrentMeasRange = 0x28
        RCNet = 0x29
        AmplifierMode = 0x2A
        ResetInterlockLatchingMode = 0x2B
        LimitValue = 0x2D
        AmplExtTurnOnConfig = 0x2E
        AmplifierState = 0x35
        DeviceID = 0x52
        LimitMode = 0x53
        WorkingVoltage = 0x54
        SensingOption = 0x5D


class A1110QE:
    """
    This instrument driver expects the instrument to be connected via USB. The Ethernet
    option is not supported by this driver.
    """

    class A1110QEError(Exception):
        pass

    class EchoMismatchError(A1110QEError):
        pass

    MAX_CURRENT_OUTPUT = 40.0
    MAX_VOLTAGE_OUTPUT = 75.0

    def __init__(self):
        self._ser: serial.Serial | None = None
        self._simulate: bool | None = False

        self.Identity = IdentityBasic(
            fct_idn=self.get_device_id, fct_drv_rev=lambda: "", fct_fw_rev=self.get_firmware_version
        )

    def __check_initialized(self):
        if self._ser is None:
            msg = "Driver has not been initialized yet!"
            raise self.A1110QEError(msg)

    def Initialize(
        self,
        ResourceName: str,
        IdQuery: bool | int = True,
        Reset: bool | int = False,
        OptionString: str = "timeout=1.0,simulate=False",
    ):
        """
        Opens the I/O session to the instrument. Driver methods and properties that
        access the instrument are only accessible after Initialize is called. Initialize
        optionally performs a Reset and queries the instrument to validate the
        instrument model.

        :param ResourceName: The name of the COM port.
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :param Reset: Specifies whether to reset the instrument.
        :param OptionString: The user can use the OptionsString parameter to specify the initial values of
            certain IVI inherent attributes for the session. The format of an assignment in
            the OptionsString parameter is "Name=Value", where Name is one of: RangeCheck,
            QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck, or
            DriverSetup. Value is either true or false except for DriverSetup. If the
            Options String parameter contains an assignment for the Driver Setup attribute,
            the Initialize function assumes that everything following "DriverSetup=" is part
            of the assignment.
        """
        options = {}
        for raw_option in OptionString.split(","):
            key, value = raw_option.split("=")
            if key.lower() == "simulate":
                if value.lower() == "false":
                    options[key.lower()] = False
                elif value.lower() == "true":
                    options[key.lower()] = True
                else:
                    msg = f"Invalid option. Expected value 'True'/'False' for '{key}', got '{value}' instead."
                    raise ValueError(msg)
            elif key.lower() == "timeout":
                try:
                    options[key.lower()] = float(value)
                except Exception:
                    msg = f"Invalid option. Expected float value for '{key}', got '{value}' instead."
                    raise ValueError(msg) from None
            else:
                msg = f"Unsupported option provided: '{raw_option}'"
                raise KeyError(msg)

        self._simulate = options.get("simulate")
        if self._simulate:
            return
        if Reset:
            msg = "This instrument does not support a remote reset."
            raise NotImplementedError(msg)
        self._ser = serial.Serial(port=ResourceName, timeout=options.get("timeout"))
        if IdQuery:
            device_id = self.get_device_id()
            if device_id not in SUPPORTED_MODELS:
                msg = f"Unsupported instrument. Expected '{SUPPORTED_MODELS}', got '{device_id}' instead."
                raise NotImplementedError(msg)

        self._ser.write_timeout = 1.0
        _ = self.get_error_store()
        self.set_current_limit(A1110QE.MAX_CURRENT_OUTPUT)

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        if self._simulate:
            return

        self.__check_initialized()
        if self._ser.is_open:
            self._ser.close()

    @RetryOnError(EchoMismatchError, retries=5, delay=0.1, backoff=1.5)
    def _query_cmd(
        self, command: int, retbytes: int, check_echo: str = "off", parameters: list[int] | None = None
    ) -> bytes | int | None:
        """
        Sends a command to the instrument, validates the response, evaluates instrument error codes and returns the
        response, depending on the command.

        :param command: A command string from the `Attr` class.
        :param retbytes: The number of bytes for the response.
        :param check_echo: The instrument sends either the command or parameter as confirmation for a received and
                           implemented command frame. Choice["off", "command", "parameter"]
        :param parameters: Optional command parameters.
        :return: The devices response.
        :raises: ValueError: for invalid `check_echo` values.
                 A1110QEError: for invalid and/or incomplete commands and options.
                 EchoMismatchError: when responses don't match the expectation.
        """
        if self._simulate:
            return None

        parameters = [] if parameters is None else parameters
        frame_length = 2 + len(parameters)
        _bytes = [frame_length, command]
        _bytes.extend(parameters)
        self._ser.write(bytes(_bytes))

        ret = bytes(self._ser.read(size=retbytes))
        # Checking response for the known error codes
        if len(ret) == 1 and ret[0] in (0xFC, 0xFD, 0xFE):
            msg = [
                "Invalid command or option!",
                "Timeout. An incomplete command frame was received!",
                "Unknown command!",
            ][[0xFC, 0xFD, 0xFE].index(ret[0])]
            msg = f"Exception 0x{ret[0]:02X} occurred: {msg}"
            raise self.A1110QEError(msg)
        else:
            # validate the response
            check_echo = str(check_echo).lower()
            if check_echo == "off":
                pass
            elif check_echo == "command":
                if ret[0] != command:
                    msg = f"Echo 0x{ret[0]:02X} and command 0x{command:02X} are not matching!"
                    raise self.EchoMismatchError(msg)
            elif check_echo == "parameter":
                if ret != bytes(parameters):
                    msg = f"Echo {ret} and parameters {parameters} are not matching!"
                    raise self.EchoMismatchError(msg)
            else:
                msg = f"Unknown option {check_echo!r} for argument 'check_echo'!"
                raise ValueError(msg)

            if len(ret) != retbytes:
                msg = (
                    f"Did not receive the correct amount of bytes from device. "
                    f"Expected: {retbytes}, Received: {len(ret)}"
                )
                raise self.A1110QEError(msg)
            if retbytes == 1:
                ret = ret[0]
            return ret

    def get_temperature(self) -> float:
        return float(self._query_cmd(command=Attr.Readonly.Temp, retbytes=1))

    def get_device_state(self) -> dict[str, bool]:
        state = self._query_cmd(command=Attr.Readonly.DeviceState, retbytes=1)
        return {
            "Ready": bool(state & (1 << 0)),
            "Overload": bool(state & (1 << 1)),
            "Overtemperature": bool(state & (1 << 2)),
            "DeviceOn": bool(state & (1 << 7)),
        }

    def get_turn_on_delay_after_ol(self) -> float:
        """Returns turn on delay after shutdown caused by overload. Unit is seconds."""
        return float(self._query_cmd(command=Attr.Readonly.TurnOnDelayAfterOL, retbytes=1))

    def get_amplifier_type(self) -> int:
        """Returns the amplifier type in Amps."""
        typ = self._query_cmd(command=Attr.Readonly.AmplifierType, retbytes=1)
        return {
            0x03: 5,
            0x04: 16,
            0x05: 40,
        }.get(typ)

    def get_firmware_version(self) -> str:
        """Returns Firmware version string."""
        major, minor = self._query_cmd(command=Attr.Readonly.FirmwareVersion, retbytes=2)
        revision = self._query_cmd(command=Attr.Readonly.FirmwareRevision, retbytes=2)
        return f"{major}.{minor}-{revision}"

    def get_ampl_ext_turnon_cfg(self):
        pass  # ToDo

    def get_working_parameters(self):
        """
        CurrentRange: 0=high, 1=low

        RCNetwork: 1-7

        OutputControlValue:

        InterlockState: 0=inactive, 1=active

        InterlockMode: 0=latching, 1=live

        OutputControlMode: 0=current, 1=voltage

        WorkingVoltage: see set_working_voltage

        """
        par = list(self._query_cmd(command=Attr.Readonly.WorkParameters, retbytes=12))
        return {
            "HighCurrentRange": not bool(par[0]),
            "RCNetwork": par[1],
            "OutputControlValue": par[4] * 256 + par[5],
            "InterlockState": par[8],
            "InterlockMode": par[9],
            "OutputControlMode": par[10],
            "WorkingVoltage": par[11],
        }

    def get_error_store(self):
        state = self._query_cmd(command=Attr.Readonly.ErrorStore, retbytes=1)
        return {
            "TransformerTempExceeded": bool(state & (1 << 0)),
            "WorkingVoltageExceeded": bool(state & (1 << 1)),
            "TemperatureExceeded": bool(state & (1 << 2)),
            "PowerLossExceeded": bool(state & (1 << 3)),
            "LowVoltageDetectionAtController": bool(state & (1 << 4)),
            "CurrentLimitExceeded": bool(state & (1 << 5)),
            "HardwareFailure": bool(state & (1 << 6)),
        }

    def get_device_id(self) -> str:
        return self._query_cmd(command=Attr.Readonly.DeviceID, retbytes=11).decode("ascii")

    def get_sensing(self) -> float:
        """
        Get Sensing Option

        (0: off; 1: 500mV; 2: 1000mV; 3: 2000mV)
        """
        opt = self._query_cmd(command=Attr.Readonly.SensingOption, retbytes=1)
        return {
            0: -1.0,
            1: 0.5,
            2: 1.0,
            3: 2.0,
        }.get(opt)

    def set_turn_on_state(self, ready_after_overload: bool, amp_on_at_switchon: bool, amp_on_after_ol: bool):
        """
        Sets the turn on state of the amp.

        :param ready_after_overload: Ready after overload (0:off; 1:on)
        :param amp_on_at_switchon: Amp enabled after switching on the instrument (0:off; 1:on)
        :param amp_on_after_ol: Amp enabled after switching on the instrument after overload event (0:off; 1:on)
        """
        self._query_cmd(
            command=Attr.Writable.TurnOnState,
            retbytes=1,
            check_echo="parameter",
            parameters=[
                (int(bool(ready_after_overload)) << 0)
                + (int(bool(amp_on_at_switchon)) << 1)
                + (int(bool(amp_on_after_ol)) << 2)
            ],
        )

    def set_turn_on_delay_after_ol(self, seconds: int):
        """
        Sets the turn on delay after shutdown caused by overload.

        :param seconds: Turn on delay (10 - 254) after overload shutdown. Unit is seconds.
        """
        if not (0x0A <= int(seconds) <= 0xFE):
            msg = f"Argument 'seconds' has to be between {10} and {254}"
            raise ValueError(msg)

        self._query_cmd(
            command=Attr.Writable.TurnOnDelayAfterOL, retbytes=1, check_echo="parameter", parameters=[int(seconds)]
        )

    def set_current_meas_range(self, high: bool):
        self._query_cmd(
            command=Attr.Writable.CurrentMeasRange, retbytes=1, check_echo="command", parameters=[int(not bool(high))]
        )

    def set_rc_net(self, net_number: int):
        if not (0x01 <= int(net_number) <= 0x07):
            msg = "Argument 'net_number' has to be between 0x01 and 0x07"
            raise ValueError(msg)

        self._query_cmd(command=Attr.Writable.RCNet, retbytes=1, check_echo="parameter", parameters=[int(net_number)])

    def set_amplifier_mode(self, mode: str):
        """
        Configure amplifier to operate in current or voltage control mode.

        :param mode: Choice["voltage", "current"]
        """
        mode = str(mode).lower()
        if "volt" in mode:
            mode = 0x00
        elif "curr" in mode:
            mode = 0x01
        else:
            msg = "mode must be either 'voltage' or 'current'!"
            raise ValueError(msg)
        self._query_cmd(command=Attr.Writable.AmplifierMode, retbytes=1, check_echo="command", parameters=[mode])

    def reset_interlock(self):
        self._query_cmd(
            command=Attr.Writable.ResetInterlockLatchingMode, retbytes=1, check_echo="command", parameters=[0x00]
        )

    def set_output_limit_mode(self, mode: str):
        """
        Configure amplifier output limit mode (current or voltage control).

        :param mode: Choice["voltage", "current"]
        """
        mode = str(mode).lower()
        if "volt" in mode:
            mode = 0x01  # yes, it's inverted to the amplifier mode parameter.
        elif "curr" in mode:
            mode = 0x00
        else:
            msg = "mode must be either 'voltage' or 'current'!"
            raise ValueError(msg)
        self._query_cmd(command=Attr.Writable.LimitMode, retbytes=1, check_echo="command", parameters=[mode])

    def set_output_limit_value(self, limit: int | float):
        """
        Configure amplifier output limit value, depending on the output limit mode.

        :param limit: The output limit. Unit is Amp or Volt.
        """

        if not (0x0000 <= int(limit) <= 0x0FFF):
            LIMIT_VAL_MIN = 0x0000
            LIMIT_VAL_MAX = 0x0FFF
            msg = f"Argument 'limit' has to be between {LIMIT_VAL_MIN} and {LIMIT_VAL_MAX}"
            raise ValueError(msg)

        limit = list(int(limit).to_bytes(2, "big", signed=False))
        self._query_cmd(command=Attr.Writable.LimitValue, retbytes=2, check_echo="parameter", parameters=limit)

    def set_current_limit(self, amps: int | float):
        """
        Configure amplifier to limit output current to the given value.

        :param amps: Output current limit. Unit is Amp.
        """
        MIN_REGISTER_VALUE = 0x000
        MAX_REGISTER_VALUE = 0xFFF
        limit_value = int((MAX_REGISTER_VALUE / A1110QE.MAX_CURRENT_OUTPUT) * amps)
        # clamping values between MIN_REGISTER_VALUE and MAX_REGISTER_VALUE
        limit_value = min(max(MIN_REGISTER_VALUE, limit_value), MAX_REGISTER_VALUE)
        self.set_output_limit_value(limit_value)
        self.set_output_limit_mode("current")

    def set_voltage_limit(self, volts: int | float):
        """
        Configure amplifier to limit output voltage to the given value.

        :param volts: Output voltage limit. Unit is Volt.
        """
        MIN_REGISTER_VALUE = 0x000
        MAX_REGISTER_VALUE = 0xFFF
        limit_value = int((MAX_REGISTER_VALUE / A1110QE.MAX_VOLTAGE_OUTPUT) * volts)
        # clamping values between MIN_REGISTER_VALUE and MAX_REGISTER_VALUE
        limit_value = min(max(MIN_REGISTER_VALUE, limit_value), MAX_REGISTER_VALUE)
        self.set_output_limit_value(limit_value)
        self.set_output_limit_mode("voltage")

    def set_ampl_ext_turnon_cfg(self):
        pass  # ToDo

    def set_amplifier_on(self):
        self._query_cmd(command=Attr.Writable.AmplifierState, retbytes=1, check_echo="parameter", parameters=[0x01])

    def set_amplifier_off(self):
        self._query_cmd(command=Attr.Writable.AmplifierState, retbytes=1, check_echo="parameter", parameters=[0x00])

    def set_device_id(self, device_id: str):
        return self._query_cmd(
            command=Attr.Writable.DeviceID, retbytes=1, check_echo="command", parameters=list(bytes(device_id, "ascii"))
        )

    def set_working_voltage(self, config: int):
        """
        ::

            config      Operating Voltage
                        +           -
            1              Automatic
            2           mid         low
            3           high        low
            4           low         mid
            5           mid         mid
            6           high        mid
            7           low         high
            8           mid         high
            9           high        high
        """
        self._query_cmd(
            command=Attr.Writable.WorkingVoltage, retbytes=1, check_echo="command", parameters=[int(config)]
        )

    def set_sensing(self, option: int):
        """
        Sets the Sensing Option

        :param option: (0: off; 1: 500mV; 2: 1000mV; 3: 2000mV)
        """
        self._query_cmd(command=Attr.Writable.SensingOption, retbytes=1, check_echo="command", parameters=[int(option)])
