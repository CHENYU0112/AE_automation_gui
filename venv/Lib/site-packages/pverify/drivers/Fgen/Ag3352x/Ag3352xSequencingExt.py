from __future__ import annotations

import contextlib
from typing import TYPE_CHECKING

from pverify import Waveform

from . import Ag3352x, Ag3352x_const
from .Ag3352x_const import *

if TYPE_CHECKING:
    from collections.abc import Iterable


class InstrumentError(Exception):
    pass


class PlayCtrl:
    @staticmethod
    def Repeat(count: int):
        """
        Repeat the waveform count times
        """
        return "repeat", int(count)

    Once = ("once", 1)  # Play waveform only once
    OnceWaitTrig = ("onceWaitTrig", 1)  # play once and wait for trigger to advance. Holds the last waveform point.
    RepeatInf = ("repeatinf", 1)  # repeat until stopped (infinite).
    RepeatTillTrig = ("repeatTilTrig", 1)  # repeat until triggered then advance.


class SegmentCfg:
    def __init__(self, waveform: Waveform, playcontrol: tuple[str, int]):
        self.waveform = waveform
        self.playcontrol = playcontrol


class SigGen:
    @staticmethod
    def create_dc(offset, duration, samplerate):
        return Waveform.Generation.DC(int(duration * samplerate), samplerate, offset)

    @staticmethod
    def create_ramp(start_level, stop_level, duration, samplerate):
        return Waveform.Generation.Ramp(int(duration * samplerate), start_level, stop_level, 1.0 / duration)

    @staticmethod
    def create_triangle(amplitude, offset, start_phase, duration, samplerate):
        return Waveform.Generation.Triangle(int(duration * samplerate), amplitude, 1.0 / duration, offset, start_phase)

    @staticmethod
    def create_sine(amplitude, offset, start_phase, duration, samplerate):
        return Waveform.Generation.Sine(int(duration * samplerate), amplitude, 1.0 / duration, offset, start_phase)

    @staticmethod
    def create_square(amplitude, offset, dutycycle, duration, samplerate):
        return Waveform.Generation.Square(int(duration * samplerate), amplitude, 1.0 / duration, offset, dutycycle)

    @staticmethod
    def create_sawtooth(amplitude, offset, width, start_phase, duration, samplerate):
        return Waveform.Generation.Sawtooth(
            int(duration * samplerate), width, amplitude, 1.0 / duration, offset, start_phase
        )


class Ag3352xSequencingExt(Ag3352x):
    C = CONST = Ag3352x_const
    CH1 = "Channel1"
    CH2 = "Channel2"

    def Initialize(self, ResourceName, IdQuery, Reset, OptionString=""):
        super().Initialize(ResourceName, IdQuery, Reset, OptionString)
        with contextlib.suppress(Exception):
            self.check_error()
        self._channels = {1: self.CH1, 2: self.CH2}

    def check_error(self):
        errors = []
        while True:
            ret = self.error_query()
            if ret[0] == 0:
                break
            errors.append(ret)
        if len(errors):
            raise InstrumentError("; ".join([f"{err[0]}, {err[1]}" for err in errors]))

    def ext_output_dc(self, dc_voltage: float, channel: str = CH1):
        self.ConfigureOutputImpedance(channel, 0)  # HighZ
        self.ConfigureOperationMode(channel, AG3352X_VAL_OPERATE_CONTINUOUS)
        self.ConfigureOutputMode(AG3352X_VAL_OUTPUT_FUNC)
        self.ConfigureStandardWaveform(channel, AG3352X_VAL_WFM_DC, 0, dc_voltage, 0, 0)
        self.check_error()

    def ext_output_on(self, channel: str = CH1):
        self.ConfigureOutputEnabled(channel, True)
        self.check_error()

    def ext_output_off(self, channel: str = CH1):
        self.ConfigureOutputEnabled(channel, False)
        self.check_error()

    def ext_configure_sequence(
        self, segment_cfg: list[SegmentCfg], max_offset=None, min_samplerate=None, scale=1.0, channel: str = CH1
    ):
        """
                Configures a sequence with arbitrary waveforms

                :param segment_cfg: A list of segment configurations
                :param max_offset: The maximum offset the Fgen can output. Typically 5V.
                :param min_samplerate: The minimal samplerate to use. If not given the greatest samplerate of all waveforms
                                       in the segment config will be used and others will be upsampled to that rate.
                :param scale: Optional scaling of the entire waveform. Useful if an amplifier is used to amplify the output.
                              E.g. for amplifier with factor 10 set scale to 0.1.
                :param channel: The channel name where the configuration shall be applied
        1"""
        wfs, offs, gain, srate = Ag3352xSequencingExt._prepare_waveforms(
            waveforms=[sc.waveform * scale for sc in segment_cfg], max_offset=max_offset, min_samplerate=min_samplerate
        )

        ch = channel

        self.ClearArbMemory()
        # self.ConfigureTriggerSource(ch, AG3352X_VAL_TRIGGER_SOURCE_BUS)  # SW Trigger is BUS here!
        # self.ConfigureTriggerSource(ch, AG3352X_VAL_TRIGGER_SOURCE_EXTERNAL)

        self.ClearArbMemory()
        for i, wf in enumerate(wfs):
            # self.ChannelOutputFunctionArbitraryWaveformLoadArbWaveform(ch, f"ARBSEG{i}", len(wf.data), wf.data)
            self.SystemWriteString(f"DATA:ARB ARBSEG{i}, {','.join(map(str, wf.data))}")
            self.check_error()

        self.ChannelOutputFunctionArbitraryWaveformCreateArbSequence(
            ch,
            "ARBSEQ",
            len(segment_cfg),
            ",".join([f"ARBSEG{i}" for i in range(len(segment_cfg))]),
            [sc.playcontrol[1] for sc in segment_cfg],
            ",".join([sc.playcontrol[0] for sc in segment_cfg]),
            ",".join(["maintain"] * len(segment_cfg)),
            [0] * len(segment_cfg),
        )
        self.check_error()
        self.ChannelOutputFunctionArbitraryWaveformSelectArbWaveform(ch, "ARBSEQ")
        self.SetAttributeViInt32(ch, AG3352X_ATTR_CHANNEL_OUTPUTFUNCTION_FUNCTION, AG3352X_VAL_OUTPUT_FUNCTION_ARB)
        self.SetAttributeViReal64(ch, AG3352X_ATTR_CHANNEL_OUTPUT_LOAD, 0)
        self.SetAttributeViReal64(ch, AG3352X_ATTR_ARB_OFFSET, offs)
        self.SetAttributeViReal64(ch, AG3352X_ATTR_ARB_GAIN, gain)
        self.SetAttributeViReal64(ch, AG3352X_ATTR_CHANNEL_OUTPUTFUNCTION_ARBITRARYWAVEFORM_SAMPLE_RATE, srate)
        self.check_error()

    @staticmethod
    def _prepare_waveforms(waveforms: Iterable[Waveform], max_offset=None, min_samplerate=None):
        fgen_samplerate = max([wf.samplerate for wf in waveforms])
        if min_samplerate is not None:
            fgen_samplerate = max(min_samplerate, fgen_samplerate)

        if any(wf.Measurements_Base.min() < 0 for wf in waveforms):
            msg = "One of the waveforms has values less than 0!"
            raise ValueError(msg)

        processed_wfs = [wf.copy().change_samplerate(fgen_samplerate) for wf in waveforms]

        concatenated = processed_wfs[0].copy()
        for wf in processed_wfs[1:]:
            concatenated = concatenated.extend(wf)

        fgen_offset = (max(concatenated.data) + min(concatenated.data)) / 2.0
        if max_offset is not None:
            fgen_offset = min(max_offset, fgen_offset)
        fgen_gain = max(abs(max(concatenated.data) - fgen_offset), abs(min(concatenated.data) - fgen_offset))

        for i, _ in enumerate(processed_wfs):
            processed_wfs[i] -= fgen_offset
            processed_wfs[i] /= fgen_gain

        return processed_wfs, fgen_offset, fgen_gain, fgen_samplerate


if __name__ == "__main__":
    pass
