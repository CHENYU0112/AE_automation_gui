from __future__ import annotations

from time import sleep

from pverify.drivers.SimplifiedLabInstruments._simple_instr.simple_instrument import (
    SimpleInstrument,
    SimpleInstrumentChannel,
)

from .ykwt500 import IIfxPwrAn as IIfxPwrAn_ykwt500
from .ykwt1800 import IIfxPwrAn as IIfxPwrAn_ykwt1800
from .ykwt3000 import IIfxPwrAn as IIfxPwrAn_ykwt3000


class SimpleYKWT(SimpleInstrument):
    def __init__(self, driver, LinkTo=None):
        if not isinstance(driver, (IIfxPwrAn_ykwt500, IIfxPwrAn_ykwt1800, IIfxPwrAn_ykwt3000)):
            msg = "You may only pass instances of IIfxPwrAn to argument 'driver'!"
            raise TypeError(msg)
        super().__init__(driver)

        if LinkTo is not None and LinkTo is not self:
            if isinstance(LinkTo, SimpleYKWT):
                self.__link = LinkTo
            else:
                self.__link = SimpleYKWT(LinkTo)
        else:
            self.__link: SimpleYKWT = None

        self._PASetting = {"CrestFactor": 6, "UpdateRate": 1.0, "AvgCount": 0.0, "Ranges": {}}

    @property
    def Initialized(self):
        return self.lld.Initialized

    @property
    def lld(self) -> IIfxPwrAn_ykwt500 | (IIfxPwrAn_ykwt1800 | IIfxPwrAn_ykwt3000):
        return self._lld

    def drivername(self) -> str:
        return self.lld.drivername

    def Initialize(self, ResourceName, IdQuery, Reset, OptionString=""):
        """
        Opens the I/O session to the instrument. Driver methods and properties
        that access the instrument are only accessible after Initialize is
        called. Initialize optionally performs a Reset and queries the
        instrument to validate the instrument model.

        :param ResourceName: An IVI logical name or an instrument specific string that identifies
            the address of the instrument, such as a VISA resource descriptor
            string.
        :type ResourceName: str
        :param IdQuery: Specifies whether to verify the ID of the instrument.
        :type IdQuery: bool|int
        :param Reset: Specifies whether to reset the instrument.
        :type Reset: bool|int
        :param OptionString:
            Provides additional functionality for the initialization process.
        :type OptionString: str
        """

        self.lld.Initialize(ResourceName, IdQuery, Reset, OptionString)

    def Close(self):
        """
        Closes the I/O session to the instrument. Driver methods and properties that
        access the instrument are not accessible after Close is called.
        """
        self.lld.Close()

    def PowerAnalyzerSetup(
        self,
        SyncSource,
        UpdateRate=1.0,
        AverageCount=0.0,
        AverageType="EXP",
        CrestFactor=6,
        WiringSettings=None,
        HarmMaxOrder=50,
    ):
        """
        Sets the most commonly used parameters for the power analyzer.

        :param SyncSource: The source the power analyzer shall synchronize on when measuring. This function will
                           automatically take the voltage of the selected source element as synchronization source.
        :type SyncSource: int
        :param UpdateRate: The time in s the PA waits between updating the measurements.

                           NOTE: If UpdateRate is less than 1 second, it is not possible to acquire waveforms!
        :type UpdateRate: float
        :param AverageCount: The number of samples that are used to calculate the moving average.

                             Averaging is disabled if 0.
        :type AverageCount: int
        :param AverageType: How the moving average is calculated. Values: "LIN" or "EXP".
        :type AverageType: str
        :param CrestFactor: The crest factor is defined as the ratio of the peak value of the waveform to the rms value.

                            WT3000: The crest factor on the WT3000 is determined by the maximum peak value that can be
                            applied for rated input in terms of a multiplication factor.
        :type CrestFactor: int
        :param WiringSettings: The wiring setting of the PA. Default: "1P2W".
        :type WiringSettings: str
        :param HarmMaxOrder: The max order of harmonics to return
        :type HarmMaxOrder: int
        """
        if self.lld.Initialized:
            if self.lld.drivername == "YK_WT500" and not 1 <= SyncSource <= 3:
                msg = "Only channels 1-3 available for YK_WT500 devices."
                raise Exception(msg)
            elif self.lld.drivername == "YK_WT3000" and not 1 <= SyncSource <= 4:
                msg = "Only channels 1-4 available for YK_WT3000 devices."
                raise Exception(msg)
            elif self.lld.drivername == "YK_WT1800" and not 1 <= SyncSource <= 6:
                msg = "Only channels 1-6 available for YK_WT1800 devices."
                raise Exception(msg)
            if not HarmMaxOrder >= 0:
                msg = "HarmonicOrders has to be greater or equal than 0."
                raise Exception(msg)
            if self.lld.drivername in ["YK_WT1800", "YK_WT3000", "YK_WT500"]:
                self.lld.interface.vi_write(":HARM:PLLS U%d" % int(SyncSource))
                self.lld.interface.vi_write(":SYNC U%d" % int(SyncSource))
            self.lld.Harmonics.SetOrder(0, HarmMaxOrder)
            self.lld.Measurements.CrestFactor = CrestFactor
            self._PASetting["CrestFactor"] = CrestFactor
            self.lld.Measurements.UpdateRate = UpdateRate
            self._PASetting["UpdateRate"] = UpdateRate
            self.lld.Display(self.lld.Enums.IfxPwrAnDisplayModeEnum.IfxPwrAnDisplayModeNumeric)

            self.lld.Measurements.AvgEnabled = bool(AverageCount > 1)
            self._PASetting["AvgCount"] = AverageCount
            if str(AverageType).upper() == "LIN":
                self.lld.Measurements.AvgType = self.lld.Enums.IfxPwrAnAvgTypeEnum.IfxPwrAnAvgTypeLIN
            elif str(AverageType).upper() == "EXP":
                self.lld.Measurements.AvgType = self.lld.Enums.IfxPwrAnAvgTypeEnum.IfxPwrAnAvgTypeEXP
            self.lld.Measurements.AvgCount = AverageCount

            if WiringSettings:
                self.lld.Channels.WiringSetting = WiringSettings
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def Arm(self, IntegrationTime=0, SkipWaitAutoRangeSettled=False):
        """
        Arms the acquisition of the probe.\n
        Lab:
        Automatically scales the channels (if range is set to 0) and waits for one or more updates of the PowerAnalyzer,
        depending on AvgCount (set in PowerAnalyzerSetup) and IntegrationTime.
        If the integration time is less than UpdateRate times AvgCount, the remaining time difference is waited.
        If the integration time is 0 the waiting time is UpdateRate times AvgCount, but at least one update.

        :param IntegrationTime: The time in seconds the PA integrates voltage and current for more precise measurement.
        :type IntegrationTime: float
        :param SkipWaitAutoRangeSettled: If enabled the routine for waiting for the autorange to settle is skipped.
                                         If the range is already settled or set to fixed range enabling this parameter will increase the readout speed.
        :type SkipWaitAutoRangeSettled: bool|int
        """
        if self.lld.Initialized:
            self._PASetting["IntegrationTime"] = IntegrationTime
            avg_en = self.lld.Measurements.AvgEnabled
            if avg_en:
                self.lld.Integration.ResetIntegration()
                self.lld.Measurements.AvgEnabled = False
            if not SkipWaitAutoRangeSettled:
                self.lld.Channels.WaitAutoRangeSettled()
                if self.__link:
                    self.__link.lld.Channels.WaitAutoRangeSettled()
            if avg_en:
                self.lld.Measurements.AvgEnabled = True

            try:
                if IntegrationTime > 0:
                    if self.__link:
                        self.__link.lld.Integration.StartIntegrationWithTimer(IntegrationTime, Wait=False)
                    self.lld.Integration.StartIntegrationWithTimer(IntegrationTime, Wait=True)
                    if self.__link and (
                        self.__link.lld.Integration.State
                        != self.lld.Enums.IfxPwrAnIntegrationStateEnum.IfxPwrAnIntegrationStateTimeup
                    ):
                        self.__link.lld.Integration.StopIntegration()
                    if IntegrationTime < self._PASetting["UpdateRate"] * self._PASetting["AvgCount"]:
                        # If integration time is less than the time the PA needs for averaging other values
                        # the time difference is waited
                        sleep(self._PASetting["UpdateRate"] * self._PASetting["AvgCount"] - IntegrationTime)
                    self.lld.Measurements.HoldNumeric(True)
                    if self.__link:
                        self.__link.lld.Measurements.HoldNumeric(True)
                elif IntegrationTime == 0 and self._PASetting["AvgCount"] >= 1:
                    self.lld.Measurements.WaitUpdate(self._PASetting["AvgCount"])
                    self.lld.Measurements.HoldNumeric(True)
                    if self.__link:
                        self.__link.lld.Measurements.WaitUpdate(self.__link._PASetting["AvgCount"])
                        self.__link.lld.Measurements.HoldNumeric(True)
                else:
                    self.lld.Measurements.WaitUpdate(1)
                    self.lld.Measurements.HoldNumeric(True)
                    if self.__link:
                        self.__link.lld.Measurements.WaitUpdate(1)
                        self.__link.lld.Measurements.HoldNumeric(True)
            except KeyError as e:
                raise Exception(
                    "Please call PowerAnalyzerSetup before calling this method. Original exception: " + str(e)
                ) from None
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ResetIntegration(self):
        if self.lld.Initialized:
            if self.lld.Integration.State == self.lld.Enums.IfxPwrAnIntegrationStateEnum.IfxPwrAnIntegrationStateStart:
                self.lld.Integration.StopIntegration()
            self.lld.Integration.ResetIntegration()

    def GetChannel(self, Index):
        """
        Returns a channel object. The different channels can be set up indepentently from each other

        :param Index: The index of the channel
        :type Index: int
        :return: _SimplePowerAnalyzerChannel instance
        :rtype: _SimplePowerAnalyzerChannel
        """
        ccount = self.lld.Channels.Count
        if Index > ccount:
            raise Exception("Only %d channels available on this instrument!" % ccount)
        return SimpleYKWTChannel(self, Index)


class SimpleYKWTChannel(SimpleInstrumentChannel):
    def __init__(self, parent, channel_index):
        super().__init__(parent, channel_index)
        self._PASetting["Ranges"].update({self._ch_index: [0, 0, True, True]})
        self._lld_ch_name = self.lld.Channels.Name(self._ch_index)
        self._lld_ch = self.lld.Channels.Item(self._lld_ch_name)

    @property
    def lld(self) -> IIfxPwrAn_ykwt500 | (IIfxPwrAn_ykwt1800 | IIfxPwrAn_ykwt3000):
        return super().lld

    @property
    def lld_ch(self):
        return self._lld_ch

    @property
    def _PASetting(self) -> dict:
        return self._parent._PASetting

    def ProbeSetup(
        self,
        UIMeasurementMode="RMS",
        LineFilter=None,
        FrequencyFilter=True,
        CurrentRange=0,
        VoltageRange=0,
        WireCompensation="OFF",
        CurrentScaling=0,
    ):
        """
        Sets the most commonly used parameters for a channel

        :param UIMeasurementMode: The mode how the voltage or current is measured when selecting the 'Voltage'
                                  measurement in method 'GetProbeMeasurement'. Use with: "RMS","DC","MEAN","RMEAN"
        :type UIMeasurementMode: str
        :param LineFilter: The filter bandwidth that is applied to the line the probe measures.
        :type LineFilter: float
        :param FrequencyFilter: Acts as a filter for detecting the zero-crossing of the
                                synchronization source signal more accurately.
        :type FrequencyFilter: bool
        :param CurrentRange: The current range the PwrAn measures with. 0 means auto range.
        :type CurrentRange: float
        :param VoltageRange: The voltage range the PwrAn measures with. 0 means auto range.
        :type VoltageRange: float
        :param WireCompensation: Sets the wire compensation for current-right or voltage-right measurement.
                                     (""OFF", "U-I", "I-U")\n
                                     UI:\n
                                     This is used when the voltage measurement circuit is connected to the load side.
                                     The measured voltage is determined by subtracting the voltage applied to the current
                                     terminal from the voltage value of each element. The voltage applied to the current
                                     terminal is derived by the equation: the measured current * the input resistance of the
                                     current terminal.\n\n
                                     IU:\n
                                     This is used when the current measurement circuit is connected to the load side.
                                     The measured current is determined by subtracting the current that flows through the
                                     voltage terminal from the current value of each element. The current that flows
                                     through the voltage terminal is derived by the equation: the measured voltage/the
                                     input resistance of the voltage terminal.

                                Available only for YKWT3000!
        :type WireCompensation: str
        """
        if self.lld.Initialized:
            istate = self.lld.Integration.State
            if istate == self.lld_ch.Enums.IfxPwrAnIntegrationStateEnum.IfxPwrAnIntegrationStateStart:
                self.lld.Integration.StopIntegration()
                self.lld.Integration.ResetIntegration()
            elif istate == self.lld_ch.Enums.IfxPwrAnIntegrationStateEnum.IfxPwrAnIntegrationStateStop:
                self.lld.Integration.ResetIntegration()

            self.lld_ch.FrequencyFilter = FrequencyFilter
            if LineFilter:
                self.lld_ch.LineFilter = LineFilter
            self.lld_ch.CurrentScaling = CurrentScaling
            if CurrentRange == 0:
                self.lld_ch.CurrentRange, self.lld_ch.AutoRangeCurrent = 100, True
            else:
                self.lld_ch.CurrentRange, self.lld_ch.AutoRangeCurrent = (
                    CurrentRange,
                    False,
                )
            if VoltageRange == 0:
                self.lld_ch.VoltageRange, self.lld_ch.AutoRangeVoltage = 1000, True
            else:
                self.lld_ch.VoltageRange, self.lld_ch.AutoRangeVoltage = (
                    VoltageRange,
                    False,
                )
            self._PASetting["Ranges"].update({self._ch_index: [VoltageRange, CurrentRange]})
            if self.lld.drivername in ["YK_WT3000"]:
                _wireComp = str(WireCompensation).upper()
                if _wireComp == "OFF":
                    self.lld_ch.WireCompensation = (
                        self.lld_ch.Enums.IfxPwrAnWireCompensationEnum.IfxPwrAnWireCompensationOff
                    )
                elif _wireComp == "U-I" or _wireComp == "UI":
                    self.lld_ch.WireCompensation = (
                        self.lld_ch.Enums.IfxPwrAnWireCompensationEnum.IfxPwrAnWireCompensationUI
                    )
                elif _wireComp == "I-U" or _wireComp == "IU":
                    self.lld_ch.WireCompensation = (
                        self.lld_ch.Enums.IfxPwrAnWireCompensationEnum.IfxPwrAnWireCompensationIU
                    )

            if str(UIMeasurementMode).upper() == "RMS":
                self.lld_ch.MeasuringMode = self.lld_ch.Enums.IfxPwrAnMeasuringModeEnum.IfxPwrAnMeasuringModeRMS
            if str(UIMeasurementMode).upper() == "DC":
                self.lld_ch.MeasuringMode = self.lld_ch.Enums.IfxPwrAnMeasuringModeEnum.IfxPwrAnMeasuringModeDC
            if str(UIMeasurementMode).upper() == "MEAN":
                self.lld_ch.MeasuringMode = self.lld_ch.Enums.IfxPwrAnMeasuringModeEnum.IfxPwrAnMeasuringModeMEAN
            if str(UIMeasurementMode).upper() == "RMEAN":
                self.lld_ch.MeasuringMode = self.lld_ch.Enums.IfxPwrAnMeasuringModeEnum.IfxPwrAnMeasuringModeRMEAN
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def ResetRanges(self, CurrentRange=0, VoltageRange=0):
        """
        Resets the voltage and current range to certain values.

        :param CurrentRange: The current range the PwrAn measures with. 0 means auto range.
        :type CurrentRange: float
        :param VoltageRange: The voltage range the PwrAn measures with. 0 means auto range.
        :type VoltageRange: float
        """
        if self.lld.Initialized:
            self._parent.ResetIntegration()
            if CurrentRange == 0:
                self.lld_ch.CurrentRange, self.lld_ch.AutoRangeCurrent = 100, True
            else:
                self.lld_ch.CurrentRange, self.lld_ch.AutoRangeCurrent = (
                    CurrentRange,
                    False,
                )
            if VoltageRange == 0:
                self.lld_ch.VoltageRange, self.lld_ch.AutoRangeVoltage = 1000, True
            else:
                self.lld_ch.VoltageRange, self.lld_ch.AutoRangeVoltage = (
                    VoltageRange,
                    False,
                )
            self._PASetting["Ranges"].update({self._ch_index: [VoltageRange, CurrentRange]})
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def GetProbeMeasurement(self, MeasurementItem):
        """
        Returns a specific measurement for the channel.

        :param MeasurementItem: The measurement that is returned.
                                Items:
                                Voltage, Current, Power, ApparentPower, ReactivePower, Lambda,
                                Phi, FreqU, FreqI, VoltagePlusPeak, VoltageMinusPeak, CurrentPlusPeak,
                                CurrentMinusPeak, WattHours, WattHoursPlus, WattHoursMinus, AmpereHours,
                                AmpereHoursPlus, AmpereHoursMinus, ETA, PhiU, PhiI, UThd, IThd, PThd

                                And user fucntions F1 ... F20
        :type MeasurementItem: str
        :return: Measured value.
        :rtype: float
        """
        if self.lld.Initialized:
            _MeasurementItem = str(MeasurementItem).upper()
            item = None
            if _MeasurementItem == "VOLTAGE":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemVoltage
            elif _MeasurementItem == "CURRENT":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemCurrent
            elif _MeasurementItem == "POWER":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemPower
            elif _MeasurementItem == "AVGPOWER":
                if self._PASetting["IntegrationTime"] == 0:
                    item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemPower
                elif self.lld.drivername in ["YK_WT3000", "YK_WT500", "YK_WT1800"]:
                    item = getattr(
                        self.lld.Enums.IfxPwrAnMeasItemEnum,
                        "IfxPwrAnMeasItemUserFct%d" % self._ch_index,
                    )
                else:
                    msg = f"{self.lld.drivername} does not support average power measurement!"
                    raise Exception(msg)
            elif _MeasurementItem == "APPARENTPOWER":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemApparentPower
            elif _MeasurementItem == "REACTIVEPOWER":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemReactivePower
            elif _MeasurementItem == "LAMBDA":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemLambda
            elif _MeasurementItem == "PHI":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemPhi
            elif _MeasurementItem == "FREQU":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemFreqU
            elif _MeasurementItem == "FREQI":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemFreqI
            elif _MeasurementItem == "VOLTAGEPLUSPEAK":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemVoltagePlusPeak
            elif _MeasurementItem == "VOLTAGEMINUSPEAK":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemVoltageMinusPeak
            elif _MeasurementItem == "CURRENTPLUSPEAK":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemCurrentPlusPeak
            elif _MeasurementItem == "CURRENTMINUSPEAK":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemCurrentMinusPeak
            elif _MeasurementItem == "WATTHOURS":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemWattHours
            elif _MeasurementItem == "WATTHOURSPLUS":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemWattHoursPlus
            elif _MeasurementItem == "WATTHOURSMINUS":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemWattHoursMinus
            elif _MeasurementItem == "AMPEREHOURS":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemAmpereHours
            elif _MeasurementItem == "AMPEREHOURSPLUS":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemAmpereHoursPlus
            elif _MeasurementItem == "AMPEREHOURSMINUS":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemAmpereHoursMinus
            elif _MeasurementItem == "ETA":
                if self.lld.drivername in ["YK_WT3000", "YK_WT500", "YK_WT1800"]:
                    item = getattr(
                        self.lld.Enums.IfxPwrAnMeasItemEnum,
                        "IfxPwrAnMeasItemETA%d" % self._ch_index,
                    )
                else:
                    msg = f"{self.lld.drivername} does not support ETA measurement!"
                    raise Exception(msg)
            elif _MeasurementItem == "PHIU":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemPhiU
            elif _MeasurementItem == "PHII":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemPhiI
            elif _MeasurementItem == "UTHD":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemUThd
            elif _MeasurementItem == "ITHD":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemIThd
            elif _MeasurementItem == "PTHD":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemPThd
            elif _MeasurementItem == "ITHF":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemIthf
            elif _MeasurementItem == "UTHF":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemUthf
            elif _MeasurementItem == "ITIF":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemItif
            elif _MeasurementItem == "UTIF":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemUtif
            elif _MeasurementItem == "HVF":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemHvf
            elif _MeasurementItem == "HCF":
                item = self.lld.Enums.IfxPwrAnMeasItemEnum.IfxPwrAnMeasItemHcf
            elif _MeasurementItem in ["F%d" % i for i in range(1, 21, 1)]:
                fnum = int(_MeasurementItem[1:])
                item = getattr(
                    self.lld.Enums.IfxPwrAnMeasItemEnum,
                    "IfxPwrAnMeasItemUserFct%d" % fnum,
                )

            if item in self.lld.Enums.IfxPwrAnMeasItemEnum:
                measItem = self.lld.Measurements.Item(self._ch_index, item)
                return measItem.Value
            else:
                msg = f"Could not find a measurement item for input '{MeasurementItem}'"
                raise ValueError(msg)
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)

    def GetProbeHarmonicMeasurement(self, MeasurementItem):
        """
        Returns a specific harmonic measurement for the channel.

        :param MeasurementItem: The measurement that is returned.
                                Items:
                                Voltage, Current, Power, ApparentPower, ReactivePower, Lambda,
                                Phi, FreqU, FreqI, Z, Rs, Xs, Rp, Xp, PhiU, PhiI, Uhdf, Ihdf, Phdf
        :type MeasurementItem: str
        :return: A list of harmonics items is returned ([DC, Fundamental, ... n-th harmonic])
        :rtype: list[float]
        """
        if self.lld.Initialized:
            _MeasurementItem = str(MeasurementItem).upper()
            item = None
            if _MeasurementItem == "VOLTAGE":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemVoltage
            elif _MeasurementItem == "CURRENT":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemCurrent
            elif _MeasurementItem == "POWER":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemPower
            elif _MeasurementItem == "APPARENTPOWER":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemApparentPower
            elif _MeasurementItem == "REACTIVEPOWER":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemReactivePower
            elif _MeasurementItem == "LAMBDA":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemLambda
            elif _MeasurementItem == "PHI":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemPhi
            elif _MeasurementItem == "PHIU":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemPhiU
            elif _MeasurementItem == "PHII":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemPhiI
            elif _MeasurementItem == "UHDF":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemUhdf
            elif _MeasurementItem == "IHDF":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemIhdf
            elif _MeasurementItem == "PHDF":
                item = self.lld.Enums.IfxPwrAnHarmMeasItemEnum.IfxPwrAnHarmMeasItemPhdf

            if item in self.lld.Enums.IfxPwrAnHarmMeasItemEnum:
                measItem = self.lld.Measurements.Item_Harmonic(self._ch_index, item)
                return measItem.Value
            else:
                msg = f"Could not find a harmonic measurement item for input '{MeasurementItem}'"
                raise ValueError(msg)
        else:
            msg = "Driver not initialized!"
            raise Exception(msg)
