# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $Rev$
# Date           : $Date$
# Last change by : $Author$
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

from pverify.drivers.PowerAnalyzer.ykwt500 import IIfxPwrAnBase


class IIfxPwrAnChannel(IIfxPwrAnBase.IIfxPwrAnBase):
    """IfxPowerAnalyzer class-compliant channel interface

    NOTE:
        Attributes/Methods marked with '#' do not exist for this instrument.
        Attributes/Methods marked with '*' are specific for this instrument.
        !Please consider when trying to program instrument independent.

    Attributes:
        CurrentExtSenseEnabled [Boolean] [rw]
            If True, the current will be measured with an external current sensor

        CurrentExtSenseRange [Float] [rw]
            The absolute value of the current input range the PwrAn can
            acquire for the channel if an external sensor if applied to
            measure the current. The units are volts.

        MeasuringMode [String] [rw]
            The mode how current or voltage is measured (Rms, Mean...)
            Values:
                "IfxPwrAnMeasuringModeEnumRMS"
                "IfxPwrAnMeasuringModeEnumMEAN"
                "IfxPwrAnMeasuringModeEnumDC"
                "IfxPwrAnMeasuringModeEnumRMEAN"

        CurrentRange [Float] [rw]
            The absolute value of the current input range the PwrAn can
            acquire for the channel. The units are amperes.
            0 value turns on AUTORANGE

        LineFilter [Float] [rw]
            Filtering bandwidth for line.

        MaxCurrentRange [r]
            The maximal current a module can supply.

        VoltageRange [Float] [rw]
            The absolute value of the voltage input range the PwrAn can
            acquire for the channel. The units are volts.
            0 value turns on AUTORANGE

        WireCompensation [String] [rw]
            Defines the wire compensation method.
            Values:
                "IfxPwrAnWireCompensationOff"
                "IfxPwrAnWireCompensationUI"
                "IfxPwrAnWireCompensationIU"

    Methods:
        ConfigureChannel(MeasuringMode, VoltageRange, CurrentRange, CurrentExtSenseEnabled,
                         CurrentExtSenseRange, LineFilter, WireCompensation)
            Configures the most commonly used properties of the PwrAn
            channel sub-system.

        ConfigureEtaMeasurement(self, NumeratorChannel, DenominatorChannel)
            Configures how the ETA value is measured.
            ETA = (NumeratorChannel/DenominatorChannel) * 100%
    """

    def __init__(self, parent, Name):
        IIfxPwrAnBase.IIfxPwrAnBase.__init__(self, parent)
        self.Element = int(Name)
        self.__CurrentExtSenseEnabled = False

    # Read only dependent properties
    @property
    def AutoRangeCurrent(self):
        ret = bool(self.interface.vi_query(f":CURR:AUTO:ELEM{self.Element}?", rformat="%d"))
        self.GetError()
        return ret

    @AutoRangeCurrent.setter
    def AutoRangeCurrent(self, value):
        self.interface.vi_write(":CURR:AUTO:ELEM{} {}".format(self.Element, ["OFF", "ON"][bool(value)]))
        self.GetError()

    @property
    def AutoRangeVoltage(self):
        ret = bool(self.interface.vi_query(f":VOLT:AUTO:ELEM{self.Element}?", rformat="%d"))
        self.GetError()
        return ret

    @AutoRangeVoltage.setter
    def AutoRangeVoltage(self, value):
        self.interface.vi_write(":VOLT:AUTO:ELEM{} {}".format(self.Element, ["OFF", "ON"][bool(value)]))
        self.GetError()

    @property
    def MaxCurrentRange(self):
        """
        The maximal current a module can supply.

        :rtype: str
        """
        ret = int(self.interface.vi_query(f":INP:MODU? {self.Element}", rformat="%s\n"))
        self.GetError()
        return ret

    # Read-write dependent properties
    @property
    def LineFilter(self):
        """
        How the lines of the PwrAn are filtered.

        :rtype: float
        """
        ret = self.interface.vi_query(f":FILT:LINE:ELEM{self.Element}?", rformat="%s")
        self.GetError()
        if ret.lower() == "off":
            return 0
        else:
            return float(ret)

    @LineFilter.setter
    def LineFilter(self, value):
        """
        How the lines of the PwrAn are filtered.

        :type value: float
        """
        value = float(value)
        if value:
            self.interface.vi_write(f":FILT:ELEM{self.Element} {value:.3f}")
        else:
            self.interface.vi_write(f":FILT:ELEM{self.Element} OFF")
        self.GetError()

    @property
    def FrequencyFilter(self):
        """
        Filter also acts as a filter for detecting the zero-crossing of the
        synchronization source signal more accurately.

        :rtype: bool
        """
        ret = self.interface.vi_query(f":FILT:FREQ:ELEM{self.Element}?", rformat="%s")
        self.GetError()
        if ret.lower() == "off":
            return 0
        else:
            return float(ret)

    @FrequencyFilter.setter
    def FrequencyFilter(self, value):
        """
        Filter also acts as a filter for detecting the zero-crossing of the
        synchronization source signal more accurately.

        :type value: bool
        """
        value = float(value)
        if value:
            self.interface.vi_write(f":FILT:FREQ:ELEM{self.Element} {value:.3f}")
        else:
            self.interface.vi_write(f":FILT:FREQ:ELEM{self.Element} OFF")
        self.GetError()

    @property
    def WireCompensation(self):
        """
        Defines the wire compensation method (Off, U-I, I-U)

        :rtype: IfxPwrAnWireCompensationEnum
        """
        ret = self.interface.vi_query(f":MEAS:COMP:WIR:ELEM{self.Element}?", rformat="%s")
        self.GetError()
        return self.Enums.enum_from_value(self.Enums.IfxPwrAnWireCompensationEnum, ret)

    @WireCompensation.setter
    def WireCompensation(self, value):
        """
        Defines the wire compensation method (Off, U-I, I-U)

        :type value: IfxPwrAnWireCompensationEnum
        """
        self.interface.vi_write(f":MEAS:COMP:WIR:ELEM{self.Element} {value.value}")
        self.GetError()

    # FIXME

    @property
    def CurrentScaling(self):
        """
        Filter also acts as a filter for detecting the zero-crossing of the
        synchronization source signal more accurately.

        :rtype: bool
        """
        ret = self.interface.vi_query(f":INP:SCAL:CT:ELEM{self.Element}?", rformat="%f")
        self.GetError()
        return bool(ret)

    @CurrentScaling.setter
    def CurrentScaling(self, value):
        """
        Scales the current that is measured on this channel

        :type value: float
        """
        if value <= 0:
            self.interface.vi_write(f":INP:SCAL:STAT:ELEM{self.Element} 0")
            self.interface.vi_write(f":INP:SCAL:CT:ELEM{self.Element} 1.000")
        else:
            self.interface.vi_write(f":INP:SCAL:STAT:ELEM{self.Element} 1")
            self.interface.vi_write(f":INP:SCAL:CT:ELEM{self.Element} {value:.4f}")
        self.GetError()

    @property
    def MeasuringMode(self):
        """
        The mode how voltage and current is measured (Rms, Mean...)

        :rtype: IfxPwrAnMeasuringModeEnum
        """
        return self._measuringMode[self.Element]

    @MeasuringMode.setter
    def MeasuringMode(self, value):
        """
        The mode how voltage and current is measured (Rms, Mean...)

        :type value: IfxPwrAnMeasuringModeEnum
        """
        self._measuringMode.update({self.Element: value})

    @property
    def VoltageRange(self):
        """
        The absolute value of the voltage input range the PwrAn can
        acquire for the channel. The units are volts.
        Negative values turn on AUTORANGE

        :rtype: float
        """
        ret = self.interface.vi_query(f":VOLT:RANG:ELEM{self.Element}?", rformat="%s")
        ret = float(ret.split(",", 1)[-1])
        self.GetError()
        return ret

    @VoltageRange.setter
    def VoltageRange(self, value=0):
        """
        The absolute value of the voltage input range the PwrAn can
        acquire for the channel. The units are volts.
        Negative values turn on AUTORANGE

        :type value: float
        """
        if value > 0:
            self.interface.vi_write(f":VOLT:RANG:ELEM{self.Element} {value:f}")
        else:
            self.interface.vi_write(f":VOLT:AUTO:ELEM{self.Element} ON")
        self.GetError()

    @property
    def CurrentRange(self):
        """
        The absolute value of the current input range the PwrAn can
        acquire for the channel. The units are amperes.
        Negative values turn on AUTORANGE

        :rtype: float
        """
        ret = self.interface.vi_query(f":CURR:RANG:ELEM{self.Element}?", rformat="%s")
        self.GetError()
        if ret.lower().startswith("ext"):
            return float(ret[4:])
        else:
            return float(ret)

    @CurrentRange.setter
    def CurrentRange(self, value=0):
        """
        The absolute value of the current input range the PwrAn can
        acquire for the channel. The units are amperes.
        Negative values turn on AUTORANGE

        :type value: float
        """
        if value > 0:
            self.interface.vi_write(f":CURR:RANG:ELEM{self.Element} {value:f}")
        else:
            self.interface.vi_write(f":CURR:AUTO:ELEM{self.Element} ON")
        self.GetError()

    @property
    def CurrentExtSenseRange(self):
        """
        The absolute value of the current input range the PwrAn can
        acquire for the channel if an external sensor if applied to
        measure the current. The units are volts.
        """
        ret = self.interface.vi_query(f":CURR:RANG:ELEM{self.Element}?", rformat="%s")
        self.GetError()
        if ret.lower().startswith("ext"):
            return float(ret[4:])
        else:
            msg = "External current sensor not enabled!"
            raise Exception(msg)

    @CurrentExtSenseRange.setter
    def CurrentExtSenseRange(self, value):
        """The absolute value of the current input range the PwrAn can
        acquire for the channel if an external sensor if applied to
        measure the current. The units are volts.

        :type value: float
        """
        self.CurrentExtSenseEnabled = True
        self.interface.vi_write(f":CURR:RANG:ELEM{self.Element} EXT,{value:f}")
        self.GetError()

    @property
    def CurrentExtSenseEnabled(self):
        """
        If TRUE, the current will be measured with an external current sensor
        """
        ret = self.interface.vi_query(f":CURR:RANG:ELEM{self.Element}?", rformat="%s")
        self.GetError()
        self.__CurrentExtSenseEnabled = ret.lower().startswith("ext")

        return self.__CurrentExtSenseEnabled

    @CurrentExtSenseEnabled.setter
    def CurrentExtSenseEnabled(self, value):
        """
        If TRUE, the current will be measured with an external current sensor

        :type value: bool
        """
        self.__CurrentExtSenseEnabled = bool(value)

    # Methods
    def ConfigureChannel(
        self,
        MeasuringMode,
        VoltageRange,
        CurrentRange,
        CurrentExtSenseEnabled,
        CurrentExtSenseRange,
        LineFilter,
        WireCompensation,
    ):
        """
        Configures the most commonly used properties of the PwrAn
        channel sub-system. They are the MeasuringMode,
        VoltageRange, CurrentRange,
        CurrentExtSensEnabled, CurrentExtSensRange, LineFilter,
        WireCompensation

        :type MeasuringMode: str

        :type VoltageRange: float

        :type CurrentRange: float

        :type CurrentExtSenseEnabled: bool

        :type CurrentExtSenseRange: float

        :type LineFilter: float

        :type WireCompensation: str
        """
        self.MeasuringMode = MeasuringMode
        self.VoltageRange = VoltageRange
        self.CurrentRange = CurrentRange
        # self.CurrentExtSenseEnabled = CurrentExtSenseEnabled
        # self.CurrentExtSenseRange = CurrentExtSenseRange
        self.LineFilter = LineFilter
        self.WireCompensation = WireCompensation

    def ConfigureEtaMeasurement(self, NumeratorChannel, DenominatorChannel):
        """C
        onfigures how the ETA value is measured.
        ETA = (NumeratorChannel/DenominatorChannel) * 100%

        :param NumeratorChannel:
        :param DenominatorChannel:
        """
        self.interface.vi_write(":MEAS:EFF:ETA%s P%d,P%d" % (self.Element, NumeratorChannel, DenominatorChannel))
        self.GetError()
