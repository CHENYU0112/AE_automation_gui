# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $Rev$
# Date           : $Date$
# Last change by : $Author$
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

from pverify.drivers.PowerAnalyzer.ykwt500 import IIfxPwrAnBase
from pverify.drivers.PowerAnalyzer.ykwt500.IIfxPwrAnChannel import IIfxPwrAnChannel


class IIfxPwrAnChannels(IIfxPwrAnBase.IIfxPwrAnBase):
    """IfxPowerAnalyzer class-compliant channel collection interface.

    NOTE:
        Attributes/Methods marked with '#' do not exist for this instrument.
        Attributes/Methods marked with '*' are specific for this instrument.
        !Please consider when trying to program instrument independent.

    Attributes:
        Count [r]
            The number of channels the power analyzer has

        WiringSetting [String] [rw]
            Defines the number of phases and wires and their setting
            {(P1W2|P1W3|P3W3|P3W4|V3A3)[,(P1W2|P1W3|P3W3|P3W4|V3A3|NONE)][,(P1W2|P1W3|P3W3|NONE)][,(P1W2|NONE)]}
                P1W2 = Single-phase, two-wire system [1P2W]
                P1W3 = Single-phase, three-wire system
                [1P3W]
                P3W3 = Three-phase, three-wire system
                [3P3W]
                P3W4 = Three-phase, four-wire system [3P4W]
                V3A3 = Three-phase, three-wire (three-voltage,
                three-current) [3P3W(3V3A)]
            Example: "P1W2,P1W2,P1W2,P1W2"

    Methods:
        Item(Name)
            Gets a pointer to a channel object.

        #Name(Index)
            Gets a pointer to a channel object absed on its index

    """

    def __init__(self, parent):
        IIfxPwrAnBase.IIfxPwrAnBase.__init__(self, parent)
        self.__channels = {
            "1": IIfxPwrAnChannel(self, 1),
            "2": IIfxPwrAnChannel(self, 2),
            "3": IIfxPwrAnChannel(self, 3),
            # "4": IIfxPwrAnChannel(self.interface, 4),
            # "5": IIfxPwrAnChannel(self.interface, 5),
            # "6": IIfxPwrAnChannel(self.interface, 6),
            # "7": IIfxPwrAnChannel(self.interface, 7),
            # "8": IIfxPwrAnChannel(self.interface, 8)
        }

    # Read-only dependent properties
    @property
    def Count(self):
        """
        The number of channels the poweranalyzer has.
        """
        return len(self.__channels)

    # Read-write dependent properties
    @property
    def WiringSetting(self):
        """
        Defines the number of phases and wires and their setting.

        :rtype: str
        """
        ret = self.interface.vi_query(":INP:WIR?", rformat="%s")
        self.GetError()
        return ret

    @WiringSetting.setter
    def WiringSetting(self, value):
        """
        Defines the number of phases and wires and their setting.

        :type value: str
        """
        self.interface.vi_write(f":INP:WIR {value}")
        self.GetError()

    # Methods
    def WaitAutoRangeSettled(self):
        """
        Checks if voltage or current of this channel exceeds its range.
        It they do so activate autorange on them.
        Them wait for the ranges to settle.
        """
        self.parent.Integration.ResetIntegration()
        self.parent.Measurements.Hold(False)
        self.interface.vi_write("*CLS")  # Clear statusbits
        self.parent.Measurements.WaitUpdate()
        ovr = self.interface.vi_query(":STAT:COND?", rformat="%d")  # Bit 8-11 are OVR bits
        ovr = (ovr >> 8) & (2**self.Count - 1)  # Mask OVR status bits and shift to bit 0
        for i in range(self.Count):
            if ovr & (2**i):  # If channel shows overrange activate autorange
                self.__channels[str(i + 1)].AutoRangeCurrent = True
                self.__channels[str(i + 1)].AutoRangeVoltage = True

        oldVrange = self.interface.vi_query(":INP:VOLT:RANG?", rformat="%s")
        oldCrange = self.interface.vi_query(":INP:CURR:RANG?", rformat="%s")
        newVrange, newCrange = "", ""

        for _ in range(15):
            self.parent.Measurements.WaitUpdate()
            newVrange = self.interface.vi_query(":INP:VOLT:RANG?", rformat="%s")
            newCrange = self.interface.vi_query(":INP:CURR:RANG?", rformat="%s")
            if oldVrange == newVrange and oldCrange == newCrange:
                break
            oldVrange = newVrange
            oldCrange = newCrange

        self.interface.vi_write("*CLS")  # Clear statusbits
        self.parent.Measurements.WaitUpdate()

    def Item(self, Name):
        """
        Gets a pointer to a channel object.

        :param Name: The channel number (1-3)
        :type Name: int
        :rtype: IIfxPwrAnChannel
        """
        if str(Name) in ["1", "2", "3"]:
            return self.__channels[str(Name)]
        else:
            msg = 'ykwt500: Channel name has to be one of ["1", "2", "3"]'
            raise IndexError(msg)

    def Name(self, Index):
        """
        Gets the name of a channel.

        Parameter "Index"
           One based index into the collection of channels.

        """
        if (int(Index) > 0) and (int(Index) <= 3):
            return ["1", "2", "3"][int(Index) - 1]
        else:
            msg = "ykwt500: Channel index exceeds the limits 1-3"
            raise IndexError(msg)
