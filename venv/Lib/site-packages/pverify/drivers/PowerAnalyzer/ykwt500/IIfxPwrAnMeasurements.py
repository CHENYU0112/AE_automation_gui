# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
#
# -------------------------------------------------------------------------------
# Revision       : $Rev$
# Date           : $Date$
# Last change by : $Author$
# -------------------------------------------------------------------------------
"""
Module docstring
"""

from __future__ import annotations

from time import sleep

from pverify.drivers.PowerAnalyzer.ykwt500 import IIfxPwrAnBase
from pverify.drivers.PowerAnalyzer.ykwt500.IIfxPwrAnMeasurement import IIfxPwrAnMeasurement


class IIfxPwrAnMeasurements(IIfxPwrAnBase.IIfxPwrAnBase):
    """IfxPowerAnalyzer class-compliant measurement collection interface

    NOTE:
        Attributes/Methods marked with '#' do not exist for this instrument.
        Attributes/Methods marked with '*' are specific for this instrument.
        !Please consider when trying to program instrument independent.

    Attributes:
        AvgEnabled [Boolean] [rw]
            Enables averaging.

        AvgType [String] [rw]
            Set the averaging type.
            Values:
                "IfxPwrAnAvgTypeEnumEXP"
                "IfxPwrAnAvgTypeEnumLIN"

        AvgCount [Int] [rw]
            The number of sampling points used to calculate a measurement

        UpdateRate [Float] [rw]
            The rate the PwrAn updates its display and new data is available.


    Methods:
        ConfigureMeasurements(UpdateRate, AvgEnabled, AvgType, AvgCount)
            Configures the most commonly used properties of the PwrAn
            measurement sub-system.

        Hold(value)
            The measurements of the power analyzer are held in a fixed state
            to read out several values without them changing between the readouts

        WaitUpdate()
            Waits for an update of all measurements

        Item(Element, PwrAnMeasItem)
            Values for Element:
                1-3
            Values for PwrAnMeasItem
                "IfxPwrAnMeasItemVoltage"
                "IfxPwrAnMeasItemCurrent"
                "IfxPwrAnMeasItemPower"
                "IfxPwrAnMeasItemApparentPower"
                "IfxPwrAnMeasItemReactivePower"
                "IfxPwrAnMeasItemLambda"
                "IfxPwrAnMeasItemPhi"
                "IfxPwrAnMeasItemFreqU"
                "IfxPwrAnMeasItemFreqI"
                "IfxPwrAnMeasItemVoltagePlusPeak"
                "IfxPwrAnMeasItemVoltageMinusPeak"
                "IfxPwrAnMeasItemCurrentPlusPeak"
                "IfxPwrAnMeasItemCurrentMinusPeak"
                "IfxPwrAnMeasItemWattHours"
                "IfxPwrAnMeasItemWattHoursPlus"
                "IfxPwrAnMeasItemWattHoursMinus"
                "IfxPwrAnMeasItemAmpereHours"
                "IfxPwrAnMeasItemAmpereHoursPlus"
                "IfxPwrAnMeasItemAmpereHoursMinus"
                "IfxPwrAnMeasItemETA1"
                "IfxPwrAnMeasItemETA2"
                "IfxPwrAnMeasItemETA3"
                "IfxPwrAnMeasItemPhiU"
                "IfxPwrAnMeasItemPhiI"
                "IfxPwrAnMeasItemUThd"
                "IfxPwrAnMeasItemIThd"
                "IfxPwrAnMeasItemPThd"
    """

    def __init__(self, parent):
        IIfxPwrAnBase.IIfxPwrAnBase.__init__(self, parent)
        self.__ItemCount = 1
        self.__ItemCountHarm = 1

    # Read-write dependent properties
    @property
    def AvgEnabled(self):
        """
        Enables averaging

        :rtype: bool
        """
        ret = self.interface.vi_query(":MEAS:AVER:STAT?", rformat="%d")
        self.GetError()
        return bool(ret)

    @AvgEnabled.setter
    def AvgEnabled(self, value):
        """
        Enables averaging

        :type value: bool
        """
        if bool(value):
            self.interface.vi_write(":MEAS:AVER:STAT ON")
        else:
            self.interface.vi_write(":MEAS:AVER:STAT OFF")
        self.GetError()

    @property
    def AvgType(self):
        """
        Set the averaging type EXP or LIN

        :rtype: IfxPwrAnAvgTypeEnum
        """
        ret = self.interface.vi_query(":MEAS:AVER:TYPE?", rformat="%s")
        self.GetError()
        return self.Enums.enum_from_value(self.Enums.IfxPwrAnAvgTypeEnum, ret)

    @AvgType.setter
    def AvgType(self, value):
        """
        Set the averaging type EXP or LIN

        :type value: IfxPwrAnAvgTypeEnum
        """
        self.interface.vi_write(f":MEAS:AVER:TYPE {value.value}")
        self.GetError()

    @property
    def AvgCount(self):
        """
        The number of sampling points used to calculate a measurement

        :rtype: int
        """
        ret = self.interface.vi_query(":MEAS:AVER:COUN?", rformat="%d")
        self.GetError()
        return ret

    @AvgCount.setter
    def AvgCount(self, value):
        """
        The number of sampling points used to calculate a measurement

        :type value: int
        """
        self.interface.vi_write(":MEAS:AVER:COUN %d" % value)
        self.GetError()

    @property
    def CrestFactor(self):
        """
        Sets or queries the crest factor

        :rtype: int
        """
        ret = self.interface.vi_query(":INP:CFAC?", rformat="%d")
        self.GetError()
        return ret

    @CrestFactor.setter
    def CrestFactor(self, value):
        """
        Sets or queries the crest factor

        :type value: int
        """
        cf = value if value in [3, 6] else 6
        self.interface.vi_write(":INP:CFAC %d" % cf)
        self.GetError()

    @property
    def UpdateRate(self):
        """
        The rate the PwrAn updates its display and new data is available

        :rtype: float
        """
        ret = self.interface.vi_query(":RATE?", rformat="%f")
        self.GetError()
        return ret

    @UpdateRate.setter
    def UpdateRate(self, value):
        """
        The rate the PwrAn updates its display and new data is available

        :type value: float
        """
        self.interface.vi_write(f":RATE {value:f}")
        self.GetError()

    # Methods
    def ConfigureMeasurements(self, UpdateRate, AvgEnabled, AvgType, AvgCount):
        """
        Configures the most commonly used properties of the PwrAn
        measurement sub-system.
        They are UpdateRate, AvgEnabled, AvgType, AvgCount

        :type UpdateRate: float
        :type AvgEnabled: bool
        :type AvgType: str
        :type AvgCount: int
        """
        self.UpdateRate = UpdateRate
        self.AvgEnabled = AvgEnabled
        self.AvgType = AvgType
        self.AvgCount = AvgCount

    def ConfigureUserDefinedFunction(self, number, name, unit, expression):
        """
        Configures a user-defined function

        :param number: The number of the function (1-20)
        :param name: The name of the function. Up to 8 characters
        :param unit: The unit of the function. Up to 8 characters
        :param expression: The function expression. Up to 50 characters
        """
        name = name[:8]
        unit = unit[:8]
        expression = expression[:50]
        if not (1 <= number <= 20):
            msg = "Argument number out of range (1-20)!"
            raise Exception(msg)
        self.interface.vi_write(':MEAS:FUNC%d:NAME "%s"' % (number, name))
        self.interface.vi_write(':MEAS:FUNC%d:UNIT "%s"' % (number, unit))
        self.interface.vi_write(':MEAS:FUNC%d:EXPR "%s"' % (number, expression))
        self.interface.vi_write(":MEAS:FUNC%d:STAT ON" % (number))
        self.GetError()

    def Hold(self, value):
        """
        The measurements of the power analyzer are held in a fixed state
        to read out several values without them changing between the readouts

        :type value: bool
        """
        if bool(value):
            self.interface.vi_write(":HOLD 1")
        else:
            self.interface.vi_write(":HOLD 0")
        self.GetError()

    def HoldNumeric(self, value):
        """
        The internal measurements of the power analyzer are held in a fixed state
        to read out several values without them changing between the readouts.
        The displayed numeric values are still updating.

        :type value: bool
        """
        if bool(value):
            self.interface.vi_write(":NUM:HOLD 1")
        else:
            self.interface.vi_write(":NUM:HOLD 0")
        self.GetError()

    def WaitUpdate(self, Count=1):
        """
        Disables HOLD and waits for an Count updates of all measurements

        :param Count: The number of updates to wait for
        """
        self.Hold(False)
        self.HoldNumeric(False)
        self.interface.vi_write(":STAT:FILT1 FALL")
        for _i in range(Count):
            self.interface.vi_write("*CLS")
            updated = False
            while not updated:
                sleep(0.05)
                updated = bool(self.interface.vi_query(":STAT:EESR?", rformat="%d") & 1)

    def Item(self, Element, PwrAnMeasItem):
        """
        Gets a pointer to a measurement object.

        :type Element: int|str
        :param PwrAnMeasItem: The measurement to perform
        :type PwrAnMeasItem: IfxPwrAnMeasItemEnum
        :rtype: IIfxPwrAnMeasurement
        """
        if (int(Element) >= 1) and (int(Element) <= 3):
            tmpItemCount = self.__ItemCount
            ret = IIfxPwrAnMeasurement(self, Element, PwrAnMeasItem, tmpItemCount)
            if tmpItemCount < 200:
                self.__ItemCount = tmpItemCount + 1
            else:
                self.__ItemCount = 1
            self.GetError()
            return ret
        else:
            msg = f"Channel '{Element}' does not exist. This power analyzer only has channel 1-3."
            raise IndexError(msg)

    def Item_Harmonic(self, Element, PwrAnMeasItem):
        """
        Gets a pointer to a harmonic measurement object.

        :type Element: int|str
        :param PwrAnMeasItem: The harmonic measurement to perform
        :type PwrAnMeasItem: IfxPwrAnHarmMeasItemEnum
        :rtype: IIfxPwrAnMeasurement
        """
        if (int(Element) >= 1) and (int(Element) <= 3):
            ret = IIfxPwrAnMeasurement(self, Element, PwrAnMeasItem, -1)
            self.GetError()
            return ret
        else:
            msg = f"Channel '{Element}' does not exist. This power analyzer only has channel 1-3."
            raise IndexError(msg)
