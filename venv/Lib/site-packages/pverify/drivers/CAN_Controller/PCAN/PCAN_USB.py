from __future__ import annotations

from functools import wraps

import numpy as np

from pverify.drivers.CAN_Controller.PCAN.Enums import Enums
from pverify.drivers.CAN_Controller.PCAN.PCANBasic import PCANBasic, TPCANMsg, TPCANMsgFD


class PCANError(Exception):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


def CheckError(func):
    @wraps(func)
    def func_wrapper(*args, **kwargs):
        status = func(*args, **kwargs)
        if int(status) in list(Enums.PCAN_ERRORS.keys()):
            raise PCANError(Enums.PCAN_ERRORS[int(status)])
        else:
            return int(status)

    return func_wrapper


def to_bytearray(data):
    """
    Converts to integer and then split it into bytes and returns a byte array and its length

    :type data: str|int
    :rtype: set(list[int], int)
    """
    if isinstance(data, str):
        data = int(data, 16)
    elif isinstance(data, int):
        pass
    else:
        msg = "Wrong datatype of argument msgData. Supported datatypes: str|int"
        raise TypeError(msg)
    length = int(np.ceil(data.bit_length() / 8.0))
    byte_array = [(data >> i & 0xFF) for i in range(0, 72, 8)[::-1]][::-1]
    return byte_array, length


class PCAN_USB:
    Enums = Enums

    def __init__(self):
        self.base = PCANBasic()
        self.channel = None
        self.baudrate = None
        self.identifier_mode = None
        self.__Initialized = False

    @property
    def Initialized(self):
        return self.__Initialized

    @CheckError
    def Initialize(self, Baudrate, USBBus=1, ExtendedID=False):
        """

        :param Baudrate: The baudrate of the connection. Use Enums.PCAN_BAUDRATES
        :param USBBus: The USB Bus number. Has to be a number from 1 (default) to 16.
        :param ExtendedID: If True, use a 29-bit identifier, else 11-bit (default).
        """
        if not 1 <= int(USBBus) <= 16:
            msg = "USB_Bus_Channel has to be a number from 1 to 16."
            raise ValueError(msg)
        self.channel = eval("pcan.PCAN_USBBUS%d" % USBBus)
        self.identifier_mode = [
            Enums.PCAN_MESSAGE_TYPE.STANDARD,
            Enums.PCAN_MESSAGE_TYPE.EXTENDED,
        ][ExtendedID]
        status = self.base.Initialize(Channel=self.channel, Btr0Btr1=Baudrate)
        if status == 0:
            self.__Initialized = True
        return status

    @CheckError
    def Uninitialize(self):
        status = self.base.Uninitialize(self.channel)
        if status == 0:
            self.__Initialized = False
        return status

    @CheckError
    def Reset(self):
        """
        Resets the receive and transmit queues of a PCAN Channel.
        """
        return self.base.Reset(self.channel)

    def GetStatus(self):
        """
        Gets the current BUS status of a PCAN Channel.

        The return value is a TPCANStatus code. The typical return values are:

        PCAN_ERROR_INITIALIZE:  Indicates that the given PCAN Channel was not found in the list of initialized channels of the calling application.\n
        PCAN_ERROR_BUSLIGHT:  Indicates a bus error within the given PCAN Channel. The hardware is in bus-light status.\n
        PCAN_ERROR_BUSHEAVY:  Indicates a bus error within the given PCAN Channel. The hardware is in bus-heavy status.\n
        PCAN_ERROR_BUSOFF:  Indicates a bus error within the given PCAN Channel. The hardware is in bus-off status.\n
        PCAN_ERROR_OK:  Indicates that the status of the given PCAN Channel is OK.
        """
        return self.base.GetStatus(self.channel)

    @CheckError
    def FilterMessages(self, FromID, ToID):
        """
        Configures the reception filter.

        :param FromID: The lowest CAN ID wanted to be received.
        :type FromID: int
        :param ToID: The highest CAN ID wanted to be received.
        :type ToID: int
        """
        return self.base.FilterMessages(Channel=self.channel, FromID=FromID, ToID=ToID, Mode=self.identifier_mode)

    @CheckError
    def Write(self, msgID, msgData):
        """
        Write a CAN message

        :param msgID: 11/29-bit message identifier. Is automatically clipped to specified ID length.
        :type msgID: int
        :param msgData: Data of the message. Either as string ("0x12abcdef" or "12abcdef") or interger (255 or 0xff)
        :type msgData: str|int
        """
        msg = TPCANMsg()
        msg.MSGTYPE = self.identifier_mode
        if self.identifier_mode == Enums.PCAN_MESSAGE_TYPE.STANDARD:
            msg.ID = msgID & ((2**11) - 1)
        else:
            msg.ID = msgID & ((2**29) - 1)

        byte_array, msgLen = to_bytearray(msgData)

        msg.LEN = msgLen
        for i in range(msgLen):
            msg.DATA[i] = byte_array[i]

        return self.base.Write(self.channel, msg)

    @CheckError
    def WriteMsg(self, msg):
        """
        Write a CAN message

        :param msg: The message
        :type msg: TPCANMsg
        """
        if not isinstance(msg, TPCANMsg):
            msg = "Argument msg must be of type TPCANMsg"
            raise TypeError(msg)

        return self.base.Write(self.channel, msg)

    @CheckError
    def WriteFD(self, msgID, msgDLC, msgData):
        """
        Write a CAN message

        :param msgID: 11/29-bit message identifier. Is automatically clipped to specified ID length.
        :type msgID: int
        :param msgDLC: Data Length Code of the message (0..15).
                       The length of data bytes contained in a CAN message is given by the
                       DATA LENGTH CODE field (DLC). The coding of the DLC within FD messages is different.
                       There are 7 additional codes (from 9 to 15) that allows a FD Messages to transport up to 64 bytes of data.
                       The relationship between DLC and data bytes length is as follow:

                       0=0,1=1,2=2,3=3,4=4,5=5,6=6,7=7,8=8,9=12,10=16,11=20,12=24,13=32,14=48,15=64
        :type msgDLC: int
        :param msgData: Data of the message. Either as string ("0x12abcdef" or "12abcdef") or interger (255 or 0xff)
        :type msgData: str|int
        """
        if not 0 <= msgDLC <= 15:
            msg = "msgDLC has to be between 0 and 15!"
            raise ValueError(msg)
        dlcList = [0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, 64]
        msg = TPCANMsgFD()
        msg.MSGTYPE = self.identifier_mode
        if self.identifier_mode == Enums.PCAN_MESSAGE_TYPE.STANDARD:
            msg.ID = msgID & ((2**11) - 1)
        else:
            msg.ID = msgID & ((2**29) - 1)

        if isinstance(msgData, str):
            data = int(msgData, 16)
        elif isinstance(msgData, int):
            data = msgData
        else:
            msg = "Wrong datatype of argument msgData. Supported datatypes: str|int"
            raise TypeError(msg)

        byte_array = [(data >> i & 0xFF) for i in range(0, 72, 8)[::-1]][::-1]

        msg.LEN = msgDLC
        for i in range(dlcList[msgDLC]):
            msg.DATA[i] = byte_array[i]

        return self.base.WriteFD(self.channel, msg)

    def Read(self):
        """
        Reads a CAN message from the receive queue of a PCAN Channel

        Remarks:
          The return value of this method is a 3-touple,\n
          where the first value is the result (TPCANStatus) of the method.\n
          The order of the values are:\n
          [0]: A TPCANStatus error code\n
          [1]: A TPCANMsg structure with the CAN message read\n
          [2]: A Timestamp in ms with the time when a message was read\n

        :return: A tuple with three values
        :rtype: (TPCANStatus,TPCANMsg,int)
        """
        status, msg, ts = self.base.Read(self.channel)
        ts = ts.micros + 1000 * ts.millis + 0x100000000 * 1000 * ts.millis_overflow
        return int(status), msg, ts / 1000

    def ReadFD(self):
        """
        Reads a CAN message from the receive queue of a FD capable PCAN Channel

        Remarks:
          The return value of this method is a 3-touple, where
          the first value is the result (TPCANStatus) of the method.
          The order of the values are:
          [0]: A TPCANStatus error code
          [1]: A TPCANMsgFD structure with the CAN message read
          [2]: A TPCANTimestampFD that is the time when a message was read

        :return: A touple with three values
        :rtype: (TPCANStatus,TPCANMsgFD,pcan.TPCANTimestampFD)
        """
        status, msg, ts = self.base.ReadFD(self.channel)
        return int(status), msg, int(ts.value)


if __name__ == "__main__":
    p = PCAN_USB()
    p.Initialize(p.Enums.PCAN_BAUDRATES.BD_500K, 1)
    p.FilterMessages(0, 0x200)
    p.Write(0x100, 0xABCDEF)
    p.Read()
    p.Uninitialize()
