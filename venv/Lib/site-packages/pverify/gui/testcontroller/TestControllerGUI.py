from __future__ import annotations

import contextlib
import logging
import logging.config
import os
import pickle
import pprint
import sys
import traceback

import arrow
import psutil
from qtpy import QtCore, QtGui, QtWidgets

from pverify.core import env  # noqa: F401
from pverify.core.internals import flow_control
from pverify.core.util.file_ops import prevent_filehandle_inherit
from pverify.core.util.path_util import join_and_make_absolute
from pverify.gui.testcontroller.TestControllerGUI_Base import Ui_MainWindow
from pverify.gui.widgets.Popup import Popup

TEST_SIGNALS = flow_control.MySignals()


class ThreadedEmitter(QtCore.QThread):
    sigInvokeMethodAsync = QtCore.Signal(object)

    def __init__(self, pipe):
        super().__init__()
        self.pipe = pipe

    def _emit(self, signature, args):
        self.sigInvokeMethodAsync.emit((signature, args))

    def run(self):
        while True:
            try:
                msg = self.pipe.recv()
            except EOFError:
                pass
            else:
                self._emit(*msg)


class TestControllerGUI(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, q, exec_mode, config, args, emitter_pipe, test_name):
        super().__init__()
        self.setupUi(self)
        self.parent_pid = os.getppid()

        self.splitter.setChildrenCollapsible(False)

        self.statusbar.setStyleSheet(
            "QStatusBar{padding-left:8px;background:rgba(0,0,0,0);color:black;font-weight:bold;}"
        )
        self.logScreen.setCurrentFont(QtGui.QFont("Courier New", 10))
        bar = self.logScreen.verticalScrollBar()
        bar.rangeChanged.connect(lambda x, y: bar.setValue(y))

        self.allow_exit = False
        self._paused = False
        self.emitter = ThreadedEmitter(pipe=emitter_pipe)
        self.emitter.daemon = True
        self.emitter.start()
        self.test_name = str(test_name)
        self._splitter_widget_sizes_set = False

        self.q = q

        self._linecounter = 0

        self.setWindowTitle("PyVerify Test - " + self.test_name)

        self.log = None
        """:type : logging.Logger"""
        self.exec_mode = exec_mode
        self.config: dict = config
        self.sysargs: dict = args

        self._setup_logger()

        # Disable controls
        self.actionStop.setEnabled(True)
        self.actionContinue.setEnabled(False)
        self.actionPause.setEnabled(True)
        self.actionNext_BP.setEnabled(False)

        self.test_info = {}
        self._statusbar_update_enabled = True

        self.popup_msgBox = Popup()

        # Connect Pushbuttons to slots
        self.actionStop.triggered.connect(self.close)
        self.actionPause.triggered.connect(self.SLOT_PauseTest)
        self.actionContinue.triggered.connect(self.SLOT_ContinueTest)
        self.actionNext_BP.triggered.connect(self.SLOT_NextBreakpoint)
        self.show()
        self._connect_testcase_signals()
        self.q.put("ready")

        self.watchdog = QtCore.QTimer()
        self.watchdog.setInterval(2000)
        self.watchdog.timeout.connect(self.check_pid_watchdog)
        self.watchdog.start()

    def check_pid_watchdog(self):
        """
        Causes the test controller to exit if the process with the specified PID terminates.
        Used if the calling testing tool ends without shuting down the test controller.
        """
        if self.parent_pid > 0:
            try:
                p = psutil.Process(self.parent_pid)
                if not p.is_running():
                    raise psutil.NoSuchProcess(self.parent_pid)
            except psutil.NoSuchProcess:
                self.log.info("Linked process (PID '%d') terminated. Terminating test controller." % self.parent_pid)
                os._exit(-1)

    def __del__(self):
        if hasattr(self, "log") and self.log is not None:
            for h in self.log.handlers:
                self.log.removeHandler(h)

    def _connect_testcase_signals(self):
        self.invokableMethods = {
            TEST_SIGNALS.show_gui.signature: self.show,
            TEST_SIGNALS.test_done.signature: self.hide,
            TEST_SIGNALS.test_terminated.signature: self.close,
            TEST_SIGNALS.new_variation.signature: self.update_param_table,
            TEST_SIGNALS.pause_entered.signature: self.entered_pause_state,
            TEST_SIGNALS.pause_left.signature: self.left_pause_state,
            TEST_SIGNALS.show_popup.signature: self.show_user_popup,
            TEST_SIGNALS.display_log_msg.signature: self.print_error_to_log,
        }

        self.emitter.sigInvokeMethodAsync.connect(self.invokeMethodAsync)

    @QtCore.Slot(object)
    def invokeMethodAsync(self, argtuple):
        fname, args_pickled = argtuple
        if fname not in self.invokableMethods:
            return
        func = self.invokableMethods[fname]
        args = pickle.loads(args_pickled)
        if self.log is not None and fname not in [
            "display_log_msg",
        ]:
            self.log.debug(f"Invoking '{fname}' async. with args {args!s}")
        try:
            func(*args)
        except Exception as e:
            print(e)

    def show_error_popup(self, message):
        self.popup_msgBox.configure("Error")
        self.popup_msgBox.show_message(message)

    def print_error_to_log(self, msg):
        if self._linecounter > 25000:
            self.logScreen.clear()
            self._linecounter = 0
        self.logScreen.append(msg)
        self._linecounter += 1

    def show_user_popup(self, title, msg, modal):
        blocking = modal
        if blocking:
            self.SLOT_PauseTest()
            self.setEnabled(False)
        self.popup_msgBox.configure(title)
        self.popup_msgBox.show_message(msg)
        if blocking:
            self.popup_msgBox.exec_()
            self.SLOT_ContinueTest()
        self.setEnabled(True)

    def _setup_logger(self):
        """
        Creates a logger called "test_controller" which logs to a file ".../LOG.log"
        The logger level is setup depending on the argument "debuglevel".
        """
        self.log = logging.getLogger(self.__class__.__name__)
        self.log.setLevel(self.sysargs["logginglevel"])

        logfilepath = join_and_make_absolute(self.config["result_dir"], "gui.log")
        if os.path.isfile(logfilepath):
            with contextlib.suppress(OSError):
                os.remove(logfilepath)
        if not os.path.exists(os.path.dirname(logfilepath)):
            os.mkdir(os.path.dirname(logfilepath))

        ch = logging.FileHandler(filename=logfilepath, mode="w")
        prevent_filehandle_inherit(ch.stream.fileno())
        ch.setLevel(self.sysargs["logginglevel"])

        # create formatter
        ch.setFormatter(logging.Formatter("%(levelname)-7s - %(asctime)s - l.%(lineno)-3d:  %(message)s", "%H:%M:%S"))
        self.log.addHandler(ch)

        self.log.info(f"Initialized GUI logging to file '{logfilepath}'")

    @QtCore.Slot(object)
    def update_param_table(self, params):
        self.log.debug("Updating parameter table.")
        self.parameter_table.setRowCount(len(params))
        for i, definition in enumerate(params):
            self.parameter_table.setItem(i, 0, QtWidgets.QTableWidgetItem(definition[0]))
            self.parameter_table.setItem(i, 1, QtWidgets.QTableWidgetItem(definition[1]))

        if not self._splitter_widget_sizes_set:
            self.set_splitter_widget_sizes()
            self._splitter_widget_sizes_set = True

    def set_splitter_widget_sizes(self):
        """
        Automatically set the size of the parameter table depending on its size hint, but max. to 300 pixels.
        It shall only be executed once, since the number of parameters is not changing
        """
        total_size = sum(self.splitter.sizes())
        height_hint_table = min(self.parameter_table.sizeHint().height(), 300)
        self.splitter.setSizes([height_hint_table, total_size - height_hint_table])

    def resizeEvent(self, event):
        QtWidgets.QMainWindow.resizeEvent(self, event)
        self.set_splitter_widget_sizes()

    def closeEvent(self, event):
        self.log.debug("Handling closeEvent...")

        self.SLOT_StopTest(timeout=60)
        self.log.debug("Deleting child widgets.")
        self.statusbar_reset()

        self.log.info("Removing log file handlers. This should be the last log entry!")
        if self.log is not None:
            for h in self.log.handlers:
                self.log.removeHandler(h)
            self.log.handlers = []

        event.accept()  # let the window close

    @QtCore.Slot()
    def statusbar_update(self, message):
        if self._statusbar_update_enabled:
            self.statusbar.showMessage(message)

    @QtCore.Slot()
    def statusbar_display_error(self, message):
        self._statusbar_update_enabled = False
        self.statusbar.setStyleSheet(
            "QStatusBar{padding-left:8px;background:rgba(255,0,0,255);color:black;font-weight:bold;}"
        )
        self.statusbar.showMessage(f"ERROR: {message}")
        self.log.error(f"ERROR: {message}")

    @QtCore.Slot()
    def statusbar_reset(self):
        self.statusbar.setStyleSheet(
            "QStatusBar{padding-left:8px;background:rgba(0,0,0,0);color:black;font-weight:bold;}"
        )
        self._statusbar_update_enabled = True

    def SLOT_StopTest(self, timeout=60):
        self.log.info("Requesting test to stop.")
        # Set the flag in the shared com object to request the test to terminate
        self.emitter.sigInvokeMethodAsync.disconnect(self.invokeMethodAsync)
        self.actionStop.setEnabled(False)
        self.actionContinue.setEnabled(False)
        self.actionPause.setEnabled(False)
        self.actionNext_BP.setEnabled(False)

        self.q.put("stop")

    @QtCore.Slot()
    def SLOT_ContinueTest(self):
        self.log.info("Continue test...")
        self.q.put("continue")
        self.statusbar.clearMessage()

    @QtCore.Slot()
    def SLOT_NextBreakpoint(self):
        self.actionStop.setEnabled(True)
        self.actionContinue.setEnabled(False)
        self.actionPause.setEnabled(False)
        self.actionNext_BP.setEnabled(False)

        self.statusbar.showMessage("Stopping at next breakpoint...")
        self.SLOT_ContinueTest()
        # sleep(0.03)
        self.SLOT_PauseTest()

    @QtCore.Slot()
    def SLOT_PauseTest(self, timeout=30):
        self.log.info("Pausing test...")
        self.statusbar.showMessage("Pausing test...")
        self.q.put("pause")
        # Enable/Disable controls
        self.actionStop.setEnabled(True)
        self.actionContinue.setEnabled(False)
        self.actionPause.setEnabled(False)
        self.actionNext_BP.setEnabled(False)

    def left_pause_state(self):
        self.log.info("Left pause state")
        self._paused = False
        self.actionContinue.setEnabled(False)
        self.actionPause.setEnabled(True)
        self.actionNext_BP.setEnabled(False)

    def entered_pause_state(self, message):
        self.log.info("Entered pause state")
        self._paused = True
        self.statusbar.showMessage(f"@Breakpoint: {message}")
        self.actionContinue.setEnabled(True)
        self.actionPause.setEnabled(False)
        self.actionNext_BP.setEnabled(True)


def testcontrollergui(q, exec_mode, config, args, emitter_pipe, testname):
    try:
        app = QtWidgets.QApplication(sys.argv)
        _ = TestControllerGUI(q, exec_mode, config, args, emitter_pipe, testname)
        app.exec_()
    except Exception:
        with open(
            join_and_make_absolute(
                config["result_dir"],
                "gui_crash_{}.log".format(arrow.now().strftime("%Y-%m-%d_%H-%M-%S")),
            ),
            "w",
        ) as f:
            f.write(traceback.format_exc())
            f.write("\nOS ENV:\n")
            f.write(pprint.pformat(dict(os.environ), width=1))
