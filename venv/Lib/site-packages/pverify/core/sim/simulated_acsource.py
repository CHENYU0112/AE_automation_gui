from __future__ import annotations

import math

import numpy as np
import srd as SRD

from .simulated_source import SimulatedSource, StimType, Stimulus


class SimulatedACSource(SimulatedSource):
    def __init__(self, ref_AI, manager, ScriptingVars):
        SimulatedSource.__init__(self, ref_AI, manager, ScriptingVars)
        if False:
            from pverify.core.sim.abstract_instruments import AI_ACSource

            self.ref_AI = AI_ACSource()

        self.static_stim = Stimulus(
            self,
            StimType.ACPWR_SINE,
            0,
            {"AmplitudeRMS": 0.0, "Frequency": 10.0, "Phase": 0.0, "Offset": 0.0},
        )
        self.r_line = 1e-9
        self.l_line = 0

    def get_netlist_entry(self):
        SimulatedSource.get_netlist_entry(self)

        if len(self.sequence):
            config = {}

            config[self.ScriptingVars.stimulustype] = 0  # Voltage source template
            config[self.ScriptingVars.stimulus] = self.create_stimulus_string()
            if self.ScriptingVars.vsrc_rin is not None:
                if self.r_line <= 0:
                    self.r_line = 1e-9
                config[self.ScriptingVars.vsrc_rin] = self.r_line
            else:
                self.manager.reftest.Utils.LogWarning(
                    f"{self.ScriptingVars} has no scripting variable specified for "
                    f"'vsrc_rin' which is used by the simulated ac source "
                    "to set the line resistance/internal resistance"
                    "of the PyVerify source. This may lead to inconsistent behavior!"
                )

            if self.ScriptingVars.vsrc_l_line is not None:
                config[self.ScriptingVars.vsrc_l_line] = str(self.l_line)
            else:
                self.manager.reftest.Utils.LogWarning(
                    f"{self.ScriptingVars} has no scripting variable specified for "
                    f"'vsrc_l_line' which is used by the simulated ac "
                    "source to set the line resistance/internal inductance"
                    "of the PyVerify source. This may lead to inconsistent behavior!"
                )

        else:
            config = None
        self.reset()
        return config

    def create_stimulus_string(self):
        """
        This Function expands a list of Stimuli to SRD API Strings
        """
        stim_string = SRD.C(value=0, begin=0, end=0)

        for idx, stim in enumerate(self.sequence):
            tmp_str = SRD.C(value=0, begin=0)
            endtime = 0
            if stim.type == StimType.WAIT:
                pass
            elif self._timetable[idx].start >= self._timetable[idx].stop:
                continue
            elif stim.type == StimType.ACPWR_SINE:
                stim_string += SRD.S(
                    period=1.0 / stim.config["Frequency"],
                    delay=(1.0 / stim.config["Frequency"]) * stim.config["Phase"] / 360.0,
                    amplitude=stim.config["AmplitudeRMS"] * math.sqrt(2),
                    offset=stim.config["Offset"],
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                ) * SRD.C(
                    value=1,
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                )
                self.static_stim = stim  # fall back to this stimulus as soon ramp/pulse/stair is finished

            elif stim.type == StimType.ACPWR_STAIR:
                amps = [
                    stim.config["StartAmplitudeRMS"] + x * stim.config["StepSize"]
                    for x in range(stim.config["StepCount"])
                ]
                cycle_duration = stim.config["StepDuration"] * (stim.config["StepCount"] - 2)
                cycle_duration += (
                    stim.config["StepDuration"] if stim.config["DwellTimeStart"] == 0 else stim.config["DwellTimeStart"]
                )
                cycle_duration += (
                    stim.config["StepDuration"] if stim.config["DwellTimeEnd"] == 0 else stim.config["DwellTimeEnd"]
                )

                cnt = stim.config["Count"]
                if cnt == 0:
                    cnt = int(np.ceil(self._timetable[idx].stop / cycle_duration))

                starttime = self._timetable[idx].start
                for c in range(cnt):
                    starttime = max(starttime, self._timetable[idx].start + c * cycle_duration)
                    for i, amp in enumerate(amps):
                        if (i == 0) and (stim.config["DwellTimeStart"] != 0):
                            endtime = starttime + stim.config["DwellTimeStart"]
                        elif (i == len(amps) - 1) and (stim.config["DwellTimeEnd"]):
                            endtime = starttime + stim.config["DwellTimeEnd"]
                        else:
                            endtime = starttime + stim.config["StepDuration"]
                        tmp_str += SRD.S(
                            period=1.0 / stim.config["Frequency"],
                            delay=(1.0 / stim.config["Frequency"]) * stim.config["Phase"] / 360.0,
                            amplitude=amp * math.sqrt(2),
                            offset=stim.config["Offset"],
                            begin=starttime,
                            end=endtime,
                        )
                        starttime = endtime

            elif stim.type == StimType.ACPWR_RAMP:
                starttime = self._timetable[idx].start
                tmp_str = SRD.C(value=0, begin=0)
                cycle_duration = stim.config["Duration"]
                if stim.config["DwellTimeStart"] > 0:
                    cycle_duration += stim.config["DwellTimeStart"]
                if stim.config["DwellTimeEnd"] > 0:
                    cycle_duration += stim.config["DwellTimeEnd"]

                cnt = stim.config["Count"]
                if cnt == 0:
                    cnt = int(np.ceil(self._timetable[idx].stop / cycle_duration))

                for _ in range(cnt):
                    endtime = starttime
                    if stim.config["DwellTimeStart"] > 0:
                        endtime += stim.config["DwellTimeStart"]
                    tmp_str += SRD.C(
                        value=stim.config["StartAmplitudeRMS"] * math.sqrt(2),
                        begin=starttime,
                        end=endtime,
                    )
                    starttime = endtime
                    endtime = starttime + stim.config["Duration"]
                    tmp_str += SRD.R(
                        start_value=stim.config["StartAmplitudeRMS"] * math.sqrt(2),
                        end_value=stim.config["StopAmplitudeRMS"] * math.sqrt(2),
                        begin=starttime,
                        end=endtime,
                    )
                    starttime = endtime
                    endtime = starttime
                    if stim.config["DwellTimeEnd"] > 0:
                        endtime += stim.config["DwellTimeEnd"]
                    tmp_str += SRD.C(
                        value=stim.config["StopAmplitudeRMS"] * math.sqrt(2),
                        begin=starttime,
                        end=endtime,
                    )
                    starttime = endtime

                tmp_str *= SRD.S(
                    period=1.0 / stim.config["Frequency"],
                    delay=(1.0 / stim.config["Frequency"]) * stim.config["Phase"] / 360.0,
                    amplitude=1,
                    offset=0,
                    begin=self._timetable[idx].start,
                    end=endtime,
                )

                tmp_str += SRD.C(
                    value=stim.config["Offset"],
                    begin=self._timetable[idx].start,
                    end=endtime,
                )

            elif stim.type == StimType.ACPWR_PULSED:
                tmp_str = SRD.C(value=0, begin=0)
                starttime = self._timetable[idx].start

                cnt = stim.config["Count"]
                if cnt == 0:
                    cnt = int(
                        np.ceil(self._timetable[idx].stop / (stim.config["DwellTime_1"] + stim.config["DwellTime_2"]))
                    )

                for _ in range(cnt):
                    endtime = starttime + stim.config["DwellTime_1"]
                    tmp_str += SRD.S(
                        period=1.0 / stim.config["Frequency"],
                        delay=(1.0 / stim.config["Frequency"]) * stim.config["Phase"] / 360.0,
                        amplitude=stim.config["AmplitudeRMS_1"] * math.sqrt(2),
                        offset=stim.config["Offset"],
                        begin=starttime,
                        end=endtime,
                    )
                    starttime = endtime
                    endtime = starttime + stim.config["DwellTime_2"]
                    tmp_str += SRD.S(
                        period=1.0 / stim.config["Frequency"],
                        delay=(1.0 / stim.config["Frequency"]) * stim.config["Phase"] / 360.0,
                        amplitude=stim.config["AmplitudeRMS_2"] * math.sqrt(2),
                        offset=stim.config["Offset"],
                        begin=starttime,
                        end=endtime,
                    )
                    starttime = endtime

            elif stim.type == StimType.ACPWR_ARB:
                starttime = self._timetable[idx].start

                cnt = stim.config["Count"]
                if cnt == 0:
                    cnt = int(np.ceil(self._timetable[idx].stop / sum(stim.config["DwellTime"])))

                for _ in range(cnt):
                    for p in range(len(stim.config["DwellTime"])):
                        endtime = starttime + stim.config["DwellTime"][p]
                        tmp_str += SRD.R(
                            start_value=stim.config["Offset_Start"][p],
                            end_value=stim.config["Offset_Stop"][p],
                            begin=starttime,
                            end=endtime,
                        ) + SRD.R(
                            start_value=stim.config["AmplitudeRMS_Start"][p],
                            end_value=stim.config["AmplitudeRMS_Stop"][p],
                            begin=starttime,
                            end=endtime,
                        ) * SRD.L(
                            start_value=stim.config["Frequency_Start"][p],
                            end_value=stim.config["Frequency_Stop"][p],
                            begin=starttime,
                            end=endtime,
                        )
                        starttime = endtime

            if stim.type not in [StimType.ACPWR_SINE, StimType.WAIT]:
                end = self._timetable[idx].stop
                start = self._timetable[idx].start
                if endtime > end:  # interrupt overwritten stimulus
                    tmp_str *= SRD.C(value=1, begin=start, end=end) + SRD.C(value=0, begin=end)
                elif endtime < end:  # extend finished stimuli with previously programmed static stimulus
                    delay = (
                        np.mod(endtime, 1.0 / self.static_stim.config["Frequency"])
                        + (1.0 / self.static_stim.config["Frequency"]) * self.static_stim.config["Phase"] / 360.0
                    )
                    tmp_str += SRD.S(
                        period=1.0 / self.static_stim.config["Frequency"],
                        delay=delay,
                        amplitude=self.static_stim.config["AmplitudeRMS"] * math.sqrt(2),
                        offset=self.static_stim.config["Offset"],
                        begin=endtime,
                        end=end,
                    )
                stim_string += tmp_str

        return stim_string
