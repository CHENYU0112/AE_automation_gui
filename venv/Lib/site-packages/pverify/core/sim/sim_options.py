from __future__ import annotations

import os

from pverify.core.internals.Enums import Enums


class SimOptions:
    def __init__(self):
        self.__SimOpts = {}
        """:type : dict[str, str|float|int]"""
        self.__SimOpts_DB = {}
        """:type : dict[str, dict[str, str|float|int]]"""
        self.__WorkingDir = ""
        self.__Simulator = None
        self.__SchematicDir = None
        self.__ProcessingMode = Enums.ProcessingMode.Local
        self.__ReloadPath = ""
        self.__KeepOpen = True
        self.__StoreVoltageSignals = Enums.SimulatorSignals.NONE
        self.__StoreCurrentSignals = Enums.SimulatorSignals.NONE
        self.__Timeout = 0
        self.__SimulatorCloseTimeout = None

    def __getitem__(self, key):
        if key.lower() == "sim_base_path":  # For backward comp.
            print("Key 'sim_base_path' is deprecated. Use attribute 'WorkingDir' instead!")
            return self.SchematicDir
        if key.lower() == "reload_path":  # For backward comp.
            print("Key 'reload_path' is deprecated. Use attribute 'ReloadPath' instead!")
            return self.ReloadPath
        if key.lower() == "keep_sim_open":  # For backward comp.
            print("Key 'KEEP_SIM_OPEN' is deprecated. Use attribute 'KeepOpen' instead!")
            return self.KeepOpen
        return getattr(self, key)

    def __setitem__(self, key, value):
        if key.lower() == "sim_base_path":  # For backward comp.
            print("Key 'sim_base_path' is deprecated. Use attribute 'WorkingDir' instead!")
            self.SchematicDir = os.path.dirname(value)
        elif key.lower() == "reload_path":  # For backward comp.
            print("Key 'reload_path' is deprecated. Use attribute 'ReloadPath' instead!")
            self.ReloadPath = value
        elif key.lower() == "keep_sim_open":  # For backward comp.
            print("Key 'KEEP_SIM_OPEN' is deprecated. Use attribute 'KeepOpen' instead!")
            self.KeepOpen = value
        elif key.lower() == "keep_all":  # For backward comp.
            print("Key 'keep_all' is deprecated. Use attribute 'KeepAll' instead!")
            if bool(value):
                self.StoreCurrentSignals = Enums.SimulatorSignals.ALL
                self.StoreVoltageSignals = Enums.SimulatorSignals.ALL
            else:
                self.StoreCurrentSignals = Enums.SimulatorSignals.NONE
                self.StoreVoltageSignals = Enums.SimulatorSignals.NONE
        else:
            setattr(self, key, value)

    def __contains__(self, item):
        return item in self.__dict__

    @property
    def Timeout(self):
        return self.__Timeout

    @Timeout.setter
    def Timeout(self, value):
        """
        The simulation will be killed after this time
        """
        self.__Timeout = float(value)

    @property
    def SimulatorCloseTimeout(self):
        return self.__SimulatorCloseTimeout

    @SimulatorCloseTimeout.setter
    def SimulatorCloseTimeout(self, value):
        """
        If set to a positive integer the simulator task is killed after SimulatorCloseTimeout seconds.
        """
        if value is not None:
            value = max(1, int(value))
        self.__SimulatorCloseTimeout = value

    @property
    def SimOpts(self):
        return self.__SimOpts

    @SimOpts.setter
    def SimOpts(self, value):
        """
        Define options for the simulation run.

        Either assign an instance of base class srd.internal.utils.simulation_options._Options_Base or a
        dictionary containing the same keys as the Options instance.

            Example:

            .. code-block:: python

                self.SimOptions.SimOpts = dict(
                    verbose=1,
                    tmaxstep=10e-6
                )

                from srd import Options_SimetrixTran
                self.SimOptions.SimOpts = Options_SimetrixTran(
                    verbose=1,
                    tmaxstep=10e-6
                )

        :type value: dict|srd._Options_Base|srd._Options_Simetrix|srd._Options_Titan|_Options_AMSDesigner|
                     srd.Options_SimetrixTran|srd.Options_TitanTran|srd.Options_AMSDesignerTran
        """
        from srd.internal.utils import simulation_options

        if isinstance(value, simulation_options._Options_Base):
            self.__SimOpts = value._opts_container.copy()
        elif isinstance(value, dict):
            self.__SimOpts = value
        else:
            msg = "Value has to be a subclass of Options_Base or a dictionary!"
            raise TypeError(msg)

    @property
    def _SimOptsDB(self):
        """
        A dictionary linking schematic paths to simulation option objects.
        """
        return self.__SimOpts_DB

    @property
    def WorkingDir(self):
        return self.__WorkingDir

    @WorkingDir.setter
    def WorkingDir(self, value):
        """
        The directory where netlists,logs and simulation results are stored.

        If not specified the working directory 'simdata' will be automatically created in the variation
        results directories.
        """
        if not isinstance(value, str):
            msg = "WorkingDir has to be a string!"
            raise TypeError(msg)
        if value == "":
            self.__WorkingDir = value
        else:
            self.__WorkingDir = os.path.abspath(os.path.normpath(value))

    @property
    def SchematicDir(self):
        return self.__SchematicDir

    @SchematicDir.setter
    def SchematicDir(self, value):
        """
        The directory containing the schematics. Acts as base path for the schematic names used for 'DUT' parameter.

        If not specified tries to automatically find the schematic dir.

        For AMSDesigner this will be ignored.
        """
        if not isinstance(value, str):
            msg = "SchematicDir has to be a string!"
            raise TypeError(msg)
        self.__SchematicDir = os.path.abspath(os.path.normpath(value))

    @property
    def StoreVoltageSignals(self):
        """
        Defines the voltage signals to automatically store (besides the already implicitly specified signals
        of the scope channels).

        Valid values:

          - Enums.SimulatorSignals.NONE     --> Stores no signals except explicitly defined one
                                                (implicitly specified signals of the scope channels)
          - Enums.SimulatorSignals.TOPLEVEL --> Stores only signals on top-level
          - Enums.SimulatorSignals.ALL      --> Stores all signals (also in sub-circuits) --> big data consumption
        """
        return self.__StoreVoltageSignals

    @StoreVoltageSignals.setter
    def StoreVoltageSignals(self, value):
        """
        Defines the voltage signals to automatically store (besides the already implicitly specified signals of
        the scope channels).

        Valid values:

          - Enums.SimulatorSignals.NONE     --> Stores no signals except explicitly defined one
                                                (implicitly specified signals of the scope channels)
          - Enums.SimulatorSignals.TOPLEVEL --> Stores only signals on top-level
          - Enums.SimulatorSignals.ALL      --> Stores all signals (also in sub-circuits) --> big data consumption
        """
        if value in Enums.SimulatorSignals.__dict__.values():
            self.__StoreVoltageSignals = value
        else:
            msg = "Unknown value! Use enum 'Enums.SimulatorSignals'"
            raise ValueError(msg)

    @property
    def StoreCurrentSignals(self):
        """
        Defines the current signals to automatically store (besides the already implicitly specified signals
        of the scope channels).

        Valid values:

          - Enums.SimulatorSignals.NONE     --> Stores no signals except explicitly defined one
                                                (implicitly specified signals of the scope channels)
          - Enums.SimulatorSignals.TOPLEVEL --> Stores only signals on top-level
          - Enums.SimulatorSignals.ALL      --> Stores all signals (also in sub-circuits) --> big data consumption
        """
        return self.__StoreCurrentSignals

    @StoreCurrentSignals.setter
    def StoreCurrentSignals(self, value):
        """
        Defines the current signals to automatically store
        (besides the already implicitly specified signals of the scope channels).

        Valid values:

          - Enums.SimulatorSignals.NONE     --> Stores no signals except explicitly defined one
                                                (implicitly specified signals of the scope channels)
          - Enums.SimulatorSignals.TOPLEVEL --> Stores only signals on top-level
          - Enums.SimulatorSignals.ALL      --> Stores all signals (also in sub-circuits) --> big data consumption
        """
        if value in Enums.SimulatorSignals.__dict__.values():
            self.__StoreCurrentSignals = value
        else:
            msg = "Unknown value! Use enum 'Enums.SimulatorSignals'"
            raise ValueError(msg)

    @property
    def Simulator(self):
        return self.__Simulator

    @Simulator.setter
    def Simulator(self, value):
        """
        The simulator type.

        Valid values:

          - Enums.Simulator.Simetrix
          - Enums.Simulator.IFXspice
          - Enums.Simulator.AMSDesigner

        See sim-attribute 'ProcessingMode' to specify where the simulation shall be executed:

        - Simetrix + ProcessingMode 'Local'          -> Netlisting & simulation on windows
        - Simetrix + ProcessingMode 'Distributed'    -> not supported, defaulting to ProcessingMode 'Local'
        - IFXSpice + ProcessingMode 'Local'          -> Netlisting & simulation on windows
        - IFXSpice + ProcessingMode 'Distributed'    -> Netlisting only on windows, simulation only on Unix
        - AMSDesigner + ProcessingMode 'Local'       -> Netlisting & simulation on linux
        - AMSDesigner + ProcessingMode 'Distributed' -> not supported, defaulting to ProcessingMode 'Local'

        """
        if value in Enums.Simulator.__dict__.values() or value is None:
            self.__Simulator = value
        else:
            msg = f"Unknown simulator '{value}'! Use enum 'Enums.Simulator'"
            raise ValueError(msg)

    @property
    def ProcessingMode(self):
        return self.__ProcessingMode

    @ProcessingMode.setter
    def ProcessingMode(self, value):
        """
        The simulation processing mode.

        Valid values:

        - Enums.ProcessingMode.Local        -> Execute simulation on local machine (e.g. Simetrix)
        - Enums.ProcessingMode.Distributed  -> Execute simulation distributed (e.g. IFXspice on Linux)

        """
        if value in Enums.ProcessingMode.__dict__.values():
            self.__ProcessingMode = value
        else:
            msg = "Unknown processing mode! Use enum 'Enums.ProcessingMode'"
            raise ValueError(msg)

    @property
    def ReloadPath(self):
        return self.__ReloadPath

    @ReloadPath.setter
    def ReloadPath(self, value):
        """
        The path from where to reload simulation data in execution mode SIM_RELOAD
        """
        if not isinstance(value, str):
            msg = "ReloadPath has to be a string!"
            raise TypeError(msg)
        if value == "":
            self.__ReloadPath = value
        else:
            self.__ReloadPath = os.path.normpath(value)

    @property
    def KeepOpen(self):
        return self.__KeepOpen

    @KeepOpen.setter
    def KeepOpen(self, value):
        """
        If True, the simulator (like Simetrix) is not closed after the test execution.
        """
        self.__KeepOpen = bool(value)


if __name__ == "__main__":
    pass
