from __future__ import annotations

import inspect
from enum import IntEnum


class StimType(IntEnum):
    WAIT = 0

    ACPWR_SINE = 10
    ACPWR_STAIR = 11
    ACPWR_RAMP = 12
    ACPWR_PULSED = 13
    ACPWR_ARB = 14

    PL_CURRENT_STATIC = 20
    PL_CURRENT_RAMP = 21
    PL_CURRENT_PULSED = 22
    PL_CURRENT_STAIR = 23
    PL_VOLTAGE_STATIC = 24
    PL_RESISTIVE_STATIC = 25
    PL_POWER_STATIC = 26
    PL_POWER_RAMP = 27
    PL_POWER_STAIR = 28
    PL_LED_VfRdN = 29

    DCPWR_STATIC = 30

    FGEN_TRIGGER = 40
    FGEN_SINE = 41
    FGEN_DC = 42
    FGEN_SQUARE = 43
    FGEN_TRIANGLE = 44
    FGEN_RAMPUP = 45
    FGEN_RAMPDOWN = 46
    FGEN_ARB = 47
    FGEN_ARBWF = 48


class TimeSpan:
    def __init__(self, start=None, stop=None):
        self.start = start
        self.stop = stop

    def is_wait(self):
        return self.start is None and self.stop is None

    def __str__(self):
        if self.start is None and self.stop is None:
            return "Timespan <WAIT>"
        return f"Timespan <{self.start}:{self.stop}>"

    def __repr__(self):
        return self.__str__()


class Caller(IntEnum):
    PRELOOP = 0
    VARLOOP = 1
    POSTLOOP = 2


class Stimulus:
    def __init__(self, refseq, type, starttime, configdict):
        self.refseq = refseq
        """:type : SimulatedSource"""

        self.type = type
        """:type : StimType"""
        self.config = configdict  # A dict of options for the stimulus
        """:type : dict[str, int|str|list|tuple]"""
        self.starttime = starttime  # The simulation time when the stimulus starts
        """:type : float|int"""

        self.isblocking = type in (StimType.WAIT,)
        self.caller = self.get_caller()
        """:type : Caller"""

    def __str__(self):
        return (
            f"Stim <{self.type.name}>, t={self.starttime} s, "
            f"caller: <{self.caller.name}>, config: {list(self.config.items())}"
        )

    def get_caller(self):
        """
        Returns the function in the user code where the stimulus was created.
        """
        stack = inspect.stack()
        callers_list = [str(stack_entry[3]) for stack_entry in stack]
        if "_do_startup" in callers_list:
            return Caller.PRELOOP
        if "_do_iteration" in callers_list:
            return Caller.VARLOOP
        if "_do_teardown" in callers_list:
            return Caller.POSTLOOP
        return None


class SimulatedSource:
    def __init__(self, ref_AI, manager, ScriptingVars):
        """

        :param ref_AI: Pointer to an AI instance
        :type ref_AI: pverify.core.sim.abstract_instruments.AI_DCSource.AI_DCSource|
                      pverify.core.sim.abstract_instruments.AI_ACSource.AI_ACSource|
                      pverify.core.sim.abstract_instruments.AI_Fgen.AI_Fgen|
                      pverify.core.sim.abstract_instruments.AI_ProgLoad.AI_ProgLoad
        :param manager: Pointer to SimulationManager instance
        :type manager: pverify.core.sim.simulation_manager.SimulationManager
        :param ScriptingVars: Configuration class for the scripting variables of a PyVerify Source
        :type ScriptingVars: pverify.core.sim.source_probe_config_classes.ScriptedSourceVariables
        """
        self.ref_AI = ref_AI
        self.manager = manager

        self.sequence = []
        """:type : list[Stimulus]"""
        self.ScriptingVars = ScriptingVars

        self._timetable = []
        """:type : list[TimeSpan]"""

    def add_stimulus(self, stimulus):
        """

        :type stimulus: Stimulus
        """
        self.sequence.append(stimulus)

    def reset(self):
        for s in self.sequence[:]:
            # Only remove stimuli defined after preloop
            if s.caller != Caller.PRELOOP:
                self.sequence.remove(s)
        self._timetable.clear()

    def get_netlist_entry(self):
        """

        :rtype: dict[str,object]
        """
        # Insert a final wait in stimulus sequence, or extend duration in case it is a 0 time wait
        if not len(self.sequence):
            return
        if self.sequence[-1].type != StimType.WAIT:
            self.sequence.append(
                Stimulus(
                    self,
                    StimType.WAIT,
                    None,
                    {"Milliseconds": self.manager.duration * 1000.0},
                )
            )
        else:
            self.sequence[-1].config["Milliseconds"] = self.manager.duration * 1000.0

        self.createTimeTable()

    def createTimeTable(self):
        """
        This Fucntion determines start end endtime from a sequence of PyVerify
        Stimulus Calls
        """
        self._timetable = []
        ctime = 0
        for stimpart in self.sequence:
            if stimpart.type == StimType.WAIT:
                ctime += stimpart.config["Milliseconds"] / 1000.0
                self._timetable.append(TimeSpan())
            else:
                if ctime > stimpart.starttime:
                    ctime = stimpart.starttime
                self.stop_previous_stimpart(ctime)
                if not stimpart.isblocking:
                    self._timetable.append(TimeSpan(ctime))

        self.stop_previous_stimpart(ctime)

    def stop_previous_stimpart(self, time):
        """
        When a new Stimuls is defined on PyVerify level, this function will
        terminate the previous one on SRD Level with the current time.
        Value.

        :param time: starttime of the new stimulus
        :type time: float
        """
        if len(self._timetable):
            for i in range(len(self._timetable) - 1, -1, -1):
                if self.sequence[i].type != StimType.WAIT:
                    self._timetable[i].stop = time
                    break
