from __future__ import annotations

from pverify.core.sim.simulated_acsource import SimulatedACSource
from pverify.core.sim.simulated_source import StimType, Stimulus

from .mappings import ACSourceMapping


class AI_ACSource:
    def __init__(self, reftest, MappingObject, sim_manager):
        """

        :type reftest: pverify.core.sim.PyVerifySimTest
        :type MappingObject: ACSourceMapping
        :type sim_manager: pverify.core.sim.simulation_manager.SimulationManager
        """
        self.__reftest = reftest

        if isinstance(MappingObject, ACSourceMapping):
            self.__MappingObject = MappingObject

            self._sim_manager = sim_manager
            self._simsrc = SimulatedACSource(self, self._sim_manager, MappingObject.Sim_ScriptingVars)
            self._sim_manager.add_simulated_source(self._simsrc)
        else:
            msg = "Parameter MappingObject has to be of type ACSourceMapping."
            raise TypeError(msg)

    def Sine(self, AmplitudeRMS, Frequency, Phase=0, Offset=0):
        """
        Applies a normal sine.

        :param AmplitudeRMS: The rms value of the sine.
        :type AmplitudeRMS: float
        :param Frequency: The frequency of the sine.
        :type Frequency: float
        :param Phase: The phase angle the ac starts with when it is enabled.
        :type Phase: float
        :param Offset: The DC offset of the sine.
        :type Offset: float

        Example:

        .. code-block:: python

            # Gets an abstract ACSource instrument.
            self.AI_Vac = self.Stimuli.ACSource(MappingObject=mappings.ACSource_ch)

            # Create a static sine wave with given properties
            self.AI_Vac.Sine(AmplitudeRMS=230, Frequency=50, Phase=90, Offset=0)
        """
        self._simsrc.add_stimulus(
            Stimulus(
                self._simsrc,
                StimType.ACPWR_SINE,
                self._sim_manager.current_time,
                {
                    "AmplitudeRMS": max(0.0, float(AmplitudeRMS)),
                    "Frequency": max(1e-12, float(Frequency)),
                    "Phase": max(0.0, float(Phase)),
                    "Offset": float(Offset),
                },
            )
        )

    def Amplitude_Stair(
        self,
        StartAmplitudeRMS,
        StepSize,
        StepCount,
        StepDuration,
        Frequency,
        DwellTimeStart=0,
        DwellTimeEnd=0,
        Phase=0,
        Offset=0,
        Count=1,
    ):
        """
        Applies a sine which amplitude increases/decreases gradually.

        :param StartAmplitudeRMS: The start amplitude (RMS) in volts.
        :type StartAmplitudeRMS: float
        :param StepSize: The amplitude delta (RMS) in volts for each step.
        :type StepSize: float
        :param StepCount: The number of steps.
        :type StepCount: int
        :param StepDuration: The duration of a step in seconds.
        :type StepDuration: float
        :param Frequency: The sine's frequency in hertz.
        :type Frequency: float
        :param DwellTimeStart: The time in seconds the voltage level is held for the first step of the stair
        :type DwellTimeStart: float
        :param DwellTimeEnd: The time in seconds the voltage level is held for the last step of the stair
        :type DwellTimeEnd: float
        :param Phase: The sine's phase in degree.
        :type Phase: float
        :param Offset: The sine's dc offset in volts
        :type Offset: float
        :param Count: The number of repetitions of the stair
        :type Count: float

        Example:

        In the example below the basic usage of the AC Source Stimulus in simulation mode is shown

        .. figure:: images/stimuli_tb.png

        Test circuitry

        .. code-block:: python

            # Gets an abstract ACSource instrument.
            self.AI_Vac = self.Stimuli.ACSource(MappingObject=mappings.ACSource_ch)

            # Create an amplitude stair in with the given properties
            # The stair will start at 90V and will stay there for 1000 ms, then stair up to 190V in 10s and then stay
            # there for 1000 ms
            self.AI_Vac.Amplitude_Stair(StartAmplitudeRMS=90, StepSize=10, StepCount=10, StepDuration=1,
                                        DwellTimeStart=1, DwellTimeEnd=1, Frequency=50, Phase=0, Offset=0, Count=1)

        .. figure:: images/stimuli_tb-graph.png

        """
        self._simsrc.add_stimulus(
            Stimulus(
                self._simsrc,
                StimType.ACPWR_STAIR,
                self._sim_manager.current_time,
                {
                    "StartAmplitudeRMS": max(0.0, float(StartAmplitudeRMS)),
                    "StepSize": float(StepSize),
                    "StepCount": max(1, int(StepCount)),
                    "StepDuration": max(1e-12, float(StepDuration)),
                    "Frequency": max(1e-12, float(Frequency)),
                    "Phase": max(0.0, float(Phase)),
                    "DwellTimeStart": max(0.0, float(DwellTimeStart)),
                    "DwellTimeEnd": max(0.0, float(DwellTimeEnd)),
                    "Offset": float(Offset),
                    "Count": max(0.0, Count),
                },
            )
        )

    def Amplitude_Ramp(
        self,
        StartAmplitudeRMS,
        StopAmplitudeRMS,
        Duration,
        Frequency,
        DwellTimeStart=0,
        DwellTimeEnd=0,
        Phase=0,
        Offset=0,
        Count=1,
        **kwargs,
    ):
        """
        Applies a sine which amplitude increases/decreases smoothly.

        :param StartAmplitudeRMS: The start amplitude (RMS) in volts.
        :type StartAmplitudeRMS: float
        :param StopAmplitudeRMS: The stop amplitude (RMS) in volts.
        :type StopAmplitudeRMS: float
        :param Duration: The duration of the ramp in seconds.
        :type Duration: float
        :param Frequency: The sine's frequency in hertz.
        :type Frequency: float
        :param DwellTimeStart: The time in seconds the voltage level is held for the first step of the stair
        :type DwellTimeStart: float
        :param DwellTimeEnd: The time in seconds the voltage level is held for the last step of the stair
        :type DwellTimeEnd: float
        :param Phase: The sine's phase in degree.
        :type Phase: float
        :param Offset: The sine's dc offset in volts
        :type Offset: float
        :param Count: The number of repetitions of the stair
        :type Count: float
        :param kwargs: Keyword arguments that are specific for simulation (leading Sim).

        Example:

        .. code-block:: python

            # Gets an abstract ACSource instrument.
            self.AI_Vac = self.Stimuli.ACSource(MappingObject=mappings.ACSource_ch)

            # Create an amplitude stair in with the given properties
            # The ramp will start at 90V and will stay there for 2000 ms, then ramp up to 230V in 1s and then stay
            # there for 500 ms
            # If VAC level was set to any level before it will return to this level afterwards
            self.AI_Vac.Amplitude_Ramp(StartAmplitudeRMS=90, StopAmplitudeRMS=230, Duration=1, Frequency=50,
                                       DwellTimeStart=2, DwellTimeEnd=0.5, Phase=0, Offset=0, Count=2)
        """
        if "SimScaleFactor" in kwargs:
            Duration = Duration / kwargs["SimScaleFactor"]
        self._simsrc.add_stimulus(
            Stimulus(
                self._simsrc,
                StimType.ACPWR_RAMP,
                self._sim_manager.current_time,
                {
                    "StartAmplitudeRMS": max(0.0, float(StartAmplitudeRMS)),
                    "StopAmplitudeRMS": max(0.0, float(StopAmplitudeRMS)),
                    "DwellTimeStart": max(0.0, float(DwellTimeStart)),
                    "DwellTimeEnd": max(0.0, float(DwellTimeEnd)),
                    "Duration": max(1e-12, float(Duration)),
                    "Frequency": max(1e-12, float(Frequency)),
                    "Phase": max(0.0, float(Phase)),
                    "Offset": float(Offset),
                    "Count": max(0.0, Count),
                },
            )
        )

    def Amplitude_Pulsed(
        self,
        AmplitudeRMS_1,
        AmplitudeRMS_2,
        DwellTime_1,
        DwellTime_2,
        Frequency,
        Phase=0,
        Offset=0,
        Count=1,
    ):
        """
        Applies a sine which amplitude jumps between two levels while staying at each level for DwellTime_1
        or DwellTime_2 seconds.


        :param AmplitudeRMS_1: The first amplitude (RMS) level in volts.
        :type AmplitudeRMS_1: float
        :param AmplitudeRMS_2: The second amplitude (RMS) level in volts.
        :type AmplitudeRMS_2: float
        :param DwellTime_1: The duration of the first level in seconds.
        :type DwellTime_1: float
        :param DwellTime_2: The duration of the second level in seconds.
        :type DwellTime_2: float
        :param Frequency: The sine's frequency in hertz.
        :type Frequency: float
        :param Phase: The sine's phase in degree.
        :type Phase: float
        :param Offset: The sine's dc offset in volts
        :type Offset: float
        :param Count: The number of repetitions of the pulse
        :type Count: float

        Example:

        .. code-block:: python

            # Gets an abstract ACSource instrument.
            self.AI_Vac = self.Stimuli.ACSource(MappingObject=mappings.ACSource_ch)

            # Create a pulsed 50 Hz sine in with that stays for 4s on 230V and then quickly jumps to 0V for 50ms.
            # This cycle is repeated 10 times
            # If VAC level was set to any level before it will return to this level afterwards
            self.AI_Vac.Amplitude_Pulsed(AmplitudeRMS_1=230, AmplitudeRMS_2=0, DwellTime_1=4, DwellTime_2=0.050,
                                         Frequency=50, Phase=0, Offset=0, Count=10)
        """
        self._simsrc.add_stimulus(
            Stimulus(
                self._simsrc,
                StimType.ACPWR_PULSED,
                self._sim_manager.current_time,
                {
                    "DwellTime_1": max(1e-12, float(DwellTime_1)),
                    "AmplitudeRMS_1": max(0.0, float(AmplitudeRMS_1)),
                    "DwellTime_2": max(1e-12, float(DwellTime_2)),
                    "AmplitudeRMS_2": max(0.0, float(AmplitudeRMS_2)),
                    "Offset": float(Offset),
                    "Frequency": max(1e-12, float(Frequency)),
                    "Phase": max(0.0, float(Phase)),
                    "Count": max(0.0, Count),
                },
            )
        )

    def Amplitude_Arbitrary(
        self,
        AmplitudeRMS_Start,
        AmplitudeRMS_Stop,
        DwellTime,
        Frequency_Start,
        Frequency_Stop,
        Phase=None,
        Offset_Start=None,
        Offset_Stop=None,
        Count=1,
    ):
        """
        Runs an arbitrary sequence of AC settings. The sequence consists of multiple steps. For each step a
        start- & stop-rms-amplitude, start- & stop-frequency, a dwell time has to be specified.
        Optionally a phase angle and start- & stop-dc-offset may be specified
        The lists of parameters AmplitudeRMS_Start, AmplitudeRMS_Stop, DwellTime, Frequency_Start, Frequency_Stop,
        Phase, Offset_Start and Offset_Stop must have the same length.

        :param AmplitudeRMS_Start: A list of start amplitudes for all steps
        :type AmplitudeRMS_Start: list
        :param AmplitudeRMS_Stop: A list of stop amplitudes for all steps
        :type AmplitudeRMS_Stop: list
        :param DwellTime: A list of dwell times for all steps
        :type DwellTime: list
        :param Frequency_Start: A list of start frequencies for all steps
        :type Frequency_Start: list
        :param Frequency_Stop: A list of stop frequencies for all steps
        :type Frequency_Stop: list
        :param Phase: A list of phases for all steps
        :type Phase: list
        :param Offset_Start: A list of start amplitudes for all steps
        :type Offset_Start: list
        :param Offset_Stop: A list of stop amplitudes for all steps
        :type Offset_Stop: list
        :param Count: The number of repetitions of the pulse
        :type Count: float

        Example:

        .. code-block:: python

            drop_times = [0.025, 0.04, 0.06, 0.09, 0.13, 0.2, 0.28, 0.4, 0.6, 0.9, 1.3, 2.0]
            dwelltimes = range(len(drop_times)*2)
            dwelltimes[::2] = drop_times
            dwelltimes[1::2] = [self.Current_variation["OnPeriod"]] * len(drop_times)
            amps = [self.Current_variation["V_drop"], self.Current_variation["Vac"]] * len(drop_times)

            self.AI_Vac.Amplitude_Arbitrary(AmplitudeRMS_Start=amps,
                                            AmplitudeRMS_Stop=amps,
                                            DwellTime=dwelltimes,
                                            Frequency_Start=[self.Current_variation["Fac"]] * len(dwelltimes),
                                            Frequency_Stop=[self.Current_variation["Fac"]] * len(dwelltimes),
                                            Count=1)

        """
        self._simsrc.add_stimulus(
            Stimulus(
                self._simsrc,
                StimType.ACPWR_ARB,
                self._sim_manager.current_time,
                {
                    "AmplitudeRMS_Start": [max(0.0, float(i)) for i in AmplitudeRMS_Start],
                    "AmplitudeRMS_Stop": [max(0.0, float(i)) for i in AmplitudeRMS_Stop],
                    "DwellTime": [max(1e-12, float(i)) for i in DwellTime],
                    "Frequency_Start": [max(1e-12, float(i)) for i in Frequency_Start],
                    "Frequency_Stop": [max(1e-12, float(i)) for i in Frequency_Stop],
                    "Phase": [max(0.0, float(i)) for i in Phase],
                    "Offset_Start": [float(i) for i in Offset_Start],
                    "Offset_Stop": [float(i) for i in Offset_Stop],
                    "Count": max(0.0, Count),
                },
            )
        )

    def Setup(self, LineResistance=None, LineInductance=None):
        """
        Setup of simulated line impedance and inrush current settings.

        :param LineResistance: Simulated line resistance.
        :type LineResistance: float
        :param LineInductance: Simulated line inductance.
        :type LineInductance: float

        Example:

        .. code-block:: python

            self.AI_Vac.Setup(LineInductance=self.Current_variation["Inrush_Lline"],
                              LineResistance=self.Current_variation["Inrush_Rline"],
                              InrushCurrentStart=0,
                              InrushCurrentInterval=self.Current_variation["Inrush_CheckInterval"],)
        """
        if LineResistance is not None:
            self._simsrc.r_line = max(0.0, float(LineResistance))
        if LineInductance is not None:
            self._simsrc.l_line = max(0.0, float(LineInductance))
