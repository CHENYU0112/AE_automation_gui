from __future__ import annotations

from typing import TYPE_CHECKING

from pverify.core.internals.Enums import Enums
from pverify.core.sim.simulated_scope import SimulatedScope

from .mappings import ScopeMapping

if TYPE_CHECKING:
    from pverify.postproc.waveform import Waveform


class AI_Scope:
    def __init__(self, reftest, sim_manager):
        """

        :type reftest: pverify.core.sim.PyVerifySimTest
        :type sim_manager: pverify.core.sim.simulation_manager.SimulationManager
        """
        self._reftest = reftest
        self._sim_manager = sim_manager
        self._SimScope = SimulatedScope(self, self._sim_manager)
        self._sim_manager.add_simulated_probe(self._SimScope)

    def ScopeSetup(self, TimePerRecord, RecordLength):
        """
        Sets the most commonly used parameters for the scope acquisition.

        :param TimePerRecord: Time in seconds of the acquired waveform. Recordlength/TimePerRecord=SampleRate.
        :type TimePerRecord: float
        :param RecordLength: The record length of the acquired waveform. Recordlength/TimePerRecord=SampleRate.
                             If set to 0, the probes waveform will not be resampled to an equidistant time vector.
        :type RecordLength: int | float

        Example:

        .. code-block:: python

          self.AI_Scope.ScopeSetup(TimePerRecord=200e-6, RecordLength=125000)
        """
        self._SimScope.ScopeSetup(TimePerRecord, RecordLength)

    def Arm(self, **kwargs):
        """
        Arms the acquisition of the probe.

        This methods defines that the point in time when the simulated scope starts looking for a trigger condition.
        This means you cannot see any simulation data in your waveform before the Arm happened

        It also sets the minimal simulation duration to:
        Arm-time + TimePerRecord + (100. - TriggerPos) * 0.01 * TimePerRecord

        Example::

            self.AI_Scope.ScopeSetup(TimePerRecord=0.1, RecordLength=100000)
            self.AI_Scope.Trigger_Edge(0, "rise", 75, "DC", mappings.Probe_Vout
            ...
            self.AbstractInstruments.Wait(20)
            self.AI_Scope.Arm()

        """
        self._SimScope.Arm()

    def Trigger_Edge(self, Level, Slope, Position, Coupling, MappingObject, **kwargs):
        """
        Specifies the parameters of an edge trigger.

        :param Level: The trigger level.
        :type Level: float
        :param Slope: Defines the slope the probe triggers on (RISE, FALL)
        :type Slope: str
        :param Position: The horizontal trigger position in %.
        :type Position: float
        :param Coupling: The coupling of the trigger.

            - "AC"
            - "DC"

        :type Coupling: str
        :param MappingObject: Acts as trigger source.
                              The mapping object which defines the netlist setup.
                              Use one of the constants of "config.mappings"
        :type MappingObject: utility.HelperClasses.ScopeMapping

        Example:

        .. code-block:: python

          self.AI_Scope.Trigger_Edge(Level=5,
                                     Slope="RISE",
                                     Position=50,
                                     Coupling="DC",
                                     MappingObject=mappings.Scope_GD)
        """
        if not (0 <= Position <= 100):
            msg = "Trigger position must be between 0% and 100%!"
            raise ValueError(msg)

        if isinstance(MappingObject, ScopeMapping):
            self._SimScope.Trigger_Edge(Level, Slope, Position, Coupling, MappingObject)
        else:
            msg = "Trigger Mapping Object must be of Type Scope Mapping"
            raise Exception(msg)

    def Trigger_Width(
        self, Level, Polarity, Condition, ThresholdLow, ThresholdHigh, Position, Coupling, MappingObject, **kwargs
    ):
        """
        Configures the width trigger Source, Level, ThresholdLow,
        ThresholdHigh, Polarity, and Condition. A width trigger occurs when a
        pulse, that passes through Level, with a width between or outside, the
        width thresholds is detected.

        :param Level: The trigger level.
        :type Level: float
        :param Polarity: The polarity of the pulse that triggers the oscilloscope.
                         Either "POSITIVE", or "NEGATIVE", or short "POS", "NEG"
        :type Polarity: str
        :param Condition: The condition of a pulse that triggers the oscilloscope.
                          The condition is either "WITHIN", "OUTSIDE" or "TIMEOUT" of the high and low thresholds.
                          If "TIMEOUT" the high threshold will be ignored.
        :type Condition: str
        :param ThresholdLow: The low width threshold time. The units are seconds.
        :type ThresholdLow: float
        :param ThresholdHigh: The high width threshold time. The units are seconds.
        :type ThresholdHigh: float
        :param Position: The horizontal trigger position in %.
        :type Position: float
        :param MappingObject: The mapping object which defines the netlist setup.
                              Use one of the constants of "config.mappings"
        :type MappingObject: ScopeMapping
        :param Coupling: The coupling of the trigger.

            - "AC"
            - "DC"

        :type Coupling: str
        """
        if not (0 <= Position <= 100):
            msg = "Trigger position must be between 0% and 100%!"
            raise ValueError(msg)

        self._SimScope.Trigger_Width(
            Level,
            Polarity,
            Condition,
            ThresholdLow,
            ThresholdHigh,
            Position,
            Coupling,
            MappingObject,
        )

    def Trigger_Glitch(self, Level, Polarity, Condition, Width, Position, MappingObject, Coupling, **kwargs):
        """
        Configures the width trigger Source, Level, ThresholdLow,
        ThresholdHigh, Polarity, and Condition. A width trigger occurs when a
        pulse, that passes through Level, with a width between or outside, the
        width thresholds is detected.

        :param Level: The trigger level.
        :type Level: float
        :param Polarity: The polarity of the pulse that triggers the oscilloscope.
                         Either "POSITIVE", or "NEGATIVE", or short "POS", "NEG"
        :type Polarity: str
        :param Condition: The glitch condition detemermines whether the oscilloscope triggers on a a
                          pulse with a width "LESS" then or "MORE" than the glitch width value.
        :type Condition: str
        :param Width: The glitch width. The units are seconds.
        :type Width: float
        :param Position: The horizontal trigger position in %.
        :type Position: float
        :param MappingObject: The mapping object which defines the netlist setup.
                              Use one of the constants of "config.mappings"
        :type MappingObject: ScopeMapping
        :param Coupling: The coupling of the trigger.

            - "AC"
            - "DC"

        :type Coupling: str
        """
        if not (0 <= Position <= 100):
            msg = "Trigger position must be between 0% and 100%!"
            raise ValueError(msg)

        self._SimScope.Trigger_Glitch(Level, Polarity, Condition, Width, Position, MappingObject, Coupling)

    def GetChannel(self, MappingObject):
        """
        Returns a channel object for the probe.
        The different probe channels can be set up indepentently from each other.
        A Differential channel can be generated by passing a reference signal in
        the constructor of the used MappingObject

        :param MappingObject: The mapping object which defines the netlist setup.
                              Use one of the constants of "config.mappings"
        :type MappingObject: ScopeMapping
        :return: _ScopeChannel class instance
        :rtype: _ScopeChannel

        Example:

        .. code-block:: python

          self.AI_Scope_GD = self.AI_Scope.GetChannel(MappingObject=mappings.Scope_GD)
        """
        if isinstance(MappingObject, ScopeMapping):
            if self._reftest.Attributes.ExecutionMode in Enums.SimExecutionModes:
                return _ScopeChannel(
                    MappingObject=MappingObject,
                    SimScope=self._SimScope,
                    reftest=self._reftest,
                )

            if self._reftest.Attributes.ExecutionMode in [Enums.ExecutionMode.PostProcOnly]:
                return _ScopeChannel(MappingObject=MappingObject, SimScope=None, reftest=self._reftest)
            return None
        msg = "An instance of type <ScopeMapping> has to be passed to this function"
        raise TypeError(msg)


# Common again
class _ScopeChannel:
    """
    A Class providing all fuunctionality of a scope channel
    """

    def __init__(self, MappingObject, SimScope, reftest):
        """
        :type MappingObject: ScopeMapping
        :type SimScope: SimulatedScope|NoneType
        :type reftest: pverify.PyVerifyBaseTest
        """
        self.__MappingObject = MappingObject
        self.__reftest = reftest

        self.__SimScope = SimScope
        self.__SimScopeChannel = SimScope.GetChannel(MappingObject)

    def ProbeSetup(self, Coupling="dc", Bandwidth=0):
        """
        Sets the most commonly used parameters for a channel

        :param Coupling: Defines how the probe is coupled (AC, DC). Default "dc" (signal not changed)
        :type Coupling: str
        :param Bandwidth: The maximum bandwidth of the probe. 0 to disable bandwidth filter.
        :type Bandwidth: float

        Example:

        .. code-block:: python

          self.AI_Scope_GD.ProbeSetup(Coupling="DC",
                                      Bandwidth=20e6)
        """
        self.__SimScopeChannel.ProbeSetup(Coupling, Bandwidth)

    def GetProbeWaveform(self, DecimationFactor=1) -> Waveform:
        """
        Returns a dictionary representing the time- and data-vector of an acquired waveform.

        :param DecimationFactor: If greater than 1, the function will return a waveform decimated by 'DecimationFactor'.
                                 E.g. calling the function with DecimationFactor=10 will return 10 times less points.
        :return: Waveform object

        Example:

        .. code-block:: python

          self.rc.add("GD_Wave", self.AI_Scope_GD.GetProbeWaveform(5))
          # Do some postprocessing
          self.rc["GD_Wave"].decimate(15000).histogram(bins=2**13).plot()
        """
        return self.__SimScopeChannel.GetProbeWaveform(DecimationFactor)

    def GetProbeMeasurement(self, MeasurementItem):
        """
        Returns a dictionary representing the time- and data-vector of an acquired waveform.

        :param MeasurementItem: The measurement that is returned.
                                Items:
                                Amplitude, Average, RMS, PeakToPeak,
                                SDeviation, BurstWidth, Delay, DeltaT,
                                Dutycycle, EdgeCount, PulseCount,
                                Risetime, Falltime, Frequency, Period,
                                AvgFreq, AvgPeriod, High, Low, Maximum,
                                Minimum, NOvershoot, POvershoot,
                                WidthPos, WidthNeg
        :type MeasurementItem: str
        :return: Measured value
        :rtype: float

        Example:

        .. code-block:: python

          self.rc.add("GD_AvgFreq", self.AI_Scope_GD.GetProbeMeasurement("AvgFreq"))
        """
        return self.__SimScopeChannel.GetProbeMeasurement(MeasurementItem)


if __name__ == "__main__":
    pass
