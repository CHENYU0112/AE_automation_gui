from __future__ import annotations

from pverify.core.sim.simulated_source import StimType, Stimulus
from pverify.core.sim.simulation_manager import SimulationManager

from . import mappings
from .AI_ACSource import AI_ACSource
from .AI_DCSource import AI_DCSource
from .AI_Fgen import AI_Fgen
from .AI_PowerAnalyzer import AI_PowerAnalyzer
from .AI_ProgLoad import AI_ProgLoad
from .AI_Scope import AI_Scope


class AbstractInstruments:
    def __init__(self, reftest):
        self._reftest = reftest
        self._simulation_manager = SimulationManager(self._reftest)

    def Scope(self):
        """
        Returns an abstract scope instrument.

        :rtype: AI_Scope

        Example:

        .. code-block:: python

          self.AI_Scope = self.AbstractInstruments.Scope()
        """
        return AI_Scope(reftest=self._reftest, sim_manager=self._simulation_manager)

    def Fgen(self):
        """
        Returns an abstract scope instrument.

        :rtype: AI_Fgen

        Example:

        .. code-block:: python

          self.AI_Scope = self.AbstractInstruments.Scope()
        """
        return AI_Fgen(reftest=self._reftest, sim_manager=self._simulation_manager)

    def PowerAnalyzer(self, LinkTo=None):
        """
        Returns an abstract power analyzer instrument.

        :param LinkTo: Another abstract poweranalyzer instance which shall be linked to this one.
                       The settings will automatically be synchronized and both will be armed at the same time.
        :rtype: AI_PowerAnalyzer

        Example:

        .. code-block:: python

          self.AI_PA = self.AbstractInstruments.PowerAnalyzer()
        """
        return AI_PowerAnalyzer(reftest=self._reftest, sim_manager=self._simulation_manager)

    def ACSource(self, MappingObject=None):
        """
        Returns an abstract ACSource stimulus instrument.

        :param MappingObject: The mapping object which defines the netlist setup.
                              Use one of the constants of "config.mappings"
        :type MappingObject: mappings.ACSourceMapping
        :rtype: AI_ACSource

        Example:

        .. code-block:: python

          self.AI_Vac = self.AbstractInstruments.ACSource(MappingObject=mappings.ACSource_ch)
        """
        if isinstance(MappingObject, mappings.ACSourceMapping):
            return AI_ACSource(
                reftest=self._reftest,
                MappingObject=MappingObject,
                sim_manager=self._simulation_manager,
            )
        msg = "A mapping object has to be passed to this function"
        raise Exception(msg)

    def DCSource(self):
        """
        Returns an abstract DCSource stimulus instrument.

        :return: AI_DCSource Object
        :rtype: AI_DCSource

        Example:

        .. code-block:: python

          self.AI_Vdc = self.AbstractInstruments.DCSource()

        """
        return AI_DCSource(reftest=self._reftest, sim_manager=self._simulation_manager)

    def ProgLoad(self, MappingObject=None):
        """
        Returns an abstract ProgLoad stimulus instrument.

        :param MappingObject: MappingObject: The mapping object which defines the netlist setup.
                              Use one of the constants of "config.mappings"
        :type MappingObject: utility.HelperClasses.ProgLoadMapping
        :rtype: AI_ProgLoad

        Example:

        .. code-block:: python

          self.AbstractInstruments.ProgLoad(MappingObject=mappings.DCSource_ch1)
          # with DCSource_ch1 = DCSourceMapping(Lab_Channel=1)
        """
        if isinstance(MappingObject, mappings.ProgLoadMapping):
            return AI_ProgLoad(
                reftest=self._reftest,
                MappingObject=MappingObject,
                sim_manager=self._simulation_manager,
            )
        msg = "A mapping object has to be passed to this function"
        raise Exception(msg)

    def Wait(self, Milliseconds, **kwargs):
        """
        Wait for a specific time.\n
        This function configures the simulation to hold the previous called stimulus.

        :param Milliseconds: The time to wait in milliseconds.
        :type Milliseconds: float
        :param kwargs: Keyword arguments that are specific for simulation.
        :keyword SimWait: If given keyword 'SimScaleFactor' is ignored and simulation performs an explicit wait
                          of 'SimWait' milliseconds.
        :keyword SimScaleFactor: The scaling factor for the specified waiting time in simulation.
                                      E.g. SimScaleFactor=0.1 means that a real waiting time of 10s is 1s in
                                      simulation.

        .. note::
           In simulation some abstract instrument methods like ACSource.Sine does not perform an explicit wait.
           That means, when the the testcase defines the Sine and without an explicit wait statement before
           defining another different Stimulus,
           the first stimulus definition will not have any effect.

        """
        try:
            _SimScaleFactor = float(kwargs["SimScaleFactor"])
            if _SimScaleFactor == 0:
                Milliseconds = 0
            else:
                Milliseconds *= float(_SimScaleFactor)
        except KeyError:
            _SimScaleFactor = 1
        if "SimWait" in kwargs:
            Milliseconds = kwargs["SimWait"]

        for s in self._simulation_manager.sources:
            # Insert wait stimulus into each simulated stimulus
            s.add_stimulus(
                Stimulus(
                    s,
                    StimType.WAIT,
                    self._simulation_manager.current_time,
                    {"Milliseconds": Milliseconds},
                )
            )
        self._simulation_manager.current_time += Milliseconds / 1000.0
