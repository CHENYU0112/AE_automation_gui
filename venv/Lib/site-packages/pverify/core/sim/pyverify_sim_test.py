from __future__ import annotations

import contextlib
import glob
import os
import pprint
import re
import tempfile
import traceback
from copy import deepcopy
from os.path import *
from pathlib import Path
from shutil import copy, move, rmtree
from subprocess import TimeoutExpired
from time import sleep

import psutil
import srd

from pverify.core.env import IS_WIN
from pverify.core.hooks import DoE
from pverify.core.internals.Enums import Enums
from pverify.core.internals.postproconly import file_prompt_process
from pverify.core.pyverify_base_test import PyVerifyBaseTest
from pverify.core.util.fnmatch_filter import filter

from .abstract_instruments.abstract_instruments import AbstractInstruments
from .sim_options import SimOptions
from .simutils import SimUtils


class NetlistingOnlyException(Exception):
    pass


class PyVerifySimTest(PyVerifyBaseTest):
    __SIM_ERRORS = (
        lambda line: "no license available" in line,
        lambda line: line.startswith("error") or "*** error ***" in line,
    )

    __SIM_IGNORE_ERRORS = (lambda line: "no license for the dvm_if feature available" in line,)

    def __init__(self, **kwargs):
        self._sim_has_run = False
        self._sim_failed = False
        self._at_least_one_sim_failed = False
        self._sim_killed = False
        self._sim_analysis = None
        """:type : srd.TransientAnalysis"""
        self._sim_netlistonly = False
        self.__SimUtils = SimUtils(self)
        self.__AbstractInstruments = AbstractInstruments(self)
        self.__SimOptions = SimOptions()

        super().__init__(**kwargs)

    def _deprecated_support(self):
        super()._deprecated_support()
        self.Attributes.SimulationAttributes = self.__SimOptions
        self.Utils.SimUtils = self.__SimUtils

    @DoE.Init(is_hook_wrapper=True, try_first=True, silent=True)
    def sim_init(self):
        yield

        if self.Attributes.ExecutionMode not in (
            Enums.ExecutionMode.Undef,
            Enums.ExecutionMode.Sim,
            Enums.ExecutionMode.Sim_Reload,
            Enums.ExecutionMode.PostProcOnly,
        ):
            msg = "Can only use this base class for simulation related execution modes!"
            raise ValueError(msg)

    @DoE.Startup(is_hook_wrapper=True, try_first=True, silent=True)
    def sim_startup(self):
        yield

        # SIMULATION SPECIFIC STUFF
        if self.Attributes.ExecutionMode == Enums.ExecutionMode.Sim:
            self.__create_analysis_instance()

        elif self.Attributes.ExecutionMode == Enums.ExecutionMode.Sim_Reload:
            self.__create_analysis_instance()

            if self.SimOptions.ReloadPath in [None, ""]:
                self.Utils.LogInfo("SimOptions.ReloadPath not set by user. Setting to ''")
                self.SimOptions.ReloadPath = ""

            if not exists(self.SimOptions.ReloadPath):
                self.Utils.LogInfo(
                    f"SimOptions.ReloadPath '{self.SimOptions.ReloadPath}' does not exist. Prompting user for path..."
                )
                self.SimOptions.ReloadPath = file_prompt_process(
                    "Select a test result root dir or working dir with simulation results",
                    None,
                    dironly=True,
                )

            if not exists(self.SimOptions.ReloadPath):
                self.Utils.LogInfo(
                    f"No simulation reload path selected by user. Using test result directory "
                    f"'{self.Utils.ResultDirectory}' as default!"
                )
                self.SimOptions.ReloadPath = str(self.Utils.ResultDirectory)
            else:
                self.Utils.LogInfo(f"Simulation reload path: '{self.SimOptions.ReloadPath}'")

        self.AbstractInstruments._simulation_manager.set_time_after_preloop()

    @DoE.Iteration(
        is_hook_wrapper=True,
        try_first=True,
        silent=True,
        ignore_error=(NetlistingOnlyException,),
    )
    def sim_iteration(self):
        self._sim_has_run = False
        self._sim_failed = False
        self._sim_killed = False
        self.AbstractInstruments._simulation_manager.reset()

        yield

    @DoE.IterationPostprocessing(is_hook_wrapper=True, try_first=True, silent=True)
    def sim_iteration_postprocessing(self):
        yield

    @DoE.Teardown(is_hook_wrapper=True, try_first=True, silent=True)
    def sim_teardown(self):
        if (
            self.Attributes.ExecutionMode in Enums.SimExecutionModes
            and self._sim_netlistonly
            and self.SimOptions.ProcessingMode == Enums.ProcessingMode.Distributed
        ):
            self.start_simulation(srd_internal_sweep=True)

        yield

        if self._sim_analysis is not None:
            try:
                self._sim_analysis.cleanup()
                if (
                    not self.SimOptions.KeepOpen
                    and not self._sim_killed
                    and self.SimOptions.Simulator != Enums.Simulator.AMSDesigner
                ):
                    self.Utils.LogInfo("Shutting down simulator!")
                    try:
                        self._sim_analysis.stopSimulator(timeout=self.SimOptions.SimulatorCloseTimeout)
                    except Exception:
                        srd.TransientAnalysis(srd.Options_SimetrixTran(workingdir="", schematic="")).stopSimulator(
                            timeout=self.SimOptions.SimulatorCloseTimeout
                        )
            except Exception as e:
                self.Utils.LogError(f"Error when uninitializing simulator: {e}")

    @property
    def AbstractInstruments(self):
        return self.__AbstractInstruments

    @property
    def sim_manager(self):
        """:rtype : pverify.core.sim.simulation_manager.SimulationManager"""
        return self.AbstractInstruments._simulation_manager

    @property
    def SimOptions(self):
        return self.__SimOptions

    @property
    def SimUtils(self):
        """
        A container class for simulation specific routines
        """
        return self.__SimUtils

    @property
    def simulation_failed(self):
        return self.Attributes.ExecutionMode == Enums.ExecutionMode.Sim and (self._sim_failed or self._sim_killed)

    def __create_analysis_instance(self):
        with tempfile.TemporaryDirectory() as td:
            temp_schem = td

        self.Utils.LogInfo("Loaded SRD module: " + str(srd))
        workingdir = Path(self._test_file_path).parent.as_posix()

        if self.SimOptions.Simulator == Enums.Simulator.Simetrix:
            if self.SimOptions.ProcessingMode != Enums.ProcessingMode.Local:
                self.Utils.LogWarning(
                    "Unsupported processing mode for simulator Simetrix! Defaulting to processing mode 'Local'!"
                )
                self.SimOptions.ProcessingMode = Enums.ProcessingMode.Local
            self._sim_analysis = srd.TransientAnalysis(
                srd.Options_SimetrixTran(workingdir=workingdir, schematic=temp_schem)
            )
        elif self.SimOptions.Simulator == Enums.Simulator.IFXspice:
            if self.SimOptions.ProcessingMode == Enums.ProcessingMode.Local:
                self._sim_analysis = srd.TransientAnalysis(
                    srd.Options_TitanTran(
                        workingdir=workingdir,
                        schematic=temp_schem,
                        simdata_format=srd.enums.SimulationDatatype.SXDAT,
                    )
                )
            elif self.SimOptions.ProcessingMode == Enums.ProcessingMode.Distributed:
                self._sim_analysis = srd.TransientAnalysis(
                    srd.Options_TitanTran(
                        workingdir=workingdir,
                        schematic=temp_schem,
                        simdata_format=srd.enums.SimulationDatatype.HDF5,
                    )
                )
            else:
                msg = "Unknown processign mode!"
                raise Exception(msg)
        elif self.SimOptions.Simulator == Enums.Simulator.AMSDesigner:
            if self.SimOptions.ProcessingMode != Enums.ProcessingMode.Local:
                self.Utils.LogWarning(
                    "Unsupported processing mode for simulator AMSDesigner! Defaulting to processing mode 'Local'!"
                )
                self.SimOptions.ProcessingMode = Enums.ProcessingMode.Local
            self._sim_analysis = srd.TransientAnalysis(
                srd.Options_AMSDesignerTran(
                    workingdir=workingdir,
                    schematic=r"lib.cell:config#ams_state",  # Dummy entry only
                    unit=os.environ.get("AVENUE_FLOW_UNITNAME"),  # Unit needed if Avenue is used
                    sim_exec_mode="local" if os.environ.get("AVENUE_FLOW_UNITNAME") else "sequential",
                )
            )
        elif self.SimOptions.Simulator is None:
            pass
        else:
            msg = "Unknown simulator type!"
            raise Exception(msg)

        self.Utils.LogInfo(f"Simulator:       {self.SimOptions.Simulator}")
        self.Utils.LogInfo(f"Processing Mode: {self.SimOptions.ProcessingMode}")

        if self.SimOptions.Simulator is not None:
            self.Utils.LogInfo("Starting simulator...")
            self._sim_analysis.startSimulator()

    def start_simulation(self, srd_internal_sweep=False):
        """:type self: PyVerifyBaseTest|BASE_SIM"""
        timeout = self.SimOptions.Timeout
        timeout = None if timeout <= 0 else timeout

        if self.Attributes.ExecutionMode in Enums.SimExecutionModes:
            # -------------------------- #
            #         Preparation        #
            # -------------------------- #
            current_variation = dict(self.Current_variation.copy())

            current_variation["DUT"] = normpath(current_variation["DUT"])

            # ----- Check for valid schematic dir ----- #
            if self.SimOptions.Simulator == Enums.Simulator.AMSDesigner:
                self.SimOptions.SchematicDir = "/"
            elif self.SimOptions.SchematicDir is None:
                if not isabs(current_variation["DUT"]):
                    self.Utils.LogWarning(
                        "Schematic path (Parameter 'DUT') is not an absolute path, "
                        "searching for schematic in test script dir and subfolders (depth=2)..."
                    )
                    files = (
                        glob.glob(
                            join(
                                dirname(self._test_file_path),
                                self.Parameters["DUT"].DefaultValues[0],
                            )
                        )
                        + glob.glob(
                            join(
                                dirname(self._test_file_path),
                                "*",
                                self.Parameters["DUT"].DefaultValues[0],
                            )
                        )
                        + glob.glob(
                            join(
                                dirname(self._test_file_path),
                                "*",
                                "*",
                                self.Parameters["DUT"].DefaultValues[0],
                            )
                        )
                    )
                    wdirs = list({normpath(dirname(f)) for f in files})  # Get dirnames and remove duplicates
                    if len(wdirs):
                        if len(wdirs) > 1:
                            self.Utils.LogWarning(
                                "Found multiple different schematic dirs:\n    {}".format("\n".join(wdirs))
                            )
                        self.Utils.LogWarning(f"Using schematic dir '{wdirs[0]}'")
                        self.SimOptions.SchematicDir = wdirs[0]
                    else:
                        self.Utils.LogError("Cannot find schematic in test script dir and subfolders!")
                        msg = "Failed automatic schematic directory lookup!"
                        raise Exception(msg)
                else:
                    self.SimOptions.SchematicDir = dirname(current_variation["DUT"])
                    self.Utils.LogWarning(
                        "Simulation attribute 'SchematicDir' was not specified. "
                        f"Using directory name of the first schematic (Parameter 'DUT')!:\n  "
                        f"{self.SimOptions.SchematicDir}"
                    )
            elif isabs(current_variation["DUT"]) and dirname(abspath(current_variation["DUT"])) != abspath(
                self.SimOptions.SchematicDir
            ):
                self.Utils.LogWarning(
                    "SimOptions.SchematicDir is specified to '{}'.\n"
                    "Nevertheless the current variation parameter 'DUT' is an absolute path!\n"
                    "Using directory name of the current variation parameter 'DUT':\n  {}".format(
                        abspath(self.SimOptions.SchematicDir),
                        dirname(abspath(current_variation["DUT"])),
                    )
                )
                self.SimOptions.SchematicDir = abspath(dirname(current_variation["DUT"]))

            if self.SimOptions.SchematicDir is None or not exists(self.SimOptions.SchematicDir):
                raise Exception("Cannot find specified schematic directory: " + str(self.SimOptions.SchematicDir))
            if self.SimOptions.SchematicDir == self.SimOptions.WorkingDir:
                msg = "SchematicDir and WorkingDir must not be equal!"
                raise Exception(msg)

            # ----- Update working dir ----- #
            if self.SimOptions.WorkingDir in [None, ""]:
                workingdir = normpath(join(self.Utils.ResultRunDirectory, "simdata"))
                if self.Attributes.ExecutionMode != Enums.ExecutionMode.Sim_Reload and exists(workingdir):
                    rmtree(workingdir, ignore_errors=True)
            else:
                workingdir = self.SimOptions.WorkingDir
                self._sim_analysis.stop_redirect_console_output()
                if (
                    self.Attributes.ExecutionMode != Enums.ExecutionMode.Sim_Reload
                    and self.VariationIndex == 0
                    and exists(workingdir)
                ):
                    rmtree(workingdir, ignore_errors=True)
            if not exists(workingdir):
                for _ in range(10):
                    try:  # Retry because of windoof filesystem
                        os.makedirs(workingdir)
                        break
                    except PermissionError:
                        sleep(0.5)
            self.Utils.LogInfo(f"Simulation working dir: {workingdir}")
            fileprefix = self.Attributes.Testcase_Name
            varindex = self.VariationIndex
            simulator_console_log_path = join(workingdir, "%s_consolelog_%04d.txt" % (fileprefix, varindex))

            # ----- Execution mode dependent actions ----- #
            # Normal simulation
            if not srd_internal_sweep:
                if self.Attributes.ExecutionMode == Enums.ExecutionMode.Sim:
                    keeps = list(self.sim_manager.keeps)

                    if self.SimOptions.Simulator == Enums.Simulator.Simetrix:
                        if "samba_unix" in self.SimOptions.SimOpts:
                            del self.SimOptions.SimOpts["samba_unix"]
                        if "samba_win" in self.SimOptions.SimOpts:
                            del self.SimOptions.SimOpts["samba_win"]

                        if self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.NONE:
                            keeps.extend(["/NOV"])
                        elif self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.TOPLEVEL:
                            pass
                        elif self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.ALL:
                            keeps.extend(["**V"])

                        if self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.NONE:
                            keeps.extend(["/NOI"])
                        elif self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.TOPLEVEL:
                            pass
                        elif self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.ALL:
                            keeps.extend(["**I"])

                    elif self.SimOptions.Simulator == Enums.Simulator.IFXspice:
                        if self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.NONE:
                            self.SimOptions.SimOpts["store_voltage_signals"] = None
                        elif self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.TOPLEVEL:
                            self.SimOptions.SimOpts["store_voltage_signals"] = "toplevel"
                        elif self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.ALL:
                            self.SimOptions.SimOpts["store_voltage_signals"] = "all"

                        if self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.NONE:
                            self.SimOptions.SimOpts["store_current_signals"] = None
                        elif self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.TOPLEVEL:
                            self.SimOptions.SimOpts["store_current_signals"] = "toplevel"
                        elif self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.ALL:
                            self.SimOptions.SimOpts["store_current_signals"] = "toplevel"  # Does not support "all"

                        if self.SimOptions.ProcessingMode == Enums.ProcessingMode.Local:
                            self.SimOptions.SimOpts["mode"] = srd.enums.IFXspiceMode.Local_Windows
                            self.SimOptions.SimOpts["simdata_format"] = srd.enums.SimulationDatatype.SXDAT
                        elif self.SimOptions.ProcessingMode == Enums.ProcessingMode.Distributed:
                            self.SimOptions.SimOpts["mode"] = srd.enums.IFXspiceMode.Distributed_RE
                            self.SimOptions.SimOpts["simdata_format"] = srd.enums.SimulationDatatype.HDF5

                    elif self.SimOptions.Simulator == Enums.Simulator.AMSDesigner:
                        if "samba_unix" in self.SimOptions.SimOpts:
                            del self.SimOptions.SimOpts["samba_unix"]
                        if "samba_win" in self.SimOptions.SimOpts:
                            del self.SimOptions.SimOpts["samba_win"]

                        if self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.NONE:
                            self.SimOptions.SimOpts["save_nets"] = []
                        elif self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.TOPLEVEL:
                            self.SimOptions.SimOpts["save_nets"] = ["*"]
                        elif self.SimOptions.StoreVoltageSignals == Enums.SimulatorSignals.ALL:
                            self.SimOptions.SimOpts["save_nets"] = ["-all"]

                        if self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.NONE:
                            self.SimOptions.SimOpts["save_currents"] = []
                        elif self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.TOPLEVEL:
                            self.SimOptions.SimOpts["save_currents"] = ["*"]
                        elif self.SimOptions.StoreCurrentSignals == Enums.SimulatorSignals.ALL:
                            self.SimOptions.SimOpts["save_currents"] = ["-all"]

                    else:
                        msg = f"Unknown simulator: {self.SimOptions.Simulator}"
                        raise Exception(msg)

                    # Sort sim params for transfer to SRD or SystemC parameter-file
                    sim_params = []
                    for stim in self.sim_manager.sources:
                        stimconfig = stim.get_netlist_entry()
                        if stimconfig is not None:
                            sim_params.extend(stimconfig.items())

                    temperature = 27.0
                    for p, v in current_variation.items():
                        if p.lower() in ["temp", "temperature"]:
                            if float(v) > -273:
                                temperature = float(v)
                        else:
                            sim_params.append((p, v))
                    sim_params = dict(sim_params)

                    try:
                        if self.Utils.SimUtils._sim_duration:
                            tstop = float(self.Utils.SimUtils._sim_duration)
                        else:
                            tstop = float(self.sim_manager.duration)

                        self.Utils.LogInfo(
                            f"Redirecting simulator console output to file '{simulator_console_log_path}'."
                        )
                        self._sim_analysis.start_redirect_console_output(simulator_console_log_path)

                        # AMSDesigner doesn't support tstart/tstop and analysis extraction
                        if self.SimOptions.Simulator != Enums.Simulator.AMSDesigner:
                            self.__extract_analysis_cmd(
                                workingdir=workingdir,
                                schematic=abspath(
                                    join(
                                        self.SimOptions.SchematicDir,
                                        current_variation["DUT"],
                                    )
                                ),
                                fileprefix=fileprefix,
                                dut_parameter=current_variation["DUT"],
                            )

                            opts = self.SimOptions._SimOptsDB[current_variation["DUT"]]
                            opts.update(self.SimOptions.SimOpts)
                            opts.update(
                                {
                                    "schematic": abspath(
                                        join(
                                            self.SimOptions.SchematicDir,
                                            current_variation["DUT"],
                                        )
                                    ),
                                    "tstart": 0.0,
                                    "tstop": tstop,
                                    "sim_params": sim_params,
                                    "keeps": list(set(keeps)),
                                    "workingdir": workingdir,
                                    "fileprefix": fileprefix,
                                }
                            )
                            if self.SimOptions.Simulator == Enums.Simulator.Simetrix:
                                opts.update({"temp": temperature})
                            elif temperature != 27.0:
                                self.Utils.LogWarning(
                                    "Setting the temperature is not available for other Simulators than Simetrix!"
                                )
                        else:
                            # For AMSDesigner we have to
                            #    take care of stimulus sequences and ':' as well
                            #    seperate voltages from currents
                            sim_params.pop("DUT", None)  # Since this contains ':', we will drop it here
                            self.SimOptions._SimOptsDB[current_variation["DUT"]] = {}
                            opts = self.SimOptions._SimOptsDB[current_variation["DUT"]]
                            opts.update(self.SimOptions.SimOpts)
                            volt_keeps = self.SimOptions.SimOpts["save_nets"] + [
                                k for k in keeps if not k.endswith("_$flow")
                            ]
                            curr_keeps = self.SimOptions.SimOpts["save_currents"] + [
                                k for k in keeps if k.endswith("_$flow")
                            ]
                            opts.update(
                                {
                                    "schematic": current_variation["DUT"],
                                    "tstop": tstop,
                                    "sim_params": sim_params,
                                    "save_nets": list(set(volt_keeps)),
                                    "save_currents": list(set(curr_keeps)),
                                    "workingdir": workingdir,
                                    "fileprefix": fileprefix,
                                    "temp": temperature,
                                }
                            )

                        if not exists(workingdir):
                            os.makedirs(workingdir)

                        scopts = join(workingdir, fileprefix + "_schem_opts_pv_%04d.txt" % varindex)
                        with open(scopts, "w" if not exists(scopts) else "a") as f:
                            print("Schematic: " + opts["schematic"], file=f)
                            pprint.pprint(opts, stream=f)
                            print("", file=f)
                        self._sim_analysis.getSimOptions().update_options(**opts)
                        self._sim_analysis.simulator.keep_netlists = True

                        self.Utils.LogInfo(
                            "Starting Simulation" + ("" if not timeout else f" with timeout {timeout:f}s")
                        )
                        self._sim_analysis.cleanup()
                        self._sim_analysis.simulator._overwrite_run_index = varindex
                        self._sim_analysis.run(timeout=timeout)
                        self._sim_failed = False
                        try:
                            self._sim_analysis.stop_redirect_console_output()
                            self.Utils.LogInfo("Stopped redirecting simulator console output.")
                        except Exception:
                            self.Utils.LogWarning("Failed to stop redirecting of simulator console log!")
                        self.__copy_simetrix_logs(workingdir, fileprefix)

                        if self.SimOptions.Simulator == Enums.Simulator.Simetrix and exists(simulator_console_log_path):
                            # Catch errors which are not seen by SRD (cannot open list file/no licence/etc)
                            self.Utils.LogInfo("Checking Simetrix console for errors...")
                            with open(simulator_console_log_path) as f:
                                while True:
                                    line = f.readline()
                                    if not line:
                                        break
                                    lline = line.lower()
                                    if any(e(lline) for e in self.__SIM_ERRORS) and not any(
                                        ie(lline) for ie in self.__SIM_IGNORE_ERRORS
                                    ):
                                        self.Utils.LogInfo("...found one or more errors!")
                                        raise Exception(line)
                            self.Utils.LogInfo("...no errors found.")

                    except Exception as e:
                        with contextlib.suppress(Exception):
                            self._sim_analysis.stop_redirect_console_output()
                        msg = self.__extract_error_from_console(e, simulator_console_log_path)
                        self._sim_failed = True
                        self._at_least_one_sim_failed = True

                        self.Utils.LogError(f"Simulation run failed: {traceback.format_exc(chain=False)}")
                        if msg is not None:
                            self.Utils.LogError(f"Error message from simulator console: {msg}")

                        try:
                            self._sim_analysis.stop_redirect_console_output()
                            self.Utils.LogInfo("Stopped redirecting simulator console output.")
                        except Exception:
                            self.Utils.LogWarning("Failed to stop redirecting of simulator console log!")

                        if (
                            self._sim_analysis.getSimOptions()._opts_container["simulator"]
                            == srd.enums.SimulatorType.Simetrix
                        ) and isinstance(e, TimeoutExpired):
                            self.Utils.LogError(
                                f"Timeout ({timeout:f}s) for simulation expired. "
                                f"Killing & restarting simulator process!"
                            )
                            self.__kill_and_restart_simetrix()

                elif self.Attributes.ExecutionMode == Enums.ExecutionMode.Sim_Reload:
                    if exists(join(self.SimOptions.ReloadPath, self.Attributes.Testcase_Name)):
                        workingdir = join(
                            self.SimOptions.ReloadPath,
                            self.Attributes.Testcase_Name,
                            "run%04d" % self.VariationIndex,
                            "simdata",
                        )
                        self.Utils.LogInfo(
                            "Reload path is a directory containing test results. Using simulation data in "
                            f"sub-directory '{workingdir}'"
                        )
                    elif exists(join(self.SimOptions.ReloadPath, "run0000")):
                        workingdir = join(
                            self.SimOptions.ReloadPath,
                            "run%04d" % self.VariationIndex,
                            "simdata",
                        )
                        self.Utils.LogInfo(
                            "Reload path is a test result root directory. Using simulation data in "
                            f"sub-directory '{workingdir}'"
                        )
                    elif exists(join(self.SimOptions.ReloadPath, "simdata")):
                        workingdir = join(
                            dirname(self.SimOptions.ReloadPath),
                            "run%04d" % self.VariationIndex,
                            "simdata",
                        )
                        self.Utils.LogInfo(
                            f"Reload path is a test result run directory. "
                            f"Using simulation data in directory '{workingdir}'"
                        )
                    elif exists(
                        join(
                            self.SimOptions.ReloadPath,
                            self.Attributes.Testcase_Name + ".swpdat",
                        )
                    ):
                        workingdir = self.SimOptions.ReloadPath
                    else:
                        msg = "Invalid path for attribute 'SimOptions.ReloadPath'. Cannot find any data to reload!"
                        raise Exception(msg)

                    self._sim_analysis.getSimOptions().update_options(workingdir=workingdir, fileprefix=fileprefix)
                    self._sim_analysis.reload()

            # SRD-internal sweep after netlisting-only
            else:
                if (
                    self.Attributes.ExecutionMode != Enums.ExecutionMode.Sim
                    or self.SimOptions.ProcessingMode != Enums.ProcessingMode.Distributed
                ):
                    msg = "This mode is only available in execution mode 'SIM' and processing mode 'Distributed'!"
                    raise Exception(msg)

                if self.SimOptions.Simulator != Enums.Simulator.IFXspice:
                    msg = "This mode is only available with simulator 'IFXspice'!"
                    raise Exception(msg)
                if "samba_unix" not in self.SimOptions.SimOpts:
                    msg = "Cannot find key 'samba_unix' in SimOpts, which is required for SrdSweep mode!"
                    raise LookupError(msg)
                if "samba_win" not in self.SimOptions.SimOpts:
                    msg = "Cannot find key 'samba_win' in SimOpts, which is required for SrdSweep mode!"
                    raise LookupError(msg)

                workingdir = join(dirname(self.Utils.ResultRunDirectory), "temp_work")

                if exists(workingdir):
                    try:  # Clear working dir
                        rmtree(workingdir)
                        os.makedirs(workingdir)
                    except Exception:
                        pass

                try:
                    opts = self.SimOptions._SimOptsDB[current_variation["DUT"]]
                    opts.update(self.SimOptions.SimOpts)
                    opts.update(
                        {
                            "schematic": abspath(
                                join(
                                    self.SimOptions.SchematicDir,
                                    current_variation["DUT"],
                                )
                            ),
                            "sim_params": {"dummy": [0] * len(self.Variations)},
                            "workingdir": workingdir,
                            "fileprefix": fileprefix,
                            "mode": srd.enums.IFXspiceMode.Distributed_DE,
                            "samba_unix": self.SimOptions.SimOpts["samba_unix"],
                            "samba_win": self.SimOptions.SimOpts["samba_win"],
                            "simdata_format": ".hdf5",
                        }
                    )
                    if not exists(workingdir):
                        os.makedirs(workingdir)

                    self._sim_analysis.getSimOptions().update_options(**opts)
                    self._sim_analysis.simulator.keep_netlists = True
                    self.Utils.LogInfo(
                        "Starting Simulation (srd is sweeping)" + ("" if not timeout else f" with timeout {timeout:f}s")
                    )
                    self._sim_analysis.cleanup()
                    self._sim_analysis.simulator._overwrite_run_index = None
                    timeout = self.SimOptions.Timeout
                    self._sim_analysis.run(_temp_pverify_mode=True, timeout=timeout if timeout > 0 else None)

                    if self.SimOptions.WorkingDir is not None and exists(self.SimOptions.WorkingDir):
                        self.Utils.LogInfo(f"Copying data from '{workingdir}' to '{self.SimOptions.WorkingDir}'")
                        files = os.listdir(workingdir)
                        for f in files:
                            move(
                                join(workingdir, f),
                                join(self.SimOptions.WorkingDir, basename(f)),
                            )
                    else:
                        # Move simulation output data from temp_work directory to run directories
                        self.Utils.LogInfo(f"Copying data from '{workingdir}' to test result run directories")
                        for i in range(len(self.Variations)):
                            simdatadir = join(
                                dirname(self.Utils.ResultRunDirectory),
                                "run%04d" % i,
                                "simdata",
                            )
                            if not exists(simdatadir):
                                os.makedirs(simdatadir)
                            files = os.listdir(workingdir)
                            for f in filter(files, [fileprefix + "_%04d.*" % i], None):
                                move(join(workingdir, f), join(simdatadir, basename(f)))
                            files = os.listdir(workingdir)
                            for f in filter(files, [fileprefix + "_?[^0-9]*"], None):
                                copy(join(workingdir, f), join(simdatadir, basename(f)))
                    rmtree(workingdir)

                except Exception:
                    self.Utils.LogError(f"Simulation run failed: {traceback.format_exc()}")

                    self._sim_failed = True
                    self._at_least_one_sim_failed = True

            self._sim_has_run = True

            if (
                self.SimOptions.Simulator == Enums.Simulator.IFXspice
                and self.SimOptions.ProcessingMode == Enums.ProcessingMode.Distributed
                and IS_WIN
                and not srd_internal_sweep
                and self.Attributes.ExecutionMode != Enums.ExecutionMode.Sim_Reload
            ):
                self._sim_netlistonly = True
                raise NetlistingOnlyException

    def __extract_analysis_cmd(self, workingdir, schematic, fileprefix, dut_parameter):
        """:type self: PyVerifyBaseTest|BASE_SIM"""
        if dut_parameter not in self.SimOptions._SimOptsDB:
            try:
                self.Utils.LogInfo(f"Extracting simulation defaults from schematic '{basename(schematic)}'")
                self._sim_analysis.getSimOptions().update_options(
                    workingdir=workingdir, fileprefix=fileprefix, schematic=schematic
                )
                self._sim_analysis.extractSchematicOptions()
                so = deepcopy(self._sim_analysis.getSimOptions()._opts_container)
                self.SimOptions._SimOptsDB[dut_parameter] = so
            except Exception as e:
                self.Utils.LogWarning("Extraction of default analysis options failed. Using default options.")
                self.Utils.LogDebug("Cause: " + str(e))
                self.SimOptions._SimOptsDB[dut_parameter] = {}

    def __extract_error_from_console(self, error, log_path):
        """

        :type error: Exception
        :type log_path: str
        """
        try:
            clsname = error.__class__.__name__
        except Exception:
            return None

        if clsname == "SxCmdERRCodeError" and error.code == 5 and exists(log_path):
            with open(log_path) as f:
                log = f.read()
            errors = []
            for match in re.findall(r"(\*\*\* ?ERROR ?\*\*\*.*)|(ERROR ?:.*)", log, flags=re.IGNORECASE):
                match_joined = "".join(match)
                if match_joined not in errors:
                    errors.append(match_joined)
            if len(errors):
                errors.append(f"For more information please check the console log file at {log_path}")
                return "\n".join(errors)

        return None

    def __copy_simetrix_logs(self, workingdir, fileprefix):
        """:type self: PyVerifyBaseTest|BASE_SIM"""
        basepathname = join(workingdir, fileprefix)

        if "VCD_OPTIONS" in self.SimOptions:
            try:
                # move vcd file to result dir
                move(
                    join(
                        self.SimOptions.WorkingDir,
                        normpath(self.SimOptions["VCD_OPTIONS"]["sysc_file"]),
                    ),
                    basepathname + ".vcd",
                )
                # copy sav file to result dir
                if "sav_template" in self.SimOptions["VCD_OPTIONS"]:
                    target_sav = join(
                        workingdir,
                        self.Attributes.Test_Name
                        + "0."
                        + self.SimOptions["VCD_OPTIONS"]["sav_template"].split(".")[-1],
                    )
                    if not exists(target_sav):
                        copy(
                            join(
                                self.SimOptions.WorkingDir,
                                normpath(self.SimOptions["VCD_OPTIONS"]["sav_template"]),
                            ),
                            target_sav,
                        )
            except Exception:
                self.Utils.LogWarning("Warning: Could not move vcd file or sav template to destination")
        # get PID of current Simulation run
        sim_pid = None
        for p in psutil.process_iter():
            if hasattr(p, "name"):
                try:
                    if p.name() == "Sim.exe":
                        sim_pid = p._pid
                        break
                except Exception:
                    pass
        # move logfiles
        if sim_pid is not None:
            file = join(self.SimOptions.WorkingDir, "powermodel_cosim_" + str(sim_pid) + ".log")
            if exists(file):
                try:
                    move(file, basepathname + "powermodel_cosim.log")
                except Exception:
                    self.Utils.LogWarning("cannot copy cosim logfile")

            file = join(self.SimOptions.WorkingDir + "systemc_" + str(sim_pid) + "_0.log")
            if exists(file):
                try:
                    move(file, join(basepathname, "simetrix_cosim.log"))
                except Exception:
                    self.Utils.LogWarning("cannot copy systemc.log")

    def __kill_simetrix(self):
        for p in psutil.process_iter():
            try:
                if p.name() in ("Sim.exe", "SIMetrix.exe"):
                    p.kill()
            except Exception:
                pass
        self._sim_killed = True
        self._sim_failed = True
        self._at_least_one_sim_failed = True

    def __kill_and_restart_simetrix(self):
        self.__kill_simetrix()
        self.__create_analysis_instance()
