from __future__ import annotations

import copy
import inspect
import sys
from enum import IntEnum

import numpy as np
import srd as SRD

from pverify.postproc.waveform import Waveform

from .simulated_source import Caller, SimulatedSource, StimType, Stimulus

sys.setrecursionlimit(100000)

E = 1e-9


def get_srd_pwl_args(pwllist):
    return pwllist[0], pwllist[-2], pwllist


class OperationModeEnum(IntEnum):
    Continuous = 0
    Burst = 1


class TriggerSourceEnum(IntEnum):
    Internal = 0
    External = 1
    Software = 2
    Other = 3


class Gating:
    def __init__(self, parent):
        """
        :type parent: SimulatedFgen
        """
        self.parent = parent
        self.time = [0]
        self.state = [0]
        self.caller = [Caller.PRELOOP]
        """:type : list[Caller]"""

    def reset(self):
        time = []
        state = []
        caller = []
        if len(self.caller):
            for i, c in enumerate(self.caller):
                if c == Caller.PRELOOP:
                    time.append(self.time[i])
                    state.append(self.state[i])
                    caller.append(c)
        if not len(time):
            time.append(0)
        if not len(state):
            state.append(0)
        if not len(caller):
            caller.append(Caller.PRELOOP)

        self.time = time
        self.state = state
        self.caller = caller

    def enable(self):
        caller = self.get_caller()
        now = self.parent.manager.current_time
        if self.state[-1] == 1:
            pass
        else:
            if self.time[-1] < now:
                self.state.extend([0, 1])
                self.time.extend([now - E, now])
                self.caller.extend([caller, caller])
            else:
                if len(self.state) > 1:
                    self.state[-2:-1] = [0, 1]
                    self.caller[-2:-1] = [caller, caller]
                else:
                    self.state[-1] = 1
                    self.caller[-1] = caller

    def disable(self):
        caller = self.get_caller()
        now = self.parent.manager.current_time
        if self.state[-1] == 0:
            pass
        else:
            if self.time[-1] < now:
                self.state.extend([1, 0])
                self.time.extend([now - E, now])
                self.caller.extend([caller, caller])
            else:
                if len(self.state) > 1:
                    self.state[-2:-1] = [1, 0]
                    self.caller[-2:-1] = [caller, caller]

    def gate_signal(self, srd_signal):
        self.time.append(self.parent.manager.duration)
        last_state = self.state[-1]
        self.state.append(last_state)
        last_caller = self.caller[-1]
        self.caller.append(last_caller)
        enable_signal = []
        [enable_signal.extend([self.time[x], self.state[x]]) for x in range(len(self.time))]
        srd_enable_signal = SRD.PWL(*get_srd_pwl_args(enable_signal))
        return srd_signal * srd_enable_signal

    def get_caller(self):
        """
        Returns the function in the user code where the stimulus was created.
        """
        stack = inspect.stack()
        callers_list = [str(stack_entry[3]) for stack_entry in stack]
        if "_do_startup" in callers_list:
            return Caller.PRELOOP
        if "_do_iteration" in callers_list:
            return Caller.VARLOOP
        if "_do_teardown" in callers_list:
            return Caller.POSTLOOP
        return None


class SimulatedFgen(SimulatedSource):
    def __init__(self, ref_AI, manager, ScriptingVars):
        SimulatedSource.__init__(self, ref_AI, manager, ScriptingVars)
        if False:
            from pverify.core.sim.abstract_instruments import AI_Fgen

            self.ref_AI = AI_Fgen()

        self._InternalTriggerRate = 0
        self._OperationMode = OperationModeEnum.Continuous
        self._BurstCount = 1
        self._TriggerSource = TriggerSourceEnum.Internal
        self.gating = Gating(self)
        self._current_stimulus = None
        self._Impedance = 1e-9
        """:type : Stimulus"""

    def FgenSetup(self, InternalTriggerRate=1.0):
        self._InternalTriggerRate = float(InternalTriggerRate)

    def ChannelSetup(self, Impedance=None, OperationMode=None, BurstCount=None, TriggerSource=None):
        if Impedance is not None:
            if Impedance > 0:
                self._Impedance = Impedance
            else:
                self._Impedance = 1e-9

        if OperationMode is not None:
            if "cont" in str(OperationMode).lower():
                self._OperationMode = OperationModeEnum.Continuous
            else:
                self._OperationMode = OperationModeEnum.Burst

        if BurstCount is not None:
            self._BurstCount = int(BurstCount)

        if TriggerSource is not None:
            ts = str(TriggerSource).lower()
            if "int" in ts:
                self._TriggerSource = TriggerSourceEnum.Internal
            elif "sw" in ts:
                self._TriggerSource = TriggerSourceEnum.Software
            else:
                msg = f"Unsupported trigger source '{TriggerSource}'. Supported: Internal, SW"
                raise TypeError(msg)

    def Enable(self):
        if self._TriggerSource == TriggerSourceEnum.Internal and not any(
            s.type == StimType.FGEN_TRIGGER for s in self.sequence
        ):
            self.trigger_generation()
        self.gating.enable()

    def Disable(self):
        self.gating.disable()

    def SendSoftwareTrigger(self):
        if self._TriggerSource == TriggerSourceEnum.Software:
            self.trigger_generation()

    def trigger_generation(self):
        if self._current_stimulus is not None:
            stim = copy.copy(self._current_stimulus)
            stim.starttime = self.manager.current_time
            self.sequence.append(
                Stimulus(
                    self,
                    StimType.FGEN_TRIGGER,
                    self.manager.current_time,
                    {"stimulus": stim},
                )
            )

    def burst_stimuli(self):
        if (
            self._TriggerSource == TriggerSourceEnum.Internal
            and self._OperationMode == OperationModeEnum.Burst
            and self._InternalTriggerRate > 0
        ):
            new_sequence = []
            """:type : list[Stimulus]"""

            for i, stim in enumerate(self.sequence):
                if stim.type == StimType.WAIT:
                    new_sequence.append(stim)
                elif stim.type == StimType.FGEN_TRIGGER:
                    # Find next trigger to determine how long to burst the current stimulus
                    stop = self.manager.duration
                    for s in self.sequence[i + 1 :]:
                        if s.type == StimType.FGEN_TRIGGER:
                            stop = s.starttime
                            break

                    # Fill rest of sim time with internal auto-triggers
                    times = np.arange(
                        start=stim.starttime,
                        stop=stop,
                        step=1.0 / self._InternalTriggerRate,
                    )

                    for t in times:
                        # Add a trigger stimulus and an explicit wait for each internal trigger time step
                        s = copy.copy(stim.config["stimulus"])
                        s.starttime = t
                        # Add a trigger and wait stimulus for each internal trigger step
                        newstim = Stimulus(self, StimType.FGEN_TRIGGER, t, {"stimulus": s})
                        newstim.caller = s.caller
                        new_sequence.append(newstim)

                        newstim = Stimulus(
                            self,
                            StimType.WAIT,
                            t,
                            {"Milliseconds": 1000.0 / self._InternalTriggerRate},
                        )
                        newstim.caller = s.caller
                        new_sequence.append(newstim)

            return new_sequence
        return self.sequence

    def get_netlist_entry(self):
        sequence_backup = self.sequence  # Backup sequence to preserver stimuli that where created during PreLoop
        self.sequence = self.burst_stimuli()

        SimulatedSource.get_netlist_entry(self)

        if any(s.type == StimType.FGEN_TRIGGER for s in self.sequence):
            config = {}

            config[self.ScriptingVars.stimulustype] = 0  # Voltage source template
            config[self.ScriptingVars.stimulus] = self.create_stimulus_string()
            if self.ScriptingVars.vsrc_rin is not None:
                config[self.ScriptingVars.vsrc_rin] = self._Impedance
            else:
                self.manager.reftest.Utils.LogWarning(
                    f"{self.ScriptingVars} has no scripting variable specified for 'vsrc_rin' which is used by "
                    "the simulated Fgen to set the source impedance "
                    "of the PyVerify source. This may lead to inconsistent behavior!"
                )

        else:
            config = None
        self.sequence = sequence_backup  # Restore backuped sequence
        self.reset()  # Delete all stimuli added during VariationLoop
        self.gating.reset()  # Delete all gating pulses added during VariationLoop
        return config

    def create_stimulus_string(self):
        """
        This Function expands a list of Stimuli to SRD API Strings
        """
        stim_string = SRD.C(value=0, begin=0, end=0)

        for idx, stim in enumerate(self.sequence):
            tmp_str = SRD.C(value=0, begin=0)
            endtime = 0
            if stim.type == StimType.WAIT:
                pass
            elif self._timetable[idx].start >= self._timetable[idx].stop:
                continue
            elif stim.type == StimType.FGEN_TRIGGER:
                s, endtime = self.stimulus2srdapi(stim.config["stimulus"])
                tmp_str += s

                end = self._timetable[idx].stop
                start = self._timetable[idx].start
                if endtime >= end:  # interrupt overwritten stimulus
                    tmp_str *= SRD.C(value=1, begin=start, end=end) + SRD.C(value=0, begin=end)
                elif endtime < end:  # extend finished stimuli with previously programmed static stimulus
                    tmp_str += SRD.C(value=0, begin=endtime, end=end)

                stim_string += tmp_str

        return self.gating.gate_signal(stim_string)

    def set_current_stimulus(self, stimulus):
        self._current_stimulus = stimulus
        if self._TriggerSource != TriggerSourceEnum.Software:
            self.trigger_generation()

    def stimulus2srdapi(self, stimulus):
        """
        This Function expands a list of Stimuli to SRD API Strings

        :type stimulus: Stimulus
        """
        starttime = stimulus.starttime
        duration = self.manager.duration
        endtime = duration

        if stimulus.type == StimType.FGEN_SINE:
            if self._OperationMode == OperationModeEnum.Burst:
                endtime = starttime + (1.0 / stimulus.config["Frequency"] * self._BurstCount)
            else:
                endtime = duration
            signal = SRD.S(
                period=1.0 / stimulus.config["Frequency"],
                delay=stimulus.config["StartPhase"],
                amplitude=stimulus.config["Amplitude"],
                offset=stimulus.config["Offset"],
                begin=starttime,
                end=endtime,
            )

        elif stimulus.type == StimType.FGEN_DC:
            signal = SRD.C(value=stimulus.config["Offset"], begin=starttime, end=duration)

        elif stimulus.type in [StimType.FGEN_ARB]:
            wdata = Waveform(stimulus.config["Data"][:]).cast_float()
            if min(wdata) < -1.0 or max(wdata) > 1.0:
                wdata.scale_to_amplitude(1.0)
            wdata *= stimulus.config["Gain"]
            wdata += stimulus.config["Offset"]
            data = wdata.data

            if self._OperationMode == OperationModeEnum.Burst:
                endtime = starttime + ((len(data) / stimulus.config["SampleRate"]) * self._BurstCount)
                nsamples = len(data) * self._BurstCount
            else:
                endtime = duration
                nsamples = int((endtime - starttime) * stimulus.config["SampleRate"])
            times, step = np.linspace(starttime, endtime, nsamples, retstep=True)

            pwl_list = []
            datalen = len(data)
            [pwl_list.extend([times[x], data[x % datalen]]) for x in range(len(times))]
            pwl_list.extend([times[-1] + E, 0])
            signal = SRD.PWL(*get_srd_pwl_args(pwl_list))

        elif stimulus.type in [StimType.FGEN_ARBWF]:
            wf = stimulus.config["Waveform"].cast_float()  # type: Waveform

            srat = stimulus.config["SampleRate"]
            if srat is not None:
                wf.change_samplerate(float(srat))
            endtime = starttime + wf.duration

            if self._OperationMode == OperationModeEnum.Burst and self._BurstCount > 1:
                wf = wf.repeat(self._BurstCount)
            wf = wf.time_shift(starttime)

            pwl_list = np.stack([wf.time, wf.data]).flatten("F").tolist()
            signal = SRD.PWL(*get_srd_pwl_args(pwl_list))

        else:
            cycle_duration = 1 / float(stimulus.config["Frequency"])
            if self._OperationMode == OperationModeEnum.Continuous:
                ncycles = int(duration / cycle_duration)
            else:
                ncycles = self._BurstCount
            ncycles = max(1, ncycles)

            pwl_list = []
            for c in range(ncycles):
                last_cycle = c == ncycles - 1
                starttime, pwl_list = self._create_cycle(stimulus, starttime, pwl_list, cycle_duration, last_cycle)
            endtime = ncycles * cycle_duration
            signal = SRD.PWL(*get_srd_pwl_args(pwl_list))

        return signal, endtime

    def _create_cycle(self, stimulus, currenttime, pwl_list, cycle_duration, last_cycle):
        e = cycle_duration / 1e6

        if stimulus.type == StimType.FGEN_RAMPDOWN:
            pwl_list.extend([currenttime, stimulus.config["Offset"]])
            currenttime += e
            pwl_list.extend([currenttime, stimulus.config["Offset"] + stimulus.config["Amplitude"]])
            currenttime += cycle_duration - e
            pwl_list.extend([currenttime, stimulus.config["Offset"] - stimulus.config["Amplitude"]])
            if last_cycle:
                currenttime += e
                pwl_list.extend([currenttime, stimulus.config["Offset"]])

        elif stimulus.type == StimType.FGEN_RAMPUP:
            pwl_list.extend([currenttime, stimulus.config["Offset"]])
            currenttime += e
            pwl_list.extend([currenttime, stimulus.config["Offset"] - stimulus.config["Amplitude"]])
            currenttime += cycle_duration - e
            pwl_list.extend([currenttime, stimulus.config["Offset"] + stimulus.config["Amplitude"]])
            if last_cycle:
                currenttime += e
                pwl_list.extend([currenttime, stimulus.config["Offset"]])

        elif stimulus.type == StimType.FGEN_TRIANGLE:
            pwl_list.extend([currenttime, stimulus.config["Offset"]])
            currenttime += e
            pwl_list.extend([currenttime, stimulus.config["Offset"]])
            currenttime += cycle_duration / 4
            pwl_list.extend([currenttime, stimulus.config["Offset"] + stimulus.config["Amplitude"]])
            currenttime += cycle_duration / 2
            pwl_list.extend([currenttime, stimulus.config["Offset"] - stimulus.config["Amplitude"]])
            currenttime += cycle_duration / 4
            pwl_list.extend([currenttime, stimulus.config["Offset"]])
            if last_cycle:
                currenttime += e
                pwl_list.extend([currenttime, stimulus.config["Offset"]])

        elif stimulus.type == StimType.FGEN_SQUARE:
            pwl_list.extend([currenttime, stimulus.config["Offset"]])
            currenttime += e
            pwl_list.extend([currenttime, stimulus.config["Offset"] + stimulus.config["Amplitude"]])
            currenttime += cycle_duration * (stimulus.config["DutyCycleHigh"] / 100.0)
            pwl_list.extend([currenttime, stimulus.config["Offset"] + stimulus.config["Amplitude"]])
            currenttime += e
            pwl_list.extend([currenttime, stimulus.config["Offset"] - stimulus.config["Amplitude"]])
            currenttime += cycle_duration * ((100.0 - stimulus.config["DutyCycleHigh"]) / 100.0)
            pwl_list.extend([currenttime, stimulus.config["Offset"] - stimulus.config["Amplitude"]])
            if last_cycle:
                currenttime += e
                pwl_list.extend([currenttime, stimulus.config["Offset"]])

        return currenttime, pwl_list
