from __future__ import annotations

import contextlib
import traceback

import numpy as np
import scipy.signal as sps

from pverify.core.internals import logging_util
from pverify.postproc.waveform import Waveform


class SimulatedScope:
    """
    Class holding Scope Runtime Data
    """

    def __init__(self, ref_AI, manager):
        """

        :param ref_AI: Pointer to an AI instance
        :type ref_AI: pverify.core.sim.abstract_instruments.AI_Scope.AI_Scope
        :param manager: Pointer to SimulationManager instance
        :type manager: pverify.core.sim.simulation_manager.SimulationManager
        """
        self.ref_AI = ref_AI
        self.manager = manager

        # Minimum simulation time needed for triggering (included TimePerRecord, Triggerposition and AddSimTime)
        self.minimum_sim_time = 0

        self.trigger = TriggerNone(self)
        """:type : Trigger|TriggerEdge|TriggerPulse|TriggerWidth|TriggerGlitch"""

        self.time_per_record = 0  # Time of one scope aquisition window
        self.record_length = 0  # Number of samples in one aquisition window
        self.arm_time = 0  # Time i seconds on which the Scope is armed

        # The raw timevector coming from simulation, it is needed to resample every channel signal
        self.timevec_raw: np.multiarray = None
        self.timevec_resampled: np.multiarray = None  # The resampled timevector but absolute to the trigger position
        self.channels = {}  # A list of defined Channles
        """:type : dict[pverify.ScopeMapping,SimulatedScopeChannel]"""

    def ScopeSetup(self, TimePerRecord, RecordLength):
        """
        Sets the most commonly used parameters for the scope acquisition.

        :param TimePerRecord: Time in seconds of the acquired waveform. Recordlength/TimePerRecord=SampleRate
        :type TimePerRecord: float
        :param RecordLength: The record length of the acquired waveform. Recordlength/TimePerRecord=SampleRate
        :type RecordLength: int | float
        """
        self.record_length = int(RecordLength)
        self.time_per_record = float(TimePerRecord)

    def Arm(self):
        self.arm_time = self.manager.current_time

        pos = self.trigger.Position
        if pos is None:
            pos = 100.0

        minimum_sim_time = self.arm_time + self.time_per_record + (100.0 - pos) * 0.01 * self.time_per_record
        self.minimum_sim_time = minimum_sim_time

        self.reset()

    def GetChannel(self, MappingObject):
        """

        :type MappingObject: pverify.ScopeMapping
        """
        if MappingObject not in self.channels:
            ch = SimulatedScopeChannel(self, MappingObject)
            self.channels[MappingObject] = ch
            self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_pos)
            if MappingObject.Sim_Probe.netname_voltage_neg is not None:
                self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_neg)

        return self.channels[MappingObject]

    def reset(self):
        for c in self.channels.values():
            c.reset()
        self.trigger.reset()
        self.timevec_resampled = None
        self.timevec_raw = None

    @property
    def sample_rate(self):
        if self.time_per_record > 0:
            return float(self.record_length / self.time_per_record)
        return 0

    def Trigger_Edge(self, Level, Slope, Position, Coupling, MappingObject):
        self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_pos)
        if MappingObject.Sim_Probe.netname_voltage_neg is not None:
            self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_neg)
        self.trigger = TriggerEdge(self, MappingObject, Level, Slope, Position, Coupling)

    def Trigger_Width(
        self,
        Level,
        Polarity,
        Condition,
        ThresholdLow,
        ThresholdHigh,
        Position,
        Coupling,
        MappingObject,
    ):
        self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_pos)
        if MappingObject.Sim_Probe.netname_voltage_neg is not None:
            self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_neg)
        self.trigger = TriggerWidth(
            self,
            MappingObject,
            Level,
            ThresholdHigh,
            ThresholdLow,
            Polarity,
            Condition,
            Position,
            Coupling,
        )

    def Trigger_Glitch(self, Level, Polarity, Condition, Width, Position, MappingObject, Coupling):
        self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_pos)
        if MappingObject.Sim_Probe.netname_voltage_neg is not None:
            self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_neg)
        self.trigger = TriggerGlitch(self, MappingObject, Level, Width, Polarity, Condition, Position, Coupling)

    @property
    def triggered(self):
        return self.timevec_resampled is not None


class SimulatedScopeChannel:
    """
    Storage Class holding data associated to a Channel/Probe
    """

    def __init__(self, parent, mappingobj):
        """

        :type parent: SimulatedScope
        :type mappingobj: pverify.ScopeMapping
        """
        self.parent = parent
        self.ref_AI = parent.ref_AI
        self.manager = parent.manager

        self.mappingobj = mappingobj
        self.coupling = "dc"
        self.bandwidth = 0
        self.waveform = None
        """:type : pverify.Waveform|NoneType"""

    def reset(self):
        self.waveform = None
        """:type : pverify.Waveform|NoneType"""

    def ProbeSetup(self, Coupling="dc", Bandwidth=0):
        self.coupling = str(Coupling).lower()
        self.bandwidth = float(Bandwidth)

    def GetProbeWaveform(self, DecimationFactor=1):
        """

        :rtype: pverify.Waveform|NoneType
        """
        try:
            if not self.waveform:
                self.waveform = self._probe()

            w = self.waveform.copy()
            if w.length and int(DecimationFactor) >= 2:
                w.decimate(factor=DecimationFactor)
            return w
        except Exception:
            self.manager.reftest.Utils.LogWarning(traceback.format_exc(chain=False))
            return None

    def GetProbeMeasurement(self, MeasurementItem):
        MeasurementItem = str(MeasurementItem).upper()
        try:
            if not self.waveform:
                self.waveform = self._probe()
        except Exception:
            self.manager.reftest.Utils.LogWarning(traceback.format_exc(chain=False))
            return None

        try:
            if MeasurementItem == "AMPLITUDE":
                return self.waveform.Measurements_NonPeriodic.amplitude()
            if MeasurementItem == "AVERAGE":
                return self.waveform.Measurements_Base.mean()
            if MeasurementItem == "RMS":
                return self.waveform.Measurements_Base.rms()
            if MeasurementItem == "PEAKTOPEAK":
                return self.waveform.Measurements_Base.peak_to_peak()
            if MeasurementItem == "RISETIME":
                return self.waveform.Measurements_NonPeriodic.risetime()
            if MeasurementItem == "FALLTIME":
                return self.waveform.Measurements_NonPeriodic.falltime()
            if MeasurementItem == "HIGH":
                return self.waveform.Measurements_NonPeriodic.high()
            if MeasurementItem == "LOW":
                return self.waveform.Measurements_NonPeriodic.low()
            if MeasurementItem == "MAXIMUM":
                return self.waveform.Measurements_Base.max()
            if MeasurementItem == "MINIMUM":
                return self.waveform.Measurements_Base.min()
            self.manager.reftest.Utils.LogWarning(f"Measurement '{MeasurementItem}' not implemented!")
            return None

        except Exception:
            self.manager.reftest.Utils.LogWarning(traceback.format_exc(chain=False))
            return None

    def _probe(self):
        """
        This Function initializes all probe specific data, like waveforms or measurements. It is called once for each
        channel, before measures ore waveforms can be read

        :rtype: pverify.Waveform
        """
        # recover TA pointer in case it got lost due to a failed simualtion
        ta = self.manager.ta
        reftest = self.manager.reftest
        varindex = reftest.VariationIndex

        if not reftest._sim_has_run and not reftest._sim_failed:
            reftest.start_simulation()

        from srd.internal.simulator.errors import Error

        if not reftest._sim_failed:
            # Get the time vector
            if self.parent.timevec_raw is None:
                try:
                    self.parent.timevec_raw = ta.probe("Time", run_num=varindex, cache=False)
                except Exception as e:
                    msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                    raise Exception("Error when extracting time vector from simulation:\n" + msg) from None

            if not self.parent.triggered:
                try:
                    self.parent.trigger.find_trigger(varindex)
                except Exception as e:
                    msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                    raise Exception("Error when finding trigger condition:\n" + msg) from None

            if self.mappingobj.Sim_Probe.netname_voltage_pos is not None:
                try:
                    # Get the raw data vector
                    signal = ta.probe(
                        self.mappingobj.Sim_Probe.netname_voltage_pos,
                        run_num=varindex,
                        cache=False,
                    )
                except Exception as e:
                    msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                    msg = (
                        f"Error when extracting signal vector '{self.mappingobj.Sim_Probe.netname_voltage_pos}' "
                        f"from simulation:\n{msg}"
                    )
                    raise Exception(msg) from None

                if self.mappingobj.Sim_Probe.netname_voltage_neg is not None:
                    try:
                        # Get the raw data vector
                        signal_ref = ta.probe(
                            self.mappingobj.Sim_Probe.netname_voltage_neg,
                            run_num=varindex,
                            cache=False,
                        )
                    except Exception as e:
                        msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                        msg = (
                            f"Error when extracting signal vector '{self.mappingobj.Sim_Probe.netname_voltage_neg}' "
                            f"from simulation:\n{msg}"
                        )
                        raise Exception(msg) from None
                    signal -= signal_ref

                # Interpolate according to the resample new time vector
                if self.parent.timevec_resampled is not None:
                    data = np.interp(self.parent.timevec_resampled, self.parent.timevec_raw, signal)
                else:
                    data = signal

                if self.coupling.lower() == "ac":
                    data -= np.mean(data)

                if self.parent.timevec_resampled is not None and self.bandwidth > 0:
                    # Bandwidth only makes sense if we ahve a equidistant sampled time vector
                    cutoff = self.bandwidth / self.parent.sample_rate / 2.0
                    if cutoff < 1:
                        if cutoff > 0.001:
                            b, a = sps.butter(1, cutoff, output="ba")
                            data = sps.filtfilt(b, a, data)
                        else:
                            msg = (
                                "Bandwidth filter will not work reliably with this small cutoff frequency. "
                                "\nReduce Scope Sample Frequency or apply custom filter in postprocessing"
                            )
                            raise Exception(msg)

                if self.parent.timevec_resampled is not None:
                    data = Waveform(data, self.parent.timevec_resampled)
                    data.remove_time_offset()
                else:
                    data = Waveform(data, self.parent.timevec_raw)
                return data
            return None

        msg = f"Simulation failed. Cannot extract signal '{self.mappingobj.Sim_Probe.netname_voltage_pos}'."
        raise Exception(msg)


# Following code is only for simulation purposes
class Trigger:
    """
    Generic Trigger Class. Bundles common properties and functions for all Trigger Classes
    """

    def __init__(self, parent, Source, Level, Position, Coupling):
        """

        :type parent: SimulatedScope
        :type Source: pverify.ScopeMapping
        """
        self.parent = parent
        self.Source = Source
        self.Level = float(Level)  # Triger Level
        self.Coupling = str(Coupling).lower()
        self.Position = min(100.0, max(0.0, float(Position)))  # Trigger position in %

        if self.Coupling not in ["ac", "dc"]:
            msg = f"Coupling '{Coupling}' is not supported."
            raise ValueError(msg)

        self.trigger_time = None
        """:type : float"""

    def reset(self):
        self.trigger_time = None

    def find_trigger(self, run_num):
        """
        Probes the trigger waveform and finds a trigger on it.

        Calculates the time when the trigger occurred as well as the resampled/final time vector
        """
        log = logging_util.get_test_logger(prefix=self.__class__.__name__)

        # Get the trigger wave (probe signal, get timevec from parent)
        from srd.internal.simulator.errors import Error

        if self.Source is not None:
            try:
                # Get the raw data vector
                triggerwave = self.parent.manager.ta.probe(
                    self.Source.Sim_Probe.netname_voltage_pos,
                    run_num=run_num,
                    cache=False,
                )
            except Exception as e:
                msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                msg = (
                    f"Error when extracting trigger signal vector '{self.Source.Sim_Probe.netname_voltage_pos}' "
                    f"from simulation:\n{msg}"
                )
                raise Exception(msg) from None

            trigger_wave = Waveform(triggerwave, self.parent.timevec_raw)

            # Preprocess trigger waveform (coupling, bandwidth, ...)
            coupling = str(self.Coupling).lower()
            if coupling == "ac":
                trigger_wave -= trigger_wave.Measurements_Base.mean()

            # Cut the part before arm time
            trigger_wave = trigger_wave[float(self.parent.arm_time) :]

            # Get the trigger time
            self.trigger_time = self.find_trigger_time(trigger_wave)
            if self.trigger_time is None:
                log.warning("Could not find trigger. Auto-triggering after arm time!")
        else:
            self.trigger_time = None
            log.info("No trigger defined. Auto-triggering after arm time!")

        if self.trigger_time is None:
            # If no trigger found, auto-trigger to armtime + time per record
            self.trigger_time = self.parent.time_per_record

        # Create new time vector
        window_start = self.trigger_time - (self.Position / 100.0 * self.parent.time_per_record)
        window_end = window_start + self.parent.time_per_record
        if self.parent.record_length > 0:
            self.parent.timevec_resampled = np.linspace(window_start, window_end, self.parent.record_length, False)
        else:
            self.parent.timevec_resampled = None
            self.parent.bandwidth = 0  # prevent filtering

    def find_trigger_time(self, trigger_wave: Waveform):
        return None


class TriggerNone(Trigger):
    """
    No Trigger Class. Derived from the Base Trigger Class is used in Case no trigger is defined
    """

    def __init__(self, parent):
        Trigger.__init__(self, parent, None, 0.0, 100.0, "dc")


class TriggerEdge(Trigger):
    """
    Edge Trigger Class. Derived from the Base Trigger Class
    """

    def __init__(self, parent, Source, Level, Slope, Position, Coupling):
        Trigger.__init__(self, parent, Source, Level, Position, Coupling)
        self.Slope = Slope

    def find_trigger_time(self, trigger_wave: Waveform):
        try:
            return trigger_wave.Measurements_Utils.find_nth_crossing(
                self.parent.trigger.Level,
                self.parent.trigger.Slope.lower(),
                0,
                0.01 if str(self.Coupling).lower() == "nr" else 0,
                "rel",
                False,
            )
        except IndexError:
            return None


class TriggerPulse(Trigger):
    """
    TriggerPulse Trigger Subclass, Generic Subclass for Width and Glitch Trigger
    """

    def __init__(self, parent, Source, Level, Polarity, Condition, Position, Coupling):
        Trigger.__init__(self, parent, Source, Level, Position, Coupling)

        self.Polarity = str(Polarity).lower()
        self.Condition = str(Condition).lower()

        if "pos" not in self.Polarity and "neg" not in self.Polarity:
            msg = f"Polarity '{Polarity}' is not supported."
            raise ValueError(msg)


class TriggerWidth(TriggerPulse):
    """
    Width Trigger CLass
    """

    def __init__(
        self,
        parent,
        Source,
        Level,
        ThresholdHigh,
        ThresholdLow,
        Polarity,
        Condition,
        Position,
        Coupling,
    ):
        TriggerPulse.__init__(self, parent, Source, Level, Polarity, Condition, Position, Coupling)
        self.ThresholdHigh = ThresholdHigh
        self.ThresholdLow = ThresholdLow

        if not any(c in self.Condition for c in ["in", "out", "tim"]):
            msg = f"Condition '{Condition}' is not supported."
            raise ValueError(msg)

        if ThresholdLow > ThresholdHigh and "tim" not in self.Condition:
            msg = "ThresholdLow must not be greater than ThresholdHigh"
            raise ValueError(msg)

    def find_trigger_time(self, trigger_wave: Waveform):
        try:
            if "tim" in self.Condition:
                try:
                    return (
                        trigger_wave.Measurements_Periodic.find_nth_timeout(
                            0,
                            self.ThresholdLow,
                            self.Level,
                            0.01 if str(self.Coupling).lower() == "nr" else 0,
                            htype="rel",
                            polarity=self.Polarity,
                        )
                        + self.ThresholdLow
                    )
                except IndexError:
                    return None

            elif any(c in self.Condition for c in ["in", "out"]):
                cr = trigger_wave.Measurements_Utils.find_all_crossings(
                    self.Level,
                    0.01 if str(self.Coupling).lower() == "nr" else 0,
                    "rel",
                    return_indices=False,
                )
                if len(cr):
                    if "pos" in self.Polarity:
                        if cr[0]["slope"] == "fall":
                            cr = cr[1:]
                        if cr[-1]["slope"] == "rise":
                            cr = cr[:-1]
                    elif "neg" in self.Polarity:
                        if cr[0]["slope"] == "rise":
                            cr = cr[1:]
                        if cr[-1]["slope"] == "fall":
                            cr = cr[:-1]
                    else:
                        msg = f"Unknown polarity '{self.Polarity}'"
                        raise ValueError(msg)

                    c = 0
                    while c < len(cr) - 1:
                        duration = cr[c + 1]["index"] - cr[c]["index"]
                        if (
                            "in" in self.Condition
                            and self.ThresholdLow <= duration <= self.ThresholdHigh
                            or "out" in self.Condition
                            and (duration <= self.ThresholdLow or duration >= self.ThresholdHigh)
                        ):
                            return cr[c + 1]["index"]
                        c += 2
            else:
                msg = f"Unknown condition '{self.Condition}'"
                raise ValueError(msg)

        except Exception:
            return None
        return None


class TriggerGlitch(TriggerWidth):
    """
    Glitch Trigger Class
    """

    def __init__(self, parent, Source, Level, Width, Polarity, Condition, Position, Coupling):
        cond = str(Condition).lower()
        if not any(c in cond for c in ["less", "more"]):
            msg = f"Condition '{Condition}' is not supported."
            raise ValueError(msg)

        if "less" in cond:
            ThresholdLow, ThresholdHigh = 0.0, float(Width)
            Condition = "within"
        else:
            ThresholdLow, ThresholdHigh = float(Width), 1e100
            Condition = "within"
        TriggerWidth.__init__(
            self,
            parent,
            Source,
            Level,
            ThresholdHigh,
            ThresholdLow,
            Polarity,
            Condition,
            Position,
            Coupling,
        )


class Measurement:
    """
    This CLass provides Measurement Functions executed on the Data of a specific channels. All Channels, that support
    Measurements instanciate this class
    """

    def __init__(self, ProbeObject):
        """:type ProbeObject: probes.Probe_Scope.Channel"""
        self._ScopeData = ProbeObject._ScopeChannel__ScopeData
        with contextlib.suppress(Exception):
            self._ProbeData = ProbeObject._ScopeChannel__probeData

    done = False
    max = None
    min = None
    pkpk = None
    AvgFreq = None
    WidthPos = None

    def Measure(self):
        """
        Executes all available Measurements and fills it into the storage class. The Sequence in which the
        measurements are executed is significant. As certain measurements use results from previous Measurements
        """
        self.done = True
        self._ProbeData.Measurement.max = self._ProbeData.Data.max()
        self._ProbeData.Measurement.min = self._ProbeData.Data.min()
        self._ProbeData.Measurement.pkpk = self._ProbeData.Measurement.max - self._ProbeData.Measurement.min
        self._ProbeData.Measurement.AvgFreq = self.__AvgFreq()
        self._ProbeData.Measurement.WidthPos = self.__WidthPos()

    def _ac_couple(self, data):
        """
        removes any DC offset from the input signal
        :param data: Input signal
        :returns The signal without DC Offset
        """
        mean = np.mean(data)
        return data - mean

    def __WidthPos(self):
        """
        determins the pulse with of the first positive pulse in a signal
        """
        thres = 1  # self._ProbeData.Measurement.min + self._ProbeData.Measurement.pkpk * 0.1
        hyst = 1  # self._ProbeData.Measurement.pkpk * 0.05
        rises = []
        wf = Waveform(self._ProbeData.Data)
        crossing = wf.Measurements_Utils.find_all_crossings(thres, hyst, "abs")
        for c in crossing:
            if c["slope"] == "rise":
                rises.append(c["index"])
                if rises.__len__() == 2:
                    break
        if rises.__len__() == 2:
            width = self._ScopeData.TimeVector[rises[1]] - self._ScopeData.TimeVector[rises[0]]
        else:
            width = -1
        return width

    def __AvgFreq(self):
        """
        Determines the average frequency of an input signal based on the number of crossing through the symmetry
        level of the signal
        """
        delta = self._ProbeData.Measurement.max - self._ProbeData.Measurement.min
        threshold = self._ProbeData.Measurement.min + delta / 2
        hyst = delta * 0.1
        wf = Waveform(self._ProbeData.Data)
        crossing = wf.Measurements_Utils.find_all_crossings(threshold, hyst, "abs")
        rises = []
        for c in crossing:
            if c["slope"] == "rise":
                rises.append(c["index"])
        if rises.__len__() > 2:
            times = self._ScopeData.TimeVector[rises]
            periods = np.diff(times)
            average_period = periods.mean()
            return 1 / average_period
        return -1

    def _filter(self, data, bandwidth):
        """
        applies an 1024 tap fir low pass filter of a given Bandwidth on an input signal
        :param data: Input signal
        :param bandwidth: bandwidth of the filter (-3dB)
        :returns the filtered signal
        """
        cutoff = float(bandwidth) / float(self._ScopeData.SampleRate) / 2.0
        if cutoff < 1:  # only filter if set bandwith is < Nyquist
            if cutoff > 0.001:
                b, a = sps.butter(1, cutoff)
                data = sps.filtfilt(b, a, data)
            else:
                msg = (
                    "Bandwidth filter will not work reliably with this small cuttoff frequency. \n"
                    "Reduce Scope Sample Frequency or apply custom filter in postprocessing"
                )
                raise Exception(msg)
        return data
