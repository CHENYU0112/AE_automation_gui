from __future__ import annotations

import traceback
from enum import IntEnum

import numpy as np
import scipy.signal as sps

from pverify.postproc.waveform import Waveform


class UIMeasurementModeEnum(IntEnum):
    RMS = 0
    DC = 1
    MEAN = 2
    RMEAN = 3


class MeasurementEnum(IntEnum):
    Voltage = 0
    Current = 1
    ApparentPower = 2
    ActivePower = 3
    ReactivePower = 4
    Lambda = 5
    FreqU = 6
    FreqI = 12
    ITHD = 7
    UTHD = 13
    PTHD = 14
    VoltagePlusPeak = 8
    VoltageMinusPeak = 9
    CurrentPlusPeak = 10
    CurrentMinusPeak = 11


class HarmMeasurementEnum(IntEnum):
    Voltage = 0
    Current = 1
    ApparentPower = 2
    ActivePower = 3
    ReactivePower = 4
    Lambda = 5
    UHDF = 6
    IHDF = 7
    PHDF = 8


class SimulatedPwrAn:
    """
    Class holding Scope Runtime Data
    """

    SAMPLERATE = 200000

    def __init__(self, ref_AI, manager):
        """

        :param ref_AI: Pointer to an AI instance
        :type ref_AI: pverify.core.sim.abstract_instruments.AI_PowerAnalyzer.AI_PowerAnalyzer
        :param manager: Pointer to SimulationManager instance
        :type manager: pverify.core.sim.simulation_manager.SimulationManager
        """
        self.ref_AI = ref_AI
        self.manager = manager

        self.minimum_sim_time = 0  # Minimum simulation time needed for updating and averaging

        self.record_length = None  # Number of samples in one aquisition window
        """:type : int"""
        self.arm_time = 0  # Time i seconds on which the PwrAn is armed
        """:type : float"""

        self.syncsource = None
        """:type : pverify.PwrAnMapping"""
        self.updaterate = None
        """:type : float"""
        self.harmmaxorder = None
        """:type : float"""
        self.avgcount = None
        """:type : int"""

        self.timevec_raw = (
            None  # The raw timevector coming from simulation, it is needed to resample every channel signal
        )
        """:type : np.multiarray"""
        self.timevec_resampled = None  # The resampled timevector but absolute to the trigger position
        """:type : np.multiarray"""
        self.timevec_final = None  # The Result waveform Timvector starting at 0s
        """:type : np.multiarray"""
        self.channels = {}  # A list of defined Channles
        """:type : dict[pverify.PwrAnMapping,SimulatedScopeChannel]"""

    def PowerAnalyzerSetup(self, SyncSource, UpdateRate, AverageCount, HarmMaxOrder):
        self.syncsource = SyncSource
        self.updaterate = max(1e-12, float(UpdateRate))
        self.harmmaxorder = max(1, int(HarmMaxOrder))
        self.avgcount = max(1, int(AverageCount))

    def Arm(self):
        self.arm_time = self.manager.current_time
        self.minimum_sim_time = self.arm_time + max(0.0, self.updaterate) * max(1, self.avgcount)
        self.reset()

    def GetChannel(self, MappingObject):
        """

        :type MappingObject: pverify.PwrAnMapping
        :rtype: SimulatedPwrAnChannel
        """
        if MappingObject not in self.channels:
            ch = SimulatedPwrAnChannel(self, MappingObject)
            self.channels[MappingObject] = ch
            self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_pos)
            self.manager.keeps.add(MappingObject.Sim_Probe.netname_current)
            if MappingObject.Sim_Probe.netname_voltage_neg is not None:
                self.manager.keeps.add(MappingObject.Sim_Probe.netname_voltage_neg)

        return self.channels[MappingObject]

    def reset(self):
        for c in self.channels.values():
            c.reset()
        self.timevec_resampled = None
        self.timevec_final = None
        self.timevec_raw = None


class SimulatedPwrAnChannel:
    """
    Storage Class holding data associated to a Channel/Probe
    """

    def __init__(self, parent, mappingobj):
        """

        :type parent: SimulatedPwrAn
        :type mappingobj: pverify.PwrAnMapping
        """
        self.parent = parent
        self.ref_AI = parent.ref_AI
        self.manager = parent.manager

        self.mappingobj = mappingobj

        self.uimeasurementmode = None
        """:type : UIMeasurementModeEnum"""
        self.linefilter = None
        """:type : float|NoneType"""
        self.frequencyfilter = False
        """:type : bool"""

        self.current_wf = None
        """:type : pverify.Waveform|NoneType"""
        self.voltage_wf = None
        """:type : pverify.Waveform|NoneType"""

        self.pll = PLL(self)
        self.measurements = Measurements(self)

    def reset(self):
        self.current_wf = None
        """:type : pverify.Waveform|NoneType"""
        self.voltage_wf = None
        """:type : pverify.Waveform|NoneType"""
        self.pll.reset()
        self.measurements.reset()

    def ProbeSetup(self, UIMeasurementMode, LineFilter, FrequencyFilter):
        mmode = str(UIMeasurementMode).lower()
        if "rms" in mmode:
            self.uimeasurementmode = UIMeasurementModeEnum.RMS
        elif "dc" in mmode:
            self.uimeasurementmode = UIMeasurementModeEnum.DC
        elif "rmean" in mmode:
            self.uimeasurementmode = UIMeasurementModeEnum.RMEAN
        elif "mean" in mmode:
            self.uimeasurementmode = UIMeasurementModeEnum.MEAN
        else:
            msg = f"Unknown UIMeasurementMode '{UIMeasurementMode}'"
            raise ValueError(msg)
        self.linefilter = None if LineFilter is None else max(1, float(LineFilter))
        self.frequencyfilter = bool(FrequencyFilter)

    def GetProbeMeasurement(self, MeasurementItem):
        try:
            if not self.voltage_wf or not self.current_wf:
                self.voltage_wf, self.current_wf = self._probe()
                self.measurements.measure_all()

            return self.measurements.get_norm_item(MeasurementItem)
        except Exception:
            self.manager.reftest.Utils.LogWarning(
                f"An exception occurred when measuring '{MeasurementItem}' on {self.parent.ref_AI}:\n"
                f"{traceback.format_exc(chain=False)}"
            )
            return None

    def GetProbeHarmonicMeasurement(self, MeasurementItem):
        try:
            if not self.voltage_wf or not self.current_wf:
                self.voltage_wf, self.current_wf = self._probe()
                self.measurements.measure_all()

            return self.measurements.get_harm_item(MeasurementItem)
        except Exception:
            self.manager.reftest.Utils.LogWarning(
                f"An exception occurred when measuring '{MeasurementItem}' on {self.parent.ref_AI}:\n"
                f"{traceback.format_exc(chain=False)}"
            )
            return None

    def _probe(self):
        """
        :rtype: (pverify.Waveform,pverify.Waveform)
        """
        ta = self.manager.ta
        reftest = self.manager.reftest
        varindex = reftest.VariationIndex

        if not reftest._sim_has_run and not reftest._sim_failed:
            reftest.start_simulation()

        from srd.internal.simulator.errors import Error

        if not reftest._sim_failed:
            # Get the time vector
            if self.parent.timevec_raw is None:
                try:
                    self.parent.timevec_raw = ta.probe("Time", run_num=varindex, cache=False)
                except Exception as e:
                    msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                    raise Exception("Error when extracting time vector from simulation:\n" + msg) from None

            if not self.pll.synchonized:
                try:
                    self.pll.synchonize()
                except Exception as e:
                    self.manager.reftest.Utils.LogWarning("Error while synchonizing PLL:\n" + str(e))

            try:
                # Get the raw voltage data vector
                voltage_data = ta.probe(
                    self.mappingobj.Sim_Probe.netname_voltage_pos,
                    run_num=varindex,
                    cache=False,
                )
            except Exception as e:
                msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                msg = (
                    f"Error when extracting voltage signal vector '{self.mappingobj.Sim_Probe.netname_voltage_pos}' "
                    f"from simulation:\n{msg}"
                )
                raise Exception(msg) from None

            if self.mappingobj.Sim_Probe.netname_voltage_neg is not None:
                try:
                    # Get the raw data vector
                    voltage_data_ref = ta.probe(
                        self.mappingobj.Sim_Probe.netname_voltage_neg,
                        run_num=varindex,
                        cache=False,
                    )
                except Exception as e:
                    msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                    msg = (
                        f"Error when extracting signal vector '{self.mappingobj.Sim_Probe.netname_voltage_neg}' "
                        f"from simulation:\n{msg}"
                    )
                    raise Exception(msg) from None
                voltage_data -= voltage_data_ref

            try:
                # Get the raw current data vector
                current_data = ta.probe(
                    self.mappingobj.Sim_Probe.netname_current,
                    run_num=varindex,
                    cache=False,
                )
            except Exception as e:
                msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                msg = (
                    f"Error when extracting current signal vector '{self.mappingobj.Sim_Probe.netname_current}' "
                    f"from simulation:\n{msg}"
                )
                raise Exception(msg) from None

            # Interpolate according to the resample new time vector
            voltage_data = np.interp(self.parent.timevec_resampled, self.parent.timevec_raw, voltage_data)
            current_data = np.interp(self.parent.timevec_resampled, self.parent.timevec_raw, current_data)

            if self.linefilter is not None:
                cutoff = float(self.linefilter) / SimulatedPwrAn.SAMPLERATE / 2.0
                if cutoff < 1:
                    if cutoff > 0.001:
                        b, a = sps.butter(1, cutoff, output="ba")
                        voltage_data = sps.filtfilt(b, a, voltage_data)
                        current_data = sps.filtfilt(b, a, current_data)
                    else:
                        msg = (
                            "Bandwidth filter will not work reliably with this small cutoff frequency. "
                            "\nReduce sample rate or apply custom filter in postprocessing"
                        )
                        raise Exception(msg)

            return Waveform(voltage_data, self.parent.timevec_final), Waveform(current_data, self.parent.timevec_final)

        msg = (
            f"Simulation failed. Cannot extract signal "
            f"'{self.mappingobj.Sim_Probe.netname_voltage_pos}' and '{self.mappingobj.Sim_Probe.netname_current}'."
        )
        raise Exception(msg)


class PLL:
    def __init__(self, parent):
        """

        :type parent: SimulatedPwrAnChannel
        """
        self.parent = parent

        self.sync_wf = None
        """:type : pverify.Waveform|NoneType"""
        self.sync_cycles = None
        """:type : list[list[float]]"""
        self.sync_success = False

    def reset(self):
        self.sync_wf = None
        """:type : pverify.Waveform|NoneType"""
        self.sync_cycles = None
        """:type : list[list[float]]"""

    @property
    def synchonized(self):
        return self.sync_cycles is not None

    def synchonize(self):
        """
        Probes the trigger waveform and finds a trigger on it.

        Calculates the time when the trigger occurred as well as the resampled/final time vector
        """
        if self.synchonized:
            return

        run_num = self.parent.manager.reftest.VariationIndex
        source = self.parent.parent.syncsource.Sim_Probe.netname_voltage_pos

        # Get the trigger wave (probe signal, get timevec from parent)
        from srd.internal.simulator.errors import Error

        if source:
            try:
                # Get the raw data vector
                sync_wf = self.parent.manager.ta.probe(source, run_num=run_num, cache=False)
            except Exception as e:
                msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                msg = f"Error when extracting PLL sync signal vector '{source}' from simulation:\n{msg}"
                raise Exception(msg) from None

            if self.parent.mappingobj.Sim_Probe.netname_voltage_neg is not None:
                try:
                    # Get the raw data vector
                    sync_wf_ref = self.parent.manager.ta.probe(
                        self.parent.mappingobj.Sim_Probe.netname_voltage_neg,
                        run_num=run_num,
                        cache=False,
                    )
                except Exception as e:
                    msg = str(e) if isinstance(e, Error) else traceback.format_exc()
                    msg = (
                        f"Error when extracting signal vector "
                        f"'{self.parent.mappingobj.Sim_Probe.netname_voltage_neg}' from simulation:\n{msg}"
                    )
                    raise Exception(msg) from None
                sync_wf -= sync_wf_ref

            self.sync_wf = Waveform(sync_wf, self.parent.parent.timevec_raw)

            # Cut the part before arm time
            self.sync_wf = self.sync_wf[float(self.parent.parent.arm_time) :]

            self.sync_cycles = self.sync_wf.Measurements_Utils.find_periods(
                "rise",
                0,
                0 if not self.parent.frequencyfilter else 0.01,
                "rel",
                False,
                "mid",
            )
            if self.sync_cycles is None:
                self.sync_cycles = self.sync_wf.Measurements_Utils.find_periods(
                    "fall",
                    0,
                    0 if not self.parent.frequencyfilter else 0.01,
                    "rel",
                    False,
                    "mid",
                )
                if self.sync_cycles is None:
                    self.sync_success = False
                    self.parent.manager.reftest.Utils.LogWarning(
                        "Error while synchonizing PLL: Did not find a full AC period in the sync signal! "
                        "Harmonic measurements will return NaN!"
                    )
                else:
                    self.sync_success = True
            else:
                self.sync_success = True

        else:
            msg = (
                f"No valid synchronization source defined: Sim_Probe.netname_voltage_pos='{source}' "
                f"@ mapping obj {self.parent.parent.syncsource}"
            )
            raise Exception(msg)
        if self.sync_success:
            self.parent.parent.timevec_resampled = np.arange(
                self.sync_cycles[0][0],
                self.sync_cycles[-1][-1],
                1.0 / SimulatedPwrAn.SAMPLERATE,
            )
        else:
            self.parent.parent.timevec_resampled = np.arange(
                self.sync_wf.time[0],
                self.sync_wf.time[-1],
                1.0 / SimulatedPwrAn.SAMPLERATE,
            )
        self.parent.parent.timevec_final = (
            self.parent.parent.timevec_resampled - self.parent.parent.timevec_resampled[0]
        )


class Measurements:
    def __init__(self, parent):
        """

        :type parent: SimulatedPwrAnChannel
        """
        self.parent = parent
        self.norm_results = {}
        """:type : dict[MeasurementEnum, float|int|NoneType]"""
        self.harm_results = {}
        """:type : dict[HarmMeasurementEnum, list[float|int]|NoneType]"""

    def reset(self):
        self.norm_results = {}
        """:type : dict[MeasurementEnum, float|int|NoneType]"""
        self.harm_results = {}
        """:type : dict[HarmMeasurementEnum, list[float|int]|NoneType]"""

    def get_norm_item(self, measure):
        """

        :type measure: str
        """
        measure = str(measure).lower()

        if measure in "voltage":
            measure = MeasurementEnum.Voltage
        elif measure in "current":
            measure = MeasurementEnum.Current
        elif measure in "power":
            measure = MeasurementEnum.ActivePower
        elif measure in "apparentpower":
            measure = MeasurementEnum.ApparentPower
        elif measure in "reactivepower":
            measure = MeasurementEnum.ReactivePower
        elif measure in "lambda":
            measure = MeasurementEnum.Lambda
        elif measure in "frequ":
            measure = MeasurementEnum.FreqU
        elif measure in "freqi":
            measure = MeasurementEnum.FreqI
        elif measure in "ithd":
            measure = MeasurementEnum.ITHD
        elif measure in "uthd":
            measure = MeasurementEnum.UTHD
        elif measure in "pthd":
            measure = MeasurementEnum.PTHD
        elif measure in "voltagepluspeak":
            measure = MeasurementEnum.VoltagePlusPeak
        elif measure in "voltageminuspeak":
            measure = MeasurementEnum.VoltageMinusPeak
        elif measure in "currentpluspeak":
            measure = MeasurementEnum.CurrentPlusPeak
        elif measure in "currentminuspeak":
            measure = MeasurementEnum.CurrentMinusPeak
        else:
            msg = f"Normal measurement '{measure}' not implemented!"
            raise NotImplementedError(msg)

        return self.norm_results.get(measure, None)

    def get_harm_item(self, measure):
        """

        :type measure: str
        """
        measure = str(measure).lower()

        if measure in "voltage":
            measure = HarmMeasurementEnum.Voltage
        elif measure in "current":
            measure = HarmMeasurementEnum.Current
        elif measure in "power":
            measure = HarmMeasurementEnum.ActivePower
        elif measure in "apparentpower":
            measure = HarmMeasurementEnum.ApparentPower
        elif measure in "reactivepower":
            measure = HarmMeasurementEnum.ReactivePower
        elif measure in "lambda":
            measure = HarmMeasurementEnum.Lambda
        elif measure in "uhdf":
            measure = HarmMeasurementEnum.UHDF
        elif measure in "ihdf":
            measure = HarmMeasurementEnum.IHDF
        elif measure in "phdf":
            measure = HarmMeasurementEnum.PHDF
        else:
            msg = f"Normal measurement '{measure}' not implemented!"
            raise NotImplementedError(msg)

        if self.parent.pll.sync_success:
            ret = self.harm_results.get(measure, None)
            if ret is not None:
                ret = ret[: self.parent.parent.harmmaxorder + 1]
            return ret
        return np.nan

    def measure_all(self):
        """
        Executes all available Measurements and fills it into the storage class. The Sequence in which the
        measurements are executed is significant. As certain measurements use results from previous Measurements
        """
        mmode = self.parent.uimeasurementmode
        if mmode == UIMeasurementModeEnum.RMS:
            self.norm_results[MeasurementEnum.Voltage] = self.parent.voltage_wf.Measurements_Base.rms()
            self.norm_results[MeasurementEnum.Current] = self.parent.current_wf.Measurements_Base.rms()

        elif mmode == UIMeasurementModeEnum.DC:
            self.norm_results[MeasurementEnum.Voltage] = self.parent.voltage_wf.Measurements_Base.mean()
            self.norm_results[MeasurementEnum.Current] = self.parent.current_wf.Measurements_Base.mean()

        elif mmode == UIMeasurementModeEnum.MEAN:
            self.norm_results[MeasurementEnum.Voltage] = (
                np.mean(np.abs(self.parent.voltage_wf.data)) * np.pi / (2.0 * np.sqrt(2))
            )
            self.norm_results[MeasurementEnum.Current] = (
                np.mean(np.abs(self.parent.current_wf.data)) * np.pi / (2.0 * np.sqrt(2))
            )

        elif mmode == UIMeasurementModeEnum.RMEAN:
            self.norm_results[MeasurementEnum.Voltage] = np.mean(np.abs(self.parent.voltage_wf.data))
            self.norm_results[MeasurementEnum.Current] = np.mean(np.abs(self.parent.current_wf.data))

        self.norm_results[MeasurementEnum.ActivePower] = np.mean(
            self.parent.voltage_wf.data * self.parent.current_wf.data
        )
        self.norm_results[MeasurementEnum.ApparentPower] = (
            self.parent.voltage_wf.Measurements_Base.rms() * self.parent.voltage_wf.Measurements_Base.rms()
        )
        self.norm_results[MeasurementEnum.Lambda] = abs(
            self.norm_results[MeasurementEnum.ActivePower] / self.norm_results[MeasurementEnum.ApparentPower]
        )
        self.norm_results[MeasurementEnum.ReactivePower] = np.sqrt(
            np.power(self.norm_results[MeasurementEnum.ApparentPower], 2)
            - np.power(self.norm_results[MeasurementEnum.ActivePower], 2)
        )
        if np.isnan(self.norm_results[MeasurementEnum.ReactivePower]):
            self.norm_results[MeasurementEnum.ReactivePower] = 0.0
        self.norm_results[MeasurementEnum.FreqU] = abs(self.parent.voltage_wf.fft()).Measurements_Utils.argmax()
        self.norm_results[MeasurementEnum.FreqI] = abs(self.parent.current_wf.fft()).Measurements_Utils.argmax()
        self.norm_results[MeasurementEnum.VoltagePlusPeak] = self.parent.voltage_wf.Measurements_Base.max()
        self.norm_results[MeasurementEnum.VoltageMinusPeak] = self.parent.voltage_wf.Measurements_Base.min()
        self.norm_results[MeasurementEnum.CurrentPlusPeak] = self.parent.current_wf.Measurements_Base.max()
        self.norm_results[MeasurementEnum.CurrentMinusPeak] = self.parent.current_wf.Measurements_Base.min()

        if self.parent.pll.sync_success:
            nperiods = len(self.parent.pll.sync_cycles)

            freqs, fft_current = self._fft(self.parent.current_wf, nperiods)
            freqs, fft_voltage = self._fft(self.parent.voltage_wf, nperiods)
            half = int(len(freqs) / 2)

            self.harm_results[HarmMeasurementEnum.Voltage] = (abs(fft_voltage) * np.sqrt(2))[:half]
            self.harm_results[HarmMeasurementEnum.Current] = (abs(fft_current) * np.sqrt(2))[:half]
            self.harm_results[HarmMeasurementEnum.Lambda] = (np.cos(np.angle(fft_current) - np.angle(fft_voltage)))[
                :half
            ]

            _tmp = np.real(fft_voltage) * np.real(fft_current) + 1j * np.imag(fft_voltage) * np.imag(fft_current)
            self.harm_results[HarmMeasurementEnum.ActivePower] = (abs(_tmp) * 2)[:half]

            _tmp = np.real(fft_voltage) * np.imag(fft_current) - np.imag(fft_voltage) * np.real(fft_current)
            self.harm_results[HarmMeasurementEnum.ReactivePower] = (abs(_tmp) * 2)[:half]

            self.harm_results[HarmMeasurementEnum.ApparentPower] = np.sqrt(
                self.harm_results[HarmMeasurementEnum.ActivePower] ** 2
                + self.harm_results[HarmMeasurementEnum.ReactivePower] ** 2
            )

            self.norm_results[MeasurementEnum.ITHD] = self._thd(self.harm_results[HarmMeasurementEnum.Current])
            self.norm_results[MeasurementEnum.UTHD] = self._thd(self.harm_results[HarmMeasurementEnum.Voltage])
            self.norm_results[MeasurementEnum.PTHD] = self._thd(self.harm_results[HarmMeasurementEnum.ApparentPower])
            self.harm_results[HarmMeasurementEnum.IHDF] = (
                self.harm_results[HarmMeasurementEnum.Current] / self.harm_results[HarmMeasurementEnum.Current][1]
            )
            self.harm_results[HarmMeasurementEnum.UHDF] = (
                self.harm_results[HarmMeasurementEnum.Voltage] / self.harm_results[HarmMeasurementEnum.Voltage][1]
            )
            self.harm_results[HarmMeasurementEnum.PHDF] = (
                self.harm_results[HarmMeasurementEnum.ApparentPower]
                / self.harm_results[HarmMeasurementEnum.ApparentPower][1]
            )
        else:
            self.harm_results[HarmMeasurementEnum.Voltage] = None
            self.harm_results[HarmMeasurementEnum.Current] = None
            self.harm_results[HarmMeasurementEnum.Lambda] = None
            self.harm_results[HarmMeasurementEnum.ActivePower] = None
            self.harm_results[HarmMeasurementEnum.ReactivePower] = None
            self.harm_results[HarmMeasurementEnum.ApparentPower] = None
            self.norm_results[MeasurementEnum.ITHD] = np.nan
            self.norm_results[MeasurementEnum.UTHD] = np.nan
            self.norm_results[MeasurementEnum.PTHD] = np.nan
            self.harm_results[HarmMeasurementEnum.IHDF] = None
            self.harm_results[HarmMeasurementEnum.UHDF] = None
            self.harm_results[HarmMeasurementEnum.PHDF] = None

    def _thd(self, bins):
        minorder = 2
        hrange = list(range(minorder, int(self.parent.parent.harmmaxorder + 1)))
        # calculate power in harmics
        harmonics = np.sqrt(np.sum(np.power(bins[hrange], 2)))
        # calculate power in fundamental
        fundamental = bins[1]
        # THD according to https://de.wikipedia.org/wiki/Total_Harmonic_Distortion
        return harmonics / fundamental

    def _fft(self, signal, nperiods):
        # Number FFT Window size. To avoid spectral leakage this must be an integer power of 2
        # As bin 1 is always exactly the fundamental, this modifies also the overall bandwidth
        nbins = np.power(2, 14)
        endtime = len(signal) / SimulatedPwrAn.SAMPLERATE
        # the respective corrected target sample frequency
        fs_target = nbins / endtime * nperiods
        # using resample function to transform the signal, it should avoid massive aliasing
        timevector = np.arange(0, endtime, 1 / fs_target)
        origtimevector = [i * 1.0 / SimulatedPwrAn.SAMPLERATE for i in range(len(signal))]
        newsignal = np.interp(timevector, origtimevector, signal)
        # newsignal = sps.resample(syncedsignal, timevector.__len__())
        # frequencies of the fft bins
        freqs = np.fft.fftfreq(nbins, 1 / fs_target)
        # the actual fft call
        bins = np.fft.fft(newsignal, nbins) / nbins
        return freqs, bins

    def _pysum(self, values):
        return np.sqrt(np.sum(np.power(values, 2)))
