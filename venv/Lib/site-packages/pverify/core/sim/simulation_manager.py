from __future__ import annotations


class SimulationManager:
    def __init__(self, reftest):
        """


        :type reftest: pverify.PyVerifyBaseTest
        """
        self.reftest = reftest

        self.sources = []
        """:type : list[pverify.core.sim.simulated_source.SimulatedSource]"""

        self.probes = []
        """:type : list[pverify.core.sim.simulated_scope.SimulatedScope|
        pverify.core.sim.simulated_pwran.SimulatedPwrAn]"""

        self.keeps = set()  # Variable used to track signels which have to be traced in simulation

        self.current_time = 0.0

        # If a stimulus is defined during preloop the current time must not be reset to 0. after the variationloop
        # but to the time the variationloop started with.
        # This time is 0. if no stimuli are defined in preloop and > 0 if blocking stimuli are defined in preloop
        self._time_after_preloop = 0.0

    @property
    def ta(self):
        """

        :rtype: srd.TransientAnalysis
        """
        if hasattr(self.reftest, "_sim_analysis"):
            return self.reftest._sim_analysis
        msg = "__sim_analysis object was apparently not yet created!"
        raise AttributeError(msg)

    def add_simulated_source(self, sequence):
        """
        :type sequence: pverify.core.sim.simulated_source.SimulatedSource
        """
        self.sources.append(sequence)

    def add_simulated_probe(self, probe):
        """
        :type probe: pverify.core.sim.simulated_scope.SimulatedScope | pverify.core.sim.simulated_pwran.SimulatedPwrAn
        """
        self.probes.append(probe)

    def reset(self):
        """
        Resets the current sim time and all stimuli/probes.

        For sources only stimuli are removed which where defined after preloop.
        The probe data is also reset.
        """
        self.reset_current_time()
        for s in self.sources:
            s.reset()
        for p in self.probes:
            p.reset()

    def reset_current_time(self):
        """Resets the current time to the time after preloop"""
        self.current_time = self._time_after_preloop

    def set_time_after_preloop(self):
        """Remembers the point simulation time after the preloop"""
        self._time_after_preloop = self.current_time

    @property
    def duration(self):
        """
        Iterates over all probes and finds the minimum simulation time required for all
        probes to properly get their data
        """
        duration = 0.0
        for p in self.probes:
            duration = max(duration, getattr(p, "minimum_sim_time", 0.0))

        return max(self.current_time, duration)
