from __future__ import annotations

from enum import IntEnum

import srd as SRD

from .simulated_source import SimulatedSource, StimType


class SimulatedProgLoad(SimulatedSource):
    class SourceTypeEnum(IntEnum):
        Voltage = 0
        Current = 1
        Power = 2
        Resistance = 3
        LED = 4

    def __init__(self, ref_AI, manager, ScriptingVars):
        SimulatedSource.__init__(self, ref_AI, manager, ScriptingVars)
        if False:
            from pverify.core.sim.abstract_instruments.AI_ProgLoad import AI_ProgLoad

            self.ref_AI = AI_ProgLoad()

        self._CurrentLevel = 0
        self._SourceType = None
        """:type : SimulatedProgLoad.SourceTypeEnum"""
        self.__von = 1e-6
        self.__voff = 0

    def reset(self):
        SimulatedSource.reset(self)
        self._SourceType = SimulatedProgLoad.SourceTypeEnum.Voltage
        """:type : SimulatedProgLoad.SourceTypeEnum"""

    def get_netlist_entry(self):
        SimulatedSource.get_netlist_entry(self)

        if len(self.sequence) and self._SourceType is not None and self._SourceType in SimulatedProgLoad.SourceTypeEnum:
            config = {}
            config[self.ScriptingVars.stimulustype] = self._SourceType.value  # Source template

            if self._SourceType == SimulatedProgLoad.SourceTypeEnum.Voltage:
                config[self.ScriptingVars.stimulus] = self.create_stimulus_string()
            elif self._SourceType == SimulatedProgLoad.SourceTypeEnum.Current:
                config[self.ScriptingVars.stimulus] = self.create_stimulus_string()
                if self.ScriptingVars.isrc_von is not None:
                    config[self.ScriptingVars.isrc_von] = self.__von
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'isrc_von'. "
                        "This may lead to inconsistent behavior!"
                    )
                if self.ScriptingVars.isrc_voff is not None:
                    config[self.ScriptingVars.isrc_voff] = self.__voff
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'isrc_voff'. "
                        "This may lead to inconsistent behavior!"
                    )
            elif self._SourceType == SimulatedProgLoad.SourceTypeEnum.Power:
                config[self.ScriptingVars.stimulus] = self.create_stimulus_string()
                if self.ScriptingVars.psrc_von is not None:
                    config[self.ScriptingVars.psrc_von] = self.__von
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'psrc_von'. "
                        "This may lead to inconsistent behavior!"
                    )
                if self.ScriptingVars.psrc_voff is not None:
                    config[self.ScriptingVars.psrc_voff] = self.__voff
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'psrc_voff'. "
                        "This may lead to inconsistent behavior!"
                    )
            elif self._SourceType == SimulatedProgLoad.SourceTypeEnum.Resistance:
                config[self.ScriptingVars.stimulus] = self.create_stimulus_string()
            elif self._SourceType == SimulatedProgLoad.SourceTypeEnum.LED:
                v_fwd, n_leds, r_dyn = self.create_stimulus_strings_LED()

                if self.ScriptingVars.ledsrc_v_fwd is not None:
                    config[self.ScriptingVars.ledsrc_v_fwd] = v_fwd
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'ledsrc_v_fwd'. "
                        "This may lead to inconsistent behavior!"
                    )
                if self.ScriptingVars.ledsrc_n_leds is not None:
                    config[self.ScriptingVars.ledsrc_n_leds] = n_leds
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'ledsrc_n_leds'. "
                        "This may lead to inconsistent behavior!"
                    )
                if self.ScriptingVars.ledsrc_r_dyn is not None:
                    config[self.ScriptingVars.ledsrc_r_dyn] = r_dyn
                else:
                    self.manager.reftest.Utils.LogWarning(
                        f"{self.ScriptingVars} has no scripting variable specified for 'ledsrc_r_dyn'. "
                        "This may lead to inconsistent behavior!"
                    )
        else:
            config = None
        self.reset()
        return config

    def create_stimulus_string(self):
        """
        This Function expands a list of Stimuli to SRD API Strings
        """
        self._CurrentLevel = 0
        stim_string = SRD.C(value=0, begin=0, end=0)

        for idx, stimpart in enumerate(self.sequence):
            tmp_str = SRD.C(value=0, begin=0)
            if stimpart.type == StimType.WAIT:
                pass
            elif self._timetable[idx].start >= self._timetable[idx].stop:
                continue

            elif stimpart.type == StimType.PL_VOLTAGE_STATIC or stimpart.type == StimType.PL_RESISTIVE_STATIC:
                stim_string += SRD.C(
                    value=stimpart.config["Level"],
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                )
                self._CurrentLevel = stimpart.config["Level"]

            elif stimpart.type == StimType.PL_CURRENT_STATIC:
                if self._CurrentLevel != "undef":
                    current_delta = stimpart.config["Level"] - self._CurrentLevel
                    if current_delta > 0:
                        transitiontime = current_delta / stimpart.config["SlewRateRise"] / 1e6
                    else:
                        transitiontime = -current_delta / stimpart.config["SlewRateFall"] / 1e6
                    if transitiontime > 0:
                        stim_string += SRD.R(
                            start_value=self._CurrentLevel,
                            end_value=stimpart.config["Level"],
                            begin=self._timetable[idx].start,
                            end=self._timetable[idx].start + transitiontime,
                        )
                else:
                    transitiontime = 0.0

                stim_string += SRD.C(
                    value=stimpart.config["Level"],
                    begin=self._timetable[idx].start + transitiontime,
                    end=self._timetable[idx].stop,
                )
                self._CurrentLevel = stimpart.config["Level"]

            elif stimpart.type == StimType.PL_POWER_STATIC:
                stim_string += SRD.C(
                    value=stimpart.config["Level"],
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                )
                self._CurrentLevel = stimpart.config["Level"]

            elif stimpart.type == StimType.PL_CURRENT_PULSED:
                duration = self._timetable[idx].stop - self._timetable[idx].start
                period = self.sequence[idx].config["DwellTime1"] + self.sequence[idx].config["DwellTime2"]
                ncycles = duration / period
                deltaI = self.sequence[idx].config["Level1"] - self.sequence[idx].config["Level2"]
                if deltaI < 0:
                    slewTime1 = -deltaI / self.sequence[idx].config["SlewRateRise"] / 1e6
                    slewTime2 = -deltaI / self.sequence[idx].config["SlewRateFall"] / 1e6
                else:
                    slewTime1 = deltaI / self.sequence[idx].config["SlewRateFall"] / 1e6
                    slewTime2 = deltaI / self.sequence[idx].config["SlewRateRise"] / 1e6
                endtime = self._timetable[idx].start
                for _cycle in range(int(ncycles)):
                    endtime, stim_string = self.__create_pulsed_load_cycle(
                        stim_string, endtime, 1, period, idx, slewTime1, slewTime2
                    )
                frac_cycle = ncycles - int(ncycles)
                if frac_cycle > 0:
                    endtime, stim_string = self.__create_pulsed_load_cycle(
                        stim_string,
                        endtime,
                        frac_cycle,
                        period,
                        idx,
                        slewTime1,
                        slewTime2,
                    )
                ctime = endtime

            elif stimpart.type == StimType.PL_CURRENT_RAMP:
                ramp_endtime = self._timetable[idx].start + stimpart.config["RiseTime"]
                tmp_str += SRD.R(
                    start_value=stimpart.config["Istart"],
                    end_value=stimpart.config["Istop"],
                    begin=self._timetable[idx].start,
                    end=ramp_endtime,
                )
                ctime = ramp_endtime
                self._CurrentLevel = stimpart.config["Istop"]

            elif stimpart.type == StimType.PL_POWER_RAMP:
                ctime = self._timetable[idx].start + stimpart.config["RiseTime"]
                tmp_str += SRD.R(
                    start_value=stimpart.config["Pstart"],
                    end_value=stimpart.config["Pstop"],
                    begin=self._timetable[idx].start,
                    end=ctime,
                )
                self._CurrentLevel = stimpart.config["Pstop"]

            elif stimpart.type == StimType.PL_CURRENT_STAIR:
                Level = stimpart.config["Istart"]
                ctime = self._timetable[idx].start
                for _step in range(stimpart.config["Nstep"] + 1):
                    endtime = ctime + float(stimpart.config["Tstep"])
                    tmp_str += SRD.C(value=Level, begin=ctime, end=endtime)
                    ctime = endtime
                    Level += stimpart.config["Istep"]
                self._CurrentLevel = stimpart.config["Istart"] + stimpart.config["Istep"] * (
                    stimpart.config["Nstep"] + 1
                )

            elif stimpart.type == StimType.PL_POWER_STAIR:
                Level = stimpart.config["Pstart"]
                ctime = self._timetable[idx].start
                for _step in range(stimpart.config["Nstep"] + 1):
                    endtime = ctime + float(stimpart.config["Tstep"])
                    tmp_str += SRD.C(value=Level, begin=ctime, end=endtime)
                    ctime = endtime
                    Level += stimpart.config["Pstep"]
                self._CurrentLevel = stimpart.config["Pstart"] + stimpart.config["Pstep"] * (
                    stimpart.config["Nstep"] + 1
                )

            if stimpart.type in [
                StimType.PL_CURRENT_RAMP,
                StimType.PL_CURRENT_STAIR,
                StimType.PL_CURRENT_PULSED,
                StimType.PL_POWER_RAMP,
                StimType.PL_POWER_STAIR,
            ]:
                end = self._timetable[idx].stop
                start = self._timetable[idx].start
                if ctime > end:
                    tmp_str = tmp_str * (SRD.C(value=1, begin=start, end=end) + SRD.C(value=0, begin=end))
                    ctime = end
                    self._CurrentLevel = "undef"
                stim_string += tmp_str

        return stim_string

    def create_stimulus_strings_LED(self):
        """
        This Function expands a list of Stimuli to SRD API Strings
        """
        stim_v_fwd = SRD.C(value=0, begin=0, end=0)
        stim_n_leds = SRD.C(value=0, begin=0, end=0)
        stim_r_dyn = SRD.C(value=0, begin=0, end=0)

        for idx, stimpart in enumerate(self.sequence):
            if stimpart.type == StimType.WAIT:
                pass
            elif self._timetable[idx].start >= self._timetable[idx].stop:
                continue
            elif stimpart.type == StimType.PL_LED_VfRdN:
                stim_v_fwd += SRD.C(
                    value=float(stimpart.config["Vf"]),
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                )

                stim_n_leds += SRD.C(
                    value=int(stimpart.config["N"]),
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                )

                stim_r_dyn += SRD.C(
                    value=float(stimpart.config["Rd"]),
                    begin=self._timetable[idx].start,
                    end=self._timetable[idx].stop,
                )

        return stim_v_fwd, stim_n_leds, stim_r_dyn

    def __create_pulsed_load_cycle(self, stim_string, starttime, fraction, period, idx, slewTime1, slewTime2):
        Dwell1_frac = (self.sequence[idx].config["DwellTime1"] - (slewTime1 / 2.0) - (slewTime2 / 2.0)) / period
        Slew1_frac = slewTime1 / period
        Dwell2_frac = (self.sequence[idx].config["DwellTime2"] - (slewTime1 / 2.0) - (slewTime2 / 2.0)) / period
        Slew2_frac = slewTime2 / period

        if Dwell1_frac <= fraction:
            Dwell1_frac_loc = 1
            fraction -= Dwell1_frac
        else:
            Dwell1_frac_loc = 1 - (Dwell1_frac - fraction) / Dwell1_frac
            fraction = 0

        if Slew1_frac <= fraction:
            Slew1_frac_loc = 1
            fraction -= -Slew1_frac
        else:
            Slew1_frac_loc = 1 - (Slew1_frac - fraction) / Slew1_frac
            fraction = 0

        if Dwell2_frac <= fraction:
            Dwell2_frac_loc = 1
            fraction -= Dwell2_frac
        else:
            Dwell2_frac_loc = 1 - (Dwell2_frac - fraction) / Dwell2_frac
            fraction = 0

        Slew2_frac_loc = 1 if Slew2_frac <= fraction else 1 - (Slew2_frac - fraction) / Slew2_frac

        endtime = starttime
        if Dwell1_frac_loc > 0:
            endtime = (
                starttime
                + (self.sequence[idx].config["DwellTime1"] - (slewTime1 / 2.0) - (slewTime2 / 2.0)) * Dwell1_frac_loc
            )
            stim_string += SRD.C(value=self.sequence[idx].config["Level1"], begin=starttime, end=endtime)
            self._CurrentLevel = self.sequence[idx].config["Level1"]
        if Slew1_frac_loc > 0:
            starttime = endtime
            endtime += slewTime1 * Slew1_frac_loc
            Level2frac = (
                self.sequence[idx].config["Level2"] - self.sequence[idx].config["Level1"]
            ) * Slew1_frac_loc + self.sequence[idx].config["Level1"]
            stim_string += SRD.R(
                start_value=self.sequence[idx].config["Level1"],
                end_value=Level2frac,
                begin=starttime,
                end=endtime,
            )
            self._CurrentLevel = Level2frac
        if Dwell2_frac_loc > 0:
            starttime = endtime
            endtime = (
                starttime
                + (self.sequence[idx].config["DwellTime2"] - (slewTime1 / 2.0) - (slewTime2 / 2.0)) * Dwell2_frac_loc
            )
            stim_string += SRD.C(value=self.sequence[idx].config["Level2"], begin=starttime, end=endtime)
            self._CurrentLevel = self.sequence[idx].config["Level2"]
        if Slew2_frac_loc > 0:
            starttime = endtime
            endtime += slewTime2 * Slew2_frac_loc
            Level2frac = (
                self.sequence[idx].config["Level1"] - self.sequence[idx].config["Level2"]
            ) * Slew2_frac_loc + self.sequence[idx].config["Level2"]
            stim_string += SRD.R(
                start_value=self.sequence[idx].config["Level2"],
                end_value=Level2frac,
                begin=starttime,
                end=endtime,
            )
            self._CurrentLevel = Level2frac

        return endtime, stim_string

    def _init_current_load(self, von, voff):
        if not self._SourceType:
            self._SourceType = SimulatedProgLoad.SourceTypeEnum.Current
        else:
            if self._SourceType != SimulatedProgLoad.SourceTypeEnum.Current:
                msg = "Source type can not dynamically change in testcase"
                raise Exception(msg)
        if von is not None:
            self.__von = max(1e-6, von)
        if voff is not None:
            self.__voff = min(von - 1e-6, voff)

    def _init_voltage_load(self):
        if not self._SourceType:
            self._SourceType = SimulatedProgLoad.SourceTypeEnum.Voltage
        else:
            if self._SourceType != SimulatedProgLoad.SourceTypeEnum.Voltage:
                msg = "Source type can not dynamically change in testcase"
                raise Exception(msg)

    def _init_power_load(self, von, voff):
        if not self._SourceType:
            self._SourceType = SimulatedProgLoad.SourceTypeEnum.Power
        else:
            if self._SourceType != SimulatedProgLoad.SourceTypeEnum.Power:
                msg = "Source type can not dynamically change in testcase"
                raise Exception(msg)
        if von is not None:
            self.__von = max(1e-6, von)
        if voff is not None:
            self.__voff = min(von - 1e-6, voff)

    def _init_resistive_load(self):
        if not self._SourceType:
            self._SourceType = SimulatedProgLoad.SourceTypeEnum.Resistance
        else:
            if self._SourceType != SimulatedProgLoad.SourceTypeEnum.Resistance:
                msg = "Source type can not dynamically change in testcase"
                raise Exception(msg)

    def _init_VfRdN_load(self):
        if not self._SourceType:
            self._SourceType = SimulatedProgLoad.SourceTypeEnum.LED
        else:
            if self._SourceType != SimulatedProgLoad.SourceTypeEnum.LED:
                msg = "Source type can not dynamically change in testcase"
                raise Exception(msg)
