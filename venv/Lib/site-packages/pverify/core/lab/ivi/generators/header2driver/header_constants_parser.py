#! /usr/bin/env python3

# Read #define's and translate to Python code.
# Handle #include statements.
# Handle #define macros with one argument.
# Anything that isn't recognized or doesn't translate into valid
# Python is ignored.

# Without filename arguments, acts as a filter.
# If one or more filenames are given, output is written to corresponding
# filenames in the local directory, translated to all uppercase, with
# the extension replaced by ".py".

# By passing one or more options of the form "-i regular_expression"
# you can specify additional strings to be ignored.  This is useful
# e.g. to ignore casts to u_long: simply specify "-i '(u_long)'".

# XXX To do:
# - turn trailing C comments into Python comments
# - turn C Boolean operators "&& || !" into Python "and or not"
# - what to do about #if(def)?
# - what to do about macros with multiple parameters?
from __future__ import annotations

import os
import re
import sys
from os.path import *
from typing import TextIO

pyverify_ivi_headers = abspath(join(dirname(__file__), "../../headers"))
if not exists(pyverify_ivi_headers):
    msg = f"Could not find '{pyverify_ivi_headers}'"
    raise FileNotFoundError(msg)

p_define = re.compile("^[\t ]*#[\t ]*define[\t ]+([a-zA-Z0-9_]+)[\t ]+")

p_macro = re.compile("^[\t ]*#[\t ]*define[\t ]+([a-zA-Z0-9_]+)\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)[\t ]+")

p_include = re.compile('^[\t ]*#[\t ]*include[\t ]+(<|")([a-zA-Z0-9_/\\.]+)')

p_comment = re.compile(r"/\*.*?\*/", flags=re.DOTALL)
p_cpp_comment = re.compile("//.*")

p_char = re.compile(r"'(\\.[^\\]*|[^\\])'")

p_hex = re.compile(r"0x([0-9a-fA-F]+)L?")


class HeaderConstantsParser:
    def __init__(self, ignores=None, searchdirs=None):
        """
        Creates a header_constants_parser object with follwoing parameters.

        :param ignores: The regular expression which need to be ignored while parsing.
        :param searchdirs: The paths where header file of the driver can be found.

        It creates a variable importable and stores all the header files
        located at 'pverify/contrib/Lab/ivi/headers', required apart from header
        file of the driver.
        """
        self.filedict = {}
        self.searchdirs = []
        self.importable = {}
        for i in os.listdir(pyverify_ivi_headers):
            fname = i.replace(".py", "")
            self.importable[fname + ".h"] = fname
        self.ignores = [p_comment, p_cpp_comment]
        if ignores is not None:
            for i in ignores:
                self.ignores.append(re.compile(i))

        if searchdirs is not None:
            self.searchdirs.extend([abspath(x) for x in searchdirs])
        dirs = [
            r"C:\Program Files\IVI Foundation\IVI\Include",
            r"C:\Program Files\IVI Foundation\VISA\Win64\Include",
            r"C:\Program Files (x86)\National Instruments\CVI2015\include",
        ]
        self.searchdirs.extend([abspath(x) for x in dirs])

    def parse(self, headerfile, outputfile=None):
        """

        :param headerfile: The path/name of the header file of the driver.
        :type headerfile: str
        :param outputfile: The path where outputfile will be created.
        :type outputfile: str | Path

        this function opens both the file: header file in read mode,
        output file in right mode and call the process function.
        """
        headerfile = abspath(headerfile)
        if outputfile is None:
            outfile = join(dirname(__file__), basename(headerfile).rsplit(".", 1)[0] + ".py")
        else:
            outfile = outputfile
        outfile = abspath(outfile)

        with open(headerfile) as hf, open(outfile, "w") as of:
            self.filedict = {}
            for dir in self.searchdirs:
                if headerfile[: len(dir)] == dir:
                    self.filedict[headerfile[len(dir) + 1 :]] = None  # no '/' trailing
                    break
            self.process(hf, of)

    def pytify(self, body):
        """

        :param body: String which contains the value for the constant
        :type body: str
        :return: value of the constant

        function find the value of the constant from the string and returns that.
        """
        # replace ignored patterns by spaces
        for p in self.ignores:
            body = p.sub(" ", body)
        # replace char literals by ord(...)
        body = p_char.sub("ord('\\1')", body)
        # Compute negative hexadecimal constants
        start = 0
        UMAX = 2 * (sys.maxsize + 1)
        while 1:
            m = p_hex.search(body, start)
            if not m:
                break
            s, e = m.span()
            val = int(body[slice(*m.span(1))], 16)
            if val > sys.maxsize:
                val -= UMAX
                body = body[:s] + "(" + str(val) + ")" + body[e:]
            start = s + 1
        return body

    def process(self, fp: TextIO, outfp: TextIO):
        """

        :param fp: object of header file of the driver.
        :type fp: object
        :param outfp: object of the output file which is getting created.
        :type outfp: object

        This function is comparing the regular expression with the string
        inside the header file,
        if it's a match then it will write that to the output file.
        """
        lineno = 0
        while 1:
            line = fp.readline()
            if not line:
                break
            lineno = lineno + 1
            match = p_define.match(line)
            if match:
                # gobble up continuation lines
                while line[-2:] == "\\\n":
                    nextline = fp.readline()
                    if not nextline:
                        break
                    lineno = lineno + 1
                    line = line + nextline
                name = match.group(1)
                body = line[match.end() :]
                body = self.pytify(body)

                # Check if statement uses L as suffix for numbers and fix
                body = re.sub("(0[xX][0-9a-fA-F]+)U?L", lambda obj: obj.group(1), body, count=1)
                body = re.sub("([0-9]+)U?L", lambda obj: obj.group(1), body, count=1)

                stmt = f"{name} = {body.strip()}\n"
                try:
                    exec(stmt)
                except NameError:
                    outfp.write(stmt)
                except Exception as e:
                    sys.stderr.write(f"Skipping: {stmt.strip()} ({e})\n")
                else:
                    outfp.write(stmt)
            match = p_macro.match(line)
            if match:
                macro, arg = match.group(1, 2)
                body = line[match.end() :]
                body = self.pytify(body)
                stmt = f"def {macro}({arg}): return {body}\n"
                try:
                    exec(stmt)
                except Exception as e:
                    sys.stderr.write(f"Skipping: {stmt.strip()} ({e})\n")
                else:
                    outfp.write(stmt)
            match = p_include.match(line)
            if match:
                regs = match.regs
                a, b = regs[2]
                filename = line[a:b]
                if filename in self.importable:
                    args = f"from pverify.core.lab.ivi.headers.{self.importable[filename]} import *\n"
                    outfp.write(args)
                    exec(args)
                elif filename not in self.filedict:
                    self.filedict[filename] = None
                    inclfp = None
                    for dir in self.searchdirs:
                        try:
                            inclfp = open(dir + "/" + filename)  # noqa: SIM115
                            break
                        except OSError:
                            pass
                    if inclfp:
                        outfp.write(f"\n# Included from {filename}\n")
                        self.process(inclfp, outfp)
                    else:
                        sys.stderr.write(f"Warning - could not find file {filename}\n")


if __name__ == "__main__":
    p = HeaderConstantsParser(
        searchdirs=[
            r"C:\Program Files\IVI Foundation\IVI\Include",
            r"C:\Program Files\IVI Foundation\VISA\Win64\Include",
            r"C:\Program Files (x86)\National Instruments\CVI2015\include",
        ]
    )
    p.parse(r"C:\Inicio_dev\sysver\PyVerify\pverify\contrib\Lab\ivic\hfiles\rsspecan\rsidr_core.h")
    p.parse(r"C:\Inicio_dev\sysver\PyVerify\pverify\contrib\Lab\ivic\hfiles\rsspecan\rsspecan_attributes.h")
    p.parse(r"C:\Inicio_dev\sysver\PyVerify\pverify\contrib\Lab\ivic\hfiles\rsspecan\rsspecan_utility.h")
