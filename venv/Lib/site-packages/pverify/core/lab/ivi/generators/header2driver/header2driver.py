from __future__ import annotations

import glob
import os
from os.path import *
from pathlib import Path

from pverify.core.lab.ivi.generators.header2driver.header_constants_parser import HeaderConstantsParser
from pverify.core.lab.ivi.generators.header2driver.header_prototype_parser import HeaderPrototypeParser, Parameter
from pverify.core.lab.ivi.generators.header2driver.templates import *

POINTER_DTYPE_LOOKUP = {
    "viint8": "int({pname}.value)",
    "viint16": "int({pname}.value)",
    "viint32": "int({pname}.value)",
    "viint64": "int({pname}.value)",
    "viuint8": "int({pname}.value)",
    "viuint16": "int({pname}.value)",
    "viuint32": "int({pname}.value)",
    "viuint64": "int({pname}.value)",
    "float": "float({pname}.value)",
    "vireal32": "float({pname}.value)",
    "double": "float({pname}.value)",
    "vireal64": "float({pname}.value)",
    "viboolean": "bool({pname}.value)",
    "viattr": "int({pname}.value)",
    "visession": "int({pname}.value)",
}


def to_python_type(parameter: Parameter):
    TYPEMAP = {
        "viuint8": int,
        "viuint16": int,
        "viuint32": int,
        "viuint64": int,
        "viint8": int,
        "viint16": int,
        "viint32": int,
        "viint64": int,
        "float": float,
        "vireal32": float,
        "double": float,
        "vireal64": float,
        "viboolean": bool,
        "vibyte": bytearray,
        "vistatus": int,
        "viobject": int,
        "viattr": int,
        "vichar": str,
        "vistring": str,
        "visession": int,
        "viconststring": str,
        "vibuf": str,
        "virsrc": str,
    }
    ctype = parameter.dtype.lower()
    if ctype in TYPEMAP:
        python_type = TYPEMAP[ctype].__name__
        if parameter.is_array and python_type not in ["bytearray", "str"]:
            return f"List[{python_type}]"
        return python_type
    return None


ARRAY_DTYPE_LOOKUP = {
    "viint8": "list({pname})",
    "viint16": "list({pname})",
    "viint32": "list({pname})",
    "viint64": "list({pname})",
    "viuint8": "list({pname})",
    "viuint16": "list({pname})",
    "viuint32": "list({pname})",
    "viuint64": "list({pname})",
    "float": "list({pname})",
    "vireal32": "list({pname})",
    "double": "list({pname})",
    "vireal64": "list({pname})",
    "viboolean": "list({pname})",
    "vichar": "decode({pname})",
    "vibyte": "bytearray({pname})",
}


class Header2Driver:
    """
    Header2Driver automatically generates the wrapper over the driver.
    """

    def __init__(
        self,
        group,
        drivername,
        dllpath32,
        dllpath64,
        headerfile,
        funcprefix,
        funcs_wth_array_arg=None,
        header_searchdirs=None,
    ):
        """
        Creates a Header2Driver object with follwoing parameters.

        :param group: The type of instrument.
        :type group: str
        :param drivername: Name of the driver.
        :type drivername: str
        :param dllpath32: Name of the DLL file(32 bit).
        :type dllpath32: str
        :param dllpath64: Name of the DLL file(64 bit).
        :type dllpath64: str
        :param headerfile: Path or name of the header file of the driver.
        :type headerfile: str
        :param funcprefix: Name of the driver or driver+"_"
        :type funcprefix: str
        :param funcs_wth_array_arg: List of the function name.
        :type funcs_wth_array_arg: list

        It also update the variable with the path where the files need to be created.
        """
        self.group = group
        self.drivername = drivername
        self.dllpath32 = dllpath32
        self.dllpath64 = dllpath64
        self.headerfile = headerfile
        self.funcprefix = str(funcprefix)
        if not self.funcprefix.endswith("_"):
            self.funcprefix += "_"
        self.funcs_wth_array_arg = funcs_wth_array_arg if funcs_wth_array_arg is not None else []
        self.header_searchdirs = header_searchdirs if header_searchdirs is not None else []

        self.driverdir = Path(__file__).parents[6] / f"pverify/drivers/build/{drivername}"
        self.drv_main_file = self.driverdir / f"{drivername}.py"
        self.drv_test_file = self.driverdir / f"{drivername}_test.py"
        self.drv_constants_file = self.driverdir / f"{drivername}_const.py"
        self.drv_dllwrapper_file = self.driverdir / f"{drivername}_dllwrap.py"

    def create_constants_file(self):
        """
        Function create the <drivername>_const.py file.
        """
        self.driverdir.mkdir(parents=True, exist_ok=True)

        hp = HeaderConstantsParser(searchdirs=self.header_searchdirs)
        hp.parse(headerfile=self.headerfile, outputfile=self.drv_constants_file)

    def create_dllwrapper_file(self):
        """
        Function create the <drivername>_dllwrap.py file.

        dllwrapper_content contains basic function template
        like constructor of dllwrapfile and properties.
        pp.functions contains the list of function.
        function is a again a list with name, rtype, arguments
        of the functions.

        Now for every type of parameter there is some preprocessing &
        postprocessing happening and then dumping into a dictonary
        which is then dumped into template and copied to the
        <drivername>_dllwrap.py file.
        """
        if not exists(self.driverdir):
            os.makedirs(self.driverdir)

        dllwrapper_content = TEMPLATE_WRAPPERCLASS.format(
            drivername=self.drivername,
            dllpath32=self.dllpath32,
            dllpath64=self.dllpath64,
        )

        pp = HeaderPrototypeParser(
            headerfile=self.headerfile,
            func_prefix=self.funcprefix,
            outputfile=self.drv_dllwrapper_file,
        )
        pp.parse()

        # a dictionary is geeting maintained for each function
        # with appropriate input to be dumped into template
        # and copied to the <drivername>_dllwrap.py file.

        for function in pp.functions:
            kwargs = {
                "fname": function.fname,
                "prefix": self.funcprefix,
                "fargs": "",
                "pointer_preprocessing": "",
                "callargs": "",
                "pointer_postprocessing": "",
                "returns": "",
            }
            fargs = []
            pointer_preprocessing = []
            callargs = []
            pointer_postprocessing = []
            returns = []

            for parameter in function.parameters:
                if parameter.valid:
                    if parameter.is_pointer:
                        pointer_preprocessing.append(f"{parameter.name} = {parameter.dtype}()")
                        callargs.append(f"byref({parameter.name})")
                        converter = POINTER_DTYPE_LOOKUP.get(parameter.dtype.lower(), "").format(pname=parameter.name)
                        if converter:
                            pointer_postprocessing.append(f"{parameter.name} = {converter}")
                        returns.append(parameter.name)

                    elif parameter.is_pointer_to_pointer:
                        pointer_preprocessing.append(
                            f'raise NotImplementedError("Argument {parameter.name!r} is a pointer to a pointers and '
                            f"is not supported by the automated wrapper generator! "
                            f'This function has to be fixed manually!")'
                        )
                        print(
                            f"\nWARNING: Argument {parameter.name!r} of function {self.funcprefix + function.fname!r} "
                            f"is a pointer to a pointers and is not supported by the automated wrapper generator!"
                        )

                    elif parameter.is_array:
                        print(
                            f"\nWARNING: Please re-check array parameter "
                            f"'{parameter.name}' ({parameter.dtype}) of function "
                            f"'{function.fname}' / '{self.funcprefix + function.fname}'!"
                        )
                        if any(
                            str(x).lower() in str(self.funcprefix + function.fname).lower()
                            for x in self.funcs_wth_array_arg
                        ):
                            print(f"    Templating {parameter.name!r} as INPUT!")
                            if parameter.dtype == "ViChar":
                                callargs.append(f"ViConstString({parameter.name})")
                            else:
                                pointer_preprocessing.append(
                                    f"_{parameter.name} = "
                                    f"({parameter.dtype} * len({parameter.name}))(*{parameter.name})"
                                )
                                callargs.append("_" + parameter.name)
                            fargs.append(parameter.name)
                        else:
                            print(f"    Templating {parameter.name!r} as OUTPUT!")
                            pointer_preprocessing.append(
                                f"{parameter.name} = ARRAY_{parameter.dtype}({parameter.array_size})"
                            )
                            callargs.append(f"{parameter.name}")
                            converter = ARRAY_DTYPE_LOOKUP.get(parameter.dtype.lower(), "").format(pname=parameter.name)
                            if converter:
                                pointer_postprocessing.append(f"{parameter.name} = {converter}")
                            returns.append(parameter.name)
                    else:
                        fargs.append(parameter.name)
                        callargs.append(f"{parameter.dtype}({parameter.name})")

            kwargs["fargs"] = ", ".join(fargs)
            kwargs["pointer_preprocessing"] = "\n        ".join(pointer_preprocessing)
            kwargs["callargs"] = ", ".join(callargs)
            kwargs["pointer_postprocessing"] = "\n        ".join(pointer_postprocessing)
            kwargs["returns"] = ", ".join(returns)

            dllwrapper_content += TEMPLATE_METHOD.format(**kwargs)

        with open(self.drv_dllwrapper_file, "w") as f:
            f.write(dllwrapper_content)

    def create_driver_main_class(self):
        """
        Function create <drivername>.py file

        pp.functions contains the list of function.
        function is a again a list with name, rtype, arguments
        of the functions.

        Now for every type of parameter there is some preprocessing &
        postprocessing happening and then dumping into a dictonary
        which is then dumped into template and copied to the
        <drivername>_dllwrap.py file.
        """
        main_driver_methods = ""

        if not exists(self.driverdir):
            os.makedirs(self.driverdir)

        pp = HeaderPrototypeParser(
            headerfile=self.headerfile,
            func_prefix=self.funcprefix,
            outputfile=self.drv_dllwrapper_file,
        )
        pp.parse()

        # a dictionary is geeting maintained for each function
        # with appropriate input to be dumped into template
        # and copied to the <drivername>.py file.

        for function in pp.functions:
            if function.fname.lower() not in ["close", "initwithoptions"]:
                kwargs = {"fname": function.fname, "fargs": "", "fargs_no_vi": ""}
                fargs = []
                fargs_no_vi = ["self"]

                returns = []
                for index, parameter in enumerate(function.parameters):
                    if parameter.valid:
                        if parameter.is_pointer:
                            add_param = False
                            returns.append(parameter)
                        elif parameter.is_array:
                            if any(
                                str(x).lower() in str(self.funcprefix + function.fname).lower()
                                for x in self.funcs_wth_array_arg
                            ):
                                add_param = True
                            else:
                                add_param = False
                                returns.append(parameter)
                        else:
                            add_param = True

                        if add_param:
                            if parameter.dtype.lower() == "visession" and index == 0:
                                fargs.append("self._vi")
                            else:
                                fargs.append(parameter.name)
                                python_type = to_python_type(parameter)

                                fargs_no_vi.append(f"{parameter.name}{(': ' + python_type) if python_type else ''}")

                kwargs["fargs"] = ", ".join(fargs)
                kwargs["fargs_no_vi"] = ", ".join(fargs_no_vi)

                if len(returns) == 0:
                    kwargs["rtype"] = ""
                elif len(returns) >= 1:
                    rtypes = [to_python_type(p) or "Any" for p in returns]
                    if len(returns) == 1:
                        kwargs["rtype"] = " -> " + rtypes[0]
                    else:
                        kwargs["rtype"] = f" -> Tuple[{', '.join(rtypes)}]"

                main_driver_methods += TEMPLATE_CLASS_METHOD.format(**kwargs)

        main_driver_content = TEMPLATE_CLASS.format(
            drivername=self.drivername,
            prefix=self.funcprefix,
            methods=main_driver_methods,
        )

        with open(self.drv_main_file, "w") as f:
            f.write(main_driver_content)

    def create_driver_test(self):
        """
        Function create <drivername>_test.py file.

        appropriate input are dumped into template
        and copied to the <drivername>_test.py file.
        """
        content = TEMPLATE_TEST.format(group=self.group, drivername=self.drivername, prefix=self.funcprefix)
        with open(self.drv_test_file, "w") as f:
            f.write(content)

    def create_ivi_structure(self):
        """
        Function creates all the IVI specific files.

        templates_iviclass : path where class specific templates are present.
        templates_ividriver: path where common templates are present.

        now it renders all the template inside the folder
        dump the appropriate input into template
        and copied to the driver specific folder.
        """
        IVI_CLASSES = {
            "Counter": "IviCounter",
            "ACPwr": "IviACPwr",
            "DCPwr": "IviDCPwr",
            "Dmm": "IviDmm",
            "Fgen": "IviFgen",
            "Scope": "IviScope",
        }
        if self.group in IVI_CLASSES:
            iviclass = IVI_CLASSES[self.group]
            templates_iviclass = abspath(join(dirname(__file__), "../_templates", iviclass))
            templates_ividriver = abspath(join(dirname(__file__), "../_templates/IviDriver"))
            files = glob.glob(join(templates_iviclass, "*.py"))
            files += glob.glob(join(templates_ividriver, "*.py"))
            for file in files:
                fname = basename(file)
                dst = join(self.driverdir, fname)
                with open(file) as f:
                    content = f.read()
                    content = content.format(
                        group=self.group,
                        drivername=self.drivername,
                        iviclass=iviclass,
                    )
                with open(dst, "w") as f:
                    f.write(content)
        else:
            (Path(self.driverdir) / "__init__.py").write_text(f"from .{self.drivername} import {self.drivername}")

    def run(self):
        """
        Function basically call all other functions which creates files.
        As for different files different functions are defined.
        """
        self.create_constants_file()
        self.create_dllwrapper_file()
        self.create_driver_main_class()
        self.create_driver_test()
        self.create_ivi_structure()


if __name__ == "__main__":
    dw = Header2Driver(
        group="Scope",
        drivername="tkmso5x",
        dllpath32="tkmso5x_32.dll",
        dllpath64="tkmso5x_64.dll",
        headerfile=r"C:\Program Files\IVI Foundation\IVI\Include\tkmso5x.h",
        funcprefix="tkmso5x_",
        funcs_wth_array_arg=[
            "CreateArbSequence",
            "CreateArbWaveform",
        ],
    )
    dw.run()
