from __future__ import annotations

import re
from os.path import *

PRINT_DEBUG_OUTPUT = False

pat_parameter = re.compile(r"^(?P<dtype>\w+)(\s*|(?P<pointer>( *\*{1,2} *)))?(?P<pname>\w+)(?P<array>\[\d*\])?$")


class HeaderPrototypeParser:
    def __init__(self, headerfile, func_prefix, return_dtype="ViStatus", outputfile=None):
        """
        Creates a header_prototype_parser object with follwoing parameters.

        :param headerfile: Path or name of the header file of the driver.
        :type headerfile: str
        :param funcprefix: Name of the driver or driver+"_"
        :type func_prefix: str
        :param return_dtype: return data type of the function dor <drivername>_dllwrap.py
        :type: str
        :param outputfile: Path where output file need to be created.
        :type outputfile: str | Path

        Converts regular expression pattern into a regular expression object i.e., proto_pat
        """
        self.hfile = headerfile
        self.func_prefix = func_prefix
        self.return_dtype = return_dtype
        if outputfile is None:
            self.outfile = join(dirname(__file__), basename(headerfile).rsplit(".", 1)[0] + ".py")
        else:
            self.outfile = outputfile
        self.fcontent = ""

        self.proto_pat = re.compile(
            pattern=rf"(?P<rtype>{self.return_dtype})\s+(.*?)(?P<fname>{self.func_prefix}\w+)\s*\((?P<args>.*?)\);",
            flags=re.IGNORECASE | re.DOTALL,
        )

        self.functions = []
        """:type : list[CFunction]"""

    def parse(self):
        """
        Opening the header file in read mode, comparing the string with
        the regular expression object.
        """
        with open(self.hfile) as f:
            self.fcontent = f.read()
        self.fcontent = re.sub(r"#define.*", "", self.fcontent, flags=re.IGNORECASE)
        defs = self.proto_pat.findall(string=self.fcontent)
        for d in defs:
            self.functions.append(CFunction(self, d[0], d[2], d[3]))


class CFunction:
    """
    Distinguish the different parts of the function like function name,
    return type, arguments of the function.
    """

    def __init__(self, parser, rtype, fname, argdef):
        """
        Creates a CFunction object with follwoing parameters

        :param parser: object of the function
        :type parser: class
        :param rtype: return type of the function
        :type rtype: str
        :param fname: function name
        :type fname: str
        :param argdef: function arguments
        :type argdef: str

        parameters is a list of class which stores the details of
        argument such as name, datatype, pointer, array, array size.
        """

        self.hpparser = parser
        """:type: HeaderPrototypeParser"""
        self.rtype = rtype
        self.fname = fname.replace(self.hpparser.func_prefix, "")
        self.argdef = argdef
        if PRINT_DEBUG_OUTPUT:
            print(self)
        self.parameters = [Parameter(x) for x in argdef.split(",")]
        """:type : list[Parameter]"""

    def __str__(self):
        return f"Method '{self.fname}', rtype '{self.rtype}', argdef: {self.argdef}"


class Parameter:
    """
    Class segregate the type of arguments by comparing the arguments
    with the regular expression.
    """

    def __init__(self, pdef):
        """

        :param pdef: Contains all the arguments of the function.
        :type pdef: str

        Matches the argument again with the regular expression object
        and assign them to the desired variables: argument name,
        argument datatype, argument is a pointer/array, array size.
        """
        self.pdef = str(pdef).strip()
        """:type : str"""
        self.valid = True
        self.array_size = "self.BUFSIZE"

        # Remove unwanted content
        self.pdef = self.pdef.replace("_VI_FAR", "").replace("\t", "    ")

        match = pat_parameter.match(self.pdef)
        self.valid &= match is not None

        # self.valid = self.valid & match is not None

        if self.valid:
            self.dtype = match.group("dtype")
            self.name = match.group("pname")
            self.is_pointer = match.group("pointer") is not None and match.group("pointer").count("*") == 1
            self.is_pointer_to_pointer = match.group("pointer") is not None and match.group("pointer").count("*") == 2
            if self.dtype.startswith("ViP"):
                self.is_pointer = True
                self.dtype = self.dtype.replace("ViP", "Vi")

            self.is_array = match.group("array") is not None
            if self.is_array:
                self.array_size = "self.BUFSIZE" if len(match.group("array")) == 2 else int(match.group("array")[1:-1])
        else:
            msg = f"Could not parse function parameter from signature: '{self.pdef}'"
            raise Exception(msg)

        if PRINT_DEBUG_OUTPUT:
            print(self)

    def __str__(self):
        if self.valid:
            return "    Parameter '%-30s', dtype '%-10s', pointer: %-5s, array: %s, array size: %d" % (
                self.name,
                self.dtype,
                [False, True][self.is_pointer],
                [False, True][self.is_array],
                self.array_size,
            )
        return "ERROR: Invalid parameter. Definition: " + self.pdef


if __name__ == "__main__":
    hp = HeaderPrototypeParser(
        headerfile=r"C:\Program Files (x86)\IVI Foundation\IVI\Include\Ag33250.h",
        func_prefix="Ag33250_",
        outputfile=None,
    )
    hp.parse()
