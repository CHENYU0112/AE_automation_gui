from __future__ import annotations

import importlib.util
import inspect
import sys
import traceback
from pathlib import Path
from typing import Any

from pverify.core import env
from pverify.core.hooks import DoE
from pverify.core.internals.Enums import Enums
from pverify.core.pyverify_base_test import PyVerifyBaseTest


class InstrumentConnectionError(Exception):
    pass


class PyVerifyLabTest(PyVerifyBaseTest):
    def __init__(self, **kwargs):
        self.__InstrumentHandler = None
        self.__Instruments = None
        """:type : pverify.core.lab.temp_.instrument_setup.Instruments"""
        self.__connect_successful = True

        super().__init__(**kwargs)
        if self.Attributes.ExecutionMode != Enums.ExecutionMode.PostProcOnly:
            self.Attributes.ExecutionMode = Enums.ExecutionMode.Lab

    def _deprecated_support(self):
        super()._deprecated_support()
        # Mock LabAttributes instance @ PyVerifyBaseTest.Attributes

        class LabAttributes:
            def __init__(self, root: PyVerifyLabTest):
                self.__root = root

            @property
            def InstrumentSetup(self):
                return self.__root.Instruments

            @InstrumentSetup.setter
            def InstrumentSetup(self, setup):
                self.__root.load_instrument_setup(setup)

        self.Attributes.LabAttributes = LabAttributes(self)

    def load_instrument_setup(self, setup: Any):
        r"""
        Selects the instrument to be used for this lab test

        Example:

        .. code-block:: python

            class DummyLabTest(PyVerifyLabTest):
                @DoE.Init()
                def init(self):
                    ...
                    self.load_instrument_setup(my_instrument_setup)
                    # or
                    self.load_instrument_setup(my_instrument_setup.Instruments)
                    # or
                    self.load_instrument_setup(r"C:\...\my_sources\my_instrument_setup.py")
                    ...

        :param setup: Either a path, the module (instrument_setup) or a reference to the 'Instruments'-class
                      inside the module

        """
        DEFAULT_SETUP = str(Path(__file__).with_name("instrument_setup_default.py"))
        TYPEHINTING_FILE = str(Path(__file__).parent / "temp_" / "instrument_setup.py")
        Path(TYPEHINTING_FILE).parent.mkdir(parents=True, exist_ok=True)

        def check_has_instr(module):
            if not hasattr(module, "Instruments"):
                msg = f"Module '{module}' has no class 'Instruments'!"
                raise LookupError(msg)

        if isinstance(setup, (str, Path)):
            name = Path(setup).stem
            spec = importlib.util.spec_from_file_location(name, setup)
            module = importlib.util.module_from_spec(spec)
            sys.modules[name] = module
            spec.loader.exec_module(module)
            check_has_instr(module)
            instruments_cls = module.Instruments
        elif setup.__class__.__name__ == "module":
            check_has_instr(setup)
            instruments_cls = setup.Instruments
        elif hasattr(setup, "Instruments"):
            instruments_cls = setup.Instruments
        elif setup.__class__.__name__ == "type" and setup.__name__ == "Instruments":
            instruments_cls = setup
        elif setup is None:
            self.Utils.LogInfo("No instrument configuration loaded, using default setup!")
            return self.load_instrument_setup(DEFAULT_SETUP)
        else:
            msg = (
                "Assigned type must be the instrument setup module, "
                "the Instruments-class or a path to the instrument setup!"
            )
            raise TypeError(msg)

        instrument_setup_filepath = inspect.getfile(instruments_cls)

        self.__Instruments = instruments_cls  # Will be instantiated once accessed via its property

        self.Utils.LogInfo(f"Using instrument setup {instrument_setup_filepath!r}")
        self.Utils.LogInfo("Importing setup for custom code completion...")
        with open(instrument_setup_filepath) as fs:
            content = fs.read()
            try:
                with open(TYPEHINTING_FILE, "w") as ft:
                    ft.write(content)
            except Exception as e:
                self.Utils.LogWarning(
                    f"Could not copy instrument setup {instrument_setup_filepath} to {TYPEHINTING_FILE}."
                    f"Code completion on 'self.Instruments' will not work properly! (Exception: {e})"
                )

    @DoE.Init(is_hook_wrapper=True, try_first=True, silent=True)
    def lab_init(self):
        yield

        if self.Attributes.ExecutionMode not in (
            Enums.ExecutionMode.Undef,
            Enums.ExecutionMode.Lab,
            Enums.ExecutionMode.PostProcOnly,
        ):
            msg = "Can only use this base class for lab related execution modes!"
            raise ValueError(msg)

    def __initialize_instrument(self, driversetup):
        objname = str(driversetup.driver).split("object at")[0].strip() + ">'"
        if not hasattr(driversetup, "driver"):
            msg = f"Driver setup {driversetup.__class__.__name__!r} does not have a 'driver' attribute!"
            raise AttributeError(msg)
        if not hasattr(driversetup, "visa_address"):
            msg = f"Driver setup {driversetup.__class__.__name__!r} does not have a 'visa_address' attribute!"
            raise AttributeError(msg)

        try:
            if driversetup.driver is None:
                return False

            self.Utils.LogInfo(f"  Connecting to instrument '{objname}' at visa address '{driversetup.visa_address}'.")
            default_args = (driversetup.visa_address, True, env.IVI_RESET, "")
            args = getattr(driversetup, "args", default_args)
            if type(args) not in (list, tuple):
                msg = "Type of 'args' is not tuple/list!"
                raise Exception(msg)
            driversetup.driver.Initialize(*args)
            drv = (
                driversetup.driver._lowlevel_driver
                if getattr(driversetup.driver, "_IsSimpleInstrument", False)
                else driversetup.driver
            )
            if hasattr(drv, "Identity"):
                for attr in ("Identifier", "Revision", "InstrumentFirmwareRevision"):
                    try:
                        self.Utils.LogInfo(f"    {attr}: {getattr(drv.Identity, attr)}")
                    except Exception:
                        self.Utils.LogWarning(f"    Cannot extract driver identity attribute '{attr}'!")
            else:
                self.Utils.LogWarning("    Identity interface not available!")
        except Exception as e:
            self.Utils.LogError(f"  Failed to connect to instrument {objname!r}: {e!s}")
            self.__connect_successful = False

    @DoE.Startup(is_hook_wrapper=True, try_first=True)
    def connect_instruments(self):
        try:
            if self.Instruments is None:
                self.load_instrument_setup(setup=None)

            self.HookCaller.execute_hooks("DoE.Lab.PreInstrConnect")

            self.Utils.LogInfo("Connecting to all instruments...")
            for driver_setup_class in self.Instruments.__dict__.values():
                if hasattr(driver_setup_class, "driver"):
                    self.__initialize_instrument(driver_setup_class)
            if not self.__connect_successful:
                msg = "Not all instruments could be connected!"
                raise InstrumentConnectionError(msg)
            self.Utils.LogInfo("Connecting successful")

            self.HookCaller.execute_hooks("DoE.Lab.PostInstrConnect")

            yield

        except Exception as e:
            self.__Instruments = None
            self.__InstrumentHandler = None
            self.Utils.LogError(traceback.format_exc())
            msg = "Error when loading instrument drivers!"
            raise Exception(msg) from e

    @DoE.Error(is_hook_wrapper=True, try_last=True)
    @DoE.Teardown(is_hook_wrapper=True, try_last=True)
    def disconnect_instruments(self):
        yield
        try:
            if self.__InstrumentHandler is not None:
                for s in self.HookCaller.execute_hooks("DoE.Lab.PreInstrDisconnect"):
                    self.Utils.SetBreakPoint(s)

                self.Utils.LogInfo("Disconnecting all instruments...")
                for _drivername, driversetup in self.Instruments.__dict__.items():
                    if hasattr(driversetup, "driver"):
                        objname = str(driversetup.driver).split("object at")[0].strip() + ">'"
                        try:
                            self.Utils.LogInfo(
                                f"  Releasing instrument '{objname}' at visa address '{driversetup.visa_address}'."
                            )
                            driversetup.driver.Close()
                        except Exception as e:
                            self.Utils.LogError(f"  Failed to disconnect from instrument {objname!r}: {e!s}")

                for s in self.HookCaller.execute_hooks("DoE.Lab.PostInstrDisconnect"):
                    self.Utils.SetBreakPoint(s)
        except Exception:
            self.Utils.LogError("Error when releasing instruments:" + traceback.format_exc())

    @property
    def Instruments(self):
        if self.Attributes.ExecutionMode != Enums.ExecutionMode.Lab:
            msg = "Access to lab instruments only allowed in execution mode 'LAB'"
            raise Exception(msg)
        if isinstance(self.__Instruments, type):
            self.__Instruments = self.__Instruments()
        return self.__Instruments

    @property
    def RealInstruments(self):
        return self.Instruments
