from __future__ import annotations

import logging
from abc import ABCMeta, abstractmethod
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pverify.core.internals.specification import SpecificationResult


class ResultHandler(metaclass=ABCMeta):
    def __init__(self, **kwargs):
        self.name = self.__class__.__name__
        self._config = {}

        class LoggingAdapter(logging.LoggerAdapter):
            def process(self, msg, kwargs):
                return f"{self.extra.get('prefix', '')}{msg}", kwargs

        self._log = LoggingAdapter(
            logging.getLogger("PyVerify_TestLogger"),
            {"prefix": f"{self.__class__.__name__}: "},
        )

    @property
    def config(self):
        return self._config

    @property
    def enabled(self):
        return bool(self.config.get("enabled", False))

    @property
    def resultdir(self):
        return Path(self.config.get("resultdir", ""))

    def initialize(self):  # noqa: B027
        ...

    @abstractmethod
    def update_file_metadata(self, key: str, value: Any):
        pass

    @abstractmethod
    def add_static_string_data(self, key: str, string_data: str):
        pass

    @abstractmethod
    def new_iteration(self, index: int):
        """
        Starts a new iteration
        """

    @abstractmethod
    def update_iteration_metadata(self, key: str, value: Any, unit: str = ""):
        pass

    @abstractmethod
    def update_iteration_parameter(self, key: str, value: Any, unit: str = ""):
        pass

    @abstractmethod
    def update_iteration_result(self, key: str, value: Any, unit: str = "", meta_data: dict[str, Any] | None = None):
        pass

    @abstractmethod
    def update_iteration_result_metadata(self, result_name: str, key: str, value: Any):
        pass

    @abstractmethod
    def add_iteration_spec_eval_result(
        self,
        result: SpecificationResult,
    ):
        pass

    @abstractmethod
    def commit_iteration(self):
        """
        Marks the iteration as complete for further processing
        """

    @abstractmethod
    def commit_file(self) -> Path:
        """
        Marks the file as complete for further processing
        """


class ConversionHandler(metaclass=ABCMeta):
    def __init__(self, enabled_for: list[str], **kwargs):
        """

        :param enabled_for: A list of handler names this conversion handler is enabled for
        """
        self.name = self.__class__.__name__
        self._config = {}
        self.enabled_for = enabled_for

        class LoggingAdapter(logging.LoggerAdapter):
            def process(self, msg, kwargs):
                return f"{self.extra.get('prefix', '')}{msg}", kwargs

        self.log = LoggingAdapter(
            logging.getLogger("PyVerify_TestLogger"),
            {"prefix": f"{self.__class__.__name__}: "},
        )

    @property
    def config(self):
        return self._config

    @property
    def enabled(self):
        return bool(self.config.get("enabled", False))

    @property
    def resultdir(self):
        return Path(self.config.get("resultdir", ""))

    def initialize(self):  # noqa: B027
        pass

    @abstractmethod
    def convert(self, file: Path) -> Path:
        """
        Marks the file as complete for further processing
        """
