from __future__ import annotations

import copy
import importlib
import json
from collections import defaultdict
from numbers import Number
from pathlib import Path
from time import perf_counter
from typing import *

from pverify.core.internals.logging_util import get_test_logger
from pverify.core.internals.specification import SpecificationResult
from pverify.core.util.json_encoder import CustomJSONEncoder

from .result_handler import ConversionHandler, ResultHandler
from .util import check_str_type


class ResultGateway:
    """
    The result gateway is a generic interface for the test to store results.
    It will load existing result handlers from the handlers subpackage automatically
    and proxy the storage requests to all loaded handlers.
    This concept enables easy and fast support of new data formats.
    """

    def __init__(self):
        self._log = get_test_logger(prefix=f"{self.__class__.__name__}: ")
        self._handlers: Dict[str, Union[ResultHandler, ConversionHandler]] = {}
        self._handler_statistics: Dict[str, Any] = defaultdict(lambda: 0)

    def _to_serializeable(self):
        return self._handlers

    def update_handler_config(self, name: Optional[str], **kwargs):
        """
        Configures the initialization arguments for a specific handler.

        :param name: The name of the handler to configure. If None all loaded handlers geht this configuration
        :keyword enabled: Set to True to enable the handler
        :keyword resultdir: The base directory where the handler shall store its output
        :param kwargs: The keyword arguments that will be passed to the handler constructor
        """
        if name is None:
            for handler in self._handlers.values():
                handler.config.update(kwargs)
        else:
            self._handlers[name].config.update(kwargs)

    def get_handler_config(self, name: str) -> Dict[str, Any]:
        """
        Configures the initialization arguments for a specific handler.

        :param name: The name of the handler to configure. If None all loaded handlers get this configuration
        """
        return self._handlers[name].config

    def load_handlers(self):
        """
        Loads all handlers which are placed in the handlers subdirectory.
        Only handlers are found whose module ends with "_handler" and contain an eponymous class.
        This class must inherit the abstract base class ResultHandler.
        """
        available_handlers = list(Path(__file__).parent.glob("handlers/*_handler.py"))
        this_package = self.__module__.rsplit(".", 1)[0]
        self._handlers.clear()
        for handler_path in available_handlers:
            handler_name = handler_path.stem
            try:
                module = importlib.import_module(f".handlers.{handler_name}", this_package)
                handler_cls = getattr(module, handler_name)
                is_result_handler = issubclass(handler_cls, ResultHandler)
                is_conversion_handler = issubclass(handler_cls, ConversionHandler)
                if not is_result_handler and not is_conversion_handler:
                    msg = "Discovered handler does not implement a ResultHandler or ConversionHandler interface!"
                    raise TypeError(msg)
                handler = handler_cls()
                if is_result_handler:
                    self._log.info(f"Loaded result handler {handler_name} ")
                elif is_conversion_handler:
                    self._log.info(f"Loaded conversion handler {handler_name} ")
                self._handlers[handler_name] = handler
            except Exception as e:
                self._log.error(f"Failed to load handler {handler_name} from module {handler_path}: {e}", exc_info=True)

    def get_result_handlers(self):
        return [h for h in self._handlers.values() if isinstance(h, ResultHandler)]

    def get_conversion_handlers(self):
        return [h for h in self._handlers.values() if isinstance(h, ConversionHandler)]

    def initialize_handlers(self):
        """
        Initializes all loaded handlers
        """
        for handler in self.get_conversion_handlers():
            if handler.enabled:
                for hname in handler.enabled_for:
                    # Enable dependent handlers
                    self.update_handler_config(hname, enabled=True)
                handler.initialize()

        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.initialize()
                self._handler_statistics[handler.name] += perf_counter() - ts

    def update_file_metadata(self, key: str, value: Any):
        """
        Will add global metadata to the generated result formats (if metadata are supported)

        :param key: The metadata name
        :param value: The metadata value. Must be JSON serializable!
        """
        check_str_type(key)
        self._log.info(f"Add metadata:  {key} = {value}")
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.update_file_metadata(key, value)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def add_static_data(self, key: str, obj: Any, **kwargs):
        """
        Add a global string dataset to the generated result formats (if supported)

        :param key: The name of the dataset
        :param obj: The object to store. Must be JSON-serializable
        :param kwargs: Keyword args to be passed to json.dumps(...) method.
        """
        check_str_type(key)
        jsonized = json.dumps(obj, **kwargs, cls=CustomJSONEncoder)
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.add_static_string_data(key, jsonized)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def new_iteration(self, index):
        """
        Proxy method that will call the respective method for all loaded handler instances
        """
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.new_iteration(index)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def update_iteration_metadata(self, key: str, value: Any, unit: str = ""):
        """
        Updates metadata of the current iteration.

        :param key: The metadata name
        :param value: The metadata. Must be JSON serializable!
        :param unit: A potential unit for the metadata.
        """
        check_str_type(key)
        check_str_type(unit)
        self._log.debug(f"Add iteration metadata:  {key} = {value}")
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.update_iteration_metadata(key, value, unit)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def update_iteration_parameter(self, key: str, value: Union[Number, str], unit: str = ""):
        """
        Proxy method that will call the respective method for all loaded handler instances
        """
        check_str_type(key)
        check_str_type(unit)
        if not isinstance(value, (str, Number)):
            msg = f"Parameter {key!r} mus tbe of numeric or string type!"
            raise TypeError(msg)
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.update_iteration_parameter(key, value, unit)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def update_iteration_result(self, key: str, value: Any, unit: str = "", meta_data: Dict[str, Any] = None):
        """
        Updates iteration result data of the current iteration.

        Note: Any results defined as test outputs will overwrite manually added results using this function,
        if argument "key" has the same name as an output!

        :param key: The iteration result name
        :param value: The result to store. May be a number, string, numpy array, Waveform.
        :param unit: A potential unit for the result
        :param meta_data: Additional metadata for the result
        """
        check_str_type(key)
        check_str_type(unit)
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.update_iteration_result(key, value, unit, copy.deepcopy(meta_data))
                self._handler_statistics[handler.name] += perf_counter() - ts

    def update_iteration_result_metadata(self, result_name: str, key: str, value: Any):
        """
        Updates metadata of an existing iteration result.

        :param result_name: The name of the result
        :param key: The metadata name
        :param value: The metadata to update. Must be JSON serializable!
        """
        check_str_type(result_name)
        check_str_type(key)
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.update_iteration_result_metadata(result_name, key, value)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def add_iteration_spec_eval_result(self, result: SpecificationResult):
        """
        Proxy method that will call the respective method for all loaded handler instances
        """
        if not isinstance(result, SpecificationResult):
            msg = "Argument 'result' has to be of type 'Limit.IterationSpecResult'!"
            raise TypeError(msg)
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.add_iteration_spec_eval_result(result)
                self._handler_statistics[handler.name] += perf_counter() - ts

    def commit_iteration(self):
        """
        Proxy method that will call the respective method for all loaded handler instances
        """
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                handler.commit_iteration()
                self._handler_statistics[handler.name] += perf_counter() - ts

    def commit_file(self):
        """
        Proxy method that will call the respective method for all loaded handler instances
        """
        for handler in self.get_result_handlers():
            if handler.enabled:
                ts = perf_counter()
                file = handler.commit_file()
                self._handler_statistics[handler.name] += perf_counter() - ts

                if isinstance(file, Path) and file.exists():
                    for conv_handler in self.get_conversion_handlers():
                        if conv_handler.enabled and handler.name in conv_handler.enabled_for:
                            try:
                                ts = perf_counter()
                                conv_handler.convert(file)
                                self._handler_statistics[conv_handler.name] += perf_counter() - ts
                            except Exception as e:
                                self._log.error(
                                    f"Converting file {file} with conversion "
                                    f"handler {conv_handler.name!r} failed: {e}",
                                    exc_info=True,
                                )

        self._log.debug("Result/Conversion handler statistics:")
        for handler in self._handlers.values():
            if handler.enabled:
                self._log.debug(f"   Total runtime of {handler.name!r}: {self._handler_statistics[handler.name]:.3f}s")
