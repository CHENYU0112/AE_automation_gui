from __future__ import annotations

import copy
import os
import re
from collections.abc import Iterable
from getpass import getuser
from numbers import Number
from operator import itemgetter
from os.path import abspath, basename, dirname, exists, join, relpath
from pathlib import Path
from typing import Any

import arrow
import numpy as np
from h5py import ExternalLink, Group
from h5py import File as h5pyFILE

from pverify.core.internals.outputs import Output as TestOutput
from pverify.core.internals.parameters import check_condition_fulfilled
from pverify.core.internals.unit import ScalarUnit
from pverify.postproc.waveform import Waveform

from .result_storage.util import is_array_type, is_number_type, is_string_type, is_waveform_type

H5None = np.bytes_("none")


def npstr(string):
    if isinstance(string, str):
        # return str(string).encode("utf-8")
        return np.bytes_(str(string).encode("utf-8"))
    if isinstance(string, bytes):
        return np.bytes_(string)
    if string is None:
        return H5None
    raise TypeError


def decode(bytestr):
    if isinstance(bytestr, (np.bytes_, bytes)):
        if bytestr == H5None:
            return None
        return bytestr.decode("utf-8")
    if isinstance(bytestr, str):
        if bytestr == H5None.decode("utf-8"):
            return None
        return bytestr
    raise TypeError


class H5_Result:
    VERSION = "2.0"

    def __init__(self, file: h5pyFILE | (str | Path), mode: str = "r"):
        if isinstance(file, (Path, str)):
            self.__filepath = str(file)
            if not exists(dirname(file)):
                os.makedirs(dirname(file))
            self.__fh = h5pyFILE(file, mode)
        elif isinstance(file, h5pyFILE):
            self.__fh = file
        else:
            msg = f"Unsupported file type {type(file)}"
            raise TypeError(msg)

        if "version" not in self.fh.attrs:
            self.set_attr_str("version", H5_Result.VERSION)
        if mode is not None and "r" not in mode.lower():
            self.set_attr_str("modified", str(arrow.now()))
            self.set_attr_str("creator", getuser())

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if isinstance(self.fh, h5pyFILE):
            self.fh.close()

    @property
    def fh(self):
        return self.__fh

    @property
    def filepath(self):
        if self.__fh is not None:
            return abspath(self.fh.filename)
        return ""

    def closefh(self):
        if isinstance(self.fh, h5pyFILE):
            self.fh.close()

    def set_attr_str(self, name, value):
        if self.fh.mode == "r+":
            self.fh.attrs[name] = npstr(str(value))

    def get_attr_str(self, name):
        if name in self.fh.attrs:
            return decode(self.fh.attrs[name])
        return None

    @staticmethod
    def open_generic(filepath: str, mode="r"):
        """

        :rtype: H5_TestResult | H5_VariationResult
        """
        if not exists(filepath):
            msg = f"Cannot find file '{filepath}'"
            raise FileNotFoundError(msg)
        with h5pyFILE(filepath, mode=mode) as f:
            if "Variation" in f:
                cls = H5_VariationResult
            elif "Test" in f:
                cls = H5_TestResult
            else:
                msg = f"Unknown HDF5 file structure of file '{filepath}'!"
                raise Exception(msg)
        return cls(filepath, mode=mode)


class Input:
    def __init__(self, name: str, unit: str, desc: str, dtype: str, data: str | (int | float)):
        self.name = name
        self.unit = unit
        self.desc = desc
        self.dtype = dtype
        self.data = data

    def __str__(self):
        return f"Input '{self.name}'"

    @staticmethod
    def create(name: str, unit: str, desc: str, data: str | (int | float)):
        if isinstance(data, (str, bytes)):
            data = decode(data)
            dtype = "string"
        elif isinstance(data, (int, np.integer)):
            data = int(data)
            dtype = "number"
        elif isinstance(data, (float, np.floating, Number)):
            data = float(data)
            dtype = "number"
        else:
            msg = "Unsupported type of dataset 'data'"
            raise TypeError(msg)
        return Input(name, unit, desc, dtype, data)

    @staticmethod
    def from_h5_group(group: Group):
        cfg = dict(group.attrs)
        name = decode(cfg["Name"])
        unit = decode(cfg["Unit"])
        desc = decode(cfg["Description"])
        dtype = decode(cfg["dtype"])

        d = group.get("data")[()]
        if isinstance(d, (str, bytes)):
            data = decode(d)
        elif isinstance(d, (int, np.integer)):
            data = int(d)
        elif isinstance(d, (float, np.floating, Number)):
            data = float(d)
        else:
            msg = f"Unsupported type of dataset 'data' of input group '{group}'"
            raise TypeError(msg)

        return Input(name, unit, desc, dtype, data)


class Output:
    def __init__(
        self,
        name: str,
        unit: str,
        desc: str,
        pfinfo: str,
        limitinfo: str,
        dtype: str,
        data=None,
    ):
        self.name = name
        self.unit = unit
        self.desc = desc
        self.pfinfo = pfinfo if data is not None else None
        if data is None and dtype is None:
            # Try to restore the dtype from the unit. Does not support string-typed outputs
            if ScalarUnit.is_waveform_unit(unit):
                self.dtype = TestOutput.OutputType.Waveform
            elif ScalarUnit.is_string_unit(unit):
                self.dtype = TestOutput.OutputType.String
            elif ScalarUnit.is_array_unit(unit):
                self.dtype = TestOutput.OutputType.Array
            elif ScalarUnit.is_valid_unit(unit):
                self.dtype = TestOutput.OutputType.Scalar
            else:
                msg = f"Unknown type of {data}!"
                raise TypeError(msg)
        elif data is not None and dtype is None:
            if is_string_type(data):
                data = decode(data)
                self.dtype = TestOutput.OutputType.String
            elif is_number_type(data):
                self.dtype = TestOutput.OutputType.Scalar
                if isinstance(data, (int, np.integer)):
                    data = int(data)
                elif isinstance(data, (float, np.floating, Number)):
                    data = float(data)
                else:
                    data = float(data)
            elif is_waveform_type(data):
                self.dtype = TestOutput.OutputType.Waveform
        else:
            self.dtype = dtype

        self.data = data
        self.limitinfo = limitinfo if data is not None else None

    def __str__(self):
        return f"Output '{self.name}'"

    @staticmethod
    def from_h5_group(group: Group):
        cfg = dict(group.attrs)
        name = decode(cfg["Name"])
        unit = decode(cfg["Unit"])
        desc = decode(cfg["Description"])

        pfinfo = decode(cfg["PassFail"])
        dtype = decode(cfg["dtype"])
        limitinfo = decode(cfg.get("LimitInfo", H5None))

        if dtype is None or "data" not in group:
            data = None
            dtype = None

        elif dtype == TestOutput.OutputType.Waveform:
            if "time" not in group:
                data = None
            else:
                d = group.get("data")[()]
                time = group.get("time")[()]
                if len(time) == 2:  # Shortened form for equidistant vector
                    data = Waveform(data=d, time=np.linspace(time[0], time[-1], len(d)))
                elif len(time) == len(d):
                    data = Waveform(data=d, time=time)
                else:
                    raise Exception(
                        "Waveforms time vector may only have 2 points (as start/stop value) or as many "
                        "points as the data vector. "
                        "len(time): %d, len(data): %d" % (len(time), len(d))
                    )
                data._name = group.attrs["waveform_name"].decode()

                if data.data.dtype == np.dtype(complex).type:
                    data.type = Waveform.TYPES.FFT

        elif dtype == TestOutput.OutputType.String:
            data = decode(group.get("data")[()])

        elif dtype == TestOutput.OutputType.Array:
            data = group.get("data")[()]

        elif dtype in [
            TestOutput.OutputType.Scalar,
            "number",
        ]:  # "number" deprecated, kept for backw. comp
            val = group.get("data")[()]

            if isinstance(val, (int, np.integer)):
                data = int(val)
            elif isinstance(val, (float, np.floating, Number)):
                data = float(val)
            else:
                data = val
        else:
            msg = f"Unsupported dtype '{dtype}'"
            raise Exception(msg)

        return Output(name, unit, desc, pfinfo, limitinfo, dtype, data)


class H5_TestResult(H5_Result):
    def __init__(self, filepath: h5pyFILE | (str | Path), mode: str = "r"):
        super().__init__(filepath, mode)

        self.__variationtable = []

    def __str__(self):
        return f"H5_TestResult <{self.filepath}>"

    @staticmethod
    def from_file(filepath: str | Path):
        """
        Creates an H5_VariationResultReader instance by reading an HDF5 file
        """
        if not exists(filepath):
            msg = f"Cannot find file '{filepath}'"
            raise FileNotFoundError(msg)
        return H5_TestResult(filepath)

    @property
    def root_variations(self):
        """
        Returns a pointer to the Variations HDF5 group
        """
        return self.fh.require_group("Test").require_group("Variations")

    def get_variation(self, variation: int | str):
        """
        Returns an H5_VariationResultReader instance for the selected variation.

        :param variation: A variation name (e.g. run0001) or variation number (e.g. 0)
        """
        if isinstance(variation, int):
            varname = f"run{variation:04d}"
        elif isinstance(variation, str):
            varname = variation
        else:
            msg = "Unsupported type of argument 'variation'"
            raise TypeError(msg)

        if varname in self.root_variations:
            return H5_VariationResult.from_parent(self.root_variations[varname].file, self)
        msg = f"No variation called '{varname}'"
        raise LookupError(msg)

    @property
    def variation_count(self) -> int:
        """
        The number of variations
        """
        return len(self.root_variations.keys())

    @property
    def variation_names(self) -> list[str]:
        """
        A list of variation names
        """
        return sorted(self.root_variations.keys())

    @property
    def variation_table(self) -> list[dict[str, str | (int | float)]]:
        """
        Restores and returns the variation table as a list of dictionaries with parameter name - parameter value pairs.
        """
        if not len(self.__variationtable):
            self.restore_parameter_variation_table()
        return self.__variationtable

    def restore_parameter_variation_table(self):
        """
        Restores the variation table.
        This method is called by property "variation_table" if the table is not yet restored
        """
        table = []  # type: List[Dict[str, Any]]
        for vname in self.variation_names:
            h5v = self.get_variation(vname)
            table.append({inp.name: inp.data for inp in h5v.get_inputs(h5v.input_names)})

        if not len(table):
            msg = "No variations included!"
            raise Exception(msg)

        # Check consitency
        inames = set(table[0].keys())
        for entry in table:
            if inames != set(entry.keys()):
                msg = (
                    f"At least one entry in the variation table contains different parameter names than the others! "
                    f"{inames} != {set(entry.keys())}"
                )
                raise Exception(msg)
        self.__variationtable = table

    def filter_variations(self, variationfilter: str | (int | list[int]) = "") -> list[str]:
        """
        Returns a list of variation names where the variation filter applies.

        :param variationfilter: An expression-string that define the variation parameter conditions.\n
                                E.g. "(ParamA==5)||(ParamB<5)&&(ParamC==0)"\n
                                E.g. "(ParamA==5)or(ParamB<5)and(ParamC==0)"

                                Or an integer/list of integers of variation numbers.
        """

        runnames = []
        if isinstance(variationfilter, str):
            for varname, var in zip(self.variation_names, self.variation_table):
                if not variationfilter or check_condition_fulfilled(var, variationfilter):
                    runnames.append(varname)
        elif isinstance(variationfilter, int):
            runnames.append(f"run{variationfilter:04d}")
        elif isinstance(variationfilter, Iterable) and all(isinstance(x, int) for x in variationfilter):
            runnames = sorted([f"run{i:04d}" for i in variationfilter])
        elif variationfilter is None:
            runnames = self.variation_names
        else:
            msg = "Argument 'variationfilter' must be of type str|int|list[int]!"
            raise TypeError(msg)

        return runnames

    def find_variation_results(
        self,
        outputs: str | (Iterable[str] | None),
        variationfilter: str | (int | list[int]) = "",
        transposed: bool = False,
        attr: str = "data",
    ) -> tuple[
        list[dict[str, str | (int | float)]] | dict[str, list[str | (int | float)]],
        list[dict[str, Any]] | dict[str, list[Any]],
    ]:
        """
        Returns output data for variations where the variation filter applies.

        :param outputs: The output for which to retrieve data. A string, list of strings or None (all outputs)
        :param variationfilter: An expression-string that define the variation parameter conditions.\n
                                E.g. "(ParamA==5)||(ParamB<5)&&(ParamC==0)"\n
                                E.g. "(ParamA==5)or(ParamB<5)and(ParamC==0)"

                                Or an integer/list of integers of variation numbers.
        :param transposed: If False, the inputs are returned as dicts of inputname-'list of inputvalues' pairs and
                           the outputs are returned as dicts of outputname-'list of outputvalues' pairs.

                           If True, the inputs are returned as lists of dicts of inputname-inputvalue pairs and
                           the outputs are returned as lists of dicts of outputname-outputvalue pairs.
        :param attr: The name of the attribute to extract. Allowed values: data, desc, unit, pfinfo, limitinfo, dtype
        """
        vnames = self.filter_variations(variationfilter)
        if not len(vnames):
            msg = "Variation filter returned empty list!"
            raise Exception(msg)

        input_data = []
        output_data = []

        for varname, var in zip(self.variation_names, self.variation_table):
            if varname in vnames:
                input_data.append(var)

        for vname in vnames:
            h5v = self.get_variation(vname)
            if isinstance(outputs, str):
                output_data.append({outp.name: getattr(outp, attr) for outp in h5v.get_outputs([outputs])})
            elif isinstance(outputs, list) and all(isinstance(x, str) for x in outputs):
                output_data.append({outp.name: getattr(outp, attr) for outp in h5v.get_outputs(outputs)})
            else:
                output_data.append({outp.name: getattr(outp, attr) for outp in h5v.get_outputs(h5v.output_names)})

        # Check output consitency
        onames = set(output_data[0].keys())
        for entry in output_data:
            if onames != set(entry.keys()):
                msg = (
                    f"At least one entry in the restored output table contains different "
                    f"output names than the others! {onames} != {set(entry.keys())}"
                )
                raise Exception(msg)

        if transposed:
            return input_data, output_data
        input_data_tr = {name: list(map(itemgetter(name), input_data)) for name in input_data[0]}
        output_data_tr = {name: list(map(itemgetter(name), output_data)) for name in output_data[0]}
        return input_data_tr, output_data_tr

    def extlink_variationresult(
        self,
        filepath: str | Path,
        name: str | None = None,
        overwrite: bool = True,
        relative: bool = True,
    ):
        """
        Links a variation result file to the test result file.
        The "Variation" group of the variation result file will be linked to the "Variations/run...."
        group of the test result file

        :param filepath: The filename of the file to link
        :param name: If given the the link target will be "Variations/<name>", otherwise the name is taken from
                     the directory name of the variation result file
        :param overwrite: If True and the group already exists, it will be deleted and recreated
        :param relative: If True, the file
        """
        filepath = abspath(filepath)
        if name is None:
            h5var = H5_VariationResult.from_file(filepath)
            name = h5var.name
            h5var.closefh()
        if name in self.root_variations and overwrite:
            del self.root_variations[name]
        if name not in self.root_variations:
            if relative:
                mydir = dirname(abspath(self.filepath))
                filepath = relpath(filepath, mydir)
            self.root_variations[name] = ExternalLink(filename=filepath, path="Variation")
        return self.get_variation(name)


class H5_VariationResult(H5_Result):
    def __init__(self, file: h5pyFILE | str, parent: H5_TestResult = None, mode: str = "r"):
        super().__init__(file, mode)
        self.__parent = parent

    def __str__(self):
        return f"H5_VariationResult '{self.name}' <{self.filepath}>"

    @staticmethod
    def from_file(filepath: str | Path):
        """
        Creates an H5_VariationResultReader instance by reading an HDF5 file
        """
        if not exists(filepath):
            msg = f"Cannot find file '{filepath}'"
            raise FileNotFoundError(msg)
        return H5_VariationResult(filepath)

    @staticmethod
    def from_parent(file: h5pyFILE, parent):
        """
        Use by H5_TestResultReader.get_variation to create an H5_VariationResultReader instance
        """
        return H5_VariationResult(file, parent)

    @property
    def parent(self):
        """
        If the instance of this class was created by an H5_TestResultReader instance, this property points to the
        H5_TestResultReader instance
        """
        if isinstance(self.__parent, H5_TestResult):
            return self.__parent
        parent_file = abspath(join(self.filepath, "..", "..", "results.hdf5"))
        if exists(parent_file):
            return H5_TestResult.from_file(parent_file)
        return None

    @property
    def root(self):
        """
        Returns a pointer to the Variation HDF5 group
        """
        return self.fh.require_group("Variation")

    @property
    def root_inputs(self):
        """
        Returns a pointer to the Variation/Inputs HDF5 group
        """
        return self.root.require_group("Inputs")

    @property
    def root_outputs(self):
        """
        Returns a pointer to the Variation/Outputs HDF5 group
        """
        return self.root.require_group("Outputs")

    @property
    def name(self):
        """
        The variation name (based on the directory name of the containing hdf5 file), e.g. run0001
        """
        return basename(dirname(self.filepath))

    @property
    def index(self):
        """
        The variation index (extracted from the 'name' property)
        """
        return int(basename(dirname(self.filepath))[3:])

    @property
    def input_count(self) -> int:
        """
        The number of parameters
        """
        return len(self.root_inputs.keys())

    @property
    def input_names(self):
        """
        A list of contained parameter names
        """
        return list(self.root_inputs.keys())

    @property
    def output_count(self) -> int:
        """
        The number of outputs
        """
        return len(self.root_outputs.keys())

    @property
    def output_names(self):
        """
        A list of contained output names
        """
        return list(self.root_outputs.keys())

    def get_input(self, inputname: str) -> Input:
        """
        Returns information about an input/parameter of the current variation data
        """
        return Input.from_h5_group(self.root_inputs[inputname])

    def get_inputs(self, inputnames: Iterable[str]) -> list[Input]:
        """
        Returns information about multiple inputs/parameters of the current variation data
        """
        return [Input.from_h5_group(self.root_inputs[i]) for i in inputnames]

    def get_output(self, outputname: str) -> Output:
        """
        Returns information about an output of the current variation data
        """
        return Output.from_h5_group(self.root_outputs[outputname])

    def get_outputs(self, outputnames: Iterable[str]) -> list[Output]:
        """
        Returns information about multiple outputs of the current variation data
        """
        return [Output.from_h5_group(self.root_outputs[o]) for o in outputnames]

    def update_input(self, input: Input, overwrite=True):
        if overwrite and input.name in self.root_inputs:
            del self.root_inputs[input.name]
        igrp = self.root_inputs.create_group(input.name)

        igrp.attrs["Name"] = npstr(input.name)
        igrp.attrs["Unit"] = npstr(input.unit)
        igrp.attrs["Description"] = npstr(input.desc)

        if isinstance(input.data, (str, bytes)):
            igrp.attrs["dtype"] = npstr("string")
            igrp.create_dataset("data", data=npstr(input.data))
        elif isinstance(input.data, Number):
            igrp.attrs["dtype"] = npstr("number")
            igrp.create_dataset("data", data=input.data)

    def update_output(self, output: Output, overwrite=True):
        if overwrite and output.name in self.root_outputs:
            del self.root_outputs[output.name]
        ogrp = self.root_outputs.create_group(output.name)

        ogrp.attrs["Name"] = npstr(output.name)
        ogrp.attrs["Unit"] = npstr(output.unit)
        ogrp.attrs["Description"] = npstr(output.desc)

        ogrp.attrs["PassFail"] = npstr(output.pfinfo)
        ogrp.attrs["LimitInfo"] = npstr(output.limitinfo)

        if is_string_type(output.data):
            ogrp.attrs["dtype"] = npstr(TestOutput.OutputType.String)
            ogrp.create_dataset("data", data=npstr(output.data))
        elif is_array_type(output.data):
            ogrp.attrs["dtype"] = npstr(TestOutput.OutputType.Array)
            ogrp.create_dataset("data", data=output.data)
        elif is_number_type(output.data):
            ogrp.attrs["dtype"] = npstr(TestOutput.OutputType.Scalar)
            ogrp.create_dataset("data", data=output.data)
        elif is_waveform_type(output.data):
            ogrp.attrs["dtype"] = npstr(TestOutput.OutputType.Waveform)
            name = output.data._name

            if re.match(".*_var[0-9]{4,}.*", output.data._name) is None:
                name += "_var%04d" % self.index
            ogrp.attrs["waveform_name"] = npstr(name)
            if output.data.samplerate == 0:
                ogrp.create_dataset("time", data=output.data.time)
            else:
                if len(output.data) >= 2:
                    ogrp.create_dataset("time", data=output.data.time[[0, -1]])
                else:
                    ogrp.create_dataset("time", data=output.data.time[0])
            ogrp.create_dataset("data", data=output.data.data, compression="gzip")
        else:
            ogrp.attrs["dtype"] = H5None
            ogrp.attrs["PassFail"] = H5None

    def restore_variation_results(
        self,
        outputs: str | (Iterable[str] | None),
        transposed: bool = False,
        attr: str = "data",
    ) -> tuple[
        list[dict[str, str | (int | float)]] | dict[str, list[str | (int | float)]],
        list[dict[str, Any]] | dict[str, list[Any]],
    ]:
        """
        Returns output data for variations where the variation filter applies.

        :param outputs: The output for which to retrieve data. A string, list of strings or None (all outputs)

                                Or an integer/list of integers of variation numbers.
        :param transposed: If False, the inputs are returned as dicts of inputname-'list of inputvalues' pairs and
                           the outputs are returned as dicts of outputname-'list of outputvalues' pairs.

                           If True, the inputs are returned as lists of dicts of inputname-inputvalue pairs and
                           the outputs are returned as lists of dicts of outputname-outputvalue pairs.
        :param attr: The name of the attribute to extract. Allowed values: data, desc, unit, pfinfo, limitinfo, dtype
        """
        input_data = []
        output_data = []

        input_data.append({inp.name: inp.data for inp in self.get_inputs(self.input_names)})

        if isinstance(outputs, str) or isinstance(outputs, list) and all(isinstance(x, str) for x in outputs):
            output_data.append({outp.name: getattr(outp, attr) for outp in self.get_outputs([outputs])})
        else:
            output_data.append({outp.name: getattr(outp, attr) for outp in self.get_outputs(self.output_names)})

        # Check output consitency
        onames = set(output_data[0].keys())
        for entry in output_data:
            if onames != set(entry.keys()):
                msg = (
                    f"At least one entry in the restored output table contains different output names than "
                    f"the others! {onames} != {set(entry.keys())}"
                )
                raise Exception(msg)

        if transposed:
            return copy.deepcopy(input_data), copy.deepcopy(output_data)

        input_data_tr = {name: list(map(itemgetter(name), input_data)) for name in input_data[0]}
        output_data_tr = {name: list(map(itemgetter(name), output_data)) for name in output_data[0]}
        return copy.deepcopy(input_data_tr), copy.deepcopy(output_data_tr)
