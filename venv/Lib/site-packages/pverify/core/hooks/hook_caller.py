from __future__ import annotations

import contextlib
import inspect
import sys
from types import FunctionType, MethodType
from typing import Any, Callable

from pverify.core.internals.logging_util import get_test_logger

from . import inspect_py311  # backport inspect for Python < 3.11 - inspect.getattr_static added in Python 3.11
from .hook_decorator import HookDecorator


# vendored from from pluggy._hooks import varnames
def varnames(func: object) -> tuple[tuple[str, ...], tuple[str, ...]]:
    """Return tuple of positional and keywrord argument names for a function,
    method, class or callable.

    In case of a class, its ``__init__`` method is considered.
    For methods the ``self`` parameter is not included.
    """
    if inspect.isclass(func):
        try:
            func = func.__init__
        except AttributeError:
            return (), ()
    elif not inspect.isroutine(func):  # callable object?
        try:
            func = getattr(func, "__call__", func)  # noqa: B004
        except Exception:
            return (), ()

    try:
        # func MUST be a function or method here, or we won't parse any args.
        sig = inspect.signature(
            func.__func__ if inspect.ismethod(func) else func  # type:ignore[arg-type]
        )
    except TypeError:
        return (), ()

    _valid_param_kinds = (
        inspect.Parameter.POSITIONAL_ONLY,
        inspect.Parameter.POSITIONAL_OR_KEYWORD,
    )
    _valid_params = {name: param for name, param in sig.parameters.items() if param.kind in _valid_param_kinds}
    args = tuple(_valid_params)
    defaults = tuple(param.default for param in _valid_params.values() if param.default is not param.empty) or None

    if defaults:
        index = -len(defaults)
        args, kwargs = args[:index], tuple(args[index:])
    else:
        kwargs = ()

    # strip any implicit instance arg
    # pypy3 uses "obj" instead of "self" for default dunder methods
    if not hasattr(sys, "pypy_version_info"):  # PYPY
        implicit_names: tuple[str, ...] = ("self",)
    else:
        implicit_names = ("self", "obj")
    if args:
        qualname: str = getattr(func, "__qualname__", "")
        if inspect.ismethod(func) or ("." in qualname and args[0] in implicit_names):
            args = args[1:]

    return args, kwargs


class HookCallerError(Exception):
    pass


class HookNotFoundError(HookCallerError):
    pass


class NotAGeneratorFunctionError(HookCallerError):
    pass


class NoYieldError(HookCallerError):
    pass


class YieldTwiceError(HookCallerError):
    pass


class SignatureError(HookCallerError):
    pass


class _Result:
    def __init__(self, result, excinfo):
        self._result = result
        self._excinfo = excinfo

    @property
    def excinfo(self):
        return self._excinfo

    @classmethod
    def from_call(cls, func):
        __tracebackhide__ = True
        result = excinfo = None
        try:
            result = func()
        except BaseException:
            excinfo = sys.exc_info()

        return cls(result, excinfo)

    def force_result(self, result):
        """Force the result(s) to ``result``.

        If the hook was marked as a ``firstresult`` a single value should
        be set otherwise set a (modified) list of results. Any exceptions
        found during invocation will be deleted.
        """
        self._result = result
        self._excinfo = None

    def get_result(self):
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        """
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        ex = self._excinfo
        raise ex[1].with_traceback(ex[2])


class HookCaller:
    def __init__(
        self,
        obj,
        config: dict[str, Any] | None = None,
        bp: Callable | None = None,  # PyVerify breakpoint function
    ):
        """"""
        self._obj = obj

        self._log = get_test_logger()

        self._config = {
            "cb_pre_execute_hook": (),
            "cb_post_execute_hook": (),
        }
        if config is not None:
            self._config.update(config)

        self._bp = bp

    @staticmethod
    def sort_hooks(hooks: list[HookDecorator]) -> list[HookDecorator]:
        """
        Sorts a list of hook first by priority, then by the name of the wrapped function
        """
        return sorted(hooks, key=lambda obj: (obj.priority, obj.hook_name))

    def get_sorted_hooks(self, hookname: str, must_exist: bool = False) -> list[HookDecorator]:
        """
        Finds all PyVerify test hooks on an objects and returns them sorted by their priority

        :param hookname: The name of the hook
        :returns: A list of hooks wrappers
        """
        found_hooks: list[HookDecorator] = []
        anchorname = HookDecorator.get_anchor_name(hookname)

        function_members = inspect_py311.getmembers_static(self._obj, predicate=inspect_py311.isfunction)
        # getmembers_static only finds statically defined attributes, so we add deprecated items manually
        for name in (
            "Initialization",
            "PreLoop",
            "VariationLoop",
            "VariationLoopPostprocessing",
            "PostLoop",
            "OnError",
        ):
            with contextlib.suppress(AttributeError):
                function_members.append((name, getattr(self._obj, name)))

        for name, item in function_members:
            if hasattr(item, anchorname):
                hook = getattr(item, anchorname)
                if isinstance(item, FunctionType):
                    # inspect.getmembers_static will get us FunctionType. So to call them correctly on the class we
                    # have to convert them to a method
                    hook.func = MethodType(item, self._obj)
                elif isinstance(item, MethodType):
                    # Legacy methods, these are methods already
                    hook.func = item
                else:
                    msg = f"Unsupported type {type(item)} of member {name}!"
                    raise TypeError(msg)
                # This cannot be done in the decoration phase, since the function is not yet bound to an object
                found_hooks.append(hook)

        if not len(found_hooks) and must_exist:
            msg = f"Cannot find any {hookname} hooks in object {self._obj}"
            raise HookNotFoundError(msg)

        hooks_wrappers_normal = self.sort_hooks(
            [hook for hook in found_hooks if not (hook.try_first or hook.try_last) and hook.is_hook_wrapper]
        )
        hooks_wrappers_try_first = self.sort_hooks(
            [hook for hook in found_hooks if hook.try_first and hook.is_hook_wrapper]
        )
        hooks_wrappers_try_last = self.sort_hooks(
            [hook for hook in found_hooks if hook.try_last and hook.is_hook_wrapper]
        )
        hooks_normal = self.sort_hooks(
            [hook for hook in found_hooks if not (hook.try_first or hook.try_last or hook.is_hook_wrapper)]
        )
        hooks_try_first = self.sort_hooks([hook for hook in found_hooks if hook.try_first and not hook.is_hook_wrapper])
        hooks_try_last = self.sort_hooks([hook for hook in found_hooks if hook.try_last and not hook.is_hook_wrapper])

        return (
            hooks_wrappers_try_first
            + hooks_wrappers_normal
            + hooks_wrappers_try_last
            + hooks_try_first
            + hooks_normal
            + hooks_try_last
        )

    def execute_hooks(
        self,
        hookname: str,
        must_exist: bool = False,
        func_kwargs: dict | None = None,
        firstresult: bool = False,
        ignore_bp: bool = False,
    ):
        """
        Returns a generator that yields each time before executing a hook
        """
        __tracebackhide__ = True

        if func_kwargs is None:
            func_kwargs = {}

        teardowns = []
        hooks = self.get_sorted_hooks(hookname, must_exist)
        if len(hooks) >= 1:
            self._log.info(f"Executing all methods marked with hook {hooks[0].hook_name!r} ...")

        results = []
        excinfo = None

        # run impl and wrapper setup functions in a loop
        teardowns = []
        try:
            for hook in hooks:
                if callable(self._bp) and not ignore_bp:
                    self._bp(hook.to_str(False, True))

                if hook.is_hook_wrapper:
                    gen = self.execute_hook(
                        hook, **func_kwargs
                    )  # Call the generator function to create a generator instance
                    if gen is None:
                        msg = (
                            f"Cannot execute hookwrapper {hook.to_str(False, True)} "
                            f"because {hook.func.__name__} is not a generator function!"
                        )
                        raise NotAGeneratorFunctionError(msg)
                    try:
                        next(gen)  # Execute generator until first yield
                        teardowns.append(gen)  # Schedule the generator for teardown
                    except StopIteration:
                        msg = f"Generator {gen} wrapped by hook {hook.to_str(False, True)} did not yield!"
                        raise NoYieldError(msg) from None
                else:
                    res = self.execute_hook(hook, **func_kwargs)
                    if res is not None:
                        results.append(res)
                        if firstresult:  # halt further impl calls
                            break
        except BaseException:
            excinfo = sys.exc_info()

        if firstresult:  # first result hooks return a single value  # noqa: SIM108
            outcome = _Result(results[0] if results else None, excinfo)
        else:
            outcome = _Result(results, excinfo)

        if excinfo is None:
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                if callable(self._bp) and not ignore_bp:
                    try:
                        s = f"Teardown of hook function " f"'{gen.gi_frame.f_locals['self']!s}.{gen.gi_code.co_name}'"
                    except Exception:
                        s = None
                    self._bp(s)

                try:
                    next(gen)
                    msg = f"Generator {gen} did yield twice!"
                    raise YieldTwiceError(msg)
                except StopIteration:
                    pass

        return outcome.get_result()

    def execute_hook(self, hook: HookDecorator, **func_kwargs):
        """
        Executes a hooked function while passing arbitrary keyword arguments

        :param hook: The hook to execute
        :param func_kwargs: Keyword arguments passed to the executed function
        """
        __tracebackhide__ = True

        args, defaults = varnames(hook.func)
        new_kwargs = {
            k: v for k, v in func_kwargs.items() if k in args
        }  # Remove the kwargs that are not in the function signature
        if not hook.kwargs_optional and set(args) != set(func_kwargs.keys()):
            msg = (
                f"Trying to pass arguments '{', '.join(func_kwargs.keys())}' to "
                f"function '{hook.get_qual_func_name()}', but {'just ' + ', '.join(args) if len(args) else 'none'} "
                f"are defined in the function signature!"
            )
            raise SignatureError(msg)

        if not hook.silent:
            if not hook.enabled:
                self._log.info(f"{hook.to_str()} is disabled. Skipping!")
            if len(new_kwargs) and not hook.nolog_kwargs:
                self._log.info(f"Executing '{hook.get_qual_func_name()}' with arguments {new_kwargs}")
            else:
                self._log.info(f"Executing '{hook.get_qual_func_name()}'")

        catch_exception = hook.ignore_error
        if catch_exception is not None:
            try:
                return hook.func(**new_kwargs)
            except catch_exception as e:
                self._log.warning(f"Ignored {e.__class__.__name__}: {e}\n", exc_info=True)
        else:
            return hook.func(**new_kwargs)
