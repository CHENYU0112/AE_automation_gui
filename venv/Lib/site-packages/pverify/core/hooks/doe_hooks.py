from __future__ import annotations

from pverify.core.hooks.hook_decorator import HookDecorator
from pverify.core.lab.lab_hooks import LabDoE


class DoE:
    Lab = LabDoE

    class Init(HookDecorator):
        """
        Functions decorated with this hook will be executed after
        test instantiation but before the actual test execution.

        It is used to declare the tests parameters, outputs limits/specifications and potential reporting.
        """

        def __init__(self, **kwargs):
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)

    class Startup(HookDecorator):
        """
        Functions decorated with this hook will be executed once at test startup and usually contain code for instrument
        initialization and static configurations.
        """

        def __init__(self, **kwargs):
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)

    class Iteration(HookDecorator):
        """
        Functions decorated with this hook will be executed once for each parameter iteration and contain code
        to configure and measure something depending of the current iterations parameter values.

        All functions marked with this decorator will be called with the current iteration parameters passed as
        arguments, in case those parameters are defined as arguments in the signature of the function.
        Alternativly the current iterations parameters can be accessed via the **self.Current_variation** dictionary.

        .. code-block:: python

            @DoE.Init()
            def init(self):
                self.Parameters.Add("ParamA", "", "", 0)
                self.Parameters.Add("ParamB", "", "", 1)
                self.Parameters.Add("ParamC", "", "", 2)

            @DoE.Iteration()
            def my_iteration(self, paramB, paramA)
                # Only paramA and paramB are defined in the function signature so only those two test parameters
                # will be passed when calling this function
                print(paramA)
                print(paramB)

        """

        def __init__(self, **kwargs):
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)

    class IterationPostprocessing(HookDecorator):
        """
        Functions decorated with this hook will be executed once for each parameter iteration and contain code
        for postprocessing and analyzing measurement data. Exceptions that occur while executing the hooks will be
        ignored but logged.

        Like Doe.Iteration, all functions marked with this decorator will be called with the current
        iteration parameters passed as arguments, in case those parameters are defined as arguments
        in the signature of the function.
        Alternatively the current iterations parameters can be accessed via the **self.Current_variation** dictionary.
        """

        def __init__(self, **kwargs):
            if "ignore_error" not in kwargs:
                kwargs["ignore_error"] = (Exception,)
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)

    class PostExportResults(HookDecorator):
        """
        Functions decorated with this hook will be executed once for each parameter iteration and after
        specification checks were done and results are stored to disk.

        This hook will be skipped, if a previous Iteration stage was interrupted via ``self.Utils.GoToNextIteration()``.

        Like Doe.Iteration, all functions marked with this decorator will be called with the current
        iteration parameters passed as arguments, in case those parameters are defined as arguments
        in the signature of the function.
        Alternatively the current iterations parameters can be accessed via the **self.Current_variation** dictionary.

        This stage may be used to access specification results in order to modify the future test flow,
        like aborting a test if specifications are not met or dynamically modifying the sweep table.
        """

        def __init__(self, **kwargs):
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)

    class Teardown(HookDecorator):
        """
        Functions decorated with this hook will be executed once at test teardown and usually
        contain code for instrument de-initialization.
        """

        def __init__(self, **kwargs):
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)

    class Error(HookDecorator):
        """
        Functions decorated with this hook will be executed whenever an unhandled Exception occurs while
        executing other hooks like Startup, Iteration and Teardown.
        The exception info will be passed to the function as tuple of exception type, exception instance and traceback.
        """

        def __init__(self, **kwargs):
            kwargs.setdefault("nolog_kwargs", True)
            super().__init__(hook_name=f"DoE.{self.__class__.__name__}", **kwargs)
