from __future__ import annotations

from collections.abc import Iterable
from typing import Callable


class HookDecorator:
    __FROM_PLUGIN__ = False

    def __init__(self, hook_name, **hook_kwargs):
        """
        A decorator class for functions of a PyVerify test. It is used to dynamically mark function of an object to
        be invoked at a specific point in time. If a function is decorated with a HookDecorator instance it will
        be invoked when a so-called hook caller is executing it.

        Multiple functions can be marked with one and the same HookDecorator instance, which means that the
        hook caller is able to execute all equally-named hooks (like DoE.Init) with a single call.

        If multiple functions are marked with the same HookDecorator instance,
        their execution order is determined by following rules:

        1.  is_hook_wrapper:    Those hooks are always executed first before all others.
                                If there are multiple hook wrappers, rule 2 applies
        2.  try_first/try_last: The hook is execute before/after all others.
                                If there are multiple hooks using try_first/try_last, rule 3 applies
        3.  prio:               Hooks with a low prio value (e.g. 0, including negative) are executed before
                                hooks with a high prio value (e.g. 100). If there are hooks with the same prio,
                                rule 4 applies.
        4.  function name:      If everything else should be equal, the hook execution is ordered by the name
                                of the respective function the hook is wrapping

        :param hook_name: The name of the hook. It will be used in the hook caller to
                          find and execute hooks of an object (e.g. the test instance)
        :keyword is_hook_wrapper: Makes the decorated function a generator/hook wrapper.
                                  That means the function must include a yield statement.
                                  This hook is executed with the highest priority of all hooks and will
                                  be executed in two parts.
                                  The code before the yield is executed first,
                                  then all other non-hookwrappers hooks are executed and finally the
                                  code after the yield statement is executed. This makes it possible to
                                  create "wrappers" for user-defined hooks.
        :keyword try_first:       Try to execute the hook before all others, ignoring their priority.
        :keyword try_last:        Try to execute the hook after all others, ignoring their priority.
        :keyword prio:            Execute hook early (low prio value including negative), execute hook late
                                  (high prio value)
        :keyword enabled:         If False (default: True) the hook execution will be by skipped by the hook caller.
        :keyword ignore_error:    An iterable of Exception types that will be ignored if they occur
        :keyword silent:          If True, executing this hook will be silent and will not produce log messages
        :keyword nolog_kwargs:    If True, executing this hook will not log the passed parameters
        :keyword kwargs_optional: If True, the hook caller will only call the hooked function with parameters it has
                                  defined in its signature, the other are removed.

                                  If False, the hook caller will provide all function parameters to the hooked function,
                                  regardless if they are defined in its signature. This will lead to errors if there
                                  are missing function parameters
        """
        self.hook_name = hook_name
        self.hook_kwargs = hook_kwargs

        self.is_hook_wrapper = bool(hook_kwargs.get("is_hook_wrapper", False))
        self.try_first = bool(hook_kwargs.get("try_first", False))
        self.try_last = bool(hook_kwargs.get("try_last", False))
        self.priority = int(hook_kwargs.get("prio", 1))
        self.enabled = bool(hook_kwargs.get("enabled", True))
        self.silent = bool(hook_kwargs.get("silent", False))
        self.nolog_kwargs = bool(hook_kwargs.get("nolog_kwargs", False))
        self.kwargs_optional = bool(hook_kwargs.get("kwargs_optional", True))

        if self.try_first and self.try_last:
            msg = "try_first and try_last must not be both True!"
            raise ValueError(msg)

        self.func: Callable = None  # The callable that is wrapped by the HookDecorator

        # Sanity checks
        self.ignore_error = self.hook_kwargs.get("ignore_error", None)
        if not (
            self.ignore_error is None
            or (
                (isiterable(self.ignore_error) and all(issubclass(e, BaseException) for e in self.ignore_error))
                or issubclass(self.ignore_error, BaseException)
            )
        ):
            msg = "If set, keyword 'ignore_error' must be a subclass of BaseException or an iterable of it"
            raise TypeError(msg)

    def __str__(self):
        return self.to_str()

    def to_str(self, args: bool = False, func: bool = True):
        string = "Plugin " if self.__FROM_PLUGIN__ else ""
        string += "Hook-wrapper " if self.is_hook_wrapper else "Hook "
        string += f"{self.hook_name.replace('_', '.')}"
        if args:
            string += f"(prio={self.priority:<2}, try_first={self.try_first:>1}, try_last={self.try_last:>1})"
        if func:
            string += " @ " + self.get_qual_func_name()
        return string

    def get_qual_func_name(self):
        if hasattr(self.func, "__func__"):
            return f"{self.func.__func__.__qualname__}"
        if hasattr(self.func, "__qualname__"):
            return f"{self.func.__qualname__}"
        return str(self.func)

    @staticmethod
    def get_anchor_name(hookname) -> str:
        """
        Converts a hook name into a valid attribute name under which the hook will be anchored to an object
        """
        return "_pyverifyhook_" + hookname.replace(".", "_")

    def __call__(self, function: Callable):
        """
        If there are decorator arguments, __call__() is only called
        once, as part of the decoration process! You can only give
        it a single argument, which is the function object.
        """

        def anchor_hook(func: Callable):
            anchorname = self.get_anchor_name(self.hook_name)
            try:
                setattr(func, anchorname, self)
                func.__pyverifyhook_anchorname__ = anchorname
            except AttributeError:
                func.__dict__[anchorname] = self
                func.__dict__["__pyverifyhook_anchorname__"] = anchorname
            return func

        if function is None:
            return anchor_hook
        return anchor_hook(function)


def isiterable(arg):
    return isinstance(arg, Iterable) and not isinstance(arg, str)
