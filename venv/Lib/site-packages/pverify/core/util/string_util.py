from __future__ import annotations

import keyword
import os
import sys
import traceback

from pverify.core.env import DEBUG_TRACEBACK


def decode(string):
    if isinstance(string, bytes):
        try:
            return string.decode("utf-8", "strict")
        except UnicodeDecodeError:
            try:
                return string.decode("latin-1", "strict")
            except UnicodeDecodeError:
                return string.decode("utf-8", "replace")
    return string


def pretty_print_traceback(nr_frames=5, context=""):
    """
    Print the usual traceback information, followed by a listing of all the
    local variables in each frame.
    """
    etype, value, tb = sys.exc_info()
    log_msg_prefix = context + "\n" if context else ""
    try:
        log_msg = log_msg_prefix + f"Oh no! An error occurred:\n\n{value!r}\n\n"
        stack_summary = traceback.StackSummary.extract(traceback.walk_tb(tb), limit=None, capture_locals=True)
        while 1:
            if not tb.tb_next:
                break
            tb = tb.tb_next
        stack = []
        f = tb.tb_frame
        while f:
            stack.append(f)
            f = f.f_back
        # stack.reverse()

        filtered_stack_summary = []
        for frame_summary in stack_summary:
            if not frame_summary.locals.get("__tracebackhide__", False) or DEBUG_TRACEBACK or len(stack_summary) == 1:
                frame_summary.locals = None
                filtered_stack_summary.append(frame_summary)
        filtererd_traceback_string = "".join(traceback.StackSummary.from_list(filtered_stack_summary).format())

        log_msg += "Traceback, most recent call last:\n"
        log_msg += "=================================\n\n"
        log_msg += filtererd_traceback_string

        if DEBUG_TRACEBACK:
            nr_frames = 10

        if nr_frames > 0:
            log_msg += "\n\nLocals by frame, innermost first:\n"
            log_msg += "================================="
            for i, frame in enumerate(stack):
                if (
                    frame.f_locals.get("__tracebackhide__", frame.f_globals.get("__tracebackhide__", False))
                    and not DEBUG_TRACEBACK
                ):
                    continue

                if str(frame.f_code.co_name).startswith("<"):
                    log_msg += "    -"
                    break

                if i >= nr_frames:
                    break
                log_msg += (
                    f"""\n\n  Frame {frame.f_code.co_name} in "{frame.f_code.co_filename}" at line {frame.f_lineno}"""
                )
                for key, value in frame.f_locals.items():
                    if not str(value).startswith("<"):
                        log_msg += str("\n  \t%20s = " % key)
                        # We have to be careful not to cause a new error in our error
                        # printer! Calling str() on an unknown object could cause an
                        # error we don't want.
                        try:
                            if isinstance(value, str):
                                log_msg += '"{}"'.format(shorten(value, 60, 20, False, " ... "))
                            else:
                                log_msg += str(shorten(str(value), 60, 20, False, " ... "))
                        except Exception:
                            log_msg += "<ERROR WHILE PRINTING VALUE>"
            log_msg += "\n"
        return log_msg
    except Exception as e:
        return (
            log_msg_prefix
            + f"Oh no! An error occurred:\n\n{value!r}\n\nFailed generating pretty traceback (Error: {e}).\n"
            f"Here is the default one:\n\n" + "\n".join(traceback.format_tb(tb))
        )


def shorten(text, maxchars_start=5, maxchars_end=10, check_path=False, separator="..."):
    if isinstance(text, str):
        if len(text) <= maxchars_start + maxchars_end:
            return text
        if check_path and os.path.splitext(text)[-1] != "":
            tmp = (
                text[:maxchars_start]
                + separator
                + "/"
                + os.path.basename(os.path.dirname(text))
                + "/"
                + os.path.basename(text)
            )
            if tmp.__len__() < text.__len__():
                return tmp
            return text
        return text[:15] + "..."
    return text


def is_valid_identifier(ident: str) -> bool:
    """Determines if string is valid Python identifier."""
    if not isinstance(ident, str):
        return False

    if not ident.isidentifier():
        return False

    if keyword.iskeyword(ident):
        return False

    return True


def check_valid_identifier(ident: str):
    if not is_valid_identifier(ident):
        msg = f"{ident!r} is not a valid identifier!"
        raise ValueError(msg)
