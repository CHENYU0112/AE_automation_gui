from __future__ import annotations

import re
from collections.abc import Iterable
from itertools import tee


def filter(names, inclusion_patterns=None, exclusion_patterns=None, flags=re.IGNORECASE):
    """
    Enhanced version of fnmatch.filter() that accepts multiple inclusion and exclusion patterns.

    If only inclusion_patterns is specified, only the names which match one or more patterns are returned.
    If only exclusion_patterns is specified, only the names which do not match any pattern are returned.
    If both are specified, the exclusion patterns take precedence.
    If neither is specified, the input is returned as-is.
    """
    if not inclusion_patterns:
        inclusion_patterns = []
    if not exclusion_patterns:
        exclusion_patterns = []

    compiled_inclusion_patterns = [re.compile(pat, flags) for pat in inclusion_patterns]
    compiled_exclusion_patterns = [re.compile(pat, flags) for pat in exclusion_patterns]

    if isinstance(names, Iterable):
        iter1, iter2 = tee(names, 2)
    else:
        msg = "You have to pass an iterable!"
        raise TypeError(msg)

    included = multi_filter(iter1, compiled_inclusion_patterns) if compiled_inclusion_patterns else []
    excluded = multi_filter(iter2, compiled_exclusion_patterns) if compiled_exclusion_patterns else []
    included = set(included)
    excluded = set(excluded)
    return included - excluded


def multi_filter(names, patterns):
    """Generator function which yields the names that match one or more of the patterns."""
    for name in names:
        if any(pattern.fullmatch(name) is not None for pattern in patterns):
            yield name


if __name__ == "__main__":
    import os

    for f in filter(
        os.listdir(r"C:\temp\PyVerify\Calib_CV_GM_Konstanter_62_N_80_RU_12.5_P_CH-1_SN-S4_AN-A4_20180731-0935"),
        [".*"],
        [r".*\.h5", r".*\.yaml"],
    ):
        print(f)
