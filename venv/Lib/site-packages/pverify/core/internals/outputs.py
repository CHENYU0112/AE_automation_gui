from __future__ import annotations

from pverify.core.internals.unit import ScalarUnit
from pverify.core.util.string_util import is_valid_identifier


class Output:
    class OutputType:
        Scalar = "scalar"
        Waveform = "waveform"
        String = "string"
        Array = "array"
        File = "file"

    def __init__(self, Name: str, Unit: str, Description: str, fmt: str = "{}"):
        self.Name = Name
        self.Description = Description
        self.Unit = ""
        self.format = str(fmt) or "{}"

        unit = Unit.replace(" ", "")
        if ScalarUnit.is_valid_unit(unit):
            self.dtype = self.OutputType.Scalar
            self.Unit = unit
        elif ScalarUnit.is_string_unit(unit):
            self.dtype = self.OutputType.String
            self.Unit = unit
        elif ScalarUnit.is_array_unit(unit):
            self.dtype = self.OutputType.Array
        elif ScalarUnit.is_file_unit(unit):
            self.dtype = self.OutputType.File
        elif ScalarUnit.is_waveform_unit(unit):
            self.dtype = self.OutputType.Waveform
        else:
            msg = f"Unknown unit fmt: {unit}"
            raise Exception(msg)

    def _to_serializeable(self):
        return self.__dict__

    def format_value(self, value) -> str:
        """
        Formats a value with the fmt string defined in this output.
        """
        if isinstance(value, float) and value.is_integer():
            # Convert floats to int is there is no precision loss, so we could fmt 1.0 also as HEX.
            value = int(value)
        return self.format.format(value)


class Outputs(dict):
    """A class containing test Outputs. Outputs can be scalar values or vectors of arbitrary size."""

    def __init__(self, baseclass):
        super().__init__()
        self.__baseclass = baseclass
        """:type : pverify.PyVerifyBaseTest"""

    def __contains__(self, item):
        return (item in list(self.keys())) or (item in list(self.values()))

    def Add(self, Name: str, Unit: str = "", Description: str = "", fmt: str = ""):
        """
        Adds a new Output to the testcase.

        :param Name: The output's name
        :param Unit: Its unit. Specifies the datatype of the output.\n

                     It has to be of following form:\n

                     :UNIT[/UNIT]: Scalar output\n
                     :UNIT[/UNIT](): Waveform output (x-axis has no unit)\n
                     :UNIT[/UNIT](UNIT[/UNIT]) or only (UNIT[/UNIT]): Waveform output (x-axis has unit)\n

                     A UNIT can be any character of [a-z,A-Z,%,_] or an empty string.
                     UNIT also may have a multiplier prefix (y,z,a,f,p,n,u,m,k,M,G,T,P,E,Z,Y).
                     When specifying a prefix, you must specify a unit!

                     E.g. a unit 'ppb' would not be 'parts per billion', it would be pico-pb.
                     To overcome this use _ as prefix: '_ppb'.

                     Further examples for scalar: mV, mA/us, /Ohm, _/mV, _ppm, ...

                     Further examples for waveform: mV(s), mA/us(mV/s), Ohm(V), (mV), ...

                     A string type can be declared with unit ``"<string>"``

                     An array type can be declared with unit ``"<array>"``

                     A file type can be declared with unit ``"<file>"``

        :param Description: The output's description
        :param fmt: The fmt to use when displaying the value of this output.
            The fmt will also be stored as result metadata key ``fmt`` for potential later usage in postprocessing.

            Some examples: ``{:.3f}`` (defined precision), ``{:.0f}`` (round to int), ``0x{:02X}`` (hex fmt),
            ``{} ppm`` (explicit unit)

        **Example:**

        .. code-block:: python

          # Scalar outputs
          self.Outputs.Add("Vout", "V", "-")
          self.Outputs.Add("SlewRate", "uA/ms", "-")
          self.Outputs.Add("Powerfactor", "", "-")
          self.Outputs.Add("Efficiency", "%", "-")

          # Waveform outputs
          self.Outputs.Add("VoutArray", "V()", "-")
          self.Outputs.Add("SlewRateArray", "uA/ms()", "-")
          self.Outputs.Add("PowerfactorArray", "()", "-")
          self.Outputs.Add("EfficiencyArray", "%()", "-")
          self.Outputs.Add("VoutWave", "V(s)", "-")  # Vout over time
          self.Outputs.Add("SlewRateWave", "uA/ms(A)", "-")  # SlewRate over load current
          self.Outputs.Add("PowerfactorWave", "(s)", "-")  # PF over time
          self.Outputs.Add("EfficiencyWave", "%(uA/ms)", "-")  # Eff over SlewRate

          # File output
          self.Outputs.Add("scope_screenshot", "<file>", "")
        """

        if Name is not None and Name != "":
            if not is_valid_identifier(Name):
                msg = "Invalid output name. Name may only contain alphanumeric characters including '_'."
                raise ValueError(msg)
            if not (
                ScalarUnit.is_valid_unit(Unit)
                or ScalarUnit.is_string_unit(Unit)
                or ScalarUnit.is_array_unit(Unit)
                or ScalarUnit.is_waveform_unit(Unit)
                or ScalarUnit.is_file_unit(Unit)
            ):
                msg = "Invalid unit. Unit has to be specified in SI notation."
                raise ValueError(msg)
            self.update({Name: Output(Name, Unit, Description, fmt)})
        else:
            msg = "For an output a name has to be specified."
            raise Exception(msg)

    def _to_serializeable(self):
        return {k: v._to_serializeable() for k, v in self.items()}
