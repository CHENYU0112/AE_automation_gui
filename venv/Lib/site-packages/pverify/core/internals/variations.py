from __future__ import annotations

import itertools
from collections import OrderedDict
from typing import TYPE_CHECKING, Any

import numpy as np

from pverify.core.internals.logging_util import get_test_logger
from pverify.core.util.dict_util import pretty_print_dict
from pverify.core.util.string_util import shorten
from pverify.core.util.tabulate import tabulate

from .unit import ScalarUnit

if TYPE_CHECKING:
    from pverify.core.internals.parameters import Parameter


class InvalidVariationError(Exception):
    pass


class Variations:
    def __init__(self):
        self.__log = get_test_logger()
        self._variations: list[tuple[str, object]] = []
        self.__used_parameters = []
        self.__defaults_filled = False
        self._variation_table = OrderedDict()
        self._variation_table_expanded: list[dict[str, object]] = []
        self.__index = -1
        self.__default_params: list[str] = []
        """:type : list[str]"""
        self.__parameter_units: dict[str, str] = {}

    def Add_ListSweep(self, Param, Values):
        """
        Adds a parameter sweep varation.

        :param Param: The parameter name. Must exist, otherwise an error is raised.
        :type Param: str
        :type Values: A list/array of values for the parameter to be sweeped.
        :type Values: list | np.multiarray.ndarray

        Example:

        .. code-block:: python

            self.Variations.Add_ListSweep("Parameter1", [1,2,3])
            self.Variations.Add_ListSweep("Parameter2", np.linspace(0,1,10))

        This will (if not other variations would be specified afterwards) generate a variationtable with 3 x 10 = 30
        different variations.

        """
        if Param in self.__used_parameters:
            for i in range(len(self._variations)):
                var_params = self._variations[i][0]
                if var_params == Param:
                    self.__log.debug(
                        f"Parameter '{Param}' is already used in a previous list-sweep definition, overwriting!"
                    )
                    self._variations.pop(i)
                    break
                if Param in var_params and "::" in var_params:
                    msg = f"Parameter '{Param}' is already used in a previous corner-sweep definition!"
                    raise InvalidVariationError(msg)

        if hasattr(Values, "tolist"):
            vals = Values.tolist()
        elif isinstance(Values, (list, tuple)):
            vals = list(Values)
        else:
            vals = list(Values)

        self._variations.append((Param, vals))
        self.__used_parameters.append(Param)

    def Add_Corner(self, Params, Values):
        """
        Adds a parameter corner variation.

        :param Params: The parameter names as list. Must exist, otherwise an error is raised.
        :type Params: list[str]
        :param Values: A list/array of lists/arrays with the values for the parameters to be varied.
        :type Values: list | np.multiarray.ndarray

        Following example adds a definition for a corner variation over parameter "In1" and "In2" which will have the
        values 1 and 2 in the first variation and 3 and 4 in the second variation.

        .. code-block:: python

            self.Variations.Add_Corner(["Parameter1", "Parameter2"], [[1, 2], [3, 4]])

        This will (if not other variations would be specified afterwards) generate a variationtable with 2
        different variations.

        """
        if type(Params) not in [list, tuple, np.ndarray]:
            msg = "Parameter 'Params' has to be a list of strings."
            raise TypeError(msg)
        try:
            arr = np.array(Values)
        except Exception:
            msg = "Unvalid values definition. Has to be list[list[str/int/float]]"
            raise TypeError(msg) from None

        if arr.dtype == np.object_:
            msg = "Unvalid values definition. Has to be list[list[str/int/float]]"
            raise TypeError(msg)
        if arr.shape[1] != len(Params):
            raise ValueError(
                "DimensionError. Parameter 'Values' must be a list of lists of length %d (len(Params))" % len(Params)
            )
        arr = [list(v) for v in list(Values)]

        varObjs = []
        for _idx, Param in enumerate(Params):
            if Param in self.__used_parameters:
                msg = f"Parameter '{Param}' already used in a previous variation definition."
                raise ValueError(msg)
            self.__used_parameters.append(Param)
        for vals in arr:
            varObjs.append(VariationObj(vals))

        self._variations.append(("::".join(Params), varObjs))

    def _validate(self, parameters: dict[str, Parameter]):
        for p in parameters.values():
            self.__parameter_units[p.Name] = p.Unit

        for param, values in self._variations:
            if not isinstance(param, str):
                msg = f"Parameter {param} must be of type str!"
                raise TypeError(msg)
            for pname in str(param).split("::"):
                if pname not in parameters:
                    msg = f"Non-existent parameter {pname} used in sweep definition!"
                    raise LookupError(msg)

            for i, pname in enumerate(str(param).split("::")):
                vals = [row.values[i] for row in values] if "::" in param else values
                parameters[pname].validate(*vals)

    def SetNextVariation(self, **VariationValues):
        """
        Creates a new variation subset and inserts it in the variation table as next variation.

        The method uses the current variations values as default and overwrites the entries specified as
        keyword arguments 'VariationValues'.

        .. note::

            The variation subset is inserted. This means that all previously defined variations will be still called,
            but after the inserted variation.

            The best way to use it is to start the test with a single default variation and then use
            **SetNextVariation** in self.VariationLoop or self.VariationLoopPostprocessing to dynamically
            generate the next variation subset. If **SetNextVariation** is not called anymore the test will end.

        Example of use:

        .. code-block:: python

            def Initialization(self):
                ...
                self.Parameters.Add("In1", "A", "", 1)
                self.Parameters.Add("In2", "A", "", 2)
                self.Parameters.Add("In3", "A", "", 3)

                self.Outputs.Add("Out1", "V", "")
                self.Outputs.Add("Out2", "V", "")
                self.Outputs.Add("Out3", "V", "")
                ...

            def VariationLoop(self):
                ...
                if self.Current_variation["In1"] < 5:
                    self.Variations.SetNextVariation(In1=self.rc["Out1"] + 1,
                                                     In2=self.rc["Out2"] + 2,
                                                     In3=self.rc["Out3"] + 3)
                elif 5 <= self.Current_variation["In1"] < 10:
                    self.Variations.SetNextVariation(**{"In1": self.rc["Out1"] + 1,
                                                      # "In2" stays the same
                                                      "In3": self.rc["Out3"] + 3})
                ...


        :param VariationValues: A dictionary containing the variation key-values pair to overwrite or keyword
                                arguments. See example.
        """
        d = self.__getitem__(self.__index).copy()
        for k, v in VariationValues.items():
            if k in self._variation_table_expanded[0]:
                d.update({k: v})
        self._variation_table_expanded.insert(self.__index + 1, d)

    def SetNextVariations(self, variations: list[dict[str, Any]]):
        """
        Create multiple new variation subsets and inserts them this order in the variation table as next variation.

        The method uses the current variations values as default and overwrites the entries specified as keyword
        arguments 'VariationValues'.

        .. note::

            The variation subsets are inserted. This means that all previously defined variations will be still
            called, but after the inserted variations.

        Example of use:

        .. code-block:: python

            def Initialization(self):
                ...
                self.Parameters.Add("Temp", "degC", "", 40)
                self.Parameters.Add("DUT", "", "", [1])
                self.Parameters.Add("Vdd", "V", "", 3.5)
                ...

            def VariationLoop(self):
                ...
                if is_this_result_suspicious():
                    # Schedule/Insert some more fine granular iterations
                    self.Variations.SetNextVariations([
                        dict(Vdd=self.Current_variation["Vdd"] + 0.1),
                        dict(Vdd=self.Current_variation["Vdd"] + 0.2),
                        dict(Vdd=self.Current_variation["Vdd"] + 0.3),
                        dict(Vdd=self.Current_variation["Vdd"] + 0.4),
                    ])
                ...


        :param variations: A list of dictionaries containing the variation key-values pairs to add. See example.
        """
        for variation in variations[::-1]:
            self.SetNextVariation(**variation.items())

    def _get_next_variation_scaled(self):
        self.__index += 1
        var_scaled = []
        var = self.__getitem__(self.__index)
        self.__log.info("Converting si-prefixes of current variation values...")
        for key, value in var.items():
            unit = ScalarUnit(self.__parameter_units[key])
            scaled_value, success = unit.unscale(value)
            var_scaled.append((key, scaled_value))
        var_scaled = OrderedDict(var_scaled)
        self.__log.info(f"... variation values after conversion: {pretty_print_dict(var_scaled)}")

        return var_scaled

    @property
    def Keys(self):
        """
        Returns a list of variation identifiers.

        :rtype: list[str]
        """
        if not len(self._variation_table.keys()):
            self._build_variation_table()
        return self._variation_table.keys()

    def __getitem__(self, item):
        return self._variation_table_expanded[int(item)]

    def __iter__(self):
        return iter(self._variation_table_expanded)

    def __len__(self):
        return max(len(self._variation_table_expanded), 1)

    def Clear(self):
        """
        Clears all variation definitions.
        """
        self.__defaults_filled = False
        self._variations = []
        self.__used_parameters = []
        self.__default_params = []

    def _add_default_parameters(self, parameters: dict[str, Parameter]):
        if not self.__defaults_filled:
            p = list(parameters.values())
            p.reverse()
            for parameter in p:
                if parameter.Name not in self.__used_parameters:
                    self._variations.insert(0, (parameter.Name, list(parameter.DefaultValues)))
                    self.__used_parameters.append(parameter.Name)
                    self.__default_params.append(parameter.Name)
            self.__defaults_filled = True

    def _build_variation_table(self):
        """
        Updates the dict self.__variation_table with key-value (variationname-variationvalues) pairs.
        Example:
            {
                "In1":      [1, 2, 3, ...],  # For list sweeps
                "In2::In3": list[VariationObj, VariationObj, ...]  # For corner sweeps
            }
        """
        self._variation_table = OrderedDict()
        for k, v in self._variations:
            self._variation_table.update({k: v})
        return self._variation_table

    def _build_variation_table_expanded(self):
        """
        Updates the list self.__variation_table_expanded.

        Each entry is a dictionary with parametername-parametervalue pairs.

        Structure:
            [
                {"In1": 1, "In2": 3, "In3":5},\n
                {"In1": 1, "In2": 3, "In3":6},\n
                {"In1": 1, "In2": 4, "In3":5},\n
                {"In1": 1, "In2": 4, "In3":6},\n
                ...
            ]
        """
        self._variation_table_expanded = []

        variation_table_entry = OrderedDict()
        values_table = list(self._variation_table.values())

        variation_values = list(itertools.product(*values_table))

        for values in variation_values:
            for idx, name in enumerate(self._variation_table.keys()):
                if "::" not in name:
                    variation_table_entry.update({name: values[idx]})
                elif "::" in name and isinstance(values[idx], VariationObj):
                    for i, p in enumerate(name.split("::")):
                        variation_table_entry.update({p: values[idx].values[i]})

            self._variation_table_expanded.append(variation_table_entry.copy())

    def _print_variation_table_expanded(self):
        # Log variation table
        if len(self._variation_table_expanded) < 100:
            entry = "\nVariation table (detailed):\n\n"
            keys = [k + f" [{self.__parameter_units[k]}]" for k in self._variation_table_expanded[0]]
            values = []
            var_names = ["Parameter"]
            for i, var in enumerate(self._variation_table_expanded):
                fixed = [shorten(x, 5, 10, True) for x in var.values()]
                values.append(fixed)
                var_names.append("run%04d" % i)
            values.insert(0, keys)
            entry += tabulate(list(map(list, zip(*values))), headers=var_names)
            entry += "\n"
        else:
            self.__log.info("Variation table too big to print, printing variation definition instead.")
            entry = "Variation definition (outer variation first):\n"
            for pname, var in self._variation_table.items():
                entry += f"              {pname}: {var}\n"

        self.__log.info(entry)

    def _to_serializeable(self):
        return {"sweeps": self._variations, "table": self._variation_table_expanded}


class VariationObj:
    def __init__(self, values):
        self.values = values

    def __str__(self):
        return ":".join([str(i) for i in self.values])

    def __repr__(self):
        return self.__str__()
