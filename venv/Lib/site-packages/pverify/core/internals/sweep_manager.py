from __future__ import annotations

__package__ = "pverify.core.internals"

import contextlib
import itertools
import numbers
from collections import Counter
from typing import TYPE_CHECKING, Any, Callable

import attr
import numpy as np

from pverify.core.util.dict_util import pretty_print_dict
from pverify.core.util.iter_util import flatten
from pverify.core.util.string_util import check_valid_identifier

from .logging_util import get_test_logger
from .unit import ScalarUnit

if TYPE_CHECKING:
    from collections.abc import Iterable

    from .parameters import Parameter


def to_numeric_or_string(value) -> str | numbers.Number:
    if isinstance(value, str):
        return value
    if isinstance(value, bytes):
        return value.decode(errors="replace")
    if isinstance(value, np.number):
        return value.item()
    if isinstance(value, (bool, np.bool_)):
        return int(bool(value))
    if isinstance(value, numbers.Number):
        return value
    msg = f"Unsupported type {type(value)} of value {value!r}"
    raise TypeError(msg)


@attr.s
class Sweep:
    sweep_type: str = attr.ib()
    parameters: tuple[str, ...] = attr.ib()
    values: tuple[Any, ...] = attr.ib()

    def __len__(self):
        return len(self.values)

    def _to_serializeable(self):
        return {"cls": self.__class__.__name__, "parameters": self.parameters, "values": self.values}


@attr.s(frozen=True)
class ListSweep(Sweep):
    sweep_type: str = attr.ib(init=False, default="ListSweep", repr=False)
    parameters: tuple[str, ...] = attr.ib(
        converter=lambda string: (str(string),),
        validator=lambda instance, attribute, value: check_valid_identifier(value[0]),
    )
    values: tuple[Any, ...] = attr.ib(converter=lambda items: tuple(map(to_numeric_or_string, items)))

    @values.validator
    def check(self, attribute, items):
        if not len(items):
            msg = "At least one value has to be specified!"
            raise ValueError(msg)
        if not any(all(isinstance(item, typ) for item in items) for typ in (numbers.Number, str)):
            msg = "values can only be a list/tuple of numbers or strings"
            raise TypeError(msg)


def _convert_to_nested_tuples(items):
    if isinstance(items, np.ndarray):
        items = items.tolist()
    return tuple(map(to_numeric_or_string, items))


@attr.s(frozen=True)
class CornerSweep(Sweep):
    sweep_type: str = attr.ib(init=False, default="CornerSweep", repr=False)
    parameters: tuple[str, ...] = attr.ib(
        converter=lambda items: tuple(map(str, items)),
        validator=attr.validators.deep_iterable(
            member_validator=lambda instance, attribute, value: check_valid_identifier(value)
        ),
    )
    values: tuple[tuple[Any, ...], ...] = attr.ib(
        converter=lambda items: tuple([tuple([to_numeric_or_string(inner) for inner in outer]) for outer in items]),
    )

    @values.validator
    def check_values(self, attribute, values):
        if len(self.parameters) < 2:
            msg = "At least two parameters needed for a corner sweep!"
            raise ValueError(msg)

        if not all(len(sublist) == len(self.parameters) for sublist in values):
            msg = (
                f"The sub-iterables inside values must have a length of {len(self.parameters)} "
                f"but have lengths of {[len(sublist) for sublist in values]}"
            )
            raise ValueError(msg)

        transposed = list(map(list, zip(*values)))
        if not all(
            any(all(isinstance(item, typ) for item in row) for typ in (numbers.Number, str)) for row in transposed
        ):
            msg = "The data type (str, number) for each parameter must not change across the sweep!"
            raise ValueError(msg)


class SweepSet:
    """
    Holds a set of sweeps (list, corner) where all parameters are at most used once
    """

    def __init__(self, sweeps: Iterable[Sweep] | None = None):
        self.sweeps: list[Sweep] = []
        self.table: list[dict[str, Any]] = []
        self.used_parameters: list[str] = []
        for sweep in sweeps or []:
            self.append(sweep)

    def __len__(self):
        return len(self.sweeps)

    def __getitem__(self, item):
        return self.sweeps[item]

    def clear(self):
        self.sweeps.clear()
        self._updated_used_parameters()
        self.table.clear()

    def append(self, sweep: Sweep):
        self.sweeps.append(sweep)
        self._updated_used_parameters()
        self.table.clear()

    def remove_sweep(self, sweep: Sweep):
        if sweep in self.sweeps:
            self.sweeps.remove(sweep)
            self._updated_used_parameters()
            self.table.clear()
            return True
        return False

    def remove_sweep_by_parameter(self, parameter: str) -> bool:
        filtered_sweeps = [sweep for sweep in self.sweeps if parameter not in sweep.parameters]
        removed = len(filtered_sweeps) != len(self.sweeps)
        self.sweeps = filtered_sweeps
        self._updated_used_parameters()
        return removed

    def _updated_used_parameters(self):
        used_parameters = list(itertools.chain([sw.parameters for sw in self.sweeps]))
        cnt = Counter(used_parameters) - Counter(list(set(used_parameters)))
        if cnt:
            raise ValueError(
                ", ".join([f"Parameter {k[0]} is used {v + 1} times in sweep definition" for k, v in cnt.items()])
            )
        self.used_parameters = list(flatten(used_parameters))

    def make_product(self):
        # Make product
        parameters = tuple(itertools.chain(*[sweep.parameters for sweep in self.sweeps]))
        product = itertools.product(*[sweep.values for sweep in self.sweeps])
        self.table.clear()
        row: list
        for row in product:
            if len(row):
                self.table.append(dict(zip(parameters, list(flatten(row)))))

    def __repr__(self):
        LF = "\n  "
        return f"""SweepSet(
  {LF.join(map(repr, self.sweeps))}
)"""

    def __str__(self):
        return self.__repr__()

    def _to_serializeable(self):
        return [sweep._to_serializeable() for sweep in self.sweeps]


@attr.s
class Filter:
    expression: str | Callable = attr.ib(
        init=True, validator=lambda instance, attribute, value: isinstance(value, str) or callable(value)
    )
    on_match: str = attr.ib(init=True, converter=str, validator=attr.validators.in_(("include", "exclude")))

    def evaluate(self, entry: dict[str, Any]) -> bool:
        """
        Returns True (on_match=="include") or False (on_match=="exclude") if the input matches the expression
        """
        if isinstance(self.expression, str):
            try:
                match = bool(eval(self.expression, entry.copy()))
            except Exception as e:
                msg = f"An exception occurred with eval filter {self.expression}: {e}"
                raise Exception(msg) from e
        else:  # Callable
            try:
                match = bool(self.expression(**entry))
            except Exception as e:
                msg = f"An exception occurred with callable filter {self.expression}: {e}"
                raise Exception(msg) from e

        return match

    def _to_serializeable(self):
        if isinstance(self.expression, str):
            return {"cls": self.__class__.__name__, "expression": self.expression, "on_match": self.on_match}
        return None


@attr.s
class SweepTable:
    sweep_sets: list[SweepSet] = attr.ib(init=False, factory=list)
    _parameters: dict[str, Parameter] = attr.ib(init=False, factory=dict)
    table: list[dict[str, Any]] = attr.ib(init=False, factory=list)
    _log = attr.ib(init=False, factory=get_test_logger)
    _sweep_index = attr.ib(init=False, default=0)
    _table_external = attr.ib(init=False, default=False)
    _filters: list[Filter] = attr.ib(init=False, factory=list)

    def __len__(self):
        return len(self.table)

    def reset(self):
        self.sweep_sets.clear()
        self.table.clear()
        self._sweep_index = 0
        self._table_external = False

    def reset_sweep_index(self):
        self._sweep_index = 0

    def reset_filters(self):
        self._filters.clear()

    def _validate_parameter_value(self, name: str, value: Any):
        self._parameters[name].validate(value)

    def initialize_and_validate(
        self, sweepsets: list[SweepSet], parameters: dict[str, Parameter], defaults: dict[str, Any] | None
    ):
        self.reset()
        defaults = defaults or {}
        self.sweep_sets = sweepsets
        self._parameters = parameters
        self.parameter_defaults = {k: v.DefaultValues[0] for k, v in self._parameters.items()}
        # Update with parameter defaults, but only of existing
        self.parameter_defaults.update({k: v for k, v in defaults.items() if k in self.parameter_defaults})

        if not len(self.sweep_sets):
            # Create default sweepset
            self.sweep_sets.append(SweepSet(None))

        # Add default sweeps from parameter definition
        for sweep_set in self.sweep_sets:
            for k, v in self._parameters.items():
                if k not in sweep_set.used_parameters and len(v.DefaultValues) > 1 and k not in defaults:
                    sweep_set.append(ListSweep(k, v.DefaultValues))

        # Build table
        for sweep_set in self.sweep_sets:
            sweep_set.make_product()
            self.table.extend(sweep_set.table)

        if not len(self.table):
            # Ensure at least one entry is in the table
            self.table.append(self.parameter_defaults.copy())

        # Filter table
        if len(self._filters):
            self._log.info("Filtering sweep table with filters:\n" + "\n    ".join(map(str, self._filters)))
            len_before = len(self.table)
            self.table = list(filter(self._filter_entry, self.table))
            len_after = len(self.table)
            if len_after < len_before:
                self._log.info(f"Sweep table reduced from {len_before} to {len_after} entries")
            else:
                self._log.info("No filter was matching. Sweep table was not reduced.")

        # Validate
        [self._validate_parameter_value(k, v) for k, v in self.parameter_defaults.items()]
        [self._validate_parameter_value(k, v) for entry in self.table for k, v in entry.items()]

    def get_row(self, index: int, unscale: bool = False) -> dict[str, Any]:
        """
        Gets a row of the sweep table at given index

        :param unscale: Autoscale the parameter values wrt. their defined unit, e.g. 1000mv -> 1V.
        """
        row = {**self.parameter_defaults, **self.table[index]}
        if not unscale:
            return row

        new_row = row.copy()
        self._log.info("Converting si-prefixes of current variation values...")
        for key, value in row.items():
            if key in self._parameters:
                unit = ScalarUnit(self._parameters[key].Unit)
                unscaled_value, _ = unit.unscale(value)
                new_row[key] = unscaled_value
            else:
                new_row[key] = value
        self._log.info(f"... sweep values after conversion: {pretty_print_dict(new_row)}")

        return new_row

    def next_row(self) -> dict[str, Any]:
        self._sweep_index += 1
        return self.current_row(unscale=False)

    def preview_next_row(self, unscale=False) -> dict[str, Any]:
        return self.get_row(self._sweep_index + 1, unscale=unscale)

    def current_row(self, unscale=False) -> dict[str, Any]:
        return self.get_row(self._sweep_index, unscale=unscale)

    def is_last_row(self):
        return self._sweep_index == len(self.table) - 1

    def set_table(self, table: list[dict[str, Any]]):
        self._table_external = True
        self.table = table

    def set_next_row(self, row_items: dict[str, Any]):
        d = self.get_row(self._sweep_index).copy()
        for k, v in row_items.items():
            if k in d:
                self._validate_parameter_value(k, v)
                d[k] = v
        self.table.insert(self._sweep_index + 1, d)

    def set_next_rows(self, rows: list[dict[str, Any]]):
        for row in rows[::-1]:
            self.set_next_row(row)

    def drop_next_rows(self, count: int):
        """
        Drops the next <count> rows (if they exist)

        :param count: The number of rows to drop
        """
        for _i in range(count):
            try:
                self.table.pop(self._sweep_index + 1)
            except IndexError:
                return

    def drop_rows(self, expression: str | Callable, stop_on_mismatch: bool):
        """
        Drops future rows that matches the expression. If stop_on_mismatch is True, no further rows are dropped
        as soon as the first mismatch occurrs.

        This function may be executed in Startup or Iteration phase of the test.

        :param expression: A string that be be evaluated like "ParamA == 1 or ParamB != 0" or a callable function with
                           `**kwargs` as single parameter, e.g. lambda `**kwargs: kwargs["C"] == 11`
        :param stop_on_mismatch: If True, no further rows are dropped as soon as the first mismatch occurrs.
        """
        filt = Filter(expression, "exclude")
        try:
            new_table = self.table[: self._sweep_index + 1]
            remaining_table = self.table[self._sweep_index + 1 :]
        except IndexError:
            return
        stop_filtering = False
        for entry in remaining_table:
            mismatch = not filt.evaluate(entry)
            if mismatch or stop_filtering:
                if stop_on_mismatch:
                    stop_filtering = True
                new_table.append(entry)
        self.table = new_table

    def add_include_filter(self, expression: str | Callable):
        """
        Adds a filter that will be applied to the sweep table. If the filter matches a row of the sweep table
        (filter evaluates to True), this row will be re-included in case the same row is explicitly excluded
        by an ExcludeFilter match.

        If the include filter does not match a row while no exclude filteres are defined, that does not lead to an
        exclusion of the row.

        So include filters have higher prio than exclude filters.

        This function must be executed during Init phase of the test, all later invocations will be ignored.

        :param expression: A string that be be evaluated like "ParamA == 1 or ParamB != 0" or a callable function with
                           `**kwargs` as single parameter, e.g. lambda `**kwargs: kwargs["C"] == 11`
        """
        if isinstance(expression, str) or callable(expression):
            self._filters.append(Filter(expression, "include"))

    def add_exclude_filter(self, expression: str | Callable):
        """
        Adds a filter that will be applied to the sweep table. If the filter matches a row of the sweep table
        (filter evaluates to True), this row will be excluded, unless the same row is not explicitly included
        by an IncludeFilter match.

        This function must be executed during Init phase of the test, all later invocations will be ignored.

        :param expression: A string that be be evaluated like "ParamA == 1 or ParamB != 0" or a callable function with
                           `**kwargs` as single parameter, e.g. lambda `**kwargs: kwargs["C"] == 11`
        """
        if isinstance(expression, str) or callable(expression):
            self._filters.append(Filter(expression, "exclude"))

    def _filter_entry(self, entry: dict[str, Any]):
        include = []
        exclude = []
        for filt in self._filters:
            match = filt.evaluate(entry)
            if filt.on_match == "include":
                include.append(match)
            else:
                exclude.append(match)

        any_exclude_match = any(exclude)
        any_include_match = any(include)
        if (not any_exclude_match and not any_include_match) or any_include_match:
            return True
        return False


@attr.s
class SweepManager:
    """
    Provides a public interface for sweep management and adds a lot more functionality for creating and
    modifying sweeps:

    -   Using the same parameter in multiple sweep definitions (refer to *CommitSweep* method)
    -   Filter unwanted entries from the sweep table by using expressions/callables
    -   Dynamically insert new iterations during test execution
    -   Drop a number of upcoming iterations
    -   Drop upcoming iterations based on a filter expression/callable.

        This can be used e.g. to:

        -   continue with the next DUT if the current DUT is damaged or not working for a certain
            other operating condition, thus removing all future iterations where this DUT is referenced
        -   "blacklist" a parameter value that showed to be defective, thus removing all future iterations where
            this parameter value is used

    """

    _sweep_sets: list[SweepSet] = attr.ib(init=False, factory=list)
    _current_sweep_set: SweepSet = attr.ib(init=False, factory=SweepSet)
    _parameters: dict[str, Parameter] = attr.ib(init=False, factory=dict)
    _log = attr.ib(init=False, factory=get_test_logger)
    _sweep_table: SweepTable = attr.ib(init=False, factory=SweepTable)
    _parameter_defaults: dict[str, Any] = attr.ib(init=False, factory=dict)

    def _add_sweep_set(self, sweepset: SweepSet):
        self._sweep_sets.append(sweepset)

    def _init_sweep_table(self, parameters: dict[str, Parameter]):
        self._parameters = parameters
        self._sweep_table.initialize_and_validate(
            sweepsets=self._sweep_sets, parameters=parameters, defaults=self._parameter_defaults
        )

    def _to_serializeable(self):
        return {
            "sweep_sets": [ss._to_serializeable() for ss in self._sweep_sets],
            "filters": [
                item for item in [filt._to_serializeable() for filt in self._sweep_table._filters] if item is not None
            ],
        }

    def _describe(self):
        if any(len(ss.sweeps) for ss in self._sweep_sets):
            return "\n".join(map(repr, self._sweep_sets))
        if len(self._sweep_table.table):
            if len(self._sweep_table.table) > 20:
                return "\n".join(
                    [str(row) for row in self._sweep_table.table[:10]]
                    + ["..."]
                    + [str(row) for row in self._sweep_table.table[-10:]]
                )
            return "\n".join([str(row) for row in self._sweep_table.table])
        return None

    def SetNextVariation(self, **VariationValues):
        """
        Creates a new variation subset and inserts it in the variation table as next variation.

        The method uses the current variations values as default and overwrites the entries specified as keyword
        arguments 'VariationValues'.

        .. note::

            The variation subset is inserted. This means that all previously defined variations will be still called,
            but after the inserted variation.

            The best way to use it is to start the test with a single default variation and then use
            **SetNextVariation** in self.VariationLoop or
            self.VariationLoopPostprocessing to dynamically generate the next variation subset.
            If **SetNextVariation** is not called anymore the test
            will end.

        Example of use:

        .. code-block:: python

            def Initialization(self):
                ...
                self.Parameters.Add("In1", "A", "", 1)
                self.Parameters.Add("In2", "A", "", 2)
                self.Parameters.Add("In3", "A", "", 3)

                self.Outputs.Add("Out1", "V", "")
                self.Outputs.Add("Out2", "V", "")
                self.Outputs.Add("Out3", "V", "")
                ...

            def VariationLoop(self):
                ...
                if self.Current_variation["In1"] < 5:
                    self.Variations.SetNextVariation(In1=self.rc["Out1"] + 1,
                                                     In2=self.rc["Out2"] + 2,
                                                     In3=self.rc["Out3"] + 3)
                elif 5 <= self.Current_variation["In1"] < 10:
                    self.Variations.SetNextVariation(**{"In1": self.rc["Out1"] + 1,
                                                      # "In2" stays the same
                                                      "In3": self.rc["Out3"] + 3})
                ...

        This function must be executed in Startup or Iteration phase of the test, all other invocations will be ignored.

        :param VariationValues: A dictionary containing the variation key-values pair to overwrite or keyword arguments.
                                See example.
        """
        self._sweep_table.set_next_row(VariationValues)

    def SetNextVariations(self, variations: list[dict[str, Any]]):
        """
        Create multiple new variation subsets and inserts them this order in the variation table as next variation.

        The method uses the current variations values as default and overwrites the entries specified as keyword
        arguments 'VariationValues'.

        .. note::

            The variation subsets are inserted. This means that all previously defined variations will be still called,
            but after the inserted variations.

        Example of use:

        .. code-block:: python

            def Initialization(self):
                ...
                self.Parameters.Add("Temp", "degC", "", 40)
                self.Parameters.Add("DUT", "", "", [1])
                self.Parameters.Add("Vdd", "V", "", 3.5)
                ...

            def VariationLoop(self):
                ...
                if is_this_result_suspicious():
                    # Schedule/Insert some more fine granular iterations
                    self.Variations.SetNextVariations([
                        dict(Vdd=self.Current_variation["Vdd"] + 0.1),
                        dict(Vdd=self.Current_variation["Vdd"] + 0.2),
                        dict(Vdd=self.Current_variation["Vdd"] + 0.3),
                        dict(Vdd=self.Current_variation["Vdd"] + 0.4),
                    ])
                ...

        This function must be executed in Startup or Iteration phase of the test, all other invocations will be ignored.

        :param variations: A list of dictionaries containing the variation key-values pairs to add. See example.
        """
        self._sweep_table.set_next_rows(variations)

    def Clear(self):
        """
        Clears the following:

        - all committed sweep sets
        - the current sweep sets
        - the sweep table
        - the include/exclude filter
        - overwritten default parameters
        """
        self._sweep_sets.clear()
        self._current_sweep_set.clear()
        self._sweep_table.reset()
        self._sweep_table.reset_filters()
        self._parameter_defaults.clear()

    def Add_ListSweep(self, Param, Values):
        """
        Adds a parameter sweep varation.

        :param Param: The parameter name. Must exist, otherwise an error is raised.
        :type Param: str
        :type Values: A list/array of values for the parameter to be sweeped.
        :type Values: list | np.multiarray.ndarray

        Example:

        .. code-block:: python

            self.Variations.Add_ListSweep("Parameter1", [1,2,3])
            self.Variations.Add_ListSweep("Parameter2", np.linspace(0,1,10))

        This will (if not other variations would be specified afterwards) generate a variationtable with 3 x 10 = 30
        different variations.

        This function must be executed during Init phase of the test, all later invocations will be ignored.
        """
        with contextlib.suppress(LookupError):
            self.RemoveSweep(Param)
        self._current_sweep_set.append(ListSweep(Param, Values))

    def Add_Corner(self, Params, Values):
        """
        Adds a parameter corner variation.

        :param Params: The parameter names as list. Must exist, otherwise an error is raised.
        :type Params: list[str]
        :param Values: A list/array of lists/arrays with the values for the parameters to be varied.
        :type Values: list | np.multiarray.ndarray

        Following example adds a definition for a corner variation over parameter "In1" and "In2" which will have the
        values 1 and 2 in the first variation and 3 and 4 in the second variation.

        .. code-block:: python

            self.Variations.Add_Corner(["Parameter1", "Parameter2"], [[1, 2], [3, 4]])

        This will (if not other variations would be specified afterwards) generate a variationtable with 2
        different variations.

        This function must be executed during Init phase of the test, all later invocations will be ignored.
        """
        for p in Params:
            with contextlib.suppress(LookupError):
                self.RemoveSweep(p)
        self._current_sweep_set.append(CornerSweep(Params, Values))

    def RemoveSweep(self, Param: str, all: bool = False):
        """
        Removes a sweep from the current uncommitted sweep set that uses the given parameter

        :param all: If True, remove the sweep also from all already committed sweep sets
        """
        removed = False
        sweep_sets = [self._current_sweep_set]
        if all:
            sweep_sets.extend(self._sweep_sets)

        for sweep_set in sweep_sets:
            if sweep_set.remove_sweep_by_parameter(Param):
                removed = True

        if not removed:
            msg = f"No such parameter {Param!r} in existing sweep set!"
            raise LookupError(msg)

    def CommitSweep(self):
        """
        Takes all added sweep definitions and builds a full factorial sweep table from it.
        After this step additional sweeps can be added and commited again.

        Example::

            self.Add_ListSweep("A", [1, 2])
            self.Add_ListSweep("B", [3, 4])
            self.CommitSweep()

            self.Add_ListSweep("A", [5, 6])
            self.Add_ListSweep("B", [7])
            self.CommitSweep()

            Will lead to following table:

                [
                    {"A": 1, "B": 3},
                    {"A": 1, "B": 4},
                    {"A": 2, "B": 3},
                    {"A": 2, "B": 4},
                    {"A": 5, "B": 7},
                    {"A": 6, "B": 7},
                ]

        This function must be executed during Init phase of the test, all later invocations will be ignored.

        """
        if len(self._current_sweep_set.sweeps):
            self._add_sweep_set(self._current_sweep_set)
            self._current_sweep_set = SweepSet()

    def UpdateDefaults(self, **kwargs):
        """
        Updates the default parameters used for the creation of the sweep table.

        Please use this function to change defaults in favor for using a single-valued list/corner sweep to
        provide defaults.

        This function must be executed during Init phase of the test, all later invocations will be ignored.
        """
        self._parameter_defaults.update(kwargs)

    def AddExcludeFilter(self, expression: str | Callable):
        """
        Adds a filter that will be applied to the sweep table. If the filter matches a row of the sweep table
        (filter evaluates to True), this row will be excluded, unless the same row is not explicitly included
        by an IncludeFilter match.

        This function must be executed during Init phase of the test, all later invocations will be ignored.

        Examples::

            self.Variations.AddExcludeFilter("current == 4 and voltage == 5.0")
            self.Variations.AddExcludeFilter(lambda **kw: kw["voltage"] * kw["current"] > 30)

        :param expression: A string that be evaluated like "ParamA == 1 or ParamB != 0" or a callable function with
                           `**kwargs` as single parameter, e.g. lambda `**kwargs: kwargs["C"] == 11`
        """
        self._sweep_table.add_exclude_filter(expression)

    def AddIncludeFilter(self, expression: str | Callable):
        """
        Adds a filter that will be applied to the sweep table. If the filter matches a row of the sweep table
        (filter evaluates to True), this row will be re-included in case the same row is explicitly excluded
        by an ExcludeFilter match.

        If the include filter does not match a row while no exclude filteres are defined, that does not lead to an
        exclusion of the row.

        So include filters have higher prio than exclude filters.

        This function must be executed during Init phase of the test, all later invocations will be ignored.

        Example::

            self.Variations.AddIncludeFilter("current >= 4")

        :param expression: A string that be be evaluated like "ParamA == 1 or ParamB != 0" or a callable function with
                           `**kwargs` as single parameter, e.g. lambda `**kwargs: kwargs["C"] == 11`
        """
        self._sweep_table.add_include_filter(expression)

    def DropIterations(self, expression: str | Callable, stop_on_mismatch: bool):
        """
        Drops future iterations whose parameters matches the expression.
        If stop_on_mismatch is True, no further rows are dropped as soon as the first mismatch occurrs.

        This function may be executed in Startup or Iteration phase of the test.

        Examples::

            self.Variations.DropIterations("voltage == 5.0", stop_on_mismatch=True)

        :param expression: A string that will be evaluated like "ParamA == 1 or ParamB != 0" or a callable function with
                           `**kwargs` as single parameter, e.g. lambda `**kwargs: kwargs["C"] == 11`
        :param stop_on_mismatch: If True, no further rows are dropped as soon as the first mismatch occurrs.
        """
        self._sweep_table.drop_rows(expression, stop_on_mismatch)

    def DropNextIterations(self, count: int):
        """
        Drops the next <count> iterations (if they exist)

        This function may be executed in Startup or Iteration phase of the test.

        :param count: The number of rows to drop
        """
        self._sweep_table.drop_next_rows(count)

    def IsLastIteration(self) -> bool:
        """
        Returns True if the current iteration is the last one, False otherwise.

        Example::

            if self.Variations.IsLastIteration():
                self.Utils.LogInfo("This is only printed in the last iteration!")

        """
        return self._sweep_table.is_last_row()

    def PreviewNextIteration(self, unscale: bool = False) -> dict[str, Any]:
        """
        Previews the iteration values of the next iteration.

        Example::

            self.Utils.LogInfo(f"Upcoming iteration parameters: {self.Variations.PreviewNextIteration()}")

        :param unscale: Autoscale the parameter values wrt. their defined unit, e.g. 1000mv -> 1V.

        :raises IndexError: If there is no next iteration.
        """
        return self._sweep_table.preview_next_row(unscale)
