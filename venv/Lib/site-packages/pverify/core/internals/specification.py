from __future__ import annotations

from collections import Counter, defaultdict
from enum import Enum
from itertools import count
from typing import TYPE_CHECKING

import numpy as np

from pverify.core.util.numeric_util import is_numeric, is_numeric_iterable

from .eval_expressions import eval_expression

if TYPE_CHECKING:
    from numbers import Number

    from .pv_types import SpecificationThresholdType


class Specification:
    class LimitType(Enum):
        Undef = "undef"
        Scalar = "scalar"
        Expr = "expr"
        PWL = "pwl"

    _uid = 0  # Stores unique id for each limit/output link
    _counter = defaultdict(count)  # Counts how many spec are created for each output

    def __init__(
        self,
        reference_output: str,
        upper_thres: SpecificationThresholdType = None,
        lower_thres: SpecificationThresholdType = None,
        conditions: str | None = None,
        reference: str | None = None,
        x_range: tuple[Number | None, Number | None] | None = None,
        alias: str | None = None,
    ):
        self.uid = Specification._uid  # Unique ID for identification purposes
        Specification._uid += 1
        self.reference_output = str(reference_output)
        self.upper_thres = upper_thres
        self.lower_thres = lower_thres
        self.conditions = conditions
        self.reference = reference
        self.x_range = x_range
        self.alias = alias

        cnt = next(self._counter[self.reference_output])
        if not self.alias:
            self.alias = f"{self.reference_output} (Spec {cnt + 1})"

        if not ((type(self.x_range) in (list, tuple) and len(self.x_range) == 2) or self.x_range is None):
            msg = "x_range argument has to be None or a set/list of 2 values (Start,Stop)."
            raise Exception(msg)

        self.upper_thres_type = get_type(self.upper_thres)
        self.lower_thres_type = get_type(self.lower_thres)

    def for_json(self):
        return {
            "uid": self.uid,
            "reference_output": self.reference_output,
            "upper_thres": self.upper_thres,
            "lower_thres": self.lower_thres,
            "conditions": self.conditions,
            "reference": self.reference,
            "x_range": self.x_range,
            "alias": self.alias,
        }

    def __str__(self):
        if self.conditions:
            return f"Specification {self.alias!r:15s} @ {self.conditions}"
        return f"Specification {self.alias!r:15s}"

    def describe(self, verbose=True):
        if not verbose:
            return str(self)
        if self.alias:
            desc = f"Specification {self.alias!r} on output {self.reference_output!r} - "
        else:
            desc = f"Specification on output {self.reference_output!r} - "
        desc += (
            f" HL: {self.upper_thres!r}, LL: {self.lower_thres!r}, Cond: {self.conditions!r}, "
            f"reference: {self.reference!r}, x-range: {self.x_range}"
        )
        return desc

    def __eq__(self, other: Specification):
        return (
            self.reference_output == other.reference_output
            and self.conditions == other.conditions
            and self.upper_thres == other.upper_thres
            and self.lower_thres == other.lower_thres
            and self.x_range == other.x_range
            and self.alias == other.alias
            and self.reference == other.reference
        )

    def __ne__(self, other):
        return not self.__eq__(other)


class SpecificationResult:
    """
    Holds limit evaluation results for a single specification of a single test iteration
    """

    class EvalResult(Enum):
        Pass = "Pass"  # Result available and spec passed
        Fail = "Fail"  # Result available but spec failed
        Skipped = "Skipped"  # Skipped limit due to unfulfilled condition
        Unknown = "Unknown"  # Result missing
        Error = "Error"  # Limit expr. evaluation failed with exception

    def __init__(
        self,
        result_upper_thres: EvalResult,
        result_lower_thres: EvalResult,
        error_msg: str,
        specification: Specification,
        results_rationale: list[str] | None = None,
    ):
        self.result_upper_thres = result_upper_thres
        self.result_lower_thres = result_lower_thres
        self.error_msg = ""
        self.results_rationale = tuple((None, None) if results_rationale is None else tuple(results_rationale))
        self.specification = specification
        if self.result_lower_thres == self.EvalResult.Error or self.result_upper_thres == self.EvalResult.Error:
            self.overall_result = self.EvalResult.Error
            self.error_msg = error_msg
        elif self.result_lower_thres == self.EvalResult.Skipped or self.result_upper_thres == self.EvalResult.Skipped:
            self.overall_result = self.EvalResult.Skipped
        elif self.result_lower_thres == self.EvalResult.Unknown or self.result_upper_thres == self.EvalResult.Unknown:
            self.overall_result = self.EvalResult.Unknown
        elif self.result_lower_thres == self.EvalResult.Fail or self.result_upper_thres == self.EvalResult.Fail:
            self.overall_result = self.EvalResult.Fail
        else:
            self.overall_result = self.EvalResult.Pass

    @property
    def is_pass(self):
        return self.overall_result == self.EvalResult.Pass

    @property
    def is_fail(self):
        return self.overall_result == self.EvalResult.Fail

    @property
    def is_skipped(self):
        return self.overall_result == self.EvalResult.Skipped

    @property
    def has_error(self):
        return self.overall_result == self.EvalResult.Error

    def for_json(self):
        return {
            "result_upper_thres": self.result_upper_thres.value,
            "result_lower_thres": self.result_lower_thres.value,
            "overall_result": self.overall_result.value,
            "results_rationale": self.results_rationale,
            "error_msg": self.error_msg,
            "specification": self.specification.for_json(),
        }

    @staticmethod
    def _consolidate_eval_results(results: list[EvalResult]):
        """
        Merges multiple evaluation results into a single one
        """
        ER = SpecificationResult.EvalResult

        def list_in(exp_results):
            return [r in exp_results for r in results]

        def list_eq(exp_result):
            return [r == exp_result for r in results]

        distribution = {"Pass": 0, "Fail": 0, "Skipped": 0, "Unknown": 0, "Error": 0}
        distribution.update(dict(Counter([r.name for r in results])))

        if len(results) == 0:
            return SpecificationResult.EvalResult.Unknown, distribution
        if any(list_eq(ER.Error)):
            return SpecificationResult.EvalResult.Error, distribution
        if all(list_in([ER.Pass, ER.Fail, ER.Skipped])):
            if any(list_eq(ER.Fail)):
                return SpecificationResult.EvalResult.Fail, distribution
            if any(list_eq(ER.Pass)):
                return SpecificationResult.EvalResult.Pass, distribution
        if any(list_eq(ER.Unknown)):
            return SpecificationResult.EvalResult.Unknown, distribution
        if all(list_eq(ER.Skipped)):
            return SpecificationResult.EvalResult.Skipped, distribution
        return None


def get_type(thres: SpecificationThresholdType) -> Specification.LimitType:
    if thres is None:
        return Specification.LimitType.Undef

    if is_numeric(thres):
        return Specification.LimitType.Scalar

    if isinstance(thres, str):
        # Check valid expression
        try:
            eval_expression(thres, 1)
        except Exception:
            msg = f"Expression '{thres}' for cannot be evaluated in Python!"
            raise SyntaxError(msg) from None
        return Specification.LimitType.Expr

    if is_numeric_iterable(thres):
        if len(thres) % 2 != 0:
            msg = "PWL notation list has to contain an even number of values!"
            raise Exception(msg)
        # Check for monotonous rising
        if not np.all(np.diff(thres[::2], 1) > 0):
            msg = "PWL x-values have to monotonously rise."
            raise Exception(msg)
        if not all(map(is_numeric, thres)):
            msg = "There are non-numerical values in the PWL notation."
            raise Exception(msg)
        return Specification.LimitType.PWL
    return None
