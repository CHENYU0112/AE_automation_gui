from __future__ import annotations

import copy
import warnings
from pathlib import Path
from typing import *
from typing import TYPE_CHECKING

import numpy as np

from pverify.core.internals.logging_util import get_test_logger
from pverify.core.io.result_storage.util import (
    check_str_type,
    is_array_type,
    is_number_type,
    is_numeric_1dim_list_type,
    is_string_type,
    is_waveform_type,
)
from pverify.postproc.waveform import Waveform

from .outputs import Output

if TYPE_CHECKING:
    from numbers import Number

PyVerifyResult = Union[str, int, float, Waveform]


class Results:
    """
    Result Container.

    To assign data follow this notation:

    self.Result.<AnyOutputName> = <Value>

    <AnyOutputName> has to be specified as an output, otherwise it is ignored.

    <Value> has to fit to the defined datatype in the output definition.
    """

    def __init__(self, parent):
        """

        :type parent: pverify.core.pyverify_base_test.PyVerifyBaseTest
        """
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=FutureWarning)
            self.__parent = parent

    def __contains__(self, item):
        return item in self.__parent._result_container

    def __getitem__(self, item) -> PyVerifyResult:
        return self.__parent._result_container.get(item)

    def __setitem__(self, key, value):
        if value is not None:
            self.__parent._result_container.add(key, value)

    def __setattr__(self, key, value):
        warnings.warn(
            "Storing test results this way is deprecated. Use the self.rc.add() family of methods instead.",
            FutureWarning,
            stacklevel=2,
        )
        if not key.startswith("_"):
            self.__parent._result_container.add(key, value)
            super().__setattr__(key, self.__parent._result_container.get(key))
        else:
            super().__setattr__(key, value)

    def __getattribute__(self, item) -> PyVerifyResult:
        if not item.startswith("_"):
            result = self.__parent._result_container.get(item)
            if result is None:
                super().__getattribute__(item)
                return None
            return result
        return super().__getattribute__(item)

    def __iter__(self):
        return iter(self.__parent._result_container.get_all())


class ResultContainer:
    """
    The result container is used to define which result data has to be stored.

    Futhermore the user has to possibility to add global/file-level metadata as well as metadata for each iteration.

    It replaces the deprecated way of dynamically assigning objects to **self.Results**, but still keeps
    compatibility. Anything assigned to **self.Results** will be internally linked to the result container.
    So results added to **self.Results** are available via the result container, but **not vice-versa**!

    Usage::

        self.rc.add("some_number", 123.456)
        self.rc.add("some_array", np.linspace(0, 100, 1000))
        self.rc.add("some_string", "bla blubb", dict(metaA="test", metaB=123))

    To retrieve results::

        self.rc.get("some_number")
        self.rc["some_number"]
        for k, v in self.rc.getall().items():
            print(k, v)

    This also works::

        self.Results.some_other_waveform = Waveform(...)
        self.rc["some_other_waveform"].interpolate(...)

    This does **not** work::

        self.rc.add_waveform("some_other_waveform", Waveform(...))
        self.Results.some_other_waveform.interpolate(...)  # Results are not mirrors back to self.Results!


    """

    def __init__(self):
        self._log = get_test_logger()
        self._meta_global_user = {}
        self._meta_global = {}
        self._meta_iteration_user = {}
        self._meta_iteration = {}
        self._results = {}
        self._results_meta = {}

    def _clear_iteration(self):
        self._results.clear()
        self._results_meta = {}
        self._meta_iteration_user.clear()
        self._meta_iteration.clear()

    def _clear_global(self):
        self._meta_global_user.clear()
        self._meta_global.clear()

    def __getitem__(self, item: str) -> PyVerifyResult:
        return self._results[item]

    def __setitem__(self, key, value):
        self.add(key, value)

    def __contains__(self, item):
        return item in self._results

    def __len__(self):
        return len(self._results)

    def get(self, item) -> PyVerifyResult | None:
        """
        Gets a result
        """
        return self._results.get(item, None)

    def get_all(self) -> Dict[str, PyVerifyResult]:
        """
        Get all results as dictionary
        """
        return self._results

    def _validate_results(self, output_defs: Dict[str, Output]):
        """
        Validate results against output definitions
        """
        for name in self._results:
            if name not in output_defs:
                self._log.warning(f"Result {name!r} was not declared as test output, hence will not be stored!")
            else:
                if output_defs[name].dtype != self._results_meta[name]["dtype"]:
                    msg = (
                        f"Inferred type {self._results_meta[name]['dtype']!r} of result {name!r} "
                        f"does not match declared type {output_defs[name].dtype!r}"
                    )
                    raise TypeError(msg)

    def _add_global_metadata(self, key: str, value: Any):
        """
        Adds system metadata which have priority over metadata of user (add_global_user_metadata).
        System metadata is added by the PyVerifyBaseTest

        :param key: The metadata name
        :param value: The metadata value
        """
        check_str_type(key)
        self._meta_global[key] = value

    def add_global_user_metadata(self, key: str, value: Any):
        """
        Adds global metadata to store at file level

        :param key: The metadata name
        :param value: The metadata value. Must be JSON-serializable!
        """
        check_str_type(key)
        self._meta_global_user[key] = value

    def add_global_metadata(self, key: str, value: Any):
        warnings.warn(
            "This is deprecated in favor of add_global_user_metadata and will be removed in future releases!",
            FutureWarning,
            stacklevel=2,
        )
        self.add_global_user_metadata(key, value)

    def add_iteration_user_metadata(self, key: str, value: Any):
        """
        Adds metadata for current iteration.

        There are certain default metadata entries we standardized for specific use cases.

        E.g. for CV use case please use following to keys: DUT, Wafer, Lot, DesignStep, ProductIdentifier

        :param key: The metadata name
        :param value: The metadata value. Must be JSON-serializable!
        """
        check_str_type(key)
        self._meta_iteration_user[key] = value

    def add_iteration_metadata(self, key: str, value: Any):
        warnings.warn(
            "This is deprecated in favor of add_iteration_user_metadata and will be removed in future releases!",
            FutureWarning,
            stacklevel=2,
        )
        self.add_iteration_user_metadata(key, value)

    def _add_iteration_metadata(self, key: str, value: Any):
        """
        Adds metadata for current iteration

        :param key: The metadata name
        :param value: The metadata value. Must be JSON-serializable!
        """
        check_str_type(key)
        self._meta_iteration[key] = value

    def add(self, name: str, data: Any, meta_data: Dict[str, Any] = None):
        """
        Store a result with auto-inference of its type.

        .. note::

            A list/tuple or set of numbers is converted to a Waveform. To store n-dim arrays use numpy.ndarray.
        """
        if isinstance(data, bytes):
            self.add_string(name, data, meta_data=meta_data)
        elif isinstance(data, (str, Path)):
            if Path(data).is_file():
                self.add_file(name, data, meta_data=meta_data)
            else:
                self.add_string(name, data, meta_data=meta_data)
        elif is_waveform_type(data):
            self.add_waveform(name, data, meta_data=meta_data)
        elif is_numeric_1dim_list_type(data):
            self.add_waveform(name, Waveform(list(map(float, data))), meta_data=meta_data)
        elif is_number_type(data):
            self.add_numeric(name, data, meta_data=meta_data)
        elif is_array_type(data):
            self.add_array(name, data, meta_data=meta_data)
        else:
            self._log.warning(f"Cannot infer type of object {data!r} for output {name!r}! Ignoring...")

    def add_numeric(
        self,
        name: str,
        data: Number,
        meta_data: Dict[str, Any] = None,
    ):
        """
        Stores a numeric result

        :param name: The declared output name to assign the result to.
        :param data: A numeric value.
        :param meta_data: A metadata dictionary. Must be JSON-serializable!
        """
        if data is None:
            self._log.warning(f"None was assigned to output {name}. Ignoring...")
            return
        m = copy.deepcopy(meta_data or {})
        if not isinstance(m, dict):
            msg = "Argument meta_data must be a dictionary!"
            raise TypeError(msg)
        if isinstance(data, (bool, np.bool_)):
            data = int(data)  # Store bools as integer
        elif not is_number_type(data):
            msg = f"The assigned result type {type(data)} is not a number!"
            raise TypeError(msg)
        m["dtype"] = Output.OutputType.Scalar
        self._results_meta[name] = m
        self._results[name] = data

    def add_string(
        self,
        name: str,
        data: Union[str, bytes],
        encoding: str | None = None,
        meta_data: Dict[str, Any] = None,
    ):
        """
        Stores a string result

        :param name: The declared output name to assign the result to.
        :param data: A string or byte-string.
        :param encoding: Encoding information, otherwise utf-8 will be used for strings and no encoding will be
                         done for bytes input.
        :param meta_data: A metadata dictionary. Must be JSON-serializable!
        """
        if data is None:
            self._log.warning(f"None was assigned to output {name}. Ignoring...")
            return
        m = copy.deepcopy(meta_data or {})
        if not isinstance(m, dict):
            msg = "Argument meta_data must be a dictionary!"
            raise TypeError(msg)
        if not is_string_type(data):
            msg = f"The assigned result type {type(data)} is not a string!"
            raise TypeError(msg)
        m["dtype"] = Output.OutputType.String
        m["encoding"] = encoding
        self._results_meta[name] = m
        self._results[name] = data

    def add_file(
        self,
        name: str,
        data: Union[str, Path],
        meta_data: Dict[str, Any] = None,
    ):
        """
        Stores a file result. The file will be read as binary data and stored in the result file.

        :param name: The declared output name to assign the result to.
        :param data: A string or Path to an existing file
        :param meta_data: A metadata dictionary. Must be JSON-serializable!
        """
        if data is None:
            self._log.warning(f"None was assigned to output {name}. Ignoring...")
            return
        data = Path(data)
        m = copy.deepcopy(meta_data or {})
        if not isinstance(m, dict):
            msg = "Argument meta_data must be a dictionary!"
            raise TypeError(msg)
        if not data.is_file():
            msg = f"The assigned result {data} is not a path to an existing file!"
            raise TypeError(msg)
        m["dtype"] = Output.OutputType.File
        self._results_meta[name] = m
        self._results[name] = data

    def add_array(self, name: str, data: np.ndarray, meta_data: Dict[str, Any] = None):
        """
        Stores a numpy array

        :param name: The declared output name to assign the result to.
        :param data: A numpy array of any dimension.
        :param meta_data: A metadata dictionary. Must be JSON-serializable!
        """
        if data is None:
            self._log.warning(f"None was assigned to output {name}. Ignoring...")
            return
        m = copy.deepcopy(meta_data or {})
        if not isinstance(m, dict):
            msg = "Argument meta_data must be a dictionary!"
            raise TypeError(msg)
        if not is_array_type(data):
            msg = f"The assigned result type {type(data)} is not an array!"
            raise TypeError(msg)
        m["dtype"] = Output.OutputType.Array
        self._results_meta[name] = m
        self._results[name] = data

    def add_waveform(self, name: str, data: Waveform, meta_data: Dict[str, Any] = None):
        """
        Stores a waveform result

        :param name: The declared output name to assign the result to.
        :param data: A waveform instance.
        :param meta_data: A metadata dictionary. Must be JSON-serializable!
        """
        if data is None:
            self._log.warning(f"None was assigned to output {name}. Ignoring...")
            return
        m = copy.deepcopy(meta_data or {})
        if not isinstance(m, dict):
            msg = "Argument meta_data must be a dictionary!"
            raise TypeError(msg)
        if not is_waveform_type(data):
            msg = f"The assigned result type {type(data)} is not a waveform!"
            raise TypeError(msg)
        m["dtype"] = Output.OutputType.Waveform
        self._results_meta[name] = m
        self._results[name] = data

    def update_result_metadata(self, name, **kwargs):
        """
        Updates the metadata of a result.

        :param name: The declared output name to assign the result to.
        :param kwargs: metadata as key-value pairs. Values be JSON-serializable!
        """
        if "dtype" in kwargs:
            msg = "Setting metadata 'dtype' is not allowed since this is used internally!"
            raise ValueError(msg)
        if name not in self._results_meta:
            self._results_meta[name] = {}
        self._results_meta[name].update(kwargs)


class ResultSummary(dict):
    @property
    def Pass(self):
        return self.get("Pass", 0)

    @property
    def Fail(self):
        return self.get("Fail", 0)

    @property
    def Skipped(self):
        return self.get("Skipped", 0)

    @property
    def Unknown(self):
        return self.get("Unknown", 0)

    @property
    def Error(self):
        return self.get("Error", 0)


if __name__ == "__main__":
    pass
