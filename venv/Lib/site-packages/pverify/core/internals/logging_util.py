from __future__ import annotations

import logging
import os
import sys
import textwrap
from os.path import *
from pathlib import Path
from textwrap import TextWrapper
from typing import TYPE_CHECKING

from pverify.core import env
from pverify.core.util.file_ops import prevent_filehandle_inherit

if TYPE_CHECKING:
    from pverify.core.internals.flow_control import MySignal

PYVERIFY_TESTLOGGER = "PyVerify_TestLogger"


class WrappedFixedIndentingLog(logging.Formatter):
    def __init__(self, fmt=None, datefmt=None, style="%", width=70, indent=4):
        logging.Formatter.__init__(
            self,
            fmt=fmt,
            datefmt=datefmt,
            style=style,
        )
        self.wrapper = textwrap.TextWrapper(width=width, subsequent_indent=" " * indent, replace_whitespace=False)

    def format(self, record):
        lev = record.levelno
        if lev == logging.ERROR or "Traceback" in record.msg or "\n" in record.msg:
            return logging.Formatter.format(self, record)
        return self.wrapper.fill(logging.Formatter.format(self, record))


FORMATTER_INFO = WrappedFixedIndentingLog(
    "%(levelname)-7s|%(asctime)s.%(msecs)03d|  %(message)s",
    "%H:%M:%S",
    indent=23,
    width=200,
)


def get_test_logger(prefix=None) -> logging.Logger | logging.LoggerAdapter:
    if prefix is None:
        return logging.getLogger(PYVERIFY_TESTLOGGER)

    class LoggingAdapter(logging.LoggerAdapter):
        def process(self, msg, kwargs):
            return f"{self.extra.get('prefix', '')}{msg}", kwargs

    return LoggingAdapter(get_test_logger(prefix=None), {"prefix": prefix})


def initialize_logger(loglevel):
    logtest = get_test_logger()
    logtest.setLevel(loglevel)


def add_stream_handler(loglevel):
    if env.LOG_STDOUT_ENABLE:
        logtest = get_test_logger()
        warnlogger = logging.getLogger("py.warnings")
        sh = logging.StreamHandler(sys.stdout)
        sh.set_name("logtest_SH")
        sh.setLevel(loglevel)
        sh.setFormatter(FORMATTER_INFO)
        logtest.addHandler(sh)
        warnlogger.addHandler(sh)


def configure_test_logger(logdirectory, loglevel):
    logtest = get_test_logger()
    # Initialize logger
    for h in logtest.handlers[:]:
        if isinstance(h, logging.FileHandler):
            h.close()
            logtest.removeHandler(h)

    logpath = abspath(join(logdirectory, "test.log"))
    fh = logging.FileHandler(filename=logpath, mode="a")
    fh.set_name("logtest_FH")
    fh.setLevel(loglevel)
    fh.setFormatter(FORMATTER_INFO)
    prevent_filehandle_inherit(fh.stream.fileno())
    logtest.addHandler(fh)

    # Add the filehandler also to py.warnings
    logging.getLogger("py.warnings").addHandler(fh)

    os.environ["SRD_USE_PYVERIFY_LOGGER"] = logtest.name


def reset_variation_logger_fh():
    logtest = get_test_logger()
    for h in logtest.handlers[:]:
        if isinstance(h, logging.FileHandler) and h.name == "LOGRUN_FH":
            h.close()
            logtest.removeHandler(h)


def configure_variation_logger_fh(logdirectory, loglevel):
    logtest = get_test_logger()
    # Initialize logger
    reset_variation_logger_fh()

    logpath = abspath(join(logdirectory, "run.log"))
    fh = logging.FileHandler(filename=logpath, mode="w")
    fh.set_name("LOGRUN_FH")
    fh.setLevel(loglevel)
    fh.setFormatter(FORMATTER_INFO)
    prevent_filehandle_inherit(fh.stream.fileno())
    logtest.addHandler(fh)


def reset_loggers():
    logtest = get_test_logger()
    loggers = [logging.getLogger("py.warnings"), logtest]

    for logger in loggers:
        if hasattr(logger, "handlers"):
            for h in logger.handlers[:]:
                h.close()
                logger.removeHandler(h)

    os.environ["SRD_USE_PYVERIFY_LOGGER"] = ""


def create_logger_with_streamhandler_and_filehandler(
    name: str, level: int, filename: str | None = None, stream=sys.stdout, fmt=FORMATTER_INFO, **kwargs
) -> logging.Logger:
    log = logging.getLogger(name)
    log.setLevel(level)

    if stream is not None:
        sh = logging.StreamHandler(stream)
        sh.setLevel(level)
        sh.setFormatter(fmt)
        log.addHandler(sh)

    if filename is not None:
        Path(filename).parent.mkdir(parents=True, exist_ok=True)
        fh = logging.FileHandler(filename, mode=kwargs.get("mode", "w"))
        fh.setLevel(level)
        fh.setFormatter(fmt)
        log.addHandler(fh)

    return log


class GuiLogHandler(logging.StreamHandler):
    errorHtml = '<font style="font-family: courier;white-space: pre-wrap;font-size:12px" color=#FF0000>'
    warningHtml = '<font style="font-family: courier;white-space: pre-wrap;font-size:12px" color=#E7A23D>'
    infoHtml = '<font style="font-family: courier;white-space: pre-wrap;font-size:12px" color=#000000>'
    endHtml = "</font></p>"

    def __init__(
        self,
        sig_display_log_msg: MySignal,
    ):
        logging.StreamHandler.__init__(self)
        self.sig_display_log_msg = sig_display_log_msg

        self.wrapper = TextWrapper(width=200, subsequent_indent=" " * 10)
        self.guipid = -1

    def emit(self, record):
        # Escape characters
        lev = record.levelno
        recordmsg = record.msg
        recordmsg = recordmsg.replace("<", "&lt;")
        recordmsg = recordmsg.replace(">", "&gt;")

        if not (lev == logging.ERROR or "Traceback" in record.msg or "\n" in record.msg):
            recordmsg = self.wrapper.fill(recordmsg)

        if record.levelname == "INFO":
            msg = f"[{record.levelname}   ] {recordmsg}"
            msg = self.infoHtml + msg + self.endHtml
        elif record.levelname == "ERROR":
            msg = f"[{record.levelname}  ] {recordmsg}"
            msg = self.errorHtml + msg + self.endHtml
        elif record.levelname == "WARNING":
            msg = f"[{record.levelname}] {recordmsg}"
            msg = self.warningHtml + msg + self.endHtml
        else:
            return

        self.sig_display_log_msg.emit(msg)
