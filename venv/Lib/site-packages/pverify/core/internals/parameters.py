from __future__ import annotations

import re
from collections import OrderedDict
from collections.abc import Iterable
from numbers import Number
from typing import TYPE_CHECKING, Callable

from pverify.core.internals.unit import ScalarUnit
from pverify.core.util.numeric_util import is_numeric

if TYPE_CHECKING:
    from .Enums import Enums


class Parameters(OrderedDict):
    """A class containing test parameters, which are actually subject to be expanded into parameters."""

    def __init__(self, baseclass):
        OrderedDict.__init__(self)
        self.__baseclass = baseclass
        """:type : pverify.core.pyverify_base_test.PyVerifyBaseTest"""
        self.Add(
            "DUT",
            "",
            "(default parameter) The device under test (lab) or schematic (sim) used for the test.",
            "",
        )
        self.Add(
            "Temp",
            "degC",
            "(default parameter) The environment temperature used for the test.",
            -273.15,
            -273.15,
            10000,
        )

    def __getitem__(self, item) -> Parameter:
        """
        :rtype: Parameter
        """
        return super().__getitem__(item)

    def __contains__(self, item):
        return (item in list(self.keys())) or (item in list(self.values()))

    def Add(self, Name, Unit, Description, DefaultValues, Min=None, Max=None, Validator: str | None = None):
        r"""
        Adds a new parameter to the collection.

        :param Name: The parameter's name
        :type Name: str
        :param Unit: Its unit.

                     It has to be of following form: UNIT[/UNIT]

                     A UNIT can be any character of [a-z,A-Z,%,_] or an empty string.
                     UNIT also may have a multiplier prefix (y,z,a,f,p,n,u,m,k,M,G,T,P,E,Z,Y).
                     When specifying a prefix, you must specify a unit!

                     E.g. a unit 'ppb' would not be 'parts per billion', it would be pico-pb.
                     To overcome this use _ as prefix: '_ppb'.

                     Further examples: mV, mA/us, /Ohm, _/mV, _ppm, ...

        :type Unit: str
        :param Description: The parameter's description
        :type Description: str
        :param DefaultValues: A scalar numeric/string value or a list of numeric/string values
        :param Min: A minimum value for this parameter. Test will fail if a parameter value below 'Min' is
                    included in the sweep
        :type Min: int|float
        :param Max: A maximum value for this parameter. Test will fail if a parameter value below 'Max' is
                    included in the sweep
        :type Max: int|float
        :param Validator:   A Python expression that evaluates to True if
                            the parameter value (local variable x) is valid.
                            Example: 'x in [1,10,100]'

        **Example:**

        .. code-block:: python

          self.Params.Add("Vac", "V", "-", 90)
          self.Params.Add("Vac", "V", "-", [120, 230])


          # Additional examples:

          self.Parameters.Add("Vac", "V", "-", [120, 230])  # Values defined as list
          self.Parameters.Add("Fac", "Hz", "-", 50)  # Scalar value also possible
          self.Parameters.Add("Iload", "A", "-", [i+1 for i in range(2)])
          self.Parameters.Add("Iload", "A", "-", numpy.linspace(start=1, stop=2, num=5, endpoint=True))

        """
        _unit = Unit if Unit else ""
        _descr = Description if Description else ""

        if not isinstance(Name, str) or not Name:
            msg = "A parameter name has to be specified."
            raise Exception(msg)
        if not check_valid_parameter_name(Name):
            msg = "Invalid parameter name. Name may only contain alphanumeric characters including '_'."
            raise ValueError(msg)
        if not ScalarUnit.is_valid_unit(Unit):
            msg = "Invalid unit. Unit has to be specified in SI notation."
            raise ValueError(msg)

        if isinstance(DefaultValues, str) or is_numeric(DefaultValues):
            defvals = [DefaultValues]
        elif isinstance(DefaultValues, Iterable):
            defvals = list(DefaultValues)
            if not (all(isinstance(x, str) for x in defvals) or all(isinstance(x, Number) for x in defvals)):
                msg = "Argument 'DefaultValues' must be a scalar number or string or a list of only numbers or strings!"
                raise TypeError(msg)
        else:
            msg = "Argument DefaultValues must a scalar or iterable of str/numeric!"
            raise TypeError(msg)

        if all(isinstance(x, str) for x in defvals) and any(len(x) > 255 for x in defvals):
            msg = (
                "String parameters must not be longer than 255 characters! "
                "Please reduce the maximun string length or contact the developers to get advice."
            )
            raise ValueError(msg)

        if Name.upper() == "DUT":
            self.update({"DUT": Parameter("DUT", _unit, _descr, defvals, Min, Max)})
        elif Name.upper() == "TEMP":
            self.update({"Temp": Parameter("Temp", _unit, _descr, defvals, Min, Max)})
        elif Name is not None and Name != "":
            self.update({Name: Parameter(Name, _unit, _descr, defvals, Min, Max)})
        else:
            msg = "For a parameter a name has to be specified."
            raise Exception(msg)

    def callback_register(self, parameter: str, callback: Callable, invoke_time: Enums.InvokeTime):
        r"""
        Registers a callback function that is called whenever a parameter or parameter expression changes.
        The point in time when the function is called is determined by the invoke_time argument

        Example::

            class DummyLabTest(PyVerifyLabTest):
                @DoE.Init()
                def init(self):
                    self.Parameters.Add("ch1_factor", "", "", 1)
                    self.Parameters.Add("ch2_factor", "", "", 2)
                    self.Parameters.callback_register(
                        parameter="ch1_factor or ch2_factor",
                        callback=self.on_any_factor_changed,
                        invoke_time=Enums.InvokeTime.BeforeVarLoop
                    )
                    self.Variations.Add_ListSweep("ch1_factor", [1, 2, 3])
                    self.Variations.Add_ListSweep("ch2_factor", [1, 2, 3])

                def on_any_factor_changed(self, **kwargs):
                    print(f"Factor 1: {kwargs['ch1_factor']}, Factor 2: {kwargs['ch2_factor']}")

        :param parameter: The name of the parameter or parameter expression to observe.
                          If the parameter value changes between variations the callback function is called.

                          E.g. Using "P1" as parameter argument: Callback is called whenever P1 changes

                          E.g. Using "(P1 and P2)": Callback is called whenever P1 AND P2 change

                          E.g. Using "(P1 or P2) and P3": Callback is called whenever (P1 OR P2) AND P3 change
        :param callback: The function that is called when the parameter changes, passing the new parameter values as
                         keyword arguments.
                         The function MUST have one of following signatures: methodname(self, \*\*kwargs) or
                         functionname(\*\*kwargs).
        :param invoke_time: Specifies when the function shall be invoked. Use values of Enums.InvokeTime
        """
        self.__baseclass._PVCC.register_callback(parameter, callback, invoke_time)

    def callback_remove(self, index):
        """
        Removes a callback function

        :param index: The index of the callback to remove
        """
        self.__baseclass._PVCC.remove_callback(index)

    def callback_remove_all(self):
        """
        Removes all callback functions
        """
        self.__baseclass._PVCC.remove_all_callbacks()

    def _to_serializeable(self):
        return {k: v._to_serializeable() for k, v in self.items()}


class Parameter:
    def __init__(
        self, Name=None, Unit=None, Description="", DefaultValues=None, Min=None, Max=None, Validator: str | None = None
    ):
        self.Name = Name
        self.Unit = Unit or ""
        self.Description = Description
        if DefaultValues is None:
            msg = f"Default value of parameter '{Name}' must not be None."
            raise Exception(msg)
        if type(DefaultValues) in (list, tuple) and None in DefaultValues:
            msg = f"Default value of parameter '{Name}' must not contains None."
            raise Exception(msg)
        if not isinstance(DefaultValues, (list, tuple)):
            msg = "DefaultValues must be a list/tuple"
            raise Exception(msg)
        self.DefaultValues = DefaultValues
        self.Min = Min
        self.Max = Max
        self.Validator = Validator

    def _to_serializeable(self):
        return self.__dict__

    def validate(self, *values):
        Max = self.Max
        if Max is not None and any(val > Max for val in values if is_numeric(val)):
            msg = (
                f"At least one value inside the sweep definition ({values}) exceeds the maximum value {Max} "
                f"of parameter {self.Name}!"
            )
            raise ValueError(msg)

        Min = self.Min
        if Min is not None and any(val < Min for val in values if is_numeric(val)):
            msg = (
                f"At least one value inside the sweep definition ({values}) exceeds the minimum value {Min} "
                f"of parameter {self.Name}!"
            )
            raise ValueError(msg)

        validator = self.Validator
        if not validator:
            return
        for value in values:
            try:
                valid = eval(validator, {"x": value})
            except Exception as e:
                msg = f"Validation of parameter {self.Name} using {validator!r} raise an error for value {value}: {e}"
                raise ValueError(msg) from None
            if not valid:
                msg = f"Validation of parameter {self.Name} using {validator!r} failed for value {value}!"
                raise ValueError(msg) from None


def check_valid_parameter_name(string):
    """
    Returns true if the string does not contain different characters than a-z A-Z 0-9 . _
    :param string:
    :return:
    """
    return re.search("[^a-zA-Z0-9_.]", string) is None


def check_condition_fulfilled(parameters, condition):
    """
    Ckecks if the specified limit applies to the variation subset.
    :param parameters: Dictionary containing input name input value key-value pairs.
    :param condition: A condition string
    :type condition: str
    :return:
    """
    if condition in (None, ""):
        return True
    if not isinstance(condition, str):
        msg = f"Wrong type {type(condition)} for condition!"
        raise TypeError(msg)

    subs = parameters

    # Fix limit conditions
    condition = condition.replace("||", " or ")
    condition = condition.replace("&&", " and ")
    for p_name in parameters:
        # condition = condition.replace(p_name, r'subs["%s"]' % p_name)
        condition = re.sub(rf"\b{p_name}\b", rf'subs["{p_name}"]', condition)

    return eval(condition, {}, {"subs": subs})


if __name__ == "__main__":
    pass
