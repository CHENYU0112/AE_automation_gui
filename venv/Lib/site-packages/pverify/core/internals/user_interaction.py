from __future__ import annotations

from multiprocessing import Process, Queue
from multiprocessing.queues import Empty as EmptyException


class UserInteraction:
    @staticmethod
    def ask_int(title, message, default, min, max, step=1):
        """
        Query an integer value from the user

        :param title: The window title
        :param message: The message label
        :param default: The default value
        :param min: The minimal input value
        :param max: The maximal input value
        :param step: The step size of the slider
        :return: Integer value
        :rtype: int
        """
        q = Queue(1)
        p = Process(
            target=UserInteraction._qtproc_ask_int,
            args=(q, title, message, default, min, max, step),
        )
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_ask_int(queue, title, message, default, min, max, step=1):
        from qtpy.QtWidgets import QApplication, QInputDialog

        _ = QApplication([]).instance()
        ret, okPressed = QInputDialog.getInt(None, title, message, default, min, max, step)
        if okPressed:
            queue.put(int(ret))
        else:
            queue.put(None)

    @staticmethod
    def ask_float(title, message, default, min, max, decimals):
        """
        Query a float value from the user

        :param title: The window title
        :param message: The message label
        :param default: The default value
        :param min: The minimal input value
        :param max: The maximal input value
        :param decimals: The number of decimals the user can input
        :return: Float value
        :rtype: float
        """
        q = Queue(1)
        p = Process(
            target=UserInteraction._qtproc_ask_float,
            args=(q, title, message, default, min, max, decimals),
        )
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_ask_float(queue, title, message, default, min, max, decimals):
        from qtpy.QtWidgets import QApplication, QInputDialog

        _ = QApplication([]).instance()
        ret, okPressed = QInputDialog.getDouble(None, title, message, default, min, max, decimals)
        if okPressed:
            queue.put(float(ret))
        else:
            queue.put(None)

    @staticmethod
    def ask_text(title, message, text="", multiline=False):
        """
        Query a text from the user

        :param title: The window title
        :param message: The message label
        :param text: The default text
        :param multiline: If True the text can be editted in multiple lines
        :return: Text string
        :rtype: str
        """
        q = Queue(1)
        p = Process(
            target=UserInteraction._qtproc_ask_text,
            args=(q, title, message, text, bool(multiline)),
        )
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_ask_text(queue, title, message, text, multiline=False):
        from qtpy.QtWidgets import QApplication, QInputDialog, QLineEdit

        _ = QApplication([]).instance()
        if multiline:
            ret, okPressed = QInputDialog.getMultiLineText(None, title, message, text)
        else:
            ret, okPressed = QInputDialog.getText(None, title, message, QLineEdit.Normal, text)
        if okPressed:
            queue.put(str(ret))
        else:
            queue.put(None)

    @staticmethod
    def ask_choice(title, message, choices, current=0):
        """
        Let the user choose from a list of choices.

        :param title: The window title
        :param message: The message label
        :param choices: The choices the user can select. Has to be a list/iterable of string values
        :param current: The index of choices that is selected per default
        :return: Text string
        :rtype: str
        """
        q = Queue(1)
        p = Process(
            target=UserInteraction._qtproc_ask_choice,
            args=(q, title, message, choices, int(current)),
        )
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_ask_choice(queue, title, message, choices, current=0):
        from qtpy.QtWidgets import QApplication, QInputDialog

        _ = QApplication([]).instance()
        ret, okPressed = QInputDialog.getItem(None, title, message, choices, current)
        if okPressed:
            queue.put(str(ret))
        else:
            queue.put(None)

    @staticmethod
    def ask_yes_no(title, message):
        """
        Ask a question that the user has to answer with Yes/No. Just closing the windows is interpreted as No

        :param title: The window title
        :param message: The message label
        :return: Text string
        :rtype: bool
        """
        q = Queue(1)
        p = Process(target=UserInteraction._qtproc_ask_yes_no, args=(q, title, message))
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_ask_yes_no(queue, title, message):
        from qtpy.QtWidgets import QApplication, QMessageBox

        _ = QApplication([]).instance()
        ret = QMessageBox.question(None, title, message, QMessageBox.Yes, QMessageBox.No)
        if ret == QMessageBox.Yes:
            queue.put(True)
        else:
            queue.put(False)

    @staticmethod
    def message_inform(title, message):
        """
        Ask a question that the user has to answer with Yes/No. Just closing the windows is interpreted as No

        :param title: The window title
        :param message: The message label
        :return: Text string
        :rtype: bool
        """
        q = Queue(1)
        p = Process(target=UserInteraction._qtproc_message_inform, args=(q, title, message))
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_message_inform(queue, title, message):
        from qtpy.QtWidgets import QApplication, QMessageBox

        _ = QApplication([]).instance()
        _ = QMessageBox.information(None, title, message, QMessageBox.Ok)
        queue.put(None)

    @staticmethod
    def message_warning(title, message):
        """
        Ask a question that the user has to answer with Yes/No. Just closing the windows is interpreted as No

        :param title: The window title
        :param message: The message label
        :return: Text string
        :rtype: bool
        """
        q = Queue(1)
        p = Process(target=UserInteraction._qtproc_message_warning, args=(q, title, message))
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_message_warning(queue, title, message):
        from qtpy.QtWidgets import QApplication, QMessageBox

        _ = QApplication([]).instance()
        _ = QMessageBox.warning(None, title, message, QMessageBox.Ok)
        queue.put(None)

    @staticmethod
    def message_error(title, message):
        """
        Ask a question that the user has to answer with Yes/No. Just closing the windows is interpreted as No

        :param title: The window title
        :param message: The message label
        :return: Text string
        :rtype: bool
        """
        q = Queue(1)
        p = Process(target=UserInteraction._qtproc_message_error, args=(q, title, message))
        p.daemon = True
        ret = None
        p.start()
        while p.is_alive():
            try:
                ret = q.get(block=True, timeout=0.5)
                p.terminate()
            except EmptyException:
                pass
        return ret

    @staticmethod
    def _qtproc_message_error(queue, title, message):
        from qtpy.QtWidgets import QApplication, QMessageBox

        _ = QApplication([]).instance()
        _ = QMessageBox.critical(None, title, message, QMessageBox.Ok)
        queue.put(None)


if __name__ == "__main__":
    print(UserInteraction.ask_yes_no("Title", "Message"))
