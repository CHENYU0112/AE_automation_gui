# ===========================================================================
# Copyright (C) 2012-2013 Infineon Technologies AG
# All rights reserved.
# ===========================================================================
#
# ===========================================================================
# This document contains proprietary information of Infineon Technologies AG.
# Passing on and copying of this document, and communication of its contents
# is not permitted without Infineon's prior written authorisation.
# ===========================================================================
"""
Module contains classes/functions for controlling the flow of a single test.
"""

from __future__ import annotations

import pickle
from multiprocessing import Event
from time import sleep

from pverify.core.internals.Enums import Enums

__all__ = ["FlowControl"]


class Events:
    def __init__(self):
        self.idle_state = Event()  # Signals the idle state of the test
        self.busy_state = Event()  # Signals the busy state of the test
        self.wakeup = Event()  # Signals the wakeup from idle state of the test
        self.gui_ready = Event()
        self.entered_pause = Event()
        self.left_pause = Event()


class MySignal:
    """
    PyQt similar signal class.
    It is possible to emit the signal by sending the signal signature and arguments via Pipe to the GUI, where an
    emitter-thread rebuilds the signal based on the signature and emits the signal.
    The arguments are always sent as string (pickled object) and must be unpickled in the SLOT connected to the signal.
    """

    def __init__(self, signature, pipe=None):
        self.signature = str(signature)
        self.pipe = pipe

    def set_pipe(self, pipe):
        self.pipe = pipe

    def emit(self, *args):
        if self.pipe is not None:
            self.pipe.send((self.signature, pickle.dumps(args)))


class MySignals:
    """Container for custom signals used for communication between test and GUIs"""

    def __init__(self, pipe=None):
        self.display_log_msg = MySignal("display_log_msg", pipe)
        self.test_loaded = MySignal("test_loaded", pipe)
        self.test_started = MySignal("test_started", pipe)
        self.test_done = MySignal("test_done", pipe)
        self.test_terminated = MySignal("test_terminated", pipe)
        self.new_variation = MySignal("new_variation", pipe)
        self.pause_entered = MySignal("pause_entered", pipe)
        self.pause_left = MySignal("pause_left", pipe)
        self.show_gui = MySignal("show_gui", pipe)
        self.show_popup = MySignal("show_popup", pipe)


class FlowControl:
    """
    Class that contains information about how the test shall execute (stop, pause,...) and its status.
    """

    def __init__(self):
        self.PauseRequest = False
        self.StopRequest = False
        self.TestStatus = None
        self.NextState = None
        self.LastLabTest = True


class SoftAbortRequestedError(Exception):
    """
    A specific error that is thrown if a soft stop (stop after preloop, between variations,...) is requested.
    """

    def __init__(self):
        Exception.__init__(self, "A stop was requested.")


def wait_if_pause_requested(test, msg):
    """
    If PauseRequest in FlowControl is True the function waits until it is reset to False
    or if a stop is requested.
    """
    if test._exec_ctrl.PauseRequest:
        tmpState = test._exec_ctrl.TestStatus
        test._exec_ctrl.TestStatus = Enums.TestStatus.Paused
        test._signals.pause_entered.emit(msg)
        test._events.entered_pause.set()
        while test._exec_ctrl.PauseRequest:
            sleep(0.02)
            handle_stop_request(test)
        test._signals.pause_left.emit()
        test._events.left_pause.set()
        test._exec_ctrl.TestStatus = tmpState


def handle_stop_request(test):
    """
    If property StopRequest in FlowControl is True the function raises a specific
    error that is catched in a wrapping layer.
    """
    if (
        test._teehouse_client is not None
        and not test._exec_ctrl.StopRequest
        and test._teehouse_client.is_stop_requested()
    ):
        test._exec_ctrl.StopRequest = True

    if test._exec_ctrl.StopRequest:
        test._exec_ctrl.StopRequest = False
        test._exec_ctrl.PauseRequest = False
        if test._exec_ctrl.TestStatus == Enums.TestStatus.Paused:
            test._events.left_pause.set()
        raise SoftAbortRequestedError
