from __future__ import annotations

import copy
import logging
from typing import TYPE_CHECKING

import numpy as np

from pverify.core.util.numeric_util import is_numeric
from pverify.postproc.waveform import Waveform

from .eval_expressions import eval_expression
from .logging_util import PYVERIFY_TESTLOGGER
from .outputs import Output
from .parameters import Parameter, check_condition_fulfilled
from .specification import Specification, SpecificationResult

if TYPE_CHECKING:
    from .pv_types import PyVerifyParameterType, PyVerifyResultType, SpecificationThresholdType


def _float(x):
    return float(x) if x is not None else None


class SpecificationChecker:
    def __init__(self):
        self.summary_result: dict[int, list[SpecificationResult]] = {}
        self._pdef: dict[str, Parameter] = None
        self._odef: dict[str, Output] = None
        self._log = logging.getLogger(PYVERIFY_TESTLOGGER)

    def validate_configuration(
        self, parameter_defs: dict[str, Parameter], output_defs: dict[str, Output], spec_defs: list[Specification]
    ):
        self._pdef = parameter_defs
        self._odef = output_defs
        self._sdef = spec_defs

        self._log.info("Validating specification definitions...")
        for spec in self._sdef:
            if spec.reference is not None and spec.reference not in self._pdef:
                msg = f"{spec}: Cannot find parameter {spec.reference} to reference to!"
                raise LookupError(msg)
            if spec.reference_output not in self._odef:
                msg = f"{spec}: Cannot create a specification for a non-existent output {spec.reference_output}!"
                raise LookupError(msg)
            if self._odef[spec.reference_output].dtype not in (
                Output.OutputType.Scalar,
                Output.OutputType.Waveform,
                Output.OutputType.Array,
            ):
                msg = (
                    f"Specification checks on output {spec.reference_output!r} "
                    f"not possible! Only scalar, waveform or array outputs can be evaluated!"
                )
                raise NotImplementedError(msg)

            o_dtype = self._odef[spec.reference_output].dtype
            for thres, thres_type in (
                (spec.upper_thres, spec.upper_thres_type),
                (spec.lower_thres, spec.lower_thres_type),
            ):
                if (
                    thres_type in (Specification.LimitType.Expr, Specification.LimitType.PWL)
                    and o_dtype == Output.OutputType.Scalar
                    and spec.reference is None
                ):
                    msg = (
                        "If an expression is used for scalar outputs 'ParameterRef' " "has to be a name of a parameter!"
                    )
                    raise Exception(msg)

                if thres_type == Specification.LimitType.Expr:
                    # Check valid expression
                    try:
                        eval_expression(thres, 1)
                    except Exception:
                        msg = (
                            f"Expression '{thres}' for output {spec.reference_output}'s "
                            f"limit can not be evaluated in Python!"
                        )
                        raise SyntaxError(msg) from None
                elif thres_type == Specification.LimitType.PWL:
                    if len(thres) % 2 != 0:
                        msg = "PWL notation list has to contain an even number of values!"
                        raise Exception(msg)
                    # Check for monotonous rising
                    if not np.all(np.diff(thres[::2], 1) > 0):
                        msg = "PWL x-values have to monotonously rise."
                        raise Exception(msg)
                    if not all(map(is_numeric, thres)):
                        msg = "There are non-numerical values in the PWL notation."
                        raise Exception(msg)

    @staticmethod
    def op_diff(lower_upper: int, expect_result, expect_thres):
        within_spec = None
        diff = expect_result - expect_thres

        diff_max_time = None
        diff_max = None
        if lower_upper == 1:  # Upper limit
            within_spec = diff <= 0
            if not within_spec:
                diff_max = abs(np.max(diff))
                diff_max_time = diff.time[np.argmax(diff.data)] if isinstance(diff, Waveform) else None
        elif lower_upper == 0:  # Lower limit
            within_spec = diff >= 0
            if not within_spec:
                diff_max = abs(np.min(diff))
                diff_max_time = diff.time[np.argmin(diff.data)] if isinstance(diff, Waveform) else None

        return within_spec, diff_max, diff_max_time

    def check(
        self,
        iteration_parameters: dict[str, PyVerifyParameterType],
        iteration_results: dict[str, PyVerifyResultType],
        specification: Specification,
    ):
        if not self._pdef or not self._odef:
            msg = "Must call validate_configuration first!"
            raise Exception(msg)

        odef = self._odef[specification.reference_output]
        result_value = iteration_results.get(specification.reference_output, None)

        # Basic checks
        if odef.dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray) and result_value.ndim != 1:
            msg = (
                f"Cannot perform limit check on array result ({result_value.ndim}-dim) "
                f"{specification.reference_output!r} only for 1-dim arrays!"
            )
            raise Exception(msg)

        if result_value is None:
            if check_condition_fulfilled(iteration_parameters, specification.conditions):
                iter_res = SpecificationResult(
                    result_upper_thres=SpecificationResult.EvalResult.Unknown,
                    result_lower_thres=SpecificationResult.EvalResult.Unknown,
                    error_msg="",
                    specification=specification,
                )
            else:
                iter_res = SpecificationResult(
                    result_upper_thres=SpecificationResult.EvalResult.Skipped,
                    result_lower_thres=SpecificationResult.EvalResult.Skipped,
                    error_msg="",
                    specification=specification,
                )

        elif odef.dtype == Output.OutputType.Waveform and isinstance(result_value, Waveform) and result_value.is_empty:
            iter_res = SpecificationResult(
                result_upper_thres=SpecificationResult.EvalResult.Error,
                result_lower_thres=SpecificationResult.EvalResult.Error,
                error_msg="Waveform is empty",
                specification=specification,
            )

        elif check_condition_fulfilled(iteration_parameters, specification.conditions):
            # Evaluate...
            try:
                output_dtype = odef.dtype

                results = []
                results_rationale = []

                lower_upper: int  # 0=lower, 1=upper
                thres: SpecificationThresholdType
                thres_type: Specification.LimitType
                for lower_upper, thres, thres_type in (
                    (0, specification.lower_thres, specification.lower_thres_type),
                    (1, specification.upper_thres, specification.upper_thres_type),
                ):
                    _result_rationale = None
                    lower_upper_str = ["Lower", "Upper"][lower_upper]
                    excdec = ["deceeded", "exceeded"][lower_upper]

                    xrange_slice_float = (
                        [_float(specification.x_range[0]), _float(specification.x_range[1]), None, 1]
                        if specification.x_range is not None
                        else [None, None, None, 1]
                    )

                    if thres is None:
                        _result = True

                    elif thres_type == Specification.LimitType.Scalar:
                        if output_dtype == Output.OutputType.Scalar and not is_numeric(result_value):
                            msg = (
                                f"Output '{specification.reference_output}' is specified as scalar, "
                                f"but '{result_value}' has a different datatype!"
                            )
                            raise Exception(msg)
                        if output_dtype == Output.OutputType.Scalar and np.iscomplexobj(result_value):
                            _result, _diff, _diff_max_time = self.op_diff(lower_upper, abs(result_value), thres)
                            if not _result:
                                _result_rationale = f"{lower_upper_str} limit {thres!r} {excdec} by {_diff:.6g}"

                        elif output_dtype == Output.OutputType.Scalar and is_numeric(result_value):
                            _result, _diff, _diff_max_time = self.op_diff(lower_upper, float(result_value), thres)
                            if not _result:
                                _result_rationale = f"{lower_upper_str} limit {thres!r} {excdec} by {_diff:.6g}"
                        elif (output_dtype == Output.OutputType.Waveform and isinstance(result_value, Waveform)) or (
                            output_dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray)
                        ):
                            if output_dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray):
                                # Convert 1-dim array to waveform to reuse limit check mechanism
                                result_value = Waveform(result_value)

                            try:
                                _result, _diff, _diff_max_time = self.op_diff(
                                    lower_upper, result_value.slice_by_time(*xrange_slice_float), thres
                                )
                            except IndexError:
                                msg = f"Failed to slice {result_value} in x-range {specification.x_range}"
                                raise Exception(msg) from None
                            if not _result:
                                _result_rationale = (
                                    f"{lower_upper_str} limit {thres!r} {excdec} by max. {_diff:.6g}"
                                    f" at x={_diff_max_time:.6g}"
                                )

                        else:
                            msg = (
                                f"Cannot perform limit check on output {specification.reference_output!r} "
                                f"(type: {type(result_value)}) and limit '{thres}'"
                            )
                            raise Exception(msg)

                    elif thres_type == Specification.LimitType.PWL:
                        if output_dtype == Output.OutputType.Scalar and not is_numeric(result_value):
                            msg = f"Cannot compare string result ('{result_value}') against limit ({thres})."
                            raise Exception(msg)
                        if output_dtype == Output.OutputType.Scalar and is_numeric(result_value):
                            pval = iteration_parameters[specification.reference]
                            lim_x = thres[::2]
                            lim_y = thres[1::2]
                            if lim_x[0] > 0:
                                lim_x.insert(0, 0.0)
                                lim_y.insert(0, lim_y[0])
                            if lim_x[-1] < pval:
                                lim_x.append(pval)
                                lim_y.append(lim_y[-1])
                            w_lim = Waveform(lim_y, lim_x)
                            thres_result = w_lim.interpolate(pval)
                            _result, _diff, _diff_max_time = self.op_diff(lower_upper, result_value, thres_result)

                            if not _result:
                                _result_rationale = f"{lower_upper_str} limit {thres_result!r} {excdec} by {_diff:.6g}"

                        elif (output_dtype == Output.OutputType.Waveform and isinstance(result_value, Waveform)) or (
                            output_dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray)
                        ):
                            if output_dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray):
                                # Convert 1-dim array to waveform to reuse limit check mechanism
                                result_value = Waveform(result_value)

                            if specification.reference is None:  # PWL refers to time of waveform
                                lim_x = thres[::2]
                                lim_y = thres[1::2]
                                if lim_x[0] > result_value.time[0]:
                                    lim_x.insert(0, result_value.time[0])
                                    lim_y.insert(0, lim_y[0])
                                if lim_x[-1] < result_value.time[-1]:
                                    lim_x.append(result_value.time[-1])
                                    lim_y.append(lim_y[-1])
                                try:
                                    w_result = result_value.slice_by_time(*xrange_slice_float)
                                except IndexError:
                                    msg = f"Failed to slice {result_value} in x-range {specification.x_range}"
                                    raise Exception(msg) from None
                                w_lim = Waveform(lim_y, lim_x).interpolate(w_result.time)
                                _result, _diff, _diff_max_time = self.op_diff(lower_upper, w_result, w_lim)

                                if not _result:
                                    _result_rationale = (
                                        f"{lower_upper_str} limit {thres!r} {excdec} "
                                        f"{w_lim[_diff_max_time]:.6g} by max. {_diff:.6g} at x={_diff_max_time:.6g}"
                                    )

                            else:  # PWL refers to linked parameter -> static limit for specific input
                                pval = iteration_parameters[specification.reference]
                                lim_x = thres[::2]
                                lim_y = thres[1::2]
                                if lim_x[0] > 0:
                                    lim_x.insert(0, 0.0)
                                    lim_y.insert(0, lim_y[0])
                                if lim_x[-1] < pval:
                                    lim_x.append(pval)
                                    lim_y.append(lim_y[-1])
                                w_lim = Waveform(lim_y, lim_x)
                                try:
                                    w_result = result_value.slice_by_time(*xrange_slice_float)
                                except IndexError:
                                    msg = f"Failed to slice {result_value} in x-range {specification.x_range}"
                                    raise Exception(msg) from None
                                _result, _diff, _diff_max_time = self.op_diff(
                                    lower_upper, w_result, w_lim.interpolate(pval)
                                )

                                if not _result:
                                    _result_rationale = (
                                        f"{lower_upper_str} limit {thres!r} {excdec} "
                                        f"{w_lim[_diff_max_time]:.6g} by max. "
                                        f"{_diff:.6g} at x={_diff_max_time:.6g}"
                                    )
                        else:
                            msg = (
                                f"Cannot perform limit check on output {specification.reference_output!r} "
                                f"(type: {type(result_value)}) and limit '{thres}'"
                            )
                            raise Exception(msg)

                    elif thres_type == Specification.LimitType.Expr:
                        if output_dtype == Output.OutputType.Scalar and not is_numeric(result_value):
                            msg = f"Cannot compare string result ('{result_value}') against limit ({thres})."
                            raise Exception(msg)
                        if output_dtype == Output.OutputType.Scalar and is_numeric(result_value):
                            # Example: Output is measured Vac, limit is EXPR("0.9*$x") with ParameterRef="Vac" (Input)
                            pval = iteration_parameters[specification.reference]
                            try:
                                lim_y = np.ndarray.item(eval_expression(thres, pval))
                                _result, _diff, _diff_max_time = self.op_diff(lower_upper, result_value, lim_y)
                            except Exception:
                                _result = False

                            if not _result:
                                _result_rationale = f"{lower_upper_str} limit {lim_y!r} {excdec} by {_diff:.6g}"

                        elif (output_dtype == Output.OutputType.Waveform and isinstance(result_value, Waveform)) or (
                            output_dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray)
                        ):
                            if output_dtype == Output.OutputType.Array and isinstance(result_value, np.ndarray):
                                # Convert 1-dim array to waveform to reuse limit check mechanism
                                result_value = Waveform(result_value)

                            if specification.reference is None:
                                try:
                                    w_result = result_value.slice_by_time(*xrange_slice_float)
                                except IndexError:
                                    msg = f"Failed to slice {result_value} in x-range {specification.x_range}"
                                    raise Exception(msg) from None
                                lim_x = w_result.time
                                lim_y = eval_expression(thres, lim_x)
                                w_lim = Waveform(lim_y, lim_x)
                                _result, _diff, _diff_max_time = self.op_diff(lower_upper, w_result, w_lim)

                                if not _result:
                                    _result_rationale = (
                                        f"{lower_upper_str} limit {thres!r}"
                                        f" {excdec} {w_lim[_diff_max_time]:.6g} by "
                                        f"max. {_diff:.6g} at x={_diff_max_time:.6g}"
                                    )

                            else:
                                pval = iteration_parameters[specification.reference]
                                try:
                                    lim_y = eval_expression(thres, pval)[0].item()
                                    try:
                                        w_result = result_value.slice_by_time(*xrange_slice_float)
                                    except IndexError:
                                        msg = f"Failed to slice {result_value} in x-range {specification.x_range}"
                                        raise Exception(msg) from None
                                    _result, _diff, _diff_max_time = self.op_diff(lower_upper, w_result, lim_y)
                                except Exception:
                                    _result = False

                                if not _result:
                                    _result_rationale = (
                                        f"{lower_upper_str} limit {thres!r} "
                                        f"{excdec} {lim_y!r} by max. {_diff:.6g} at x={_diff_max_time:.6g}"
                                    )
                        else:
                            msg = (
                                f"Cannot perform limit check on output {specification.reference_output!r} "
                                f"(type: {type(result_value)}) and limit '{thres}'"
                            )
                            raise Exception(msg)

                    #  UNKNOWN  #
                    else:
                        msg = f"Unknown limit type '{type}'"
                        raise TypeError(msg)

                    results.append(_result)
                    results_rationale.append(_result_rationale)

                iter_res = SpecificationResult(
                    result_upper_thres=[
                        SpecificationResult.EvalResult.Fail,
                        SpecificationResult.EvalResult.Pass,
                    ][int(bool(results[0]))],
                    result_lower_thres=[
                        SpecificationResult.EvalResult.Fail,
                        SpecificationResult.EvalResult.Pass,
                    ][int(bool(results[1]))],
                    error_msg="",
                    specification=specification,
                    results_rationale=results_rationale,
                )

            except Exception as e:
                iter_res = SpecificationResult(
                    result_upper_thres=SpecificationResult.EvalResult.Error,
                    result_lower_thres=SpecificationResult.EvalResult.Error,
                    error_msg=f"{e.__class__.__name__}: {e}",
                    specification=specification,
                )

        else:
            iter_res = SpecificationResult(
                result_upper_thres=SpecificationResult.EvalResult.Skipped,
                result_lower_thres=SpecificationResult.EvalResult.Skipped,
                error_msg="",
                specification=specification,
            )

        if specification.uid not in self.summary_result:
            self.summary_result[specification.uid] = []
        self.summary_result[specification.uid].append(iter_res)
        return iter_res

    def get_results(
        self,
        iteration: int,
        case_sensitive: bool = False,
        partial_match: bool = False,
        *,
        alias: str | None = None,
        output: str | None = None,
    ) -> list[SpecificationResult]:
        if not output and not alias or alias and output:
            msg = "Either 'alias' OR 'output' have to be given!"
            raise ValueError(msg)
        if alias:
            to_lookup = alias
            lookup_key = "alias"
        else:
            to_lookup = output
            lookup_key = "reference_output"

        if not self.summary_result:
            msg = (
                "No specification available yet! The first time this function produces valid results, "
                "is the 'DoE.PostExportResults' stage of the first iteration."
            )
            raise Exception(msg)
        iteration_results = []
        for v in self.summary_result.values():
            try:
                iteration_results.append(v[iteration])
            except IndexError:
                msg = (
                    f"Accessing specification results of iteration {iteration} failed. "
                    f"Results available for iterations 0-{len(v) - 1}"
                )
                raise IndexError(msg) from None
        found = []
        for res in iteration_results:
            lookup_value = getattr(res.specification, lookup_key)
            if not case_sensitive:
                to_lookup = to_lookup.lower()
                lookup_value = lookup_value.lower()
            if partial_match and to_lookup in lookup_value:
                found.append(copy.deepcopy(res))
            if not partial_match and to_lookup == lookup_value:
                found.append(copy.deepcopy(res))
        if not found:
            msg = f"Cannot find spec with {lookup_key} {to_lookup!r}!"
            raise LookupError(msg)
        return found
