from __future__ import annotations

import json
import sys
from multiprocessing import Process, Queue
from multiprocessing.queues import Empty as EmptyException
from os.path import expanduser
from pathlib import Path

from pverify.core.io.hdf5_handler import H5_TestResult

from .logging_util import get_test_logger


class postproc_mode_handler:
    def __init__(self):
        self._result_hdf_path: Path = None
        self._log = get_test_logger("Postprocessing-only mode: ")

    def _check_valid_file(self, file: str):
        if file in ("", None):
            return False
        file = Path(file)
        valid = file.exists() and file.is_file() and file.suffix.lower() in (".hdf5", ".dlh5")
        if valid and file.suffix.lower() == ".hdf5":
            return len(list(file.parent.glob("run[0-9]*"))) > 0
        return valid

    def select_file(self, path_test_results):
        """Reloads only variation table"""
        if not self._check_valid_file(path_test_results):
            self._log.warning(
                f"{path_test_results} is not an "
                f"existing file path! Prompting user to select a valid path instead..."
            )
            path_test_results = file_prompt_process(
                "Select HDF5 result overview file", "PyVerify Results (*.hdf5 *.dlh5)"
            )

        if not self._check_valid_file(path_test_results):
            msg = f"Selected path {path_test_results} does not exist!"
            raise Exception(msg)

        self._result_hdf_path = Path(path_test_results)
        return self._result_hdf_path

    def get_test_variation_table(self):
        self._log.info(f"Reloading test results from PyVerify result file '{self._result_hdf_path}'")
        if self._result_hdf_path.suffix.lower() == ".hdf5":
            h5test = H5_TestResult(str(self._result_hdf_path))
            table = h5test.variation_table
            h5test.closefh()
            return table
        if self._result_hdf_path.suffix.lower() == ".dlh5":
            from pverify.core.io.pv_dlh5 import PyVerifyDLH5 as DLH5

            with DLH5(self._result_hdf_path.with_suffix(".dlh5"), DLH5.Mode.ReadOnly) as h:
                index = h.get_index_operating_conditions()
                if h.get_version() == "0.1.0":
                    return [{k: json.loads(v)["value"] for k, v in line[1].items()} for line in index]
                return [dict(line[1].items()) for line in index]
        return None

    def get_test_variation_results(self, index: int):
        """
        Takes self.restored_result_table and restores the real result. Includes importing of exported waveforms.
        """
        self._log.info("Overwriting variation results")
        if self._result_hdf_path.suffix.lower() == ".hdf5":
            with H5_TestResult(str(self._result_hdf_path)) as h5test:
                h5var = h5test.get_variation(index)
            _, data = h5var.restore_variation_results(outputs=None)
            h5var.closefh()
            return {k: (v[0], {}) for k, v in data.items()}

        if self._result_hdf_path.suffix.lower() == ".dlh5":
            from pverify.core.io.pv_dlh5 import PyVerifyDLH5 as DLH5

            with DLH5(self._result_hdf_path.with_suffix(".dlh5"), DLH5.Mode.ReadOnly) as h:
                grp = h.file_get_group(index)
                channels = h.list_channels(grp)
                results = {}
                for ch in channels:
                    data, metadata = h.group_get_channel(grp, ch)
                    #   legacy                   new tag
                    if (
                        "asjson" in metadata
                        or "specresult" in metadata
                        or metadata.get("subtype", "") == "specification_result"
                    ):
                        # Skip spec results
                        continue
                    results[ch] = (data, metadata)
                return results
        return None


def file_prompt_process(caption, filter, dironly=False):
    q = Queue(1)
    p = Process(target=file_prompt, args=(q, caption, filter, dironly))
    p.daemon = True
    p.start()
    path = ""
    while p.is_alive():
        try:
            path = q.get(block=True, timeout=0.5)
            path = str(path)
            p.terminate()
        except EmptyException:
            pass

    return path


def file_prompt(queue, caption, filter, dironly=False):
    if sys.platform in ["linux", "linux2"]:
        HOMEPATH = expanduser("~")
    else:
        HOMEPATH = "C:/"
    from qtpy.QtWidgets import QApplication, QFileDialog

    _ = QApplication([]).instance()
    if dironly:
        ret = QFileDialog.getExistingDirectory(
            caption=caption,
            directory=HOMEPATH,
            options=QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks,
        )
    else:
        ret = QFileDialog.getOpenFileName(caption=caption, filter=filter, directory=HOMEPATH)[0]
    if ret:
        queue.put(ret)
    else:
        queue.put("")


if __name__ == "__main__":
    pass
