from __future__ import annotations

import re

import numpy as np

if __name__ == "__main__":
    from pverify.core.util.numeric_util import is_numeric
else:
    from pverify.core.util.numeric_util import is_numeric

PREFIXES = "yzafpnumkMGTPEZY"
SI = "[yzafpnumkMGTPEZY]?([a-zA-Z%_]+)"


class ScalarUnit:
    class InvalidUnitError(Exception):
        pass

    def __init__(self, unit: str):
        self.unit_str = str(unit).replace(" ", "")
        self.__unscaled = None  # type: str
        self.__scale_factor = None  # type: float

        if any(x in unit for x in "()"):
            msg = f"Invalid character(s) in unit '{unit}'!"
            raise ScalarUnit.InvalidUnitError(msg)

        # Check if unit contains "/"
        unit_str = self.unit_str
        cnt_div = self.unit_str.count("/")
        is_div = cnt_div == 1

        if cnt_div > 1:
            msg = "Unit may only contain a single /"
            raise ScalarUnit.InvalidUnitError(msg)

        nom = unit_str.split("/", maxsplit=1)[0]
        match = re.match(SI, nom)
        if match is not None:
            if any(nom.startswith(x) for x in PREFIXES):
                if len(nom) == 1:
                    msg = (
                        f"Invalid unit '{nom}': when using a scaling prefix (yzafpnumkMGTPEZY) a unit must be supplied!"
                    )
                    raise ScalarUnit.InvalidUnitError(msg)
                nom_unscaled = nom[1:]
            else:
                nom_unscaled = nom
        else:
            if nom == "":
                nom_unscaled = ""
            else:
                msg = f"'{nom}' is invalid!"
                raise ScalarUnit.InvalidUnitError(msg)
        nom_scale_factor = siEval("1" + nom)

        if is_div:
            denom = unit_str.split("/", maxsplit=1)[1]
            match = re.match(SI, denom)
            if match is not None:
                if any(denom.startswith(x) for x in PREFIXES):
                    if len(denom) == 1:
                        msg = (
                            f"Invalid unit '{denom}': when using a scaling prefix (yzafpnumkMGTPEZY) "
                            f"a unit must be supplied!"
                        )
                        raise ScalarUnit.InvalidUnitError(msg)
                    denom_unscaled = denom[1:]
                else:
                    denom_unscaled = denom
            else:
                if denom == "":
                    denom_unscaled = ""
                else:
                    msg = f"'{denom}' is invalid!"
                    raise ScalarUnit.InvalidUnitError(msg)
            denom_scale_factor = siEval("1" + denom)
        else:
            denom = ""
            denom_unscaled = ""
            denom_scale_factor = 1

        if not is_div:
            self.unit_str = nom
            self.__unscaled = nom_unscaled
        else:
            if nom_unscaled == "" and denom_unscaled == "":
                self.unit_str = ""
                self.__unscaled = ""
            elif nom_unscaled == "" and denom_unscaled != "":
                self.unit_str = "/" + denom
                self.__unscaled = "/" + denom_unscaled
            elif nom_unscaled != "" and denom_unscaled == "":
                self.unit_str = nom
                self.__unscaled = nom_unscaled
            elif nom_unscaled != "" and denom_unscaled != "":
                self.unit_str = nom + "/" + denom
                self.__unscaled = nom_unscaled + "/" + denom_unscaled

        self.__scale_factor = nom_scale_factor / denom_scale_factor
        if self.__scale_factor > 1.1:
            self.__scale_factor = np.round(self.__scale_factor, -3)
        elif 0.9 < self.__scale_factor <= 1.1:
            self.__scale_factor = 1.0

    def __str__(self):
        return self.unit_str

    def __repr__(self):
        return self.__str__()

    @property
    def unscaled(self):
        return self.__unscaled

    @property
    def scale_factor(self):
        return self.__scale_factor

    def unscale(self, value):
        if is_numeric(value) and self.scale_factor != 1.0:
            return value * self.scale_factor, True
        return value, False

    @staticmethod
    def check_valid_unit(unit: str):
        try:
            _ = ScalarUnit(unit)
        except Exception as e:
            msg = f"Invalid unit '{unit}': {e}"
            raise ScalarUnit.InvalidUnitError(msg) from None

    @staticmethod
    def is_valid_unit(unit: str):
        try:
            ScalarUnit.check_valid_unit(unit)
            return True
        except Exception:
            return False

    @staticmethod
    def is_string_unit(unit: str):
        return unit == "<string>"

    @staticmethod
    def is_array_unit(unit: str):
        return unit == "<array>"

    @staticmethod
    def is_file_unit(unit: str):
        return unit == "<file>"

    @staticmethod
    def check_valid_waveform_unit(unit: str):
        match = re.match(r"(.*)\((.*)\)$", unit)
        if match is None:
            msg = f"Invalid unit '{unit}'!"
            raise ScalarUnit.InvalidUnitError(msg)
        part1, part2 = match.groups()
        try:
            for p in (part1, part2):
                _ = ScalarUnit(p)
        except Exception as e:
            msg = f"Invalid unit '{unit}': {e}"
            raise ScalarUnit.InvalidUnitError(msg) from None

    @staticmethod
    def is_waveform_unit(unit: str):
        try:
            ScalarUnit.check_valid_waveform_unit(unit)
            return True
        except Exception:
            return False


def siEval(s):
    """
    Convert a value written in SI notation to its equivalent prefixless value

    Example::

        siEval("100 μV")  # returns 0.0001
    """
    SI_PREFIXES = "yzafpnµm kMGTPEZY"

    m = re.match(r"(-?((\d+(\.\d*)?)|(\.\d+))([eE]-?\d+)?)\s*([u" + SI_PREFIXES + r"]?).*$", s)
    if m is None:
        msg = f"Can't convert string '{s}' to number."
        raise Exception(msg)
    v = float(m.groups()[0])
    p = m.groups()[6]
    # if p not in SI_PREFIXES:
    # raise Exception("Can't convert string '%s' to number--unknown prefix." % s)
    if p == "":
        n = 0
    elif p == "u":
        n = -2
    else:
        n = SI_PREFIXES.index(p) - 8
    return v * 1000**n


if __name__ == "__main__":
    # Shall work
    ScalarUnit.check_valid_unit("")
    # ScalarUnit.check_valid_unit("V")
    # ScalarUnit.check_valid_unit("V/s")
    # ScalarUnit.check_valid_unit("mV/s")
    #
    ScalarUnit.check_valid_waveform_unit("")
    # ScalarUnit.check_valid_waveform_unit("V()")
    # ScalarUnit.check_valid_waveform_unit("(mA)")
    # ScalarUnit.check_valid_waveform_unit("V(ms)")
    # ScalarUnit.check_valid_waveform_unit("mV/s(ms/uA)")

    u = ScalarUnit("/")
    u = ScalarUnit("mV/")
    u = ScalarUnit("_/mV")
    u = ScalarUnit("/mV")

    # Shall not work

    for unit in ("", "_ppm", "mppm", "mV/V", "uV/kV", "V/mV", "mV/uV", "yV/YV"):
        u = ScalarUnit(unit)
        print("Unit: " + unit)
        print("  unscaled: " + u.unscaled)
        print(f"  factorS:   {u.scale_factor}")
        print(f"  factorF:   {u.scale_factor:.15f}")
        for x in (
            0,
            0.0000001,
            0.000001,
            0.00001,
            0.0001,
            0.001,
            0.01,
            0.1,
            1,
            10,
            100,
            1000,
            1000000,
        ):
            print(f"    {x} {u.unit_str} is {u.unscale(x)[0]} {u.unscaled}")
