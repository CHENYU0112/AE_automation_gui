from __future__ import annotations

import inspect
import traceback
from collections import OrderedDict
from typing import Callable

from .Enums import Enums


class ParameterValueChangeCallbacks:
    def __init__(self, baseclass):
        self.__tbc = baseclass
        """:type : pverify.core.pyverify_base_test.PyVerifyBaseTest"""

        self.__ave_last_variation = (
            OrderedDict()
        )  # Is set via test controller and contains parameters which are varied globally
        self.__registry = []  # type: List[ParameterValueChangeCallback]

    @property
    def last_var(self):
        return self.__tbc.Last_variation

    @property
    def curr_var(self):
        return self.__tbc.Current_variation

    def parameter_changed(self, parameter):
        """

        :return:  Tuple: (parameter changed, new parameter value, first parameter change)
        :rtype: (bool, float|str, bool)
        """
        dl = self.last_var.get(parameter, None)
        dc = self.curr_var.get(parameter, None)

        if dl is None and dc is None:
            return False, None, False
        if dl is None and dc is not None:
            return True, dc, True
        if dl is not None and dc is None:
            msg = (
                f"Parameter '{parameter}' of last variation cannot have a value ({dl}) "
                f"while value of current variation is undefined!"
            )
            raise ValueError(msg)
        if dl is not None and dc is not None:
            return dl != dc, dc, False
        msg = f"Undefined input, tl={dl}, tc={dc}"
        raise ValueError(msg)

    def set_last_variation(self, data: dict):
        orig_pnames = set(self.__tbc.Parameters.keys())
        data_pnames = set(data.keys())
        intersect = orig_pnames.intersection(data_pnames)
        self._last_variation = OrderedDict([(k, data[k]) for k in orig_pnames if k in intersect])

    def register_callback(self, parameter: str, callback: Callable, invoke_time: Enums.InvokeTime):
        """
        Registers a callback function that is called whenever the parameter changes. The point in time when the function
        is called is determined by the invoke_time argument

        :param parameter: The name of the parameter or parameter expression to observe.
                          If the parameter value changes between variations the callback function is called.

                          E.g. Using "P1" as parameter argument: Callback is called whenever P1 changes

                          E.g. Using "(P1 and P2)": Callback is called whenever P1 AND P2 change

                          E.g. Using "(P1 or P2) and P3": Callback is called whenever (P1 OR P2) AND P3 change
        :param callback: The function that is called when the parameter changes, passing the new parameter values as
                         keyword arguments.
                         The function MUST have one of following signatures: methodname(self, **kwargs) or
                         functionname(**kwargs).
        :param invoke_time: Specifies when the function shall be invoked. Use values of Enums.InvokeTime
        """
        if not callable(callback):
            msg = f"Argument {callback!s} is not callable!"
            raise TypeError(msg)

        argspec = inspect.getfullargspec(callback)
        if argspec.varkw is None:
            msg = "The callable function must contain '**kwargs' as an argument!"
            raise TypeError(msg)
        if argspec.varargs is not None:
            msg = "The callable function must not contain variable arguments (*args) as an argument!"
            raise TypeError(msg)
        if argspec.args not in (["self"], []):
            msg = (
                "The callable function must not contain other arguments except 'self' (if used inside a class) "
                "and '**kwargs'"
            )
            raise TypeError(msg)
        if invoke_time not in Enums.InvokeTime:
            msg = f"Invalid value of argument 'invoke_time': {invoke_time}"
            raise ValueError(msg)

        self.__registry.append(ParameterValueChangeCallback(parameter, callback, invoke_time))

    def remove_callback(self, index: int):
        """
        Removes a callback function

        :param index: The index of the callback to remove
        """
        self.__registry.pop(index)

    def remove_all_callbacks(self):
        """
        Removes all callback functions
        """
        self.__registry.clear()

    def process_callbacks(self, invoke_time: Enums.InvokeTime):
        if len(self.__registry):
            self.__tbc.Utils.LogInfo(f"Processing callbacks for invoketime <{invoke_time.name}>...")

            avail_params = [p.Name for p in self.__tbc.Parameters.values()]

            for reg in self.__registry:
                if reg.invoke_time == invoke_time:
                    p_in_expr = [p for p in avail_params if p in reg.parameter]

                    if len(p_in_expr) == 1:
                        p_changed, p_newval, p_firstchange = self.parameter_changed(p_in_expr[0])
                        if p_changed:
                            self.__tbc.Utils.LogInfo(
                                f"    Value of parameter '{reg.parameter}' changed to '{p_newval}', "
                                f"invoking callback '{reg.callback}'"
                            )
                            try:
                                reg.callback(**{reg.parameter: p_newval})
                            except Exception:
                                self.__tbc.Utils.LogError(
                                    f"    An exception occurred when invoking the callback '{reg.callback}':"
                                    f"\n{traceback.format_exc()}"
                                )
                    elif len(p_in_expr) > 1:
                        p_in_expr_changed = [[p, *list(self.parameter_changed(p)[:2])] for p in p_in_expr]
                        eval_expr = reg.parameter
                        eval_expr = eval_expr.replace("&&", " and ")
                        eval_expr = eval_expr.replace("||", " or ")
                        context = {item[0]: item[1] for item in p_in_expr_changed}
                        try:
                            p_changed = eval(eval_expr, {}, context)
                        except Exception:
                            self.__tbc.Utils.LogError(
                                "    An exception occurred when evaluating the parameter expression "
                                f"'{reg.parameter}' ('{eval_expr}'):\n{traceback.format_exc()}"
                            )
                            return
                        if p_changed:
                            self.__tbc.Utils.LogInfo(
                                f"    A value of one of the parameters in expression '{reg.parameter}' "
                                f"('{eval_expr}') changed, invoking callback '{reg.callback}'"
                            )
                            try:
                                reg.callback(**{p[0]: p[2] for p in p_in_expr_changed})
                            except Exception:
                                self.__tbc.Utils.LogError(
                                    f"    An exception occurred when invoking the callback "
                                    f"'{reg.callback}':\n{traceback.format_exc()}"
                                )

                    else:
                        self.__tbc.Utils.LogError(
                            f"    There are no parameters in the expression '{reg.parameter}' "
                            f"that are defined in the test!"
                        )


class ParameterValueChangeCallback:
    def __init__(self, parameter: str, callback: Callable, invoke_time: Enums.InvokeTime):
        self.parameter = parameter
        self.callback = callback
        self.invoke_time = invoke_time


if __name__ == "__main__":
    pass
