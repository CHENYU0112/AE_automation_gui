from __future__ import annotations

import sys
import traceback
import warnings
from pathlib import Path
from time import sleep
from typing import TYPE_CHECKING

from pverify.core.util.numeric_util import is_numeric
from pverify.postproc.waveform import Waveform

from . import flow_control
from .logging_util import get_test_logger
from .notifications import Notifications
from .user_interaction import UserInteraction

if TYPE_CHECKING:
    from .specification import SpecificationResult

PY3 = sys.version_info > (3,)


class IterationInterruptedError(InterruptedError):
    pass


class Utils:
    """
    A collection of useful methods for test programming, debugging and interactive usage.

    Access as follows in test:

    .. code-block:: python

        self.Utils.LogInfo(...)

    """

    def __init__(self, BaseClass):
        """

        :type BaseClass: pverify.core.pyverify_base_test.PyVerifyBaseTest
        """
        self.__BaseClass = BaseClass

        self.__Notifications = Notifications(self.__BaseClass)
        self.__UserInteraction = UserInteraction
        self.__log = get_test_logger()

    @property
    def Notifications(self):
        """
        A container class for notification routines
        """
        return self.__Notifications

    @property
    def UserInteraction(self):
        """
        A container class for user interaction routines
        """
        return self.__UserInteraction

    def LogDebug(self, message, **kwargs):
        """
        Created a log entry for the test with a time stamp.

        :param message: The message to be logged.
        """
        self.__log.debug(str(message), **kwargs)

    def LogInfo(self, message, **kwargs):
        """
        Created a log entry for the test with a time stamp.

        :param message: The message to be logged.
        """
        self.__log.info(str(message), **kwargs)

    def LogWarning(self, message, **kwargs):
        """
        Created a log entry for the test with a time stamp.

        :param message: The message to be logged.
        """
        self.__log.warning(str(message), **kwargs)

    def LogError(self, message, **kwargs):
        """
        Created a log entry for the test with a time stamp.

        :param message: The message to be logged.
        """
        self.__log.error(str(message), **kwargs)

    def GetLogger(self, prefix=""):
        """
        Returns a logging adapter to the current test logger to be used by the test.

        :param prefix: The prefix for the adapter. It will be prefixed to all log messages printed with this logger
        """
        return get_test_logger(prefix=prefix)

    def SetBreakPoint(self, message=None):
        """
        Sets a breakpoint, where the test can be aborted or stopped by the test controller.

        :param message: A description where the breakpoint is located
        """
        if not (self.__BaseClass._is_interactive_test and self.__BaseClass.RunOptions.SuppressGUI):
            sleep(0.001)
            flow_control.handle_stop_request(self.__BaseClass)
            flow_control.wait_if_pause_requested(self.__BaseClass, message)

    def SetAutoBreakPoint(self, message=None):
        """
        Sets a breakpoint, where the test can be aborted or stopped by the test controller.

        The test is automatically paused at this breakpoint without the need to press 'Pause' in the GUI.

        :param message: A description where the breakpoint is located
        """
        if not (self.__BaseClass._is_interactive_test and self.__BaseClass.RunOptions.SuppressGUI):
            self.__BaseClass._events.entered_pause.clear()
            self.__BaseClass._exec_ctrl.PauseRequest = True
            self.SetBreakPoint(message=message)

    def DownsampleAllWaveforms(self, nr_points, aaf=True):
        """
        Downsamples all waveforms in result container

        :param nr_points: The number of points to downsample to.
        :type nr_points: int
        :param aaf: If True the downsampling is performed using an anti-aliasing filter (-> Decimation)
        :type aaf: bool
        """
        for _name, value in self.__BaseClass._result_container.get_all().items():
            if isinstance(value, Waveform) and len(value) > nr_points:
                (value.decimate(nr_points) if aaf else value.down_sample(nr_points),)

    def ShowPopup(self, message, title="Info", blocking=True, log=True):
        """
        Shows a popup message.

        :param message: The message the display.
        :type message: str
        :param title: The window title of the popup window
        :type title: str
        :param blocking: If True, the execution is paused wenn the popup window is raised.
                         The execution has to be continued by clicking the 'Run' button again.
        :type blocking: bool
        """
        if log:
            self.__BaseClass.Utils.LogInfo(f"Showing popup '{title}':\n{message}")
        if self.__BaseClass._is_interactive_test and self.__BaseClass.RunOptions.SuppressGUI:
            self.__BaseClass.UI.Show_Popup(message, title, blocking)
        else:
            self.__BaseClass._signals.show_popup.emit(title, message, blocking)
            if blocking:
                sleep(0.5)
                self.SetBreakPoint("Blocking Error Message...")

    def sleep(self, seconds=0, minutes=0, hours=0, log_every=0, chk_func=None, nolog=False):
        """
        Like sleep(seconds) but test can be aborted while sleeping and function logs the sleeping time.

        :param seconds: The seconds to wait
        :type seconds: int|float
        :param minutes: The minutes to wait
        :type minutes: int|float
        :param hours: The hours to wait
        :type hours: int|float
        :param log_every: If > 1 the function will print a log message each log_every seconds:
                          "Sleeping for s s, m min, h hours now..."
        :type log_every: int
        :param chk_func: A tuple of callable function that returns a boolean and integer 'chktime'
                         in seconds when the function is called.

                         The checker function is called each 'chktime' seconds.

                         If the function returns False or raises an exception, the sleep function terminates.

                         The checker function only works if the waiting time is greater than 1 second.

                         Example: chk_func=(lambda: 1==2, 10)  It will return false after 10s and the sleep function
                                  will terminate.
        :type chk_func: (callable, int)
        :param nolog: If True, the function does not log anything
        :type nolog: bool
        """
        if chk_func is None:
            chkfunc = None
            chktime = None
        elif type(chk_func) in (tuple, list) and callable(chk_func[0]) and is_numeric(chk_func[1]):
            chkfunc = chk_func[0]
            chktime = int(chk_func[1])
        else:
            msg = f"Unknown argument type for 'chk_func'! {chk_func!s}"
            raise TypeError(msg)

        sec_to_wait = seconds + minutes * 60.0 + hours * 3600.0
        if sec_to_wait <= 0:
            return
        if 0 < sec_to_wait <= 1.0:
            sleep(sec_to_wait)
            if sec_to_wait > log_every and not nolog:
                self.LogInfo(f"Sleeping for {seconds:.2f} s...")
        else:
            if not nolog:
                self.LogInfo("Sleeping for %d s, %d min, %d hours..." % (seconds, minutes, hours))
            timer = sec_to_wait
            for i in range(int(sec_to_wait / 1.0) + 1):
                flow_control.handle_stop_request(self.__BaseClass)
                flow_control.wait_if_pause_requested(self.__BaseClass, "Paused during self.Utils.sleep statement.")
                if timer >= 1.0:
                    sleep(1.0)
                    timer -= 1.0
                else:
                    sleep(timer)
                if log_every >= 1 and (i + 1) % log_every == 0 and not nolog:
                    self.LogInfo(
                        "Sleeping for %d s, %d min, %d hours now..."
                        % ((i + 1) % 60, int(((i % 3600) + 1) / 60), int(i / 3600))
                    )
                if chkfunc is not None and (i + 1) % chktime == 0:
                    try:
                        result = chkfunc()
                        if result not in [True, False, 0, 1]:
                            self.LogWarning(
                                f"Checker function did not return a boolean like result ({result}, {type(result)}), "
                                f"casting to bool: {bool(result)}"
                            )
                            result = bool(result)
                        if not result:
                            self.LogInfo(
                                "Terminating sleep at %d s, %d min, %d hours because the checker "
                                "function evaluated to False."
                                % (
                                    (i + 1) % 60,
                                    int(((i % 3600) + 1) / 60),
                                    int(i / 3600),
                                )
                            )
                            break
                    except Exception:
                        ex = traceback.format_exc()
                        self.LogError(
                            "Terminating sleep at %d s, %d min, %d hours because the checker "
                            "function in self.Utils.sleep raised an error:\n%s"
                            % (
                                (i + 1) % 60,
                                int(((i % 3600) + 1) / 60),
                                int(i / 3600),
                                ex,
                            )
                        )
                        break

    def VariationValueChanged(self, *parameters):
        """
        Checks if one or many parameter values have changed since the last variation.

        Use parameter names as positional arguments, e.g. self.Utils.VariationValueChanged("Vac", "Fac")

        Returns always True for the first variation.

        :rtype: bool
        """
        return any(self.__BaseClass._PVCC.parameter_changed(parametername)[0] for parametername in parameters)

    @property
    def ResultDirectory(self) -> Path:
        """
        Returns the directory where the final report and toplevel result data is stored.
        """
        if self.__BaseClass._config["result_dir"] is None:
            msg = (
                "The test does not yet know where the results are going to be stored. You can use this property "
                "only after Initialization!"
            )
            raise Exception(msg)
        return Path(self.__BaseClass._config["result_dir"]).resolve()

    @property
    def ResultRunDirectory(self) -> Path:
        """
        Returns the directory where the results and logs of the current test iteration are stored
        """
        if self.__BaseClass._result_dir_iteration is None:
            msg = (
                "The test does not yet know where the results are going to be stored. You can use this property "
                "only after inside the VariationLoops!"
            )
            raise Exception(msg)
        return Path(self.__BaseClass._result_dir_iteration).resolve()

    @property
    def ResultRunsDirectory(self) -> Path:
        warnings.warn(
            "Deprecated as Avenue support has been removed. Use property ResultDirectory instead!",
            DeprecationWarning,
            stacklevel=2,
        )
        return self.ResultDirectory

    @property
    def DLH5Result(self) -> Path:
        """
        Returns the path to the DLH5 result file (if activated)
        """
        filename = self.__BaseClass._result_gateway._handlers["dlh5_handler"].filename
        return Path(self.ResultDirectory) / f"{filename}.dlh5"

    def GoToNextIteration(self, reason: str | None = None):
        """
        Interrupts the current iteration immediately and continues with the next iteration if there is any.

        :param reason: The reason for aborting which will appear in the log message.
        :raises: IterationInterruptedError
        """
        if self.__BaseClass._inside_variation:
            raise IterationInterruptedError(reason)

    def GetSpecResults(
        self,
        iteration: int = -1,
        case_sensitive: bool = False,
        partial_match: bool = False,
        *,
        alias: str | None = None,
        output: str | None = None,
    ) -> list[SpecificationResult]:
        """
        Retrieves the specification result of the current or previous iterations.

        Either ``alias`` **OR** ``output`` must be defined as keyword-arguments.

        Example::

            GetSpecResults(alias="spec123", iteration=-1)

        :param iteration: The iteration index to retrieve the results from.
            If this function is executed within the ``DoE.PostExportResults`` hook, -1 will return the spec results of
            the current iteration, otherwise it will return results from the previous iteration.
        :param case_sensitive: Enable case-sensitive matching
        :param partial_match: Enable partial matching
        :param alias: If set, match against the spec's alias
        :param output: If set, match against the spec's reference output
        :return: A list of SpecificationResult
        """
        return self.__BaseClass._spec_checker.get_results(
            iteration, case_sensitive, partial_match, alias=alias, output=output
        )


if __name__ == "__main__":
    pass
