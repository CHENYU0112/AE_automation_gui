from __future__ import annotations

from pverify import *


class DummyTest(PyVerifyBaseTest):
    @DoE.Init()
    def init(self):
        self.RunOptions.SuppressGUI = True
        self.StorageOptions.ConfigureExcelHandler()
        self.StorageOptions.ConfigureJsonHandler()
        self.StorageOptions.ConfigureJUnitXMLHandler()
        self.StorageOptions.ConfigurePassfinderHandler()

        self.Parameters.Add("Offset", "A", "DC current offset", 0.1)
        self.Parameters.Add("Amplitude", "A", "Base amplitude of oscillation", 0.01)
        self.Parameters.Add("Frequency", "Hz", "-", 10)
        self.Parameters.Add("Damping", "", "Damping constant", 2)
        self.Parameters.Add("Dummy", "", "Dummy parameter for abort", 1)

        self.Variations.Add_ListSweep("Offset", [0.099, 0.101, 0.103, 0.105])
        self.Variations.Add_ListSweep("Amplitude", [0.01, 0.0125, 0.015])
        self.Variations.Add_Corner(["Frequency", "Damping"], [[8, 2], [10, 2.5]])

        self.Outputs.Add("dampedOsc", "A(s)", "damped oscillating current")
        self.Outputs.Add("loadCurve", "V(s)", "load and unload of output voltage")
        self.Outputs.Add("energyAvg", "A", "average energy")
        self.Outputs.Add("maxLoad", "V", "maximum load voltage")

        self.Limits.Add("energyAvg", 0.105, 0.099)
        self.Limits.Add("maxLoad", 2.7e3, 2.45e3)
        self.Limits.Add("maxLoad", 2.7e3, 2.45e3, Conditions="Offset < 0.102 and Amplitude > 0.012")
        self.Limits.Add("maxLoad", 2.45e3, 2.35e3, Conditions="Offset == 0.099 and Amplitude == 0.01")
        self.Limits.Add("maxLoad", 2.7e3, 2.45e3, Conditions="Offset >= 0.103 and Amplitude <= 0.0125")
        self.Limits.Add("maxLoad", 2.6e3, None, Conditions="Offset == 0.103")
        self.Limits.Add(
            "maxLoad",
            2.8e3,
            None,
            Conditions="Amplitude == 0.015 and not ( Offset < 0.104)",
        )
        self.Limits.Add("dampedOsc", LowLimit=0.09, HighLimit=0.113, x_Range=[0.2, None])
        self.Limits.Add(
            "loadCurve",
            HighLimit="2000 + 1900 * $x if $x < 0.5 else 200 + 5500 * ( 1 - $x)",
            LowLimit=[0, 0, 0.1, 1000, 0.4, 2200, 0.6, 500, 0.8, 100],
            x_Range=[0.134, 0.804],
        )

    @DoE.Startup()
    def startup(self): ...

    @DoE.Iteration()
    def iteration(self):
        """Contains the code that is executed during the variation loop."""
        timeVector = np.arange(0, 1, 0.0025)
        shiftedTimeVector = timeVector.copy() - 0.5
        shiftedTimeVector[0:200] = 0.0
        freq = self.Current_variation["Frequency"]
        offs = self.Current_variation["Offset"]
        ampl = self.Current_variation["Amplitude"]
        damping = self.Current_variation["Damping"]
        self.rc.add(
            "dampedOsc",
            Waveform(
                time=timeVector,
                data=(offs + ampl * np.sin(2 * np.pi * freq * timeVector) * np.exp(-timeVector * damping)),
            ),
        )
        self.rc.add(
            "loadCurve",
            Waveform(
                time=timeVector,
                data=10000
                * (2 * offs + 5 * ampl)
                * (1.0 - np.exp(-timeVector * 3 * damping))
                * np.exp(-shiftedTimeVector * 4 * damping),
            ),
        )

    @DoE.IterationPostprocessing()
    def data_analysis(self):
        self.rc.add("energyAvg", self.rc["dampedOsc"].Measurements_Base.rms())
        self.rc.add("maxLoad", self.rc["loadCurve"].Measurements_Base.max())

    @DoE.Teardown()
    def teardown(self): ...


if __name__ == "__main__":
    test = DummyTest(result_dir=".DummyTestResults")
    test.RunTest()
