from __future__ import annotations

import pytest

from pverify import *
from pverify.integrations.fpga import PyVerifyFpgaTest


class FPGAExampleTest(PyVerifyFpgaTest):
    def __init__(self, simulator_name: str):
        # add simulator_name as instance attribute which allows changing the employed RTL simulator
        self.simulator_name = simulator_name
        super().__init__()

    @DoE.Init()
    def init(self):
        # add a variation over several active targets, all possible targets are specified in the prj.yaml file
        self.Variations.Add_ListSweep("active_target", ["sim", "fpga", "fpga"])

        # add a simulation output signal 'v_out' which is later used for limit checking
        self.Outputs.Add("v_out", "V(s)", "v_out_probe")

        # those are functions that allow configuration of the anasymod analysis object, simulation and emulation
        self.configure_anasymod_analysis(simulator_name=self.simulator_name)
        self.configure_analysis_launch(debug=True)
        self.configure_analysis_simulate(unit="main", id="xrun")

        # add limits for the signal 'v_out' after simulation/emulation, 'v_out' will be checked against these limits
        self.Limits.Add(
            "v_out",
            [
                0.0,
                0.0,
                2.8413774247451245e-09,
                0.009945820794713432,
                9.309273070463006e-08,
                0.1916629730491373,
                2.7520940854679694e-07,
                0.35000637390135797,
                7.73390766604486e-07,
                0.616421190692346,
                1.3234660161265176e-06,
                0.8162323032855869,
                2.2990711756561586e-06,
                0.9594302673107433,
                4.28637988667479e-06,
                1.0192001953843686,
                9.916080825508866e-06,
                1.025864273869302,
            ],
            [
                0.0,
                -0.010248278629549357,
                1.6696430900069848e-07,
                -0.007472076773346437,
                3.1035360647340796e-07,
                0.05419327103111199,
                4.4104433618694535e-07,
                0.10603913886769195,
                6.033711615633037e-07,
                0.272905858764812,
                1.0904121564564114e-06,
                0.5156731284515185,
                1.7440210855321782e-06,
                0.7313241847773563,
                2.412678500822464e-06,
                0.8529560427526678,
                4.267059312253798e-06,
                0.9598784427049813,
                9.867283730842193e-06,
                0.9718969763249603,
            ],
            x_Range=[0.0, 0.00001],
        )

    @DoE.IterationPostprocessing()
    def postprocessing(self):
        # add the simulation/emulation result of signal 'v_out'. This will be used for limit checking
        # the get_signal() function extracts corresponding simulation results in this case using the signal name
        # 'v_out_probe' which is specified in the my_custom_simctrl.yaml file
        self.rc.add_waveform("v_out", self.get_signal("v_out_probe"))


# this is an example of how a unit test may be setup, where the test is run with two different RTL simulators
@pytest.mark.parametrize("simulator_name", ["icarus", "vivado"])
def unittest_main(simulator_name):
    t = FPGAExampleTest(simulator_name=simulator_name)
    t.RunUnittest()


if __name__ == "__main__":
    test = FPGAExampleTest(simulator_name="vivado")
    test.RunTest()
