from __future__ import annotations

import os
import re
from typing import TYPE_CHECKING

from wavewatson.waveform import (  # noqa: F401, most imports needed for sphinx documentation
    Export,
    Filter,
    Fitting,
    Generator,
    Math,
    Measurements_Base,
    Measurements_NonPeriodic,
    Measurements_Periodic,
    Measurements_Utils,
    Waveform,
)

if TYPE_CHECKING:
    from collections.abc import Mapping

__all__ = ["Waveform"]


def load_from_hdf5(
    filepath: str,
    outputs: str | (list[str] | (tuple[str] | None)) = None,
    variationfilter: str | (int | list[int]) = "",
) -> list[Waveform] | Mapping[str, list[Waveform]]:
    """
    Reloads waveform data from a pyverify result file (either from overview file or variation result).

    :param filepath: The path of the hdf5 file
    :param outputs: The output for which to retrieve data. A string, list of strings or None (all outputs)
    :param variationfilter:
        An expression-string that define the variation from which the output shall be retrieved.

        E.g. "(ParamA==5)||(ParamB<5)&&(ParamC==0)"\n
        E.g. "(ParamA==5)or(ParamB<5)and(ParamC==0)"

        Or an integer/list of integers of variationnumbers to retrieve data from.
    :return: A list of output waveforms if only one output is specified or a dict of output-name output-data pairs
    """
    if not os.path.exists(filepath):
        msg = f"hdf5 file '{filepath}' does not exist!"
        raise FileNotFoundError(msg)
    from pverify.core.io.hdf5_handler import H5_TestResult

    regex_wavename = re.compile("wave_[0-9]+_var([0-9]+)")

    h5res = H5_TestResult.open_generic(filepath)
    if isinstance(h5res, H5_TestResult):
        _, res = h5res.find_variation_results(outputs, variationfilter)
    else:
        _, res = h5res.restore_variation_results(outputs)
    if isinstance(res, dict):
        data = {}
        for name, _ in filter(lambda item: isinstance(item[1][0], Waveform), list(res.items())):
            data.update({name: res[name]})
        for name, wfs in data.items():
            for wf in wfs:
                wf: Waveform
                match = regex_wavename.findall(wf.getMeta("name"))
                if len(match) == 1:
                    wf.setMeta(name=f"{name} (run{match[0]})")
        return data
    return res


def load_from_file(**kwargs) -> Waveform | list[Waveform]:
    r"""
    Reloads a waveform from a file and returns a waveform instance.

    If filepath is a path to an npz file created by Waveform.save_to_file("\*.npz")
    this method will return a single Waveform instance.

    If filepath is a path to an npz file created by a PyVerify test,
    this method will return a list of Waveform instances.

    :keyword filepath: Path to the file to load the waveform
    """
    filepath = kwargs["filepath"]
    if os.path.basename(filepath).endswith(".npz"):
        return Waveform.load_from_npz(filepath)
    if os.path.basename(filepath).endswith(".hdf5"):
        return load_from_hdf5(filepath, kwargs.get("outputs", None), kwargs.get("variationfilter", ""))
    if os.path.basename(filepath).endswith(".csv"):
        return Waveform.load_from_csv(
            filepath,
            kwargs.get("delimiter", ";"),
            kwargs.get("common_time_col", True),
        )
    msg = "File to reload has to ba a hdf5, npz or csv"
    raise TypeError(msg)


if __name__ == "__main__":
    print("Done")
