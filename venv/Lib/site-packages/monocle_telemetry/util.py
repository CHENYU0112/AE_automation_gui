from __future__ import annotations

import getpass
import os
import pickle
import platform
import re
import threading
import time
import uuid
from typing import Any

import wrapt

from .const import CACHE_DIR, MONOCLE_HOME, NO_WRITE_ACCESS, ONE_MONTH
from .log import log

BU_REGEX = re.compile(r"\(([A-Z0-9\s]+)(?:/[A-Za-z0-9\s]+)?\)")
UNKNOWN_BU = "UNKNOWN"
IN_GITLAB_CI = os.environ.get("GITLAB_CI", "").lower() == "true"
IN_JENKINS_CI = "JENKINS_HOME" in os.environ or os.environ.get("CI", "").lower() == "true"
IN_CI = IN_JENKINS_CI or IN_GITLAB_CI
PLATFORM = platform.system()
ON_LINUX = PLATFORM == "Linux"
ON_WINDOWS = PLATFORM == "Windows"
ON_KUBERNETES = "KUBERNETES_SERVICE_HOST" in os.environ


def drop_none(dikt: dict) -> dict:
    """
    Drops all None values from input dict
    """
    return {k: v for k, v in dikt.items() if v is not None}


def _get_business_unit() -> str:
    try:
        if IN_GITLAB_CI:
            return parse_bu_from_full_name(os.environ.get("GITLAB_USER_NAME", "")) or UNKNOWN_BU
        if IN_CI or ON_KUBERNETES:
            return UNKNOWN_BU
        if ON_LINUX:
            return UNKNOWN_BU
        if ON_WINDOWS:
            return _get_business_unit_windows()
    except Exception as e:
        log.warning(f"Failed betting BU: {e}")
    return UNKNOWN_BU


def parse_bu_from_full_name(full_name: str) -> str | None:
    pattern = r".+\(([A-Z ]+)\)$"
    match = re.search(pattern, full_name)
    if not match:
        return None
    try:
        return match.group(1).strip()
    except Exception:
        return None


def _get_business_unit_windows() -> str:
    import win32net

    user_info = win32net.NetUserGetInfo(win32net.NetGetAnyDCName(), getpass.getuser(), 2)
    full_name = user_info["full_name"].strip()
    name = user_info["name"].strip()

    is_special_account_candidate = name.lower() == full_name.lower()
    if is_special_account_candidate:
        return UNKNOWN_BU

    return parse_bu_from_full_name(full_name) or UNKNOWN_BU


def get_business_unit_cached() -> str:
    if NO_WRITE_ACCESS:
        return _get_business_unit()

    bu_cache_file = MONOCLE_HOME / ".bu"
    refresh_bu_cache_file = bu_cache_file.exists() and time.time() - bu_cache_file.stat().st_mtime > ONE_MONTH
    if refresh_bu_cache_file:
        log.info("Refreshing cached BU value")

    if bu_cache_file.exists() and not refresh_bu_cache_file:
        return bu_cache_file.read_text().strip()

    bu = _get_business_unit()
    if bu is None:
        return UNKNOWN_BU

    bu = bu.strip()
    bu_cache_file.write_text(bu)
    return bu


def get_user():
    try:
        if IN_GITLAB_CI:
            return os.environ.get("GITLAB_USER_LOGIN", getpass.getuser())
        if ON_KUBERNETES:
            return "kubernetes_user"
        return getpass.getuser()
    except Exception:
        return "unknown_user"


def get_platform():
    if ON_KUBERNETES:
        return "KUBERNETES"
    if IN_GITLAB_CI and ON_LINUX:
        return "GITLAB_CI_LINUX"
    if IN_GITLAB_CI and ON_WINDOWS:
        return "GITLAB_CI_WINDOWS"
    if IN_JENKINS_CI and ON_LINUX:
        return "JENKINS_CI_LINUX"
    if IN_JENKINS_CI and ON_WINDOWS:
        return "JENKINS_CI_WINDOWS"
    return platform.system().upper() or "UNKNOWN"


def offline_cache_post_request(url: str, payload: Any, combine: bool) -> bool:
    if NO_WRITE_ACCESS:
        return False
    obj = {"url": url, "payload": payload, "combine": combine}
    filename = str(uuid.uuid4().hex)
    log.info(f"Caching offline request {filename}")
    with open(CACHE_DIR / filename, "wb") as f:
        pickle.dump(obj, f)
    return True


@wrapt.decorator
def run_async(wrapped, instance, args, kwargs):
    thread = threading.Thread(target=wrapped, args=args, kwargs=kwargs)
    thread.start()
    return


@wrapt.decorator
def log_errors(wrapped, instance, args, kwargs):
    try:
        return wrapped(*args, **kwargs)
    except Exception as e:
        log.error(f"Error in {wrapped}: {e}", exc_info=True)
