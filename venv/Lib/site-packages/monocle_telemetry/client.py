from __future__ import annotations

import collections
import contextlib
import datetime
import logging
import os
import pickle
import ssl
from threading import Lock
from typing import TYPE_CHECKING

import httpx
import wrapt

from monocle_telemetry.const import CACHE_DIR
from monocle_telemetry.log import log
from monocle_telemetry.util import (
    drop_none,
    get_business_unit_cached,
    get_platform,
    get_user,
    offline_cache_post_request,
)
from monocle_telemetry.version import __version__

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator

MONOCLE_BASE_URL_PROD = "https://monocle.eu-de-3.icp.infineon.com"
MONOCLE_BASE_URL_DEV = "https://monocle-dev.eu-de-3.icp.infineon.com"
MONOCLE_BASE_URL_LOCAL = "http://localhost:8081"


@wrapt.decorator
def needs_connection(wrapped, instance: MonocleClient, args, kwargs):
    if not instance.client:
        msg = "Client not connected yet! Use the 'connect' method or the context manager."
        raise ConnectionError(msg)
    return wrapped(*args, **kwargs)


@wrapt.decorator
def maybe_skip(wrapped, instance, args, kwargs):
    if "MONOCLE_DISABLE" in os.environ:
        return None
    return wrapped(*args, **kwargs)


def _cache_enforced():
    return "MONOCLE_FORCE_CACHE" in os.environ


def _get_ssl_context() -> ssl.SSLContext:
    ssl_context = ssl.create_default_context()
    ssl_context.load_default_certs()
    return ssl_context


class MonocleClient:
    _sync_lock = Lock()

    def __init__(self, base_url: str | None = None, api_version: str | None = None, timeout: float = 2.0):
        self._timeout = float(timeout)
        self.client: httpx.Client | None = None
        default = (
            MONOCLE_BASE_URL_DEV
            if "MONOCLE_DEBUG" in os.environ
            else os.environ.get("MONOCLE_BASE_URL", MONOCLE_BASE_URL_PROD)
        )
        self._base_url = base_url or default
        self._base_url = self._base_url.rstrip("/")
        self._api_version = api_version or os.environ.get("MONOCLE_API_VERSION", "v1")
        self._api_url = f"{self._base_url}/api/{self._api_version}"

    def connect(self):
        """
        Creates a client.

        It is recommended to use the context manager instead of this method::

            from monocle_telemetry.client import MonocleClient

            with MonocleClient() as client:
                client...
        """
        event_hooks = {"response": [_raise_on_4xx_5xx]}
        if log.isEnabledFor(logging.DEBUG):
            event_hooks["request"] = [_log_request]

        self.client = httpx.Client(
            base_url=self._api_url,
            follow_redirects=True,
            headers={"User-Agent": f"Monocle Telemetry Python Client/{__version__}"},
            event_hooks=event_hooks,
            timeout=self._timeout,
            verify=_get_ssl_context(),
        )
        log.debug(f"Monocle Telemetry Client {__version__} - Server {self._api_url}")

    def disconnect(self):
        """
        Disconnect
        """
        if self.client is not None:
            self.client.close()
            self.client = None

    def __enter__(self) -> MonocleClient:
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()

    def _try_post(self, url: str, json: dict):
        try:
            return self.client.post(url=url, json=json)
        except httpx.ConnectError as e:
            if "CERTIFICATE_VERIFY_FAILED" in str(e):
                # Switch to HTTP
                self.client.base_url = str(self.client.base_url).replace("https://", "http://")
                return self.client.post(url=url, json=json)
            raise e

    @needs_connection
    def is_server_alive(self) -> bool:
        """
        Returns True if the server is active, False otherwise.
        """
        try:
            response = httpx.get(f"{self._base_url}/healthcheck", timeout=1.0, verify=_get_ssl_context())
            return response.is_success
        except httpx.TimeoutException:
            return False

    @needs_connection
    def sync_offline_cache(self):
        """
        Syncs former tracking calls that were cached locally due to unavailability of the server.
        """
        with MonocleClient._sync_lock:
            entries = collections.defaultdict(list)
            for file in CACHE_DIR.glob("*"):
                payload = None
                log.info(f"Reading cached file {file.name}")
                try:
                    with open(file, "rb") as f:
                        content = pickle.load(f)
                        url = content["url"]
                        payload = content["payload"]
                        combine = content["combine"]
                    file.unlink(missing_ok=False)
                except PermissionError:
                    # File is currently read by another process, skip processing
                    continue
                except FileNotFoundError:
                    # File already deleted by another process, skip processing
                    continue
                except Exception:
                    # Dev didn't expect this error happen
                    continue

                if payload is not None:
                    if combine:
                        entries[url].append(payload)
                    else:
                        try:
                            response = self._try_post(url=url, json=payload)
                            response.raise_for_status()
                        except Exception as e:
                            log.error(f"Failed syncing file {file}: {e}")

            for url, payloads in entries.items():
                try:
                    response = self._try_post(url=url, json={"data": payloads})
                    response.raise_for_status()
                except Exception as e:
                    log.error(f"Failed syncing {len(payloads)} files for url {url}: {e}")

    @needs_connection
    @maybe_skip
    def create_feature(
        self,
        project: str,
        tool: str,
        version: str,
        feature: str,
        misc: str = "",
        bu: str | None = None,
        user: str | None = None,
        platform: str | None = None,
        migration_id: None | int = None,
        timestamp: None | datetime.datetime = None,
    ):
        """
        Tracks an application feature

        :param project: Your project name. Max length: 32.
        :param tool: The tool/application name. Max length: 32.
        :param version: The tool's/application's version. Max length: 32.
        :param feature: The name of the feature. Max length: 64.
        :param misc: Miscellaneous data. Max length: 128.
        :param bu: The business unit (optional - will be determined automatically, only for migration purposes).
            Max length: 64.
        :param user: The username (optional - will be determined automatically, only for migration purposes).
        :param platform: The platform (optional - will be determined automatically, only for migration purposes).
            Max length: 32.
        :param migration_id: The migration id (optional - will be determined automatically, only for migration purposes)
        :param timestamp: The timestamp of the request (optional - will be determined automatically,
            only for migration purposes)
        """
        tool_filter = os.environ.get("MONOCLE_FEATURES_TRACK_TOOLS", "").lower()
        if tool_filter and tool.lower() not in tool_filter:
            return

        payload = {
            "project": project,
            "tool": tool,
            "version": version,
            "feature": feature,
            "misc": misc,
            "bu": bu or get_business_unit_cached(),
            "platform": platform or get_platform(),
            "user": user or get_user(),
            "migration_id": migration_id,
        }
        if timestamp is not None:
            payload["timestamp"] = timestamp.isoformat()
        else:
            with contextlib.suppress(Exception):
                payload["timestamp"] = datetime.datetime.now(datetime.timezone.utc).isoformat()

        if _cache_enforced():
            offline_cache_post_request(url="/features/create_many", payload=payload, combine=True)
            return

        try:
            response = self._try_post(url="/features/create", json=payload)
            response.raise_for_status()
        except (httpx.TimeoutException, httpx.NetworkError) as e:
            log.warning(f"Post request failed with error: {e}")
            offline_cache_post_request(url="/features/create_many", payload=payload, combine=True)
            return
        self.sync_offline_cache()

    @needs_connection
    @maybe_skip
    def create_features(
        self,
        features: Iterable[dict],
    ):
        """
        Upload a batch of features. Used for migration and sync purposes only.
        """
        tool_filter = os.environ.get("MONOCLE_FEATURES_TRACK_TOOLS", "").lower()
        payload = []
        for f in features:
            timestamp = f.get("timestamp")
            if timestamp is not None:
                timestamp = timestamp.isoformat()
            else:
                with contextlib.suppress(Exception):
                    timestamp = datetime.datetime.now(datetime.timezone.utc).isoformat()

            tool = f["tool"]
            if tool_filter and tool.lower() not in tool_filter:
                continue

            payload.append(
                {
                    "project": f["project"],
                    "feature": f["feature"],
                    "tool": tool,
                    "version": f["version"],
                    "bu": f.get("bu") or get_business_unit_cached(),
                    "platform": f.get("platform") or get_platform(),
                    "user": f.get("user") or get_user(),
                    "migration_id": f.get("migration_id", None),
                    "timestamp": timestamp,
                }
            )
        if _cache_enforced():
            offline_cache_post_request(url="/features/create_many", payload={"data": payload}, combine=False)
            return

        try:
            response = self._try_post(url="/features/create_many", json={"data": payload})
            response.raise_for_status()
        except (httpx.TimeoutException, httpx.NetworkError) as e:
            log.warning(f"Post request failed with error: {e}")
            offline_cache_post_request(url="/features/create_many", payload={"data": payload}, combine=False)
            return
        self.sync_offline_cache()

    @needs_connection
    def search_features(
        self,
        project: str,
        tool: str | None = None,
        feature: str | None = None,
        start_date: datetime.datetime | None = None,
        end_date: datetime.datetime | None = None,
        timeout: float = 10.0,
        page_size: int = 500,
        start_page: int = 1,
        max_items: int = 0,
    ) -> Iterator[dict]:
        """
        Searches for tracked features in the database.

        Example:

        .. code-block::

            from monocle_telemetry.client import MonocleClient

            with MonocleClient() as client:
                # Find the latest 1000 entries for project "my-project"
                data = list(client.search_features(project="my-project", max_items=1000))

        .. important:: This method returns an iterator, not a list.
            Either pass directly to ``monocle_telemetry.analytics.feature.to_dataframe`` or convert to a list.

        :param project: The project to search data for (required)
        :param tool: The tool/application name
        :param feature: The name of the feature
        :param start_date: The start time
        :param end_date: The end time
        :param timeout: The timeout for the request.
        :param page_size: The page size for paging.
        :param start_page: The start page for paging
        :param max_items: The maximum number of items to return.
        """
        current_page = max(1, start_page)
        item_nr = 0

        while True:
            response = self.client.get(
                url=f"/features/search/{project}",
                params=drop_none(
                    {
                        "tool": tool,
                        "feature": feature,
                        "start_date": start_date,
                        "end_date": end_date,
                        "page": current_page,
                        "size": page_size,
                    }
                ),
                timeout=timeout,
            )
            response.raise_for_status()
            resp_json = response.json()

            for item in resp_json["items"]:
                yield item
                item_nr += 1
                if item_nr >= max_items > 0:
                    return

            if not resp_json["total"]:
                break

            if resp_json["page"] == resp_json["pages"]:
                break
            current_page += 1

    @needs_connection
    @maybe_skip
    def create_metric(
        self,
        project: str,
        metric: str,
        value: float,
        log_errors: bool = False,
    ):
        """
        Tracks a numeric application metric.

        :param project: Your project name
        :param metric: The metric name
        :param value: The numeric metric value
        """
        metric_filter = os.environ.get("MONOCLE_TRACK_METRICS", "").lower()
        if metric_filter and metric.lower() not in metric_filter:
            return

        payload = {
            "project": project,
            "metric": metric,
            "value": float(value),
            "timestamp": datetime.datetime.now(datetime.timezone.utc).isoformat(),
        }
        try:
            response = self._try_post(url="/metrics/create", json=payload)
            response.raise_for_status()
        except Exception:
            if log_errors:
                log.error(f"An exception occurred when tracking metric {metric} for project {project}!", exc_info=True)
            else:
                raise

    @needs_connection
    def search_metrics(
        self,
        project: str,
        metric: str | None = None,
        start_date: datetime.datetime | None = None,
        end_date: datetime.datetime | None = None,
        timeout: float = 10.0,
        page_size: int = 500,
        start_page: int = 1,
        max_items: int = 0,
    ) -> Iterator[dict]:
        """
        Searches for tracked metrics in the database.

        Example:

        .. code-block::

            from monocle_telemetry.client import MonocleClient

            with MonocleClient() as client:
                # Find the latest 1000 metrics for project "my-project"
                data = list(client.search_metrics(project="my-project", max_items=1000))

        .. important:: This method returns an iterator, not a list.
            Either pass directly to ``monocle_telemetry.analytics.metrics.to_dataframe`` or convert to a list.

        :param project: The project to search data for (required)
        :param metric: The metrics name
        :param start_date: The start time
        :param end_date: The end time
        :param timeout: The timeout for the request.
        :param page_size: The page size for paging.
        :param start_page: The start page for paging
        :param max_items: The maximum number of items to return.
        """
        current_page = max(1, start_page)
        item_nr = 0

        while True:
            response = self.client.get(
                url=f"/metrics/search/{project}",
                params=drop_none(
                    {
                        "metric": metric,
                        "start_date": start_date,
                        "end_date": end_date,
                        "page": current_page,
                        "size": page_size,
                    }
                ),
                timeout=timeout,
            )
            response.raise_for_status()
            resp_json = response.json()

            for item in resp_json["items"]:
                yield item
                item_nr += 1
                if item_nr >= max_items > 0:
                    return

            if not resp_json["total"]:
                break

            if resp_json["page"] == resp_json["pages"]:
                break
            current_page += 1


def _raise_on_4xx_5xx(response: httpx.Response):
    if response.is_error:
        try:
            response.read()
            if "application/json" in response.headers.get("Content-Type", ""):
                error: dict = response.json()
                detail = error.get("detail")
                if detail:
                    raise httpx.HTTPStatusError(detail, request=response.request, response=response)
            response.raise_for_status()
        except Exception as e:
            log.error(f"Received error response {response.status_code} for url {response.request.url}: {e}")
            raise


def _log_request(request: httpx.Request):
    try:
        content = request.content.decode("utf-8")
    except Exception:
        content = ""
    log.debug(f"Request event hook: {request.method} {request.url} {content}")


if __name__ == "__main__":
    with MonocleClient(MONOCLE_BASE_URL_DEV) as c:
        c.is_server_alive()
        c.create_feature("pyveco", "reviz", "1.0.0", "import", "DES")
        # print(c.search_features("string"))
